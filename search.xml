<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>anaconda创建虚拟环境</title>
      <link href="/2023/11/14/anaconda%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
      <url>/2023/11/14/anaconda%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Anaconda创建虚拟环境"><a href="#一、Anaconda创建虚拟环境" class="headerlink" title="一、Anaconda创建虚拟环境"></a>一、Anaconda创建虚拟环境</h2><p>1、查看所有虚拟环境<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info --envs</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env list</span><br></pre></td></tr></table></figure></p><p>2、创建名字为ycyh，环境为python3.8的虚拟环境(python3.8为例)<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name ycyh python=3.8</span><br></pre></td></tr></table></figure></p><p>3、激活（进入）虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activate ycyh</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate ycyh</span><br></pre></td></tr></table></figure><p>4、删除虚拟环境<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove --name your_env_name --all</span><br></pre></td></tr></table></figure></p><p>5、退出环境<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure></p><h2 id="二、修改环境名"><a href="#二、修改环境名" class="headerlink" title="二、修改环境名"></a>二、修改环境名</h2><p>1、进入旧环境<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate old_name</span><br></pre></td></tr></table></figure></p><p>2、克隆旧环境<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda create -n new_name --clone old_name</span><br><span class="line"><span class="meta">#</span>示例</span><br><span class="line">conda create -n yc --clone base</span><br></pre></td></tr></table></figure></p><p>3、退出旧环境<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure></p><p>4、删除旧环境<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove -n old_name</span><br></pre></td></tr></table></figure></p><p>5、查看最终结果<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info --envs</span><br></pre></td></tr></table></figure></p><h2 id="三、分享环境"><a href="#三、分享环境" class="headerlink" title="三、分享环境"></a>三、分享环境</h2><p>1、进入要分享的环境：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activate target_env_name</span><br></pre></td></tr></table></figure></p><p>2、输入命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env export &gt; environment.yml</span><br></pre></td></tr></table></figure></p><p>会在当前目录下生成environment.yml文件，别人拿到environment.yml文件，在cmd中进入目录文件下可以通过以下命令从该文件创建环境conda env create -f environment.yml</p><h2 id="四、安装第三方库"><a href="#四、安装第三方库" class="headerlink" title="四、安装第三方库"></a>四、安装第三方库</h2><p>1、查看当前环境下安装的第三方库：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure></p><p>2、 给当前环境安装第三方库：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install package_name</span><br></pre></td></tr></table></figure></p><p>3、给指定环境安装第三方库：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -n env_name package_name</span><br></pre></td></tr></table></figure></p><h2 id="1、安装Anaconda3"><a href="#1、安装Anaconda3" class="headerlink" title="1、安装Anaconda3"></a>1、安装Anaconda3</h2><p>打开<a href="https://www.anaconda.com/" target="_blank" rel="noopener">Anaconda</a>官网，下载Anaconda对应的Linux文件，并将文件拖进Linux系统中。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1643147/1668786280383-e3acd137-548a-43c2-a1d6-3aae98c9979b.png#averageHue=%23f7f3f1&amp;clientId=uafdbca42-2407-4&amp;from=paste&amp;height=314&amp;id=uc9fffb30&amp;originHeight=471&amp;originWidth=989&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=50218&amp;status=done&amp;style=none&amp;taskId=u8928fe4d-6aac-4d59-8022-f0ccc7146d0&amp;title=&amp;width=659.3333333333334" alt="image.png"><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建anaconda用户并设置密码。</span></span><br><span class="line">useradd anaconda</span><br><span class="line"><span class="comment">#修改anaconda密码为anaconda</span></span><br><span class="line">echo anaconda|passwd <span class="comment">--stdin anaconda</span></span><br></pre></td></tr></table></figure></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换用户</span></span><br><span class="line">su - anaconda</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始安装</span></span><br><span class="line">bash Anaconda3-2022.10-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><p>随后开始anaconda的安装，只需按照提示不断安装即可。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1643147/1692952493061-7d417864-5297-4ff0-b474-4b1ad2cb38f4.png#averageHue=%23022b47&amp;clientId=ucfa41739-b5d3-4&amp;from=paste&amp;height=246&amp;id=u4054580d&amp;originHeight=369&amp;originWidth=656&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=29244&amp;status=done&amp;style=none&amp;taskId=ua0c4938c-5e30-4a4b-bf68-f617adfa06d&amp;title=&amp;width=437.3333333333333" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/1643147/1692952532193-8cb07f02-5056-4bae-bb8f-551984bee958.png#averageHue=%23012a46&amp;clientId=ucfa41739-b5d3-4&amp;from=paste&amp;height=249&amp;id=u8ab1cdf1&amp;originHeight=373&amp;originWidth=1305&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=34726&amp;status=done&amp;style=none&amp;taskId=u5b4c2925-df3f-46e5-b649-7fb17e08abd&amp;title=&amp;width=870" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/1643147/1692952551807-982d880b-c0f6-4fd8-9eef-0ec749d07c7b.png#averageHue=%23012a47&amp;clientId=ucfa41739-b5d3-4&amp;from=paste&amp;height=249&amp;id=u63c53ed7&amp;originHeight=373&amp;originWidth=658&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=29848&amp;status=done&amp;style=none&amp;taskId=u29006062-ed74-456c-a020-fe725ab4cf7&amp;title=&amp;width=438.6666666666667" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/1643147/1692952975361-bc8c20ab-438b-4c66-ae09-72497c0ea150.png#averageHue=%23032c4a&amp;clientId=u96f22a0c-6136-4&amp;from=paste&amp;height=125&amp;id=uaa1f6a21&amp;originHeight=156&amp;originWidth=575&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=17698&amp;status=done&amp;style=none&amp;taskId=u28676497-d390-499b-b23d-02f028af482&amp;title=&amp;width=460" alt="image.png"><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda -V</span><br><span class="line">anaconda -V</span><br></pre></td></tr></table></figure></p><p>即可查看安装结果<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1643147/1668786131554-491910d1-2a79-488f-a534-9ef6fe5969e0.png#averageHue=%23042e4b&amp;clientId=uafdbca42-2407-4&amp;from=paste&amp;height=115&amp;id=u50f6b4a6&amp;originHeight=173&amp;originWidth=526&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11685&amp;status=done&amp;style=none&amp;taskId=ua2f89843-babd-4a5d-a390-c9f0b5b0beb&amp;title=&amp;width=350.6666666666667" alt="image.png"></p><h2 id="2、配置Jupyter-Notebook"><a href="#2、配置Jupyter-Notebook" class="headerlink" title="2、配置Jupyter Notebook"></a>2、配置Jupyter Notebook</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /home/anaconda/anaconda3/bin/python</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from notebook.auth import passwd</span><br><span class="line">passwd()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1643147/1692953071128-64ad61c8-9f85-493d-b30f-7ed7318bcb68.png#averageHue=%23032c49&amp;clientId=u96f22a0c-6136-4&amp;from=paste&amp;height=252&amp;id=wCZcO&amp;originHeight=315&amp;originWidth=821&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=45917&amp;status=done&amp;style=none&amp;taskId=u9ce4e6e3-d0cb-4d9f-9153-1654a9c4fe5&amp;title=&amp;width=656.8" alt="image.png"><br>按照提示设置jupyter登录密码，随后会出现如下图所示的秘钥，复制此秘钥，随后会使用到。执行完毕后输入exit()退出。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1643147/1692953085562-a1e71ae2-d7d7-43cc-a19c-acfcd372433c.png#averageHue=%23022b48&amp;clientId=u96f22a0c-6136-4&amp;from=paste&amp;height=118&amp;id=u412f3f7c&amp;originHeight=148&amp;originWidth=863&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=19412&amp;status=done&amp;style=none&amp;taskId=ueab258bc-92fc-4b6f-9b22-6848ddd5dac&amp;title=&amp;width=690.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/1643147/1668786344610-07b2dd91-f5eb-4006-a62a-0ed7918ee8ed.png#averageHue=%23262423&amp;clientId=uafdbca42-2407-4&amp;from=paste&amp;id=ued52f40c&amp;originHeight=137&amp;originWidth=853&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=61161&amp;status=done&amp;style=none&amp;taskId=u7b5547fe-3af1-4122-8fe5-d3ded8bff9d&amp;title=" alt="image.png"><br>下面开始配置文件。</p><p>在anaconda安装目录下创建文件夹fin<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1643147/1692944120056-6b42fd27-051e-495e-a4c0-5006b674008c.png#averageHue=%23032d4a&amp;clientId=u29fab278-34d6-4&amp;from=paste&amp;height=83&amp;id=u5ffc5498&amp;originHeight=124&amp;originWidth=696&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=21170&amp;status=done&amp;style=none&amp;taskId=u20d9bde1-2606-4275-b52c-b202d5f3c6c&amp;title=&amp;width=464" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/1643147/1692953130224-b70ee270-9098-4184-bd8a-4702a2be9525.png#averageHue=%23042e4c&amp;clientId=u96f22a0c-6136-4&amp;from=paste&amp;height=62&amp;id=u91c78c40&amp;originHeight=78&amp;originWidth=736&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=16046&amp;status=done&amp;style=none&amp;taskId=u8d1cd5cb-7e91-45af-aa46-161169446d5&amp;title=&amp;width=588.8" alt="image.png"><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim  /home/anaconda/.jupyter/jupyter_notebook_config.py</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c.NotebookApp.ip=<span class="string">'*'</span>                     <span class="comment"># 就是设置所有ip皆可访问</span></span><br><span class="line">c.NotebookApp.password = <span class="string">'sha1:be76b1960e3b:dd47c1dfc46654e354114c7df0eaf871be92e8cc'</span>     <span class="comment"># 上面复制的那个sha密文'</span></span><br><span class="line">c.NotebookApp.open_browser = False       <span class="comment"># 禁止自动打开浏览器</span></span><br><span class="line">c.NotebookApp.port =8888                 <span class="comment"># 端口，默认8888</span></span><br><span class="line">c.NotebookApp.notebook_dir = <span class="string">'/home/anaconda/fin/indicators'</span>  <span class="comment">#设置Notebook启动进入的目录</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1643147/1693741034490-bd83c46c-1b27-4184-be94-1ec1d6129d92.png#averageHue=%23012b4c&amp;clientId=udcd14da2-1d79-4&amp;from=paste&amp;height=351&amp;id=u385061e5&amp;originHeight=527&amp;originWidth=788&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=56054&amp;status=done&amp;style=none&amp;taskId=u8db51626-1d12-4e69-bbad-acdd207d492&amp;title=&amp;width=525.3333333333334" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/1643147/1692949769646-851d9dc9-b9ac-4799-9e9a-328b94eb1e53.png#averageHue=%23002b4a&amp;clientId=u40b9ddcb-cfe8-4&amp;from=paste&amp;height=123&amp;id=uf5c43e10&amp;originHeight=185&amp;originWidth=555&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=16845&amp;status=done&amp;style=none&amp;taskId=uf7e2f132-0cc1-44c9-b86d-81a3199ecb3&amp;title=&amp;width=370" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/1643147/1693560337055-e9b4700d-a6bf-462c-9273-4fc6ba719e0c.png#averageHue=%23002a48&amp;clientId=u9e09f6a7-02f6-4&amp;from=paste&amp;height=684&amp;id=u5cc38672&amp;originHeight=855&amp;originWidth=1039&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=93113&amp;status=done&amp;style=none&amp;taskId=u8a652951-65cf-4c38-94a5-e9e37cb30d7&amp;title=&amp;width=831.2" alt="image.png"><br>随后:wq写入保存</p><h2 id="3、运行JupyterLab"><a href="#3、运行JupyterLab" class="headerlink" title="3、运行JupyterLab"></a>3、运行JupyterLab</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh jupyter-lab-start.sh</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export PYTHONPATH=/home/anaconda/fin</span><br><span class="line"></span><br><span class="line">cd /home/anaconda/fin/indicators </span><br><span class="line"></span><br><span class="line">nohup jupyter-lab --ip 0.0.0.0 --port 8888 --no-browser &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>效果如图<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1643147/1693561239794-13b2010f-9484-4a48-8904-530dfa141c6d.png#averageHue=%23032c49&amp;clientId=u02735ece-5e2e-4&amp;from=paste&amp;height=423&amp;id=u291dd6b2&amp;originHeight=529&amp;originWidth=1451&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=169924&amp;status=done&amp;style=none&amp;taskId=ucbccf51c-8496-4451-960b-852133af6b3&amp;title=&amp;width=1160.8" alt="image.png"><br>打开浏览器，输入<a href="http://192.168.60.48:8888/" target="_blank" rel="noopener">http://192.168.60.48:8888/</a>，输入密码，即可进入jupyter<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1643147/1693561383609-6c2f4d65-d82d-4340-a89c-52c7e1d54ebf.png#averageHue=%23f8f7f6&amp;clientId=u02735ece-5e2e-4&amp;from=paste&amp;height=678&amp;id=ub8cf51af&amp;originHeight=848&amp;originWidth=1235&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=83435&amp;status=done&amp;style=none&amp;taskId=u2209b89e-6fea-47f6-8d10-3d110a62e94&amp;title=&amp;width=988" alt="image.png"></p><h2 id="4、下载金融算法依赖"><a href="#4、下载金融算法依赖" class="headerlink" title="4、下载金融算法依赖"></a>4、下载金融算法依赖</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy==1.21.5 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install pandas==1.4.0 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install xlrd==2.0.1 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install scipy==1.6.3 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install connexion==2.14.0 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install flask==2.1.2 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install flask_cors==3.0.10 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install jupyterlab==3.4.3 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install jupyter -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install jupyter notebook -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install jupyter-server==1.18.1 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install pymysql==1.0.2 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install dbutils==3.0.2 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install py_eureka_client==0.10.0 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install clickhouse-driver==0.2.4 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install empyrical==0.5.5 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install flask_restful==0.3.9 -i https://pypi.mirrors.ustc.edu.cn/simple </span><br><span class="line">pip install flask_restplus==0.13.0 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install flask_moment==1.0.2 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install pycryptodome==3.15.0 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install python-dotenv==0.20.0 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install sklearn==0.0 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install statsmodels==0.12.2 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install apscheduler==3.9.1 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install pypinyin==0.46.0  -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install xlsxwriter==1.4.4 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install gevent==21.12.0 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install psycopg2==2.9.3 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install StrEnum==0.4.8 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install xlwt==1.3.0 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install flask_socketio==5.2.0 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install werkzeug==2.0.3 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install sql_metadata==2.6.0 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install sqlparse==0.4.2 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install SQLAlchemy==1.4.39 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install joblib==1.1.0 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install crypto==1.4.1 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip install cryptography==37.0.4 -i https://pypi.mirrors.ustc.edu.cn/simple</span><br></pre></td></tr></table></figure><h2 id="5、配置文件修改"><a href="#5、配置文件修改" class="headerlink" title="5、配置文件修改"></a>5、配置文件修改</h2><ul><li>假设项目所全路径为 &lt;DIR/fin_indicators&gt;</li><li>修改 &lt;DIR/fin_indicators&gt;/settings.ini文件，根据实际数据库连接信息修改如下变量<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[PostgreSQL]</span><br><span class="line">DB_ENABLE = True</span><br><span class="line">DB_SERVER = <span class="number">192.168</span>.<span class="number">70.144</span></span><br><span class="line">DB_PORT = <span class="number">5432</span></span><br><span class="line">DB_NAME = cebrisk</span><br><span class="line"><span class="comment"># 官方推荐用户名跟schemaName保持相同cebrisk/cebrisk</span></span><br><span class="line">DB_SCHEMA = cebrisk</span><br><span class="line">DB_USER = cebrisk</span><br><span class="line">DB_PWD = <span class="number">9</span>fd81959a8285c074cb1a52e99e5d39a</span><br><span class="line">DB_MAX_CONNECTIONS = <span class="number">10</span></span><br><span class="line">DB_MIN_CACHED = <span class="number">3</span></span><br><span class="line">DB_MAX_SHARED = <span class="number">5</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1643147/1693562309832-1cc29e9e-f107-4184-8088-0d31ef010dfe.png#averageHue=%231f2124&amp;clientId=u55fba1c6-3bcf-4&amp;from=paste&amp;height=268&amp;id=u9325ef11&amp;originHeight=335&amp;originWidth=711&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=39028&amp;status=done&amp;style=none&amp;taskId=u3bd109d5-a940-49e0-b6c5-5e64a29f01a&amp;title=&amp;width=568.8" alt="image.png"><br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[ClickHouse]</span><br><span class="line">CH_ENABLE = True</span><br><span class="line">CH_HOST = <span class="number">192.168</span>.<span class="number">70.144</span></span><br><span class="line">CH_PORT = <span class="number">9000</span></span><br><span class="line">CH_DATABASE = chdb</span><br><span class="line">CH_USER = cebrisk</span><br><span class="line">CH_PASSWORD = <span class="number">9</span>fd81959a8285c074cb1a52e99e5d39a</span><br><span class="line">CH_MAX_CONNECTIONS = <span class="number">10</span></span><br><span class="line">CH_MIN_CACHED = <span class="number">3</span></span><br><span class="line">CH_MAX_SHARED = <span class="number">5</span></span><br><span class="line">CH_BATCH_SIZE = <span class="number">2000</span></span><br></pre></td></tr></table></figure></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1643147/1693562289070-00ff5bf2-c868-4141-9efb-627110f56ad3.png#averageHue=%231f2024&amp;clientId=u55fba1c6-3bcf-4&amp;from=paste&amp;height=262&amp;id=u35338407&amp;originHeight=328&amp;originWidth=705&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=33670&amp;status=done&amp;style=none&amp;taskId=u7cea7e62-9d5c-46be-8967-e6aa34bbc94&amp;title=&amp;width=564" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SERVER_HOST = &apos;DESKTOP-K6CGD0K&apos;</span><br><span class="line">SERVER_PORT = 8000</span><br><span class="line">JUPYTER_LAB_URL = &apos;http://localhost:8888/lab/tree/&apos;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 注册中心信息</span><br><span class="line">EUREKA_SERVER = &apos;http://localhost:8761/eureka/&apos;</span><br><span class="line">EUREKA_ENABLE = False</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1643147/1693561865979-1b8453fa-07d3-4c8a-8a92-3317639cc940.png#averageHue=%23212326&amp;clientId=u55fba1c6-3bcf-4&amp;from=paste&amp;height=411&amp;id=ue6d392d7&amp;originHeight=514&amp;originWidth=819&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=62037&amp;status=done&amp;style=none&amp;taskId=u9e6c69bd-1ea6-4244-afae-96c6535f76d&amp;title=&amp;width=655.2" alt="image.png"></p><h2 id="6、修改Anaconda3配置文件"><a href="#6、修改Anaconda3配置文件" class="headerlink" title="6、修改Anaconda3配置文件"></a>6、修改Anaconda3配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /home/anaconda/anaconda3/lib/python3.9/site-packages/werkzeug/__init__.py</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.utils <span class="keyword">import</span> cached_property</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1643147/1691466123411-bea1b86a-b26e-45bc-9292-0cc4226d5de7.png#averageHue=%233b3a37&amp;clientId=u9393bc7f-e08d-4&amp;from=paste&amp;height=160&amp;id=u613f6f8c&amp;originHeight=200&amp;originWidth=608&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=57200&amp;status=done&amp;style=none&amp;taskId=ub3b63b9e-be71-4f37-a7d6-0276c1e142f&amp;title=&amp;width=486.4" alt="image.png"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /home/anaconda/anaconda3/lib/python3.9/site-packages/flask_restplus/api.py</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#from flask.helpers import _endpoint_from_view_func</span></span><br><span class="line"><span class="keyword">import</span> flask.scaffold</span><br><span class="line">flask.helpers._endpoint_from_view_func = flask.scaffold._endpoint_from_view_func</span><br><span class="line"><span class="keyword">import</span> flask_restful</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1643147/1691466147818-d0c7ef38-4113-42c6-84b1-efb53c80a896.png#averageHue=%233d3c3a&amp;clientId=u9393bc7f-e08d-4&amp;from=paste&amp;height=159&amp;id=u551a16fc&amp;originHeight=199&amp;originWidth=899&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=85157&amp;status=done&amp;style=none&amp;taskId=u0e109cd2-d48b-49b7-812d-7483c4b6e07&amp;title=&amp;width=719.2" alt="image.png"></p><h2 id="7、运行指标库微服务"><a href="#7、运行指标库微服务" class="headerlink" title="7、运行指标库微服务"></a>7、运行指标库微服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh fin_start.sh</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">nohup sh -c <span class="string">"python3 job_convert.py &amp;&amp; python3 run_service.py"</span> &gt;/dev/null <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1643147/1693562993593-21e494d8-57dd-40b1-bcc1-9ddf77b6476c.png#averageHue=%2307304f&amp;clientId=u55fba1c6-3bcf-4&amp;from=paste&amp;height=456&amp;id=u66122ec4&amp;originHeight=570&amp;originWidth=1155&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=240435&amp;status=done&amp;style=none&amp;taskId=u349c08ef-2a8e-4a59-8cfe-cc995f119f4&amp;title=&amp;width=924" alt="image.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install conda-pack</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1643147/1693980364197-6919cb5e-e9f3-47bd-bcd0-c85caa1021fb.png#averageHue=%230a3350&amp;clientId=ubace367a-f443-4&amp;from=paste&amp;height=64&amp;id=u006249aa&amp;originHeight=96&amp;originWidth=932&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=22523&amp;status=done&amp;style=none&amp;taskId=u505597a3-29ed-451a-b8e4-868e5c8e179&amp;title=&amp;width=621.3333333333334" alt="image.png"><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda pack -n ycyh</span><br></pre></td></tr></table></figure></p><p>如下图，正在对环境进行打包，还是很快的。最后打包成·后缀为.tar.gz的压缩文件。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1643147/1694415967666-1a6182d6-8b93-4aaf-9e4b-1ea00fbece33.png#averageHue=%23032c49&amp;clientId=u209ab1e3-2ec8-4&amp;from=paste&amp;height=89&amp;id=u8c735884&amp;originHeight=111&amp;originWidth=689&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=13927&amp;status=done&amp;style=none&amp;taskId=u535c9f53-93f2-4bf3-8227-caa9939bd4d&amp;title=&amp;width=551.2" alt="image.png"><br>第三步“还原环境”<br>现在已经ycyh.tar.gz上传到无网的服务器了，现在将ycyh.tar.gz解压到/home/fundApp/anaconda3/envs下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ycyh</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf ycyh.tar.gz -C /home/fundApp/anaconda3/envs/ycyh</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info -e</span><br></pre></td></tr></table></figure><p>虚拟环境已迁移完毕</p><p>进入虚拟环境，就可以使用了<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate ycyh</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常工作常用</title>
      <link href="/2023/08/24/%E6%97%A5%E5%B8%B8%E5%B7%A5%E4%BD%9C%E5%B8%B8%E7%94%A8/"/>
      <url>/2023/08/24/%E6%97%A5%E5%B8%B8%E5%B7%A5%E4%BD%9C%E5%B8%B8%E7%94%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sql编写规范</title>
      <link href="/2023/08/23/sql%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/"/>
      <url>/2023/08/23/sql%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p>​    </p><p><strong>SQL编码规范</strong></p><p>1 综述</p><p>1.1 概述</p><p>本文主要描述了在开发过程中编写SQL语句的各种规范。 </p><p>本文主要面向读者为 业务设计人员、程序设计人员、程序开发人员。</p><p>1.2 使用范围</p><p>本项目，以及使用本项目框架的后续项目。</p><p>2 SQL语句格式</p><p>2.1 SQL基本格式要求</p><p>2.1.1 全大写</p><p>SQL 关键字应保持全大写，默认SQL中不添加注释。</p><p>2.1.2 换行</p><p>保持每行仅一个字段和每行仅一个条件。 </p><p>保持子句关键字右对齐(SELECT FROM WHERE ORDER GROUP)</p><p>2.1.3 嵌套缩进</p><p>嵌套的SQL子句应缩进2 字符并保持对齐。</p><p>2.2 SQL关联方式</p><p>默认使用 INNER JOIN 和 LEFT JOIN,尽量避免使用OUTER JOIN ,FULL JOIN 及 RIGHT JOIN。（此处因考虑数据库兼容性，使用标准SQL语法。实际使用时，如果仅使用ORACLE数据库，建议使用ORACLE语法，以提高效率和可读性）</p><p>2.2.1 建议关联表不超过3个</p><p>超过3个表关联的SQL，要向上反馈，尽量从业务和编码上避免3表以上关联，特别是对于千万级的表。</p><p>2.2.2 表关联字段必须有索引</p><p>写sql注意，表关联字段必须加索引，如果没有，要向上反馈，添加合适索引。</p><p>2.2.3 LEFT JOIN</p><p>LEFT JOIN 示例格式如下。</p><p><img src="file:///sql编写规范\wps20.png" alt="img"></p><p>对于LEFT JOIN ,因为设置左表为主表，在LEFT JOIN 的 ON中添加条件，是在关联前进行过滤。  </p><p>WHERE 条件中添加的子表条件，会对整体关联后的结果做过滤。 所以如果关联不到的记录，在关联后子表所有字段值为空，再添加条件会将所有记录过滤掉。  因此，禁止在WHERE 子句中添加子表条件，除非能保证结果正确。  </p><p>以上示例中，WHERE 子句的  APFD.STATUS=‘2’ 应添加在ON 子句中。 </p><p>2.2.4 INNER JOIN</p><p>INNER JOIN示例格式如下。</p><p><img src="file:///sql编写规范\wps21.png" alt="img"></p><p>INNER JOIN 为全关联。  仍然建议条件添加在ON 子句中，以优化性能。</p><p>2.2.5 其他关联</p><p>建议不使用其他关联。 有特殊业务需求时，可以使用，但应明确了解查询结果的匹配，保证结果正确，并对SQL进行适当的优化。</p><p>2.3 别名规范</p><p>在SQL 查询中，所有表名应使用别名。 字段名尽量避免使用别名。 使用别名时，不使用 AS 关键字进行分隔。 </p><p>例如：</p><p><img src="file:///sql编写规范\wps22.png" alt="img"></p><p>2.3.1 表别名</p><p>表别名默认以”_” 分隔表名，每部分取首字母，例如 ABS_PROJECT_FLOW 别名为 APF, ABS_PROJECT_FLOW_DICT别名为APFD。</p><p>特殊情况下，如果表别名重复或单表关联的情况下，可使用字母或数字区分别名。</p><p>尽量避免简单粗暴的使用 a、b、c类似的纯字母命令。</p><p>2.3.2 字段别名</p><p>默认不使用字段别名。</p><p>对结果列运算或多表关联后重复的列，需要使用别名的，可以考虑使用运算前的列名作为别名，重复的，可以添加数字后缀作为别名。</p><p>非必要情况，应尽量避免对列结果进行运算。（减少SQL语句对数据库兼容性的约束，方便代码移植）</p><p>2.4 参数名</p><p>参数名应与列名保持一致，对同一列做多个限制的，可以根据限制的类别，例如MIN  MAX等，添加MIN MAX后缀。</p><p>3 SQL性能优化要求</p><p>3.1 子查询</p><p>禁止在 SELECT 子句中使用任何子查询。</p><p>尽量避免在WHERE 条件值中使用子查询（根据条件而定，使用IN和EXISTS子句不可避免 ）</p><p>尽量使用表关联完成功能。</p><p>3.2 SELECT子句</p><p>默认SELECT 子句中不允许使用 “*” 。</p><p>Count函数中根据结果需求可选择使用 “<em>”。（使用</em>列为空时计算该列， 使用 列名等，如果该列为 null 则不计算。）</p><p>通用分页方法中使用 “*” 基本不可避免，不考虑。</p><p>3.3 分组查询优化</p><p>WHERE子句替换HAVING子句。  </p><p><img src="file:///sql编写规范\wps23.png" alt="img"></p><p>3.4 避免隐式转换</p><p>在使用纯数字常量时，根据数据库字段的类型，数据库会自动转换数字类型为数字或字符。 实际写SQL 时，应避免此类情况发生。</p><p>在SQL中，所有数字字符应以 ‘1’这样的形式出现。  纯数字应只匹配NUMBER类型。</p><p>DATE‘2017-02-23’ 语法等于 TO_DATE(‘2017-02-23’,’YYYY-MM-DD’)</p><p>3.5 运算添加在常量端</p><p>严格禁止对WHERE 子句中的列所任何运算。 应将运算添加在条件常量或参数一端。</p><p>例如：</p><p><img src="file:///sql编写规范\wps24.png" alt="img"></p><p>3.6 EXISTS代替IN</p><p>使用EXISTS语法代替IN语法以提高性能。</p><p><img src="file:///sql编写规范\wps25.png" alt="img"></p><p>3.7 NOT EXISTS代替NOT IN</p><p>语法同上。</p><p>3.8 表连接替换EXISTS</p><p><img src="file:///sql编写规范\wps26.png" alt="img"></p><p>3.9 用EXISTS替换DISTINCT</p><p><img src="file:///sql编写规范\wps27.png" alt="img"></p><p>3.10 注意索引列</p><p>设计时应根据数据查询频度设计表索引。 查询时应适当注意索引类型，以优化查询效率。（索引应尽量在设计数据库表时根据数据量和查询特性确定，当然后期仍然可以添加）</p><p>注意： 模糊查询的前置 “%” 会使索引失效。 必须支持全模糊查询的，目前没有更好的优化方法。</p><p>禁止在索引列上使用计算列。（同3.5，但严格禁止）</p><p>3.11 索引列上禁止使用IS NULL和IS NOT NULL</p><p>在索引列上使用IS NULL 和IS NOT NULL 将使索引失效。  应在设计时，对可以规避允许为空的列进行规避，设定默认值。</p><p>3.12 使用UNION-ALL和UNION</p><p>当SQL语句需要UNION两个查询结果集合时，这两个结果集合会以UNION-ALL的方式被合并，然后在输出最终结果前进行排序。</p><p>如果用UNION ALL替代UNION，这样排序就不是必要了，效率就会因此得到提高。</p><p>需要注意的是，UNION ALL将重复输出两个结果集合中相同记录，因此还是要从业务需求分析使用UNION ALL的可行性。</p><p>关于索引下列经验请参考:</p><p>如果检索数据量超过30%的表中记录数，使用索引将没有显著的效率提高；</p><p>在特定情况下，使用索引也许会比全表扫描慢，但这是同一个数量级上的差距；而通常情况下，使用索引比全表扫描要快几倍乃至几千倍！</p>]]></content>
      
      
      <categories>
          
          <category> 规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clickhouse集群版部署-clickhouse-keeper</title>
      <link href="/2023/08/23/clickhouse%E9%9B%86%E7%BE%A4%E7%89%88%E9%83%A8%E7%BD%B2-clickhouse-keeper/"/>
      <url>/2023/08/23/clickhouse%E9%9B%86%E7%BE%A4%E7%89%88%E9%83%A8%E7%BD%B2-clickhouse-keeper/</url>
      
        <content type="html"><![CDATA[<p><strong><em>\</em>前言**</strong></p><p>本文档为基于ClickHouse-Keeper搭建集群，和单机版本安装步骤差不多，差异在于在config.xml中增加一段配置，以及增加了metrika.xml配置文件，安装过程中需要在防火墙中多开几个端口号。以下为基于单机版本ClickHouse安装步骤增加了集群的内容，集群内容为标黄色字体。</p><p>多节点配置文件样例SVN地址：<a href="https://192.168.60.125/svn/非银绩效分析/06_实施/01_中信XT/部署/clickhouse/集群版本配置_clickhouse-keeper/" target="_blank" rel="noopener">https://192.168.60.125/svn/非银绩效分析/06_实施/01_中信XT/部署/clickhouse/集群版本配置_clickhouse-keeper/</a></p><p><strong><em>\</em>clickhouse安装与启动**</strong></p><table><thead><tr><th>操作步骤与用户</th><th>操作内容</th></tr></thead><tbody><tr><td>创建用户/root</td><td>1.创建用户 useradd clickhouse</td></tr><tr><td>解压安装包/root</td><td>1. 上传安装包及单机配置文件到/home/clickhouseSvn路径：<a href="https://192.168.60.125/svn/非银绩效分析/06_实施/01_中信XT/部署/clickhouse1" target="_blank" rel="noopener">https://192.168.60.125/svn/非银绩效分析/06_实施/01_中信XT/部署/clickhouse1</a>. 解压安装包 (clickhouse-client-22.3.6.5.tar.gz, clickhouse-common-static-22.3.6.5.tar.gz,clickhouse-server-22.3.6.5.tar.gz) cd /home/clickhouse tar -zxvf clickhouse-client-22.3.6.5-amd64.tgztar -zxvf clickhouse-common-static-22.3.6.5-amd64.tgztar -zxvf clickhouse-server-22.3.6.5-amd64.tgz</td></tr><tr><td>安装列式数据库/root</td><td>1.安装公共包 ./clickhouse-common-static-22.3.6.5/install/doinst.sh 2.安装服务端./clickhouse-server-22.3.6.5/install/doinst.sh<img src="file:///clickhouse集群版部署-clickhouse-keeper\wps9.jpg" alt="img"> 输入 cebrisk<img src="file:///clickhouse集群版部署-clickhouse-keeper\wps10.jpg" alt="img"> 输入 N <img src="file:///clickhouse集群版部署-clickhouse-keeper\wps11.jpg" alt="img">安装服务端成功 3. 安装客户端 ./clickhouse-client-22.3.6.5/install/doinst.sh</td></tr><tr><td>防火墙增加端口配置/root</td><td>1. 防火墙增加端口配置 firewall-cmd –add-port=8123/tcp –permanent firewall-cmd –add-port=9000/tcp –permanent firewall-cmd –add-port=9004/tcp –permanent 集群：下面是clickhouse-keeper集群配置需要放开的端口：firewall-cmd –add-port=9181/tcp –permanentfirewall-cmd –add-port=9234/tcp –permanentfirewall-cmd –add-port=9009/tcp –permanent 2. 重新加载防火墙配置 firewall-cmd –reload</td></tr><tr><td>创建数据挂载目录/root</td><td>1. 创建数据挂载目录 (根据实际硬盘挂载目录再调整) mkdir -p /大空间目录/ck1此处使用mkdir -p /data/clickhouse/ck1（实际情况调整）  2. 给目录赋权 chown clickhouse:clickhouse -R /大空间目录/ck1此处使用chown clickhouse:clickhouse -R /data/clickhouse/ck1查看storage.xml里配置的存储路径<img src="file:///clickhouse集群版部署-clickhouse-keeper\wps12.jpg" alt="img"> 修改config.xml中关于本机ip等配置 clickhouse-keeper集群相关：在config.xml中增加集群配置：<img src="file:///clickhouse集群版部署-clickhouse-keeper\wps13.jpg" alt="img"> 需要注意：1、集群中每个IP节点的config.xml中都需要增加这段配置，且每个文件中第53行server_id不能重复；2、从第65行开始，集群中有多少个节点就配置多少个server，比如样例中有三个节点，那么每个config.xml中65~87行是一样的。id和priority可以配自增的数字，IP改成对应的IP，端口号9234不用改；3、第95行要改成对应节点的IP地址；样例：  &lt;keeper_server&gt;    &lt;tcp_port&gt;9181&lt;/tcp_port&gt;    &lt;server_id&gt;1&lt;/server_id&gt;    &lt;log_storage_path&gt;/var/lib/clickhouse/coordination/log&lt;/log_storage_path&gt;    &lt;snapshot_storage_path&gt;/var/lib/clickhouse/coordination/snapshots&lt;/snapshot_storage_path&gt;     &lt;coordination_settings&gt;      &lt;operation_timeout_ms&gt;5000&lt;/operation_timeout_ms&gt;      &lt;session_timeout_ms&gt;10000&lt;/session_timeout_ms&gt;      &lt;snapshot_distance&gt;75&lt;/snapshot_distance&gt;      &lt;raft_logs_level&gt;trace&lt;/raft_logs_level&gt;    &lt;/coordination_settings&gt;     &lt;raft_configuration&gt;      <server>        <id>1</id>        <hostname>192.168.88.67</hostname>        <port>9234</port>        &lt;can_become_leader&gt;true&lt;/can_become_leader&gt;        <priority>1</priority>      </server>      <server>        <id>2</id>        <hostname>192.168.88.68</hostname>        <port>9234</port>        &lt;can_become_leader&gt;true&lt;/can_become_leader&gt;        &lt;start_as_follower&gt;true&lt;/start_as_follower&gt;        <priority>2</priority>      </server>      <server>        <id>3</id>        <hostname>192.168.88.69</hostname>        <port>9234</port>        &lt;can_become_leader&gt;true&lt;/can_become_leader&gt;        &lt;start_as_follower&gt;true&lt;/start_as_follower&gt;        <priority>3</priority>      </server>    &lt;/raft_configuration&gt;  &lt;/keeper_server&gt;   &lt;include_from&gt;/etc/clickhouse-server/metrika.xml&lt;/include_from&gt;  &lt;remote_servers incl=”clickhouse_remote_servers” /&gt;  <zookeeper incl="zookeeper-servers" optional="true">  <compression incl="clickhouse_compression" optional="true">  &lt;interserver_http_host&gt;192.168.88.67&lt;/interserver_http_host&gt;  <macros incl="macros" optional="true"> 增加集群配置文件metrika.xml：<img src="file:///clickhouse集群版部署-clickhouse-keeper\wps14.jpg" alt="img"> 需要注意：1、上面和下面两段分别也要配置所有节点的IP，上面还需要配置数据库实际端口（通常是9000，如果更改了则配置修改后的）、数据库的用户和密码，密码也可以配置密文；2、下面那段IP中的端口9181不需要修改，中间第35行配所在节点的IP； 样例：&lt;?xml version=”1.0”?&gt;<clickhouse>  <!-- 集群配置 -->  &lt;clickhouse_remote_servers&gt;    <!-- 集群名称 一分配一副本，名称可自定义 -->    <jxshares>      <!-- 数据分片1  -->      <shard>        &lt;internal_replication&gt;true&lt;/internal_replication&gt;        <replica>          <host>192.168.88.67</host>          <port>9000</port>          <user>cebrisk</user>          <password>cebrisk</password>        </replica>        <replica>          <host>192.168.88.68</host>          <port>9000</port>          <user>cebrisk</user>          <password>cebrisk</password>        </replica>        <replica>          <host>192.168.88.69</host>          <port>9000</port>          <user>cebrisk</user>          <password>cebrisk</password>        </replica>      </shard>    </jxshares>  &lt;/clickhouse_remote_servers&gt;   <!-- 本服务器的ip地址 -->  <macros>    <shard>node01</shard>    <replica>192.168.88.67</replica>  </macros>  <zookeeper-servers>    <node index="1">      <host>192.168.88.67</host>      <port>9181</port>    </node>    <node index="2">      <host>192.168.88.68</host>      <port>9181</port>    </node>    <node index="3">      <host>192.168.88.69</host>      <port>9181</port>    </node>  </zookeeper-servers>    &lt;clickhouse_compression&gt;    <case>      &lt;min_part_size&gt;10000000000&lt;/min_part_size&gt;      &lt;min_part_size_ratio&gt;0.01&lt;/min_part_size_ratio&gt;      <method>lz4</method>    </case>  &lt;/clickhouse_compression&gt;</clickhouse> 2.1 其他关于大目录的修改点,见如下文件<img src="file:///clickhouse集群版部署-clickhouse-keeper\wps15.png" alt="img"> 如果目录空间不够需要更换目录的话，执行以下（待定，命令尚不完善）： <strong><img src="file:///clickhouse集群版部署-clickhouse-keeper\wps16.png" alt="img"></strong>  3.复制配置文件（storage.xml需要先修改路径到大空间目录下） cp storage.xml /etc/clickhouse-server/config.d/storage.xml cp users.xml /etc/clickhouse-server/users.xmlcp config.xml /etc/clickhouse-server/config.xmlcp metrika.xml /etc/clickhouse-server/metrika.xml 如果提示是否强制替换？输入 y：是  4.配置目录属主赋予clickhouse用户 chown clickhouse:clickhouse -R /etc/clickhouse-serverchown clickhouse:clickhouse -R /etc/clickhouse-client/chown clickhouse:clickhouse -R /home/clickhouse/ck1/ 5. 注意看一下config.xml中的大文件路径是否已经修改（修改/etc/clickhouse-server/config.xml下的)clickhouse.logger.logclickhouse.logger.errorlogclickhouse.keeper_server.snapshot_storage_pathclickhouse.tmp_path</macros></compression></zookeeper></td></tr><tr><td>启动服务，同步数据/root</td><td>1.启动服务 clickhouse start  2.登录客户端 clickhouse-client -h 127.0.0.1 -u cebrisk –password cebrisk若遇到登录错误时可查看日志检查是否与以下命令有关，如果有关，则需执行以下命令openssl dhparam -out /etc/clickhouse-server/dhparam.pem 4096相关命令存在于config.xml中，可查看相关解决问题openssl req -subj “/CN=localhost” -new -newkey rsa:2048 -days 365 -nodes -x509 -keyout /etc/clickhouse-server/server.key -out /etc/clickhouse-server/server.crt</td></tr><tr><td>clickhouse-backup安装</td><td>0. cd /home/clickhouse1. tar -xf clickhouse-backup.tar 2. cd clickhouse-backup3. cp clickhouse-backup /usr/local/bin4. 验证: clickhouse-backup -v<img src="file:///clickhouse集群版部署-clickhouse-keeper\wps17.jpg" alt="img"> 5. 配置目录属主赋予clickhouse用户 chown clickhouse:clickhouse -R /usr/local/bin/clickhouse-backup 6. 添加配置文件到/etc/clickhouse-backup/config.yml。如果没有则创建目录及文件。注意账号密码是否需要修改<img src="file:///clickhouse集群版部署-clickhouse-keeper\wps18.jpg" alt="img"> general: remote_storage: none backups_to_keep_local: 30 backups_to_keep_remote: 31clickhouse: username: cebrisk password: cebrisk host: localhost port: 9000 data_path: “/var/log/clickhouse-server/data”</td></tr><tr><td>查看日志</td><td>tail -200f /var/log/clickhouse-server/clickhouse-server.log</td></tr><tr><td>导入数据库脚本</td><td>clickhouse-client -h 127.0.0.1 -u cebrisk –password cebrisk –multiquery &lt; /home/clickhouse/20200627_clickhouse单库基础数据.sql** 注意到数据库脚本已经内部创建数据库，可根据实际修改<img src="file:///clickhouse集群版部署-clickhouse-keeper\wps19.jpg" alt="img"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 实施 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clickhouse单机版部署</title>
      <link href="/2023/08/23/clickhouse%E5%8D%95%E6%9C%BA%E7%89%88%E9%83%A8%E7%BD%B2/"/>
      <url>/2023/08/23/clickhouse%E5%8D%95%E6%9C%BA%E7%89%88%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p><strong><em>\</em>clickhouse安装与启动**</strong></p><table><thead><tr><th>操作步骤与用户</th><th>操作内容</th></tr></thead><tbody><tr><td>创建用户/root</td><td>1.创建用户 useradd clickhouse</td></tr><tr><td>解压安装包/root</td><td>1. 上传安装包及单机配置文件到/home/clickhouseSvn路径：<a href="https://192.168.60.125/svn/非银绩效分析/06_实施/01_中信XT/部署/clickhouse1" target="_blank" rel="noopener">https://192.168.60.125/svn/非银绩效分析/06_实施/01_中信XT/部署/clickhouse1</a>. 解压安装包 (clickhouse-client-22.3.6.5.tar.gz, clickhouse-common-static-22.3.6.5.tar.gz,clickhouse-server-22.3.6.5.tar.gz) cd /home/clickhouse ls *.tar.gz \</td><td>xargs -n1 tar xzvf</td></tr><tr><td>安装列式数据库/root</td><td>1.安装公共包 ./clickhouse-common-static-22.3.6.5/install/doinst.sh 2.安装服务端./clickhouse-server-22.3.6.5/install/doinst.sh<img src="/2023/08/23/clickhouse单机版部署/wps1.jpg" alt="img"> 输入 cebrisk<img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml9560\wps2.jpg" alt="img"> 输入 N <img src="file:///clickhouse单机版部署\wps3.jpg" alt="img">安装服务端成功 3. 安装客户端 ./clickhouse-client-22.3.6.5/install/doinst.sh</td></tr><tr><td>防火墙增加端口配置/root</td><td>1. 防火墙增加端口配置 firewall-cmd –add-port=8123/tcp –permanent firewall-cmd –add-port=9000/tcp –permanent firewall-cmd –add-port=9004/tcp –permanent  2. 重新加载防火墙配置 firewall-cmd –reload</td></tr><tr><td>创建数据挂载目录/root</td><td>1. 创建数据挂载目录 (根据实际硬盘挂载目录再调整) mkdir -p /大空间目录/ck1此处使用mkdir -p /home/clickhouse/ck1（实际情况调整）  2. 给目录赋权 chown clickhouse:clickhouse -R /大空间目录/ck1此处使用chown clickhouse:clickhouse -R /home/clickhouse/ck1查看storage.xml里配置的存储路径<img src="file:///clickhouse单机版部署\wps4.jpg" alt="img"> 修改config.xml中关于本机ip等配置 如果目录空间不够需要更换目录的话，执行以下（待定，命令尚不完善）： <strong><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml9560\wps5.png" alt="img"></strong>  3.复制配置文件（storage.xml需要先修改路径到大空间目录下） cp storage.xml /etc/clickhouse-server/config.d/storage.xml cp users.xml /etc/clickhouse-server/users.xmlcp config.xml /etc/clickhouse-server/config.xml 如果提示是否强制替换？输入 y：是  4.配置目录属主赋予clickhouse用户 chown clickhouse:clickhouse -R /etc/clickhouse-serverchown clickhouse:clickhouse -R /etc/clickhouse-client/chown clickhouse:clickhouse -R /home/clickhouse(修改到大空间目录)</td></tr><tr><td>启动服务，同步数据/root</td><td>1.启动服务 clickhouse start  2.登录客户端 clickhouse-client -h 127.0.0.1 -u cebrisk –password cebrisk若遇到登录错误时可查看日志检查是否与以下命令有关，如果有关，则需执行以下命令openssl dhparam -out /etc/clickhouse-server/dhparam.pem 4096相关命令存在于config.xml中，可查看相关解决问题openssl req -subj “/CN=localhost” -new -newkey rsa:2048 -days 365 -nodes -x509 -keyout /etc/clickhouse-server/server.key -out /etc/clickhouse-server/server.crt</td></tr><tr><td>clickhouse-backup安装</td><td>0. cd /home/clickhouse1. tar -xf clickhouse-backup.tar 2. cd clickhouse-backup chmod +x clickhouse-backup3. cp clickhouse-backup  /usr/local/bin4. 验证: clickhouse-backup –v<img src="file:///clickhouse单机版部署\wps6.jpg" alt="img"> 5. 配置目录属主赋予clickhouse用户 chown clickhouse:clickhouse -R /usr/local/bin/clickhouse-backup 6. 添加配置文件到/etc/clickhouse-backup/config.yml。如果没有则创建目录及文件。<img src="file:///clickhouse单机版部署\wps7.jpg" alt="img"> general: remote_storage: none backups_to_keep_local: 30 backups_to_keep_remote: 31clickhouse: username: cebrisk password: cebrisk host: localhost port: 9000 data_path: “/var/log/clickhouse-server/data”</td></tr><tr><td>查看日志</td><td>tail -200f /var/log/clickhouse-server/clickhouse-server.log</td></tr><tr><td>导入数据库脚本</td><td>clickhouse-client -h 127.0.0.1 -u cebrisk –password cebrisk –multiquery &lt; /home/clickhouse/20200627_clickhouse单库基础数据.sql** 注意到数据库脚本已经内部创建数据库，可根据实际修改<img src="file:///clickhouse单机版部署\wps8.jpg" alt="img"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 实施 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/2023/08/23/docker/"/>
      <url>/2023/08/23/docker/</url>
      
        <content type="html"><![CDATA[<h4 id="常见的指令"><a href="#常见的指令" class="headerlink" title="常见的指令"></a>常见的指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. docker ps 查看运行的容器</span><br><span class="line">2. docker restart 容器名/id 重启容器</span><br><span class="line">3. dokcer-compose down 关闭所有容器</span><br><span class="line">4. docker-compose up -d 启动所有服务</span><br><span class="line">5. docker logs -n 200  85e0bae108c5 查看容器后200行的日志</span><br><span class="line">6. docker logs -f  85e0bae108c5 实时查看容器的日志</span><br><span class="line">7. docker exec -it 85e0bae108c5 bash 进入某个容器内,然后执行python</span><br><span class="line">8. exit 退出容器</span><br></pre></td></tr></table></figure><h3 id="镜像保存及使用"><a href="#镜像保存及使用" class="headerlink" title="镜像保存及使用"></a>镜像保存及使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">完成对容器的修改和配置后，我们需要将这些变更提交为一个新的镜像。可以使用以下命令：</span><br><span class="line"></span><br><span class="line">docker commit &lt;container_name&gt; &lt;new_image_name&gt;</span><br><span class="line">参数解释：</span><br><span class="line">docker commit 是提交容器变更为镜像的命令</span><br><span class="line">&lt;container_name&gt; 是要提交的容器的名称或ID</span><br><span class="line">&lt;new_image_name&gt; 是新的镜像名称</span><br><span class="line"></span><br><span class="line">docker save -o &lt;output_path&gt; &lt;image_name&gt;</span><br><span class="line">参数解释：</span><br><span class="line">docker save 是保存镜像的命令</span><br><span class="line">-o 参数指定输出路径</span><br><span class="line">&lt;output_path&gt; 是保存镜像的输出路径（需包含文件名如xxx/xxx/name.jar）</span><br><span class="line">&lt;image_name&gt; 是要保存的镜像名称</span><br><span class="line"></span><br><span class="line">如果要推送到远程仓库，可以使用以下命令：</span><br><span class="line"></span><br><span class="line">docker push &lt;image_name&gt;</span><br><span class="line">参数解释：</span><br><span class="line">docker push 是推送镜像到远程仓库的命令</span><br><span class="line">&lt;image_name&gt; 是要推送的镜像名称</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">首先，我们需要创建一个Docker容器并运行。可以使用以下命令：</span><br><span class="line"></span><br><span class="line">docker run -it --name mycontainer &lt;image_name&gt;</span><br><span class="line">参数解释：</span><br><span class="line">docker run 是运行一个容器的命令</span><br><span class="line">-it 参数使容器运行在交互式终端模式下</span><br><span class="line">--name 参数指定容器的名称</span><br><span class="line">&lt;image_name&gt; 是用于创建容器的镜像名称</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 实施 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反向推包算法</title>
      <link href="/2023/04/26/%E5%8F%8D%E5%90%91%E6%8E%A8%E5%8C%85%E7%AE%97%E6%B3%95/"/>
      <url>/2023/04/26/%E5%8F%8D%E5%90%91%E6%8E%A8%E5%8C%85%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1. 理解什么是推包和反向推包:</span><br><span class="line">从海量资产中逆向筛选出满足要求的基础资产池,即条件已知反过来推符合条件的</span><br><span class="line">2. 模型的实现流程:前期处理-&gt;建立模型-&gt;求解模型</span><br><span class="line">前期处理: 备选池处理</span><br><span class="line">建立模型: 确定决策变量-&gt;决策变量取值限制-&gt;建立目标函数-&gt;设立约束条件</span><br><span class="line">模型求解: 单纯形法,分支切割法,目前代码使用的是CBC和GLOP</span><br><span class="line"></span><br><span class="line">要求是线性的: 非线性要转换成线性 a/b&gt;2 转换成a-2b&gt;0</span><br><span class="line"></span><br><span class="line">使用的是混合整数规划的思想,分成线性规划和纯整数规划.</span><br><span class="line"></span><br><span class="line">约束条件分成几类,其中规模必须有,按照优先级排序. 全部约束条件获取不到,则依次减少</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">代码层面:</span><br><span class="line">一: 对备选池数据进行筛选</span><br><span class="line">①按照约束条件进行排序</span><br><span class="line">②排序完,需要针对约束条件获取到最少获取的资产数量,目的是减少计算过程,省得浪费时间</span><br><span class="line">   1)按照资产规模上限,使用累计值,获取最低索引位置</span><br><span class="line">   2)按照2和3的资产规模限制获取最低的索引位置</span><br><span class="line">   3)当没有排序只有枚举值时候,使用枚举条件的第一个获取该字段大于0的最大索引和三倍规模上限获取最小的值. (3倍最大规模所在位置)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总次数TOTAL_TIME 的获取逻辑是什么,没看懂</span><br><span class="line">glop_cha=0.00的作用是什么</span><br><span class="line">跑这个代码对服务器的要求是怎么样的,内存,cpu</span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. File_parameter存放各个文件的地址,包含线性规划限制条件Parameter.csv,推包结果集result.csv. 资产池文件Asset_IN_10w.csv</span><br><span class="line">核心点就是Parameter文件</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python进行PDF识别</title>
      <link href="/2023/04/24/Python%E8%BF%9B%E8%A1%8CPDF%E8%AF%86%E5%88%AB/"/>
      <url>/2023/04/24/Python%E8%BF%9B%E8%A1%8CPDF%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主要是文字和表格识别,图片识别相对较少或者没有,针对图片识别,可以使用paddler-ocr或者pytenseract实现,或者自己训练一个卷积神经网络的模型进行识别(lspn+crnn)</span><br></pre></td></tr></table></figure><h4 id="2-业务知识"><a href="#2-业务知识" class="headerlink" title="2.业务知识"></a>2.业务知识</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">NPL: 代表不良</span><br><span class="line">情况说明:</span><br><span class="line">目前仅支持pdf的识别,doc文档不支持. 针对PDF版本,支持受托报告和发行说明书. 受托报告分为不良NPL和正常两种情况.两个代码. ABS+ABN合并识别,只要针对发行说明书.用到了ocr提取图片,不涉及文字提取.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ABS:资产证券化, 分为信贷ABS,企业ABS(格式不统一,正在做),ABN. </span><br><span class="line">ABS受托报告: 分为不良和正常两种,不良的pdf格式相对固定,需要返回的字段也不尽相同</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">匹配逻辑: 先看能不能匹配到对应的数据,能匹配到再查找想要的结果</span><br><span class="line">存在一些指标已经写好给定值,只需要判断在文档里能不能找到对应的值即可</span><br><span class="line">先匹配表格,没有再匹配文档,部分需要使用ocr去获取图片进行保存</span><br><span class="line"></span><br><span class="line">存在需要提取交易结构图的情况,分为两种情况,交易结构本来就是图和本来不是图.针对本来就是图的情况,需要使用坐标定位图片所在的位置(四个坐标位置),然后使用裁剪功能裁剪图片</span><br><span class="line"></span><br><span class="line">开发思路: 改bug或者匹配不准,先看规则的正则,然后看代码的正则</span><br><span class="line"></span><br><span class="line">新识别的开发思路: 按照某一个版本,重新写</span><br><span class="line">猜想:是否可以结合jieba提词</span><br><span class="line"></span><br><span class="line">难点:</span><br><span class="line">1.针对一个pdf文档,我怎么确定哪些是我需要的数据</span><br><span class="line">2.不同pdf格式的差别</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Clickhouse集群部署</title>
      <link href="/2023/04/18/Clickhouse%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"/>
      <url>/2023/04/18/Clickhouse%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>详细部署文档见D:\Blog\source_posts\Clickhouse集群部署\下的word文档</p><h3 id="ROOT部署"><a href="#ROOT部署" class="headerlink" title="ROOT部署"></a>ROOT部署</h3><table><thead><tr><th>一: 安装docker和docker-compose</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>服务器</td><td>操作用户</td><td>序列</td><td>步骤</td><td>操作命令</td></tr><tr><td>168.130.7.11 (APP1) 168.130.7.12 (APP2) 168.130.7.13 (DB1) 168.130.7.14 (DB2) 168.130.7.15 (CP1) 168.130.7.16 (CP2)</td><td>root</td><td>1</td><td>准备工作:hylc.zip</td><td>上传 hylc.zip 到 /home/hybrisk 目录</td></tr><tr><td>cd /home/hybrisk</td><td></td><td></td><td></td><td></td></tr><tr><td>unzip hylc.zip</td><td></td><td></td><td></td><td></td></tr><tr><td>cd hylc</td><td></td><td></td><td></td><td></td></tr><tr><td>mv docker_deploy ../</td><td></td><td></td><td></td><td></td></tr><tr><td>cd ../docker_deploy/1.docker-setup</td><td></td><td></td><td></td><td></td></tr><tr><td>2</td><td>安装docker和docker-compose</td><td>tar -zxf docker-20.10.11.tgz</td><td></td><td></td></tr><tr><td>cp docker/* /usr/local/bin/</td><td></td><td></td><td></td><td></td></tr><tr><td>cp docker-compose-Linux-x86_64 /usr/local/bin/docker-compose</td><td></td><td></td><td></td><td></td></tr><tr><td>chmod +x /usr/local/bin/docker-compose</td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td>新建docker配置文件</td><td>mkdir -p /etc/docker/</td><td></td><td></td></tr><tr><td>创建配置文件1</td><td>vi /etc/docker/daemon.json</td><td></td><td></td><td></td></tr><tr><td>填写文件内容（6行）</td><td>{   “registry-mirrors”: [     “<a href="https://registry.docker-cn.com&quot;" target="_blank" rel="noopener">https://registry.docker-cn.com&quot;</a>   ],   “data-root”: “/home/hybrisk/docker” }</td><td></td><td></td><td></td></tr><tr><td>创建配置文件2</td><td>vi /usr/lib/systemd/system/docker.service</td><td></td><td></td><td></td></tr><tr><td>填写文件内容（23行）</td><td>[Unit] Description=Docker Application Container Engine Documentation=<a href="https://docs.docker.com" target="_blank" rel="noopener">https://docs.docker.com</a> After=network-online.target firewalld.service Wants=network-online.target   [Service] Type=notify ExecStart=/usr/local/bin/dockerd ExecReload=/bin/kill -s HUP $MAINPID LimitNOFILE=infinity LimitNPROC=infinity TimeoutStartSec=0 Delegate=yes KillMode=process Restart=on-failure StartLimitBurst=3 StartLimitInterval=60s   [Install] WantedBy=multi-user.target</td><td></td><td></td><td></td></tr><tr><td>4</td><td>加载并启动docker</td><td>systemctl daemon-reload</td><td></td><td></td></tr><tr><td>systemctl enable docker</td><td></td><td></td><td></td><td></td></tr><tr><td>systemctl start docker</td><td></td><td></td><td></td><td></td></tr><tr><td>5</td><td>把hybrisk加入docker用户组，并对相应的文件赋权</td><td>groupadd docker</td><td></td><td></td></tr><tr><td>usermod -aG docker hybrisk</td><td></td><td></td><td></td><td></td></tr><tr><td>systemctl daemon-reload</td><td></td><td></td><td></td><td></td></tr><tr><td>systemctl restart docker</td><td></td><td></td><td></td><td></td></tr><tr><td>chown -R hybrisk:docker /home/hybrisk/docker</td><td></td><td></td><td></td><td></td></tr><tr><td>chown -R hybrisk:docker /usr/local/bin/containerd<em> /usr/local/bin/docker</em> /usr/local/bin/ctr /usr/local/bin/runc</td><td></td><td></td><td></td><td></td></tr><tr><td>chown -R hybrisk:docker /etc/docker/daemon.json</td><td></td><td></td><td></td><td></td></tr><tr><td>chown -R hybrisk:docker /usr/lib/systemd/system/docker.service</td><td></td><td></td><td></td><td></td></tr><tr><td>cd /home/hybrisk</td><td></td><td></td><td></td><td></td></tr><tr><td>chown -R hybrisk:hybrisk docker_deploy</td><td></td><td></td><td></td><td></td></tr><tr><td>chown -R hybrisk:hybrisk hylc hylc.zip</td><td></td><td></td><td></td></tr></tbody></table><p><img src="/2023/04/18/Clickhouse集群部署/image-20230418115612786.png" alt="image-20230418115612786"></p><p><img src="/2023/04/18/Clickhouse集群部署/image-20230418115633317.png" alt="image-20230418115633317"></p><table><thead><tr><th>二: 安装ClickHouse</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>服务器</td><td>用户</td><td>序列</td><td>描述</td><td>操作步骤</td></tr><tr><td>168.130.7.13(DB1) 168.130.7.14(DB2) 168.130.7.16(CP2)</td><td>root</td><td>1</td><td>确认clickhouse用户已经创建 确认clickhouse数据目录 如果没有，需要运维团队确认</td><td>ls /home/clickhouse</td></tr><tr><td>ls /home/clickhouse/data</td><td></td><td></td><td></td><td></td></tr><tr><td>2</td><td>准备工作:installs.zip</td><td>上传ClickHouse安装文件installs.zip 到 /home/clickhouse/data 目录</td><td></td><td></td></tr><tr><td>cd /home/clickhouse/data</td><td></td><td></td><td></td><td></td></tr><tr><td>unzip installs.zip</td><td></td><td></td><td></td><td></td></tr><tr><td>cd installs</td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td>解压安装包</td><td>tar -zxf clickhouse-client-22.3.6.5-amd64.tgz</td><td></td><td></td></tr><tr><td>tar -zxf clickhouse-common-static-22.3.6.5-amd64.tgz</td><td></td><td></td><td></td><td></td></tr><tr><td>tar -zxf clickhouse-server-22.3.6.5-amd64.tgz</td><td></td><td></td><td></td><td></td></tr><tr><td>4</td><td>安装公共包</td><td>./clickhouse-common-static-22.3.6.5/install/doinst.sh</td><td></td><td></td></tr><tr><td>5</td><td>安装服务端</td><td>./clickhouse-server-22.3.6.5/install/doinst.sh  输入hybrisk 输入N</td><td></td><td></td></tr><tr><td>6</td><td>安装客户端</td><td>./clickhouse-client-22.3.6.5/install/doinst.sh</td><td></td><td></td></tr><tr><td>7</td><td>如果防火墙开启，增加端口配置</td><td>systemctl status firewalld 确认返回： Active: active(running)。  如返回内容中包含 Active: inactive (dead)，则表示服务器没有开启防火墙，可以直接跳到第9步</td><td></td><td></td></tr><tr><td>firewall-cmd –add-port=8123/tcp –permanent</td><td></td><td></td><td></td><td></td></tr><tr><td>firewall-cmd –add-port=9000/tcp –permanent</td><td></td><td></td><td></td><td></td></tr><tr><td>firewall-cmd –add-port=9004/tcp –permanent</td><td></td><td></td><td></td><td></td></tr><tr><td>firewall-cmd –reload</td><td></td><td></td><td></td><td></td></tr><tr><td>8</td><td>创建数据挂载目录 (根据实际硬盘挂载目录再调整)</td><td>mkdir -p /home/clickhouse/data/ck1</td><td></td><td></td></tr><tr><td>9</td><td>给目录赋权</td><td>chown clickhouse:clickhouse -R /home/clickhouse/data/ck1</td><td></td><td></td></tr><tr><td>10</td><td>配置目录属主赋予clickhouse用户</td><td>chown clickhouse:clickhouse -R /etc/clickhouse-server</td><td></td><td></td></tr><tr><td>chown clickhouse:clickhouse -R /etc/clickhouse-client</td><td></td><td></td><td></td><td></td></tr><tr><td>chown clickhouse:clickhouse -R /home/clickhouse/data</td><td></td><td></td><td></td><td></td></tr><tr><td>root</td><td>11</td><td>备份工具安装： clickhouse-backup</td><td>cd /home/clickhouse/data/installs</td><td></td></tr><tr><td>tar -xf clickhouse-backup.tar</td><td></td><td></td><td></td><td></td></tr><tr><td>cd clickhouse-backup</td><td></td><td></td><td></td><td></td></tr><tr><td>cp clickhouse-backup /usr/local/bin/</td><td></td><td></td><td></td><td></td></tr><tr><td>chown clickhouse:clickhouse -R /usr/local/bin/clickhouse-backup</td><td></td><td></td><td></td><td></td></tr><tr><td>chown clickhouse:clickhouse -R /home/clickhouse/data</td><td></td><td></td><td></td></tr></tbody></table><p><img src="/2023/04/18/Clickhouse集群部署/image-20230418115817549.png" alt="image-20230418115817549"></p><h3 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h3><table><thead><tr><th>一: 启动ClickHouse</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>服务器</td><td>用户</td><td>序列</td><td>描述</td><td>操作步骤</td></tr><tr><td>168.130.7.13(DB1) 168.130.7.14(DB2) 168.130.7.16(CP2)</td><td>clickhouse</td><td>1</td><td>创建默认配置文件备份目录</td><td>mkdir /etc/clickhouse-server/bk</td></tr><tr><td>2</td><td>移除默认配置文件</td><td>chmod -R 775 /etc/clickhouse-server/</td><td></td><td></td></tr><tr><td>mv /etc/clickhouse-server/* /etc/clickhouse-server/bk</td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td>上传配置文件/13/*</td><td>cd /etc/clickhouse-server</td><td></td><td></td></tr><tr><td>中转机下载13.zip</td><td></td><td></td><td></td><td></td></tr><tr><td>unzip 13.zip</td><td></td><td></td><td></td><td></td></tr><tr><td>cd 13</td><td></td><td></td><td></td><td></td></tr><tr><td>mv * ../</td><td></td><td></td><td></td><td></td></tr><tr><td>chmod -R 755 /etc/clickhouse-server/</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>4</td><td>上传配置文件/14/*</td><td>cd /etc/clickhouse-server</td><td></td><td></td></tr><tr><td>中转机下载14.zip</td><td></td><td></td><td></td><td></td></tr><tr><td>unzip 14.zip</td><td></td><td></td><td></td><td></td></tr><tr><td>cd 14</td><td></td><td></td><td></td><td></td></tr><tr><td>mv * ../</td><td></td><td></td><td></td><td></td></tr><tr><td>chmod -R 755 /etc/clickhouse-server/</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>5</td><td>上传配置文件/16/*</td><td>cd /etc/clickhouse-server</td><td></td><td></td></tr><tr><td>中转机下载16.zip</td><td></td><td></td><td></td><td></td></tr><tr><td>unzip 16.zip</td><td></td><td></td><td></td><td></td></tr><tr><td>cd 16</td><td></td><td></td><td></td><td></td></tr><tr><td>mv * ../</td><td></td><td></td><td></td><td></td></tr><tr><td>chmod -R 755 /etc/clickhouse-server/</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>7</td><td>手动创建日志目录</td><td>mkdir /home/clickhouse/data/log</td><td></td><td></td></tr><tr><td>8</td><td>压缩备份脚本</td><td>cd /etc/clickhouse-server</td><td></td><td></td></tr><tr><td>zip -r bk.zip bk</td><td></td><td></td><td></td><td></td></tr><tr><td>rm -rf bk</td><td></td><td></td><td></td><td></td></tr><tr><td>9</td><td>启动clickhouse</td><td>clickhouse start</td><td></td></tr></tbody></table><p><img src="/2023/04/18/Clickhouse集群部署/image-20230418115948996.png" alt="image-20230418115948996"></p><table><thead><tr><th>二: ClickHouse 导入数据</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>服务器</td><td>用户</td><td>序列</td><td>描述</td><td>操作步骤</td><td></td></tr><tr><td>168.130.7.16(CP2)</td><td>clickhouse</td><td>1</td><td>创建备份目录(表结构)</td><td>mkdir /var/lib/clickhouse/backup</td><td></td></tr><tr><td>mkdir /home/clickhouse/data/ck1/backup</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>2</td><td>上传 ch_bk_yyyymmdd.table.zip</td><td>上传至 /var/lib/clickhouse/backup 目录</td><td></td><td></td><td></td></tr><tr><td>上传 ch_bk_yyyymmdd.data.zip</td><td>上传至 /home/clickhouse/data/ck1/backup 目录</td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td>上传三份配置文件到备份目录 config_13.xml, config_14.xml, config_15,xml</td><td>上传至 /var/lib/clickhouse/backup</td><td>一台服务器执行</td><td></td><td></td></tr><tr><td>4</td><td>登录客户端</td><td>clickhouse-client -h 127.0.0.1 -u cebrisk –password</td><td></td><td></td><td></td></tr><tr><td>5</td><td>创建数据库</td><td>create database chdb on cluster jxshares;</td><td></td><td></td><td></td></tr><tr><td>6</td><td>退出客户端</td><td>exit</td><td></td><td></td><td></td></tr><tr><td>7</td><td>导入表结构及数据</td><td>clickhouse-backup restore -c /var/lib/clickhouse/backup/config_13.yml -s ch_bk_yyyymmdd</td><td></td><td></td><td></td></tr><tr><td>clickhouse-backup restore -c /var/lib/clickhouse/backup/config_14.yml -s ch_bk_yyyymmdd</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>clickhouse-backup restore -c /var/lib/clickhouse/backup/config_16.yml ch_bk_yyyymmdd</td><td></td><td></td><td></td><td></td></tr></tbody></table><p><img src="/2023/04/18/Clickhouse集群部署/image-20230418120020095.png" alt="image-20230418120020095"></p><table><thead><tr><th>三: 导入MySQL数据</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>服务器</td><td>用户</td><td>序列</td><td>描述</td><td>操作步骤</td><td></td></tr><tr><td>168.130.7.13 (DB1)</td><td>mysql</td><td>1</td><td>导入数据</td><td>项目组提供数据文件，由行方数据库运维人员导入</td><td>完成</td></tr><tr><td>mysql -u hybrisk -p</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>use hybrisk</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>source /备份脚本路径/xxx.sql</td><td></td><td></td><td></td><td></td></tr></tbody></table><p><img src="/2023/04/18/Clickhouse集群部署/image-20230418120045035.png" alt="image-20230418120045035"></p><table><thead><tr><th>四: 安装应用</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>服务器</td><td>用户</td><td>序列</td><td>描述</td><td>操作步骤</td></tr><tr><td>168.130.7.11(APP1) 168.130.7.12(APP2)</td><td>hybrisk</td><td>1</td><td>上传文件 docker_deploy_xx.zip</td><td>上传至 /home/hybrisk/ 目录</td></tr><tr><td>2</td><td>放置安装文件</td><td>mkdir /home/hybrisk/tmp</td><td></td><td></td></tr><tr><td>mv docker_deploy_xx.zip /home/hybrisk/tmp/</td><td></td><td></td><td></td><td></td></tr><tr><td>cd /home/hybrisk/tmp/</td><td></td><td></td><td></td><td></td></tr><tr><td>unzip docker_deploy_xx.zip</td><td></td><td></td><td></td><td></td></tr><tr><td>cd  docker_deploy</td><td></td><td></td><td></td><td></td></tr><tr><td>mv * /home/hybrisk/docker_deploy</td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td>进镜像目录</td><td>cd /home/hybrisk/docker_deploy/images</td><td></td><td></td></tr><tr><td>4</td><td>加载Nginx镜像</td><td>docker load &lt; prmnginx.tar</td><td></td><td></td></tr><tr><td>5</td><td>加载金融算法镜像</td><td>docker load &lt; fin_server_1.2.0.tar</td><td></td><td></td></tr><tr><td>6</td><td>docker load &lt; fin_jupyter_1.0.0.tar</td><td></td><td></td><td></td></tr><tr><td>7</td><td>docker load &lt; jxhub_1.0.0.tar</td><td></td><td></td><td></td></tr><tr><td>8</td><td>加载jdk镜像</td><td>docker load &lt; openjdk_8u292-jdk_GMT8_1.0.tar</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td>docker load &lt; jxhub_1.0.0.tar</td></tr></tbody></table><p><img src="/2023/04/18/Clickhouse集群部署/image-20230418120113416.png" alt="image-20230418120113416"></p><table><thead><tr><th>五: 安装应用</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>服务器</td><td>用户</td><td>序列</td><td>描述</td><td>操作步骤</td></tr><tr><td>168.130.7.15(CP1) 168.130.7.16(CP2)</td><td>hybrisk</td><td>1</td><td>上传文件 docker_deploy_xx.zip</td><td>上传至 /home/hybrisk/ 目录</td></tr><tr><td>2</td><td>放置安装文件</td><td>mkdir /home/hybrisk/tmp</td><td></td><td></td></tr><tr><td>mv docker_deploy_xx.zip /home/hybrisk/tmp/</td><td></td><td></td><td></td><td></td></tr><tr><td>cd /home/hybrisk/tmp/</td><td></td><td></td><td></td><td></td></tr><tr><td>unzip docker_deploy_xx.zip</td><td></td><td></td><td></td><td></td></tr><tr><td>cd  docker_deploy</td><td></td><td></td><td></td><td></td></tr><tr><td>mv * /home/hybrisk/docker_deploy</td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td>进镜像目录</td><td>cd /home/hybrisk/docker_deploy/images</td><td></td><td></td></tr><tr><td>7</td><td>加载jdk镜像</td><td>docker load &lt; openjdk_8u292-jdk_GMT8_1.0.tar</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>六: 启动应用</td><td></td><td></td><td></td><td></td></tr><tr><td>服务器</td><td>用户</td><td>序列</td><td>描述</td><td>操作步骤</td></tr><tr><td>168.130.7.11(APP1) 168.130.7.12(APP2) 168.130.7.15(CP1) 168.130.7.16(CP2)</td><td>hybrisk</td><td>1</td><td>登录启动目录</td><td>cd /home/hybrisk/docker_deploy/dc-start</td></tr><tr><td>2</td><td>启动所有应用</td><td>docker-compose up -d</td><td></td><td></td></tr><tr><td>3</td><td>停止所有应用</td><td>docker-compose down</td><td></td><td></td></tr><tr><td>4</td><td>重启某个应用</td><td>docker-compose restart 某应用</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>七: 验证</td><td></td><td></td><td></td><td></td></tr><tr><td>服务器</td><td>用户</td><td>序列</td><td>描述</td><td>操作步骤</td></tr><tr><td>办公终端</td><td></td><td>1</td><td>绩效归因服务</td><td><a href="http://168.130.7.17/hxbweb/" target="_blank" rel="noopener">http://168.130.7.17/hxbweb/</a></td></tr><tr><td>2</td><td>绩效归因中台</td><td><a href="http://168.130.7.17/dpweb/" target="_blank" rel="noopener">http://168.130.7.17/dpweb/</a></td><td></td><td></td></tr><tr><td>堡垒机/跳板机</td><td></td><td>3</td><td>注册中心</td><td><a href="http://168.130.7.11:8761" target="_blank" rel="noopener">http://168.130.7.11:8761</a></td></tr><tr><td>4</td><td>金融算法开发平台</td><td><a href="http://168.130.7.11:8001" target="_blank" rel="noopener">http://168.130.7.11:8001</a></td><td></td><td></td></tr><tr><td>5</td><td>MySQL连接</td><td>168.130.7.18:3306/dbrisk</td><td></td><td></td></tr><tr><td>6</td><td>ClickHouse连接(dbeaver)</td><td>168.130.7.19:8123/chdb</td><td></td></tr></tbody></table><p><img src="/2023/04/18/Clickhouse集群部署/image-20230418120145697.png" alt="image-20230418120145697"></p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p><img src="/2023/04/18/Clickhouse集群部署/image-20230418133702182.png" alt="image-20230418133702182"></p>]]></content>
      
      
      <categories>
          
          <category> Clickhouse </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tets</title>
      <link href="/2023/04/11/tets/"/>
      <url>/2023/04/11/tets/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/03/31/clickhouse%E6%9B%B4%E6%96%B0%E6%8F%92%E5%85%A5/"/>
      <url>/2023/03/31/clickhouse%E6%9B%B4%E6%96%B0%E6%8F%92%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br></pre></td><td class="code"><pre><span class="line">指定引擎: engine=CollapsingMergeTree</span><br><span class="line">逻辑: </span><br><span class="line">1.构建临时表</span><br><span class="line">2.向临时表中插入批跑出来的数据, 包含字段: 批返回的字段+ CREATE_TIME, CREATE_USER, UPDATE_TIME, INPUT_TYPE, _sign</span><br><span class="line">3.向目标表插入新增的主键数据(eg: 新增的PORT_ID,VALID_DATE)</span><br><span class="line">4.向目标表插入批跑出来的数据(关联目标表,按照主键<span class="keyword">merge</span>,需要更新的字段从临时表获取,不需要更新的从目标表获取)</span><br><span class="line"><span class="number">5.</span>整合更新最新数据</span><br><span class="line">①无分区键: 直接<span class="string">"optimize table "</span> + table_name + <span class="string">" final"</span></span><br><span class="line">②有分区键: <span class="string">"optimize table dwd_val_detail PARTITION + 分区id+ final"</span></span><br><span class="line"></span><br><span class="line">案例:</span><br><span class="line"><span class="number">1.</span>                           </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dwd_val_detail2C3wru86 <span class="keyword">AS</span> dwd_val_detail <span class="keyword">engine</span>=CollapsingMergeTree(_sign) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(VALID_DATE)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>  (SEC_ID,</span><br><span class="line">         PORT_ID,</span><br><span class="line">         SUB_PORT_ID,</span><br><span class="line">         VALID_DATE,</span><br><span class="line">         ACCOUNT_CLASS_TYPE) <span class="keyword">SETTINGS</span> index_granularity = <span class="number">8192</span></span><br><span class="line"> <span class="number">2.</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tag_val_detailM7mZbs4d(PORT_ID, SUB_PORT_ID, SEC_ID, ACCOUNT_CLASS_TYPE, VALID_DATE, UPDATE_USER, REAL_SEC_ID, CREATE_TIME, CREATE_USER, UPDATE_TIME, INPUT_TYPE, _sign) <span class="keyword">VALUES</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dwd_val_detail <span class="keyword">select</span> * <span class="keyword">from</span> dwd_val_detailgACo328j <span class="keyword">where</span> (PORT_ID,SUB_PORT_ID,SEC_ID,VALID_DATE,ACCOUNT_CLASS_TYPE) <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">DISTINCT</span> PORT_ID,SUB_PORT_ID,SEC_ID,VALID_DATE,ACCOUNT_CLASS_TYPE <span class="keyword">from</span> dwd_val_detail)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dwd_val_detail (SEC_ID,</span><br><span class="line">        VALUATION_METHODS,</span><br><span class="line">        BACK_AMOUNT,</span><br><span class="line">        COUNTERPARTY_ID,</span><br><span class="line">        END_DATE,</span><br><span class="line">        INTECALC_RULE,</span><br><span class="line">        UNDERLYING_CODE,</span><br><span class="line">        UNDERLYING_VOLUME,</span><br><span class="line">        ORDER_ID,</span><br><span class="line">        F_JSFXJ,</span><br><span class="line">        F_HHF,</span><br><span class="line">        F_RGF,</span><br><span class="line">        F_SGF,</span><br><span class="line">        F_SHF,</span><br><span class="line">        INT_RATE,</span><br><span class="line">        ASS_CODE,</span><br><span class="line">        CASH_PS_PAYMENT,</span><br><span class="line">        BOND_PS_PAYMENT,</span><br><span class="line">        F_YHS,</span><br><span class="line">        F_JSF,</span><br><span class="line">        F_GHF,</span><br><span class="line">        F_ZGF,</span><br><span class="line">        F_JSFWF,</span><br><span class="line">        REGIST_ORG,</span><br><span class="line">        REMARK,</span><br><span class="line">        SETTLE_SPEED,</span><br><span class="line">        PAR_VALUE,</span><br><span class="line">        CPRICE_AMT,</span><br><span class="line">        FPRICE_AMT,</span><br><span class="line">        INV_AIM,</span><br><span class="line">        TRAN_COMMISION,</span><br><span class="line">        TRADER_NAME,</span><br><span class="line">        IMGR_ID_NAME,</span><br><span class="line">        TRAN_STATUS,</span><br><span class="line">        CPRICE_DATE,</span><br><span class="line">        IS_CANCEL,</span><br><span class="line">        COUNTER_TRADER,</span><br><span class="line">        ENT_INT_FLAG,</span><br><span class="line">        LONG_CURRENCY,</span><br><span class="line">        LONG_QUANTITY,</span><br><span class="line">        LONG_PRINCIPAL,</span><br><span class="line">        LONG_INTEREST,</span><br><span class="line">        LONG_AMOUNT,</span><br><span class="line">        LONG_TRAN_FEE,</span><br><span class="line">        TRADE_ID,</span><br><span class="line">        DEAL_DEP,</span><br><span class="line">        TRAN_DATE,</span><br><span class="line">        SETTLE_DATE,</span><br><span class="line">        TRAN_SIDE,</span><br><span class="line">        PRICE_YIELD,</span><br><span class="line">        COUNTER_PARTY,</span><br><span class="line">        Column39,</span><br><span class="line">        Column40,</span><br><span class="line">        Column41,</span><br><span class="line">        SEC_ABBR,</span><br><span class="line">        REAL_SEC_ID,</span><br><span class="line">        NET_VAL_DATE,</span><br><span class="line">        NET_VAL_PRICE,</span><br><span class="line">        Column32,</span><br><span class="line">        Column33,</span><br><span class="line">        Column34,</span><br><span class="line">        Column35,</span><br><span class="line">        Column36,</span><br><span class="line">        Column37,</span><br><span class="line">        Column38,</span><br><span class="line">        Column25,</span><br><span class="line">        Column26,</span><br><span class="line">        Column27,</span><br><span class="line">        Column28,</span><br><span class="line">        Column29,</span><br><span class="line">        Column30,</span><br><span class="line">        Column31,</span><br><span class="line">        Column18,</span><br><span class="line">        Column19,</span><br><span class="line">        Column20,</span><br><span class="line">        Column21,</span><br><span class="line">        Column22,</span><br><span class="line">        Column23,</span><br><span class="line">        Column24,</span><br><span class="line">        Column11,</span><br><span class="line">        Column12,</span><br><span class="line">        Column13,</span><br><span class="line">        Column14,</span><br><span class="line">        Column15,</span><br><span class="line">        Column16,</span><br><span class="line">        Column17,</span><br><span class="line">        Column4,</span><br><span class="line">        Column5,</span><br><span class="line">        Column6,</span><br><span class="line">        Column7,</span><br><span class="line">        Column8,</span><br><span class="line">        Column9,</span><br><span class="line">        Column10,</span><br><span class="line">        TRADE_MARKET,</span><br><span class="line">        SEC_CATEGORY,</span><br><span class="line">        ACC_ID,</span><br><span class="line">        ACC_NAME,</span><br><span class="line">        Column1,</span><br><span class="line">        Column2,</span><br><span class="line">        Column3,</span><br><span class="line">        L_MV_LOSS,</span><br><span class="line">        L_NET_MV_LOSS,</span><br><span class="line">        NET_MV_LOSS,</span><br><span class="line">        ASSET_BIG_TYPE,</span><br><span class="line">        ASSET_CATEGORY,</span><br><span class="line">        LEVEL_TYPE,</span><br><span class="line">        PORT_NAME,</span><br><span class="line">        _sign,</span><br><span class="line">        SUB_PORT_ID,</span><br><span class="line">        DEPT_ID,</span><br><span class="line">        ASSET_LOSS,</span><br><span class="line">        IS_LT_BOUNDED,</span><br><span class="line">        L_ASSET_LOSS,</span><br><span class="line">        FULL_MV_LOSS,</span><br><span class="line">        UPDATE_USER,</span><br><span class="line">        UPDATE_TIME,</span><br><span class="line">        INPUT_TYPE,</span><br><span class="line">        L_SHADOW_MV,</span><br><span class="line">        L_SHADOW_DELTA,</span><br><span class="line">        FULL_COST,</span><br><span class="line">        L_FULL_COST,</span><br><span class="line">        L_R_GL,</span><br><span class="line">        L_GAINLOSS_GL,</span><br><span class="line">        L_AMOR_GL,</span><br><span class="line">        L_TOTAL_GL,</span><br><span class="line">        CREATE_USER,</span><br><span class="line">        CREATE_DEPT,</span><br><span class="line">        CREATE_TIME,</span><br><span class="line">        L_INTEREST,</span><br><span class="line">        L_DIVIDEND,</span><br><span class="line">        L_GAINLOSS,</span><br><span class="line">        L_INCOME_GL,</span><br><span class="line">        L_INTEREST_GL,</span><br><span class="line">        L_EXPENSE,</span><br><span class="line">        L_INVEST_GL,</span><br><span class="line">        L_CURRENCY,</span><br><span class="line">        L_ZYJ,</span><br><span class="line">        L_MV,</span><br><span class="line">        L_NET_MV,</span><br><span class="line">        L_NET_COST,</span><br><span class="line">        L_FULL_PRICE,</span><br><span class="line">        L_NET_PRICE,</span><br><span class="line">        EXPENSE,</span><br><span class="line">        INVEST_GL,</span><br><span class="line">        R_GL,</span><br><span class="line">        GAINLOSS_GL,</span><br><span class="line">        AMOR_GL,</span><br><span class="line">        EX_GL,</span><br><span class="line">        TOTAL_GL,</span><br><span class="line">        NET_COST,</span><br><span class="line">        FULL_PRICE,</span><br><span class="line">        NET_PRICE,</span><br><span class="line">        INTEREST,</span><br><span class="line">        GAINLOSS,</span><br><span class="line">        INCOME_GL,</span><br><span class="line">        INTEREST_GL,</span><br><span class="line">        SHADOW_MV,</span><br><span class="line">        SHADOW_DELTA,</span><br><span class="line">        PRINFXRATE,</span><br><span class="line">        CURRENCY,</span><br><span class="line">        ZYJ,</span><br><span class="line">        FULL_MV,</span><br><span class="line">        NET_MV,</span><br><span class="line">        PORT_ID,</span><br><span class="line">        VALID_DATE,</span><br><span class="line">        INVALID_DATE,</span><br><span class="line">        SEC_NAME,</span><br><span class="line">        ACCOUNT_CLASS_TYPE,</span><br><span class="line">        HOLDING_SIDE,</span><br><span class="line">        HOLDING_AMOUNT)</span><br><span class="line"><span class="keyword">SELECT</span> tb2.SEC_ID,</span><br><span class="line">        </span><br><span class="line">        tb1.VALUATION_METHODS,</span><br><span class="line">        </span><br><span class="line">        tb1.BACK_AMOUNT,</span><br><span class="line">        </span><br><span class="line">        tb1.COUNTERPARTY_ID,</span><br><span class="line">        </span><br><span class="line">        tb1.END_DATE,</span><br><span class="line">        </span><br><span class="line">        tb1.INTECALC_RULE,</span><br><span class="line">        </span><br><span class="line">        tb1.UNDERLYING_CODE,</span><br><span class="line">        </span><br><span class="line">        tb1.UNDERLYING_VOLUME,</span><br><span class="line">        </span><br><span class="line">        tb1.ORDER_ID,</span><br><span class="line">        </span><br><span class="line">        tb1.F_JSFXJ,</span><br><span class="line">        </span><br><span class="line">        tb1.F_HHF,</span><br><span class="line">        </span><br><span class="line">        tb1.F_RGF,</span><br><span class="line">        </span><br><span class="line">        tb1.F_SGF,</span><br><span class="line">        </span><br><span class="line">        tb1.F_SHF,</span><br><span class="line">        </span><br><span class="line">        tb1.INT_RATE,</span><br><span class="line">        </span><br><span class="line">        tb1.ASS_CODE,</span><br><span class="line">        </span><br><span class="line">        tb1.CASH_PS_PAYMENT,</span><br><span class="line">        </span><br><span class="line">        tb1.BOND_PS_PAYMENT,</span><br><span class="line">        </span><br><span class="line">        tb1.F_YHS,</span><br><span class="line">        </span><br><span class="line">        tb1.F_JSF,</span><br><span class="line">        </span><br><span class="line">        tb1.F_GHF,</span><br><span class="line">        </span><br><span class="line">        tb1.F_ZGF,</span><br><span class="line">        </span><br><span class="line">        tb1.F_JSFWF,</span><br><span class="line">        </span><br><span class="line">        tb1.REGIST_ORG,</span><br><span class="line">        </span><br><span class="line">        tb1.REMARK,</span><br><span class="line">        </span><br><span class="line">        tb1.SETTLE_SPEED,</span><br><span class="line">        </span><br><span class="line">        tb1.PAR_VALUE,</span><br><span class="line">        </span><br><span class="line">        tb1.CPRICE_AMT,</span><br><span class="line">        </span><br><span class="line">        tb1.FPRICE_AMT,</span><br><span class="line">        </span><br><span class="line">        tb1.INV_AIM,</span><br><span class="line">        </span><br><span class="line">        tb1.TRAN_COMMISION,</span><br><span class="line">        </span><br><span class="line">        tb1.TRADER_NAME,</span><br><span class="line">        </span><br><span class="line">        tb1.IMGR_ID_NAME,</span><br><span class="line">        </span><br><span class="line">        tb1.TRAN_STATUS,</span><br><span class="line">        </span><br><span class="line">        tb1.CPRICE_DATE,</span><br><span class="line">        </span><br><span class="line">        tb1.IS_CANCEL,</span><br><span class="line">        </span><br><span class="line">        tb1.COUNTER_TRADER,</span><br><span class="line">        </span><br><span class="line">        tb1.ENT_INT_FLAG,</span><br><span class="line">        </span><br><span class="line">        tb1.LONG_CURRENCY,</span><br><span class="line">        </span><br><span class="line">        tb1.LONG_QUANTITY,</span><br><span class="line">        </span><br><span class="line">        tb1.LONG_PRINCIPAL,</span><br><span class="line">        </span><br><span class="line">        tb1.LONG_INTEREST,</span><br><span class="line">        </span><br><span class="line">        tb1.LONG_AMOUNT,</span><br><span class="line">        </span><br><span class="line">        tb1.LONG_TRAN_FEE,</span><br><span class="line">        </span><br><span class="line">        tb1.TRADE_ID,</span><br><span class="line">        </span><br><span class="line">        tb1.DEAL_DEP,</span><br><span class="line">        </span><br><span class="line">        tb1.TRAN_DATE,</span><br><span class="line">        </span><br><span class="line">        tb1.SETTLE_DATE,</span><br><span class="line">        </span><br><span class="line">        tb1.TRAN_SIDE,</span><br><span class="line">        </span><br><span class="line">        tb1.PRICE_YIELD,</span><br><span class="line">        </span><br><span class="line">        tb1.COUNTER_PARTY,</span><br><span class="line">        </span><br><span class="line">        tb1.Column39,</span><br><span class="line">        </span><br><span class="line">        tb1.Column40,</span><br><span class="line">        </span><br><span class="line">        tb1.Column41,</span><br><span class="line">        </span><br><span class="line">        tb1.SEC_ABBR,</span><br><span class="line">        </span><br><span class="line">        tb2.REAL_SEC_ID,</span><br><span class="line">        </span><br><span class="line">        tb1.NET_VAL_DATE,</span><br><span class="line">        </span><br><span class="line">        tb1.NET_VAL_PRICE,</span><br><span class="line">        </span><br><span class="line">        tb1.Column32,</span><br><span class="line">        </span><br><span class="line">        tb1.Column33,</span><br><span class="line">        </span><br><span class="line">        tb1.Column34,</span><br><span class="line">        </span><br><span class="line">        tb1.Column35,</span><br><span class="line">        </span><br><span class="line">        tb1.Column36,</span><br><span class="line">        </span><br><span class="line">        tb1.Column37,</span><br><span class="line">        </span><br><span class="line">        tb1.Column38,</span><br><span class="line">        </span><br><span class="line">        tb1.Column25,</span><br><span class="line">        </span><br><span class="line">        tb1.Column26,</span><br><span class="line">        </span><br><span class="line">        tb1.Column27,</span><br><span class="line">        </span><br><span class="line">        tb1.Column28,</span><br><span class="line">        </span><br><span class="line">        tb1.Column29,</span><br><span class="line">        </span><br><span class="line">        tb1.Column30,</span><br><span class="line">        </span><br><span class="line">        tb1.Column31,</span><br><span class="line">        </span><br><span class="line">        tb1.Column18,</span><br><span class="line">        </span><br><span class="line">        tb1.Column19,</span><br><span class="line">        </span><br><span class="line">        tb1.Column20,</span><br><span class="line">        </span><br><span class="line">        tb1.Column21,</span><br><span class="line">        </span><br><span class="line">        tb1.Column22,</span><br><span class="line">        </span><br><span class="line">        tb1.Column23,</span><br><span class="line">        </span><br><span class="line">        tb1.Column24,</span><br><span class="line">        </span><br><span class="line">        tb1.Column11,</span><br><span class="line">        </span><br><span class="line">        tb1.Column12,</span><br><span class="line">        </span><br><span class="line">        tb1.Column13,</span><br><span class="line">        </span><br><span class="line">        tb1.Column14,</span><br><span class="line">        </span><br><span class="line">        tb1.Column15,</span><br><span class="line">        </span><br><span class="line">        tb1.Column16,</span><br><span class="line">        </span><br><span class="line">        tb1.Column17,</span><br><span class="line">        </span><br><span class="line">        tb1.Column4,</span><br><span class="line">        </span><br><span class="line">        tb1.Column5,</span><br><span class="line">        </span><br><span class="line">        tb1.Column6,</span><br><span class="line">        </span><br><span class="line">        tb1.Column7,</span><br><span class="line">        </span><br><span class="line">        tb1.Column8,</span><br><span class="line">        </span><br><span class="line">        tb1.Column9,</span><br><span class="line">        </span><br><span class="line">        tb1.Column10,</span><br><span class="line">        </span><br><span class="line">        tb1.TRADE_MARKET,</span><br><span class="line">        </span><br><span class="line">        tb1.SEC_CATEGORY,</span><br><span class="line">        </span><br><span class="line">        tb1.ACC_ID,</span><br><span class="line">        </span><br><span class="line">        tb1.ACC_NAME,</span><br><span class="line">        </span><br><span class="line">        tb1.Column1,</span><br><span class="line">        </span><br><span class="line">        tb1.Column2,</span><br><span class="line">        </span><br><span class="line">        tb1.Column3,</span><br><span class="line">        </span><br><span class="line">        tb1.L_MV_LOSS,</span><br><span class="line">        </span><br><span class="line">        tb1.L_NET_MV_LOSS,</span><br><span class="line">        </span><br><span class="line">        tb1.NET_MV_LOSS,</span><br><span class="line">        </span><br><span class="line">        tb1.ASSET_BIG_TYPE,</span><br><span class="line">        </span><br><span class="line">        tb1.ASSET_CATEGORY,</span><br><span class="line">        </span><br><span class="line">        tb1.LEVEL_TYPE,</span><br><span class="line">        </span><br><span class="line">        tb1.PORT_NAME,</span><br><span class="line">        </span><br><span class="line">        tb1._sign,</span><br><span class="line">        </span><br><span class="line">        tb2.SUB_PORT_ID,</span><br><span class="line">        </span><br><span class="line">        tb1.DEPT_ID,</span><br><span class="line">        </span><br><span class="line">        tb1.ASSET_LOSS,</span><br><span class="line">        </span><br><span class="line">        tb1.IS_LT_BOUNDED,</span><br><span class="line">        </span><br><span class="line">        tb1.L_ASSET_LOSS,</span><br><span class="line">        </span><br><span class="line">        tb1.FULL_MV_LOSS,</span><br><span class="line">        </span><br><span class="line">        tb2.UPDATE_USER,</span><br><span class="line">        </span><br><span class="line">        tb2.UPDATE_TIME,</span><br><span class="line">        </span><br><span class="line">        tb2.INPUT_TYPE,</span><br><span class="line">        </span><br><span class="line">        tb1.L_SHADOW_MV,</span><br><span class="line">        </span><br><span class="line">        tb1.L_SHADOW_DELTA,</span><br><span class="line">        </span><br><span class="line">        tb1.FULL_COST,</span><br><span class="line">        </span><br><span class="line">        tb1.L_FULL_COST,</span><br><span class="line">        </span><br><span class="line">        tb1.L_R_GL,</span><br><span class="line">        </span><br><span class="line">        tb1.L_GAINLOSS_GL,</span><br><span class="line">        </span><br><span class="line">        tb1.L_AMOR_GL,</span><br><span class="line">        </span><br><span class="line">        tb1.L_TOTAL_GL,</span><br><span class="line">        </span><br><span class="line">        tb2.CREATE_USER,</span><br><span class="line">        </span><br><span class="line">        tb1.CREATE_DEPT,</span><br><span class="line">        </span><br><span class="line">        tb2.CREATE_TIME,</span><br><span class="line">        </span><br><span class="line">        tb1.L_INTEREST,</span><br><span class="line">        </span><br><span class="line">        tb1.L_DIVIDEND,</span><br><span class="line">        </span><br><span class="line">        tb1.L_GAINLOSS,</span><br><span class="line">        </span><br><span class="line">        tb1.L_INCOME_GL,</span><br><span class="line">        </span><br><span class="line">        tb1.L_INTEREST_GL,</span><br><span class="line">        </span><br><span class="line">        tb1.L_EXPENSE,</span><br><span class="line">        </span><br><span class="line">        tb1.L_INVEST_GL,</span><br><span class="line">        </span><br><span class="line">        tb1.L_CURRENCY,</span><br><span class="line">        </span><br><span class="line">        tb1.L_ZYJ,</span><br><span class="line">        </span><br><span class="line">        tb1.L_MV,</span><br><span class="line">        </span><br><span class="line">        tb1.L_NET_MV,</span><br><span class="line">        </span><br><span class="line">        tb1.L_NET_COST,</span><br><span class="line">        </span><br><span class="line">        tb1.L_FULL_PRICE,</span><br><span class="line">        </span><br><span class="line">        tb1.L_NET_PRICE,</span><br><span class="line">        </span><br><span class="line">        tb1.EXPENSE,</span><br><span class="line">        </span><br><span class="line">        tb1.INVEST_GL,</span><br><span class="line">        </span><br><span class="line">        tb1.R_GL,</span><br><span class="line">        </span><br><span class="line">        tb1.GAINLOSS_GL,</span><br><span class="line">        </span><br><span class="line">        tb1.AMOR_GL,</span><br><span class="line">        </span><br><span class="line">        tb1.EX_GL,</span><br><span class="line">        </span><br><span class="line">        tb1.TOTAL_GL,</span><br><span class="line">        </span><br><span class="line">        tb1.NET_COST,</span><br><span class="line">        </span><br><span class="line">        tb1.FULL_PRICE,</span><br><span class="line">        </span><br><span class="line">        tb1.NET_PRICE,</span><br><span class="line">        </span><br><span class="line">        tb1.INTEREST,</span><br><span class="line">        </span><br><span class="line">        tb1.GAINLOSS,</span><br><span class="line">        </span><br><span class="line">        tb1.INCOME_GL,</span><br><span class="line">        </span><br><span class="line">        tb1.INTEREST_GL,</span><br><span class="line">        </span><br><span class="line">        tb1.SHADOW_MV,</span><br><span class="line">        </span><br><span class="line">        tb1.SHADOW_DELTA,</span><br><span class="line">        </span><br><span class="line">        tb1.PRINFXRATE,</span><br><span class="line">        </span><br><span class="line">        tb1.CURRENCY,</span><br><span class="line">        </span><br><span class="line">        tb1.ZYJ,</span><br><span class="line">        </span><br><span class="line">        tb1.FULL_MV,</span><br><span class="line">        </span><br><span class="line">        tb1.NET_MV,</span><br><span class="line">        </span><br><span class="line">        tb2.PORT_ID,</span><br><span class="line">        </span><br><span class="line">        tb2.VALID_DATE,</span><br><span class="line">        </span><br><span class="line">        tb1.INVALID_DATE,</span><br><span class="line">        </span><br><span class="line">        tb1.SEC_NAME,</span><br><span class="line">        </span><br><span class="line">        tb2.ACCOUNT_CLASS_TYPE,</span><br><span class="line">        </span><br><span class="line">        tb1.HOLDING_SIDE,</span><br><span class="line">        </span><br><span class="line">        tb1.HOLDING_AMOUNT</span><br><span class="line"><span class="keyword">FROM</span> dwd_val_detail tb1, dwd_val_detail2C3wru86 tb2</span><br><span class="line"><span class="keyword">WHERE</span> tb1.PORT_ID=tb2.PORT_ID</span><br><span class="line">        <span class="keyword">AND</span> tb1.SUB_PORT_ID=tb2.SUB_PORT_ID</span><br><span class="line">        <span class="keyword">AND</span> tb1.SEC_ID=tb2.SEC_ID</span><br><span class="line">        <span class="keyword">AND</span> tb1.VALID_DATE=tb2.VALID_DATE</span><br><span class="line">        <span class="keyword">AND</span> tb1.ACCOUNT_CLASS_TYPE=tb2.ACCOUNT_CLASS_TYPE<span class="string">'</span></span><br><span class="line"><span class="string">5.</span></span><br><span class="line"><span class="string">"select partition_key from system.tables where database =(select database()) and name = '</span>dwd_val_detail<span class="string">'"===&gt;找该表分区字段</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">6.</span></span><br><span class="line"><span class="string">"select distinct partition_id from system.parts where database =(select database()) and table = '</span>dwd_val_detail<span class="string">' and active = 1 and `partition` in (select distinct(toYYYYMM(VALID_DATE) ) from dwd_val_detail2C3wru86)"===&gt;找涉及的分区</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">7.</span></span><br><span class="line"><span class="string">optimize table dwd_val_detail PARTITION '</span><span class="number">202112</span><span class="string">' final</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git入门</title>
      <link href="/2022/07/02/git%E5%85%A5%E9%97%A8/"/>
      <url>/2022/07/02/git%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>视频b站搜狂神,文档见B站狂神说公众号</p><p>注意点: git add .</p><p>​        git commit -m”评论”</p><p>​        git push </p><p>​        上传完毕</p><p>一般直接复制原来git仓库的配置</p><p>ideal选择分支时候点几checkout</p><p>ideal中可以看到log情况</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习</title>
      <link href="/2022/04/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/04/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">常用于二分类算法,分成回归函数和sigmod逻辑函数两部分组成,想要实现多分类可以通过softmax实现,本身为一个判别模型</span><br><span class="line"></span><br><span class="line">判别模型相比较生成模型一般较好,生成模型是一种先验概率,判别是后验概率,生成模型带有推测扩展的效果,假设样本之间互相独立,一般适用于数据量过少或者样本中含有噪音影响判断的</span><br><span class="line"></span><br><span class="line">softmax的多分类变成二分类就变成了对应的逻辑回归函数了</span><br><span class="line"></span><br><span class="line">逻辑回归使用的是cross_entropy函数,不使用线性函数的平方损失是因为,离最优值远的位置的积分较大,可以达到快速实现求解的过程,而平方损失整体较平缓,更新参数较慢(可以联想一下两个图,一个高抖,一个平缓)</span><br><span class="line"></span><br><span class="line">求解方法是最大似然法和梯度下降法.</span><br><span class="line">讲到似然函数和概率函数,已知参数,求是a类别的概率为概率函数,已知类别反推参数的函数为似然函数</span><br></pre></td></tr></table></figure><h4 id="时间序列及LSTM"><a href="#时间序列及LSTM" class="headerlink" title="时间序列及LSTM"></a>时间序列及LSTM</h4><p>code见: <a href="https://github.com/sksujan58/Multivariate-time-series-forecasting-using-LSTM/blob/main/timeseries%20Forecasting.ipynb" target="_blank" rel="noopener">https://github.com/sksujan58/Multivariate-time-series-forecasting-using-LSTM/blob/main/timeseries%20Forecasting.ipynb</a></p><h4 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Kmeans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dbscan</span><br><span class="line">基本介绍:1,2,3,4</span><br><span class="line">1:1个基本的核心思想,基于密度</span><br><span class="line">2:2个重要概念,邻域半径R和最小点数目minpoints</span><br><span class="line">3:3个点,核心点,边界点,噪音点</span><br><span class="line">4:4个点与点之间的关系,密度直达,密度可达,密度相连,非密度相连</span><br><span class="line">    算法实现过程:</span><br><span class="line">    1). 从数据集中任意选取一个数据对象点 p；</span><br><span class="line">    2）如果对于参数 Eps 和 MinPts，所选取的数据对象点 p 为核心点，则找出所有从 p 密度可达的数据对象点，形成一个簇；</span><br><span class="line">3）如果选取的数据对象点 p 是边缘点，选取另一个数据对象点；</span><br><span class="line">4）重复（2）、（3）步，直到所有点被处理。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java基础</title>
      <link href="/2022/03/15/java%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/03/15/java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hadoop入门</title>
      <link href="/2022/02/21/hadoop%E5%85%A5%E9%97%A8/"/>
      <url>/2022/02/21/hadoop%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h5 id="hadoop基础知识"><a href="#hadoop基础知识" class="headerlink" title="hadoop基础知识"></a>hadoop基础知识</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">hadoop:分为<span class="number">1.0</span>、<span class="number">2.0</span>和<span class="number">3.0</span>版本.目前企业最常见的是<span class="number">2.0</span>版本. <span class="number">1.0</span>版本由hdfs和mapreduce构成,<span class="number">2.0</span>在hdfs的上层添加了yarn,并且计算框架也由单一的mapreduce,添加了其他计算框架如spark,Mr等</span><br><span class="line"></span><br><span class="line">hadoop 是在nutch distributed file System的基础上开发的.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.hdfs架构的组成:namenode和datanode,然后数据是分块的存储在datanode中(block),namenode相当于一个大管家进行整体的控制.除此之外进行的备份策略,有个secondary namenode,定期和namenode联系进行备份,防止节点挂了影响整体功能.secondnameode 会定期整合fsimage和fsedits发送给namenode)</span><br><span class="line">  fsimage:元数据的镜像文件</span><br><span class="line">  fsedits:元数据的操作日志</span><br><span class="line">(并非 NameNode 的热备。当NameNode 挂掉的时候，它并不能马上替换 NameNode 并提供服务。)</span><br><span class="line">      </span><br><span class="line">namenode:</span><br><span class="line"><span class="number">1</span>.管理hdfs的命名空间</span><br><span class="line"><span class="number">2</span>.控制数据块的映射</span><br><span class="line"><span class="number">3</span>.配置备份策略</span><br><span class="line"><span class="number">4</span>.管理读写语句</span><br><span class="line"></span><br><span class="line">datanode:</span><br><span class="line"><span class="number">1</span>.存储分块数据</span><br><span class="line"><span class="number">2</span>.进行数据的读写操作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hadoop本身是具有高吞吐量,高扩展性等优点,但是不具备快速查询功能,可使用hbase实现</span><br><span class="line"></span><br><span class="line">secondnamenode 是namenode 的冷备份</span><br><span class="line">热备份:一个节点坏了后,宁一个节点可以直接替换这个节点继续工作,称为热节点</span><br><span class="line">冷备份:一个节点坏了后,宁一个节点不能直接替换工作,只是为了减少损失</span><br><span class="line"></span><br><span class="line">每次重启namenode都会从fsimage读取元文件,然后经过edits中记录的操作,当edits中记录很多时候,namenode启动会非常慢,因而需要定时的合并fsimage文件和edits文件,同时清空edits文件.</span><br><span class="line"></span><br><span class="line">合并fsimage和edits文件是在secondaryname中实现的,会让namenode暂停写入edits,然后从namenode中获取fsimage和edits文件,合并后得到新的fsimage和edits传输给namenode,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">视频学习流程:</span><br><span class="line">hadoop发展----&gt;hadoop架构解释及面试问题----&gt;hadoop命令----&gt;namenode和datenode详解---&gt;edits文件详解---&gt;fsimage文件详解---&gt;hdfsApi操作-----&gt;hdfs流程图(写入,写出,删除操作流程)----&gt;hadoop源码详解----&gt;租约锁和hadoop特点(见:https:<span class="comment">//blog.csdn.net/sinat_35667067/article/details/104250251?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.pc_relevant_default&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=2)</span></span><br><span class="line"></span><br><span class="line">                                                                                   hive是建立在hadoop基础上的数据仓库,会将hdfs中的文件映射到表中,提供sql查询和mapreduce功能.Hive本身不存储和计算数据,依靠于hadoop的hdfs和mapreduce,只是一种映射</span><br><span class="line">                                                                                   hbase是物理表,简单理解为，hive是文件的视图，hbase是建了索引的key-value表。</span><br></pre></td></tr></table></figure><h5 id="hadoop-API"><a href="#hadoop-API" class="headerlink" title="hadoop API"></a>hadoop API</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> HDFS.learnself;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.URISyntaxException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FSDataOutputStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Hdfs;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Write</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException, URISyntaxException </span>&#123;</span><br><span class="line">  <span class="comment">//1.加载hdfs的配置文件</span></span><br><span class="line">  Configuration conf=<span class="keyword">new</span> Configuration();</span><br><span class="line">  <span class="comment">//2.获取hdfs的操作对象</span></span><br><span class="line">  FileSystem fs=FileSystem.get(<span class="keyword">new</span> URI(<span class="string">"hdfs://hdp02:9000"</span>), conf, <span class="string">"hdp02"</span>);</span><br><span class="line">  <span class="comment">//3.文件路径</span></span><br><span class="line">  Path File=<span class="keyword">new</span> Path(<span class="string">"hdfs://hdp02:9000/test/cao.txt"</span>);</span><br><span class="line">  <span class="comment">//4.创建FSDataOutputStream对象</span></span><br><span class="line">  FSDataOutputStream out=fs.create(File);</span><br><span class="line">  <span class="comment">//5.写入数据</span></span><br><span class="line">  out.writeUTF(<span class="string">"Hello world!"</span>);</span><br><span class="line">  out.close();</span><br><span class="line">  System.out.println(<span class="string">"数据写入成功！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="hadoop特点"><a href="#hadoop特点" class="headerlink" title="hadoop特点"></a>hadoop特点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.分布式存储架构,支持海量数据(GB,PB,TB级别)</span><br><span class="line"><span class="number">2</span>.高容错性,数据块存在多个副本,副本丢失自动恢复</span><br><span class="line"><span class="number">3</span>.低成本部署,可在廉价机器上搭建</span><br><span class="line"><span class="number">4</span>.能够检测和快速应对硬件故障,通过rpc心跳机制来实现</span><br><span class="line"><span class="number">5</span>.hdfs不能实现低延迟数据访问(毫秒级),hadoop的优势是高吞吐量(单位时间内产生的数据流),低延迟可通过hbase实现</span><br><span class="line"><span class="number">6</span>.hadoop不支持数据修改,适用于:一次写入,多次读取.但是允许追加数据</span><br><span class="line"><span class="number">7</span>.hadoop不适合存储海量小文件,会浪费namenode 的内存空间</span><br></pre></td></tr></table></figure><h5 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map reduce"></a>map reduce</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">任务分成:map任务和reduce任务。map操作完后会进行shuffle操作,将相同key的分发到一起,同一个reduce任务中</span><br><span class="line">mapreduce阶段:泛型对应 String ----&gt;Text,Integer----&gt;Intwritable,Long-----&gt;LongWritable</span><br><span class="line">原因: 在map完了之后,需要将数据传递给reduce,这时候涉及到了序列化和反序列化,但是jdk自带的效率较慢,因而hadoop自己实现了序列化接口.</span><br><span class="line"> * hadoop为jdk中的常用基本类型Long String Integer Float等数据类型封住了自己的实现了hadoop序列化接口的类型：LongWritable,Text,IntWritable,FloatWritable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">####map阶段</span><br><span class="line"><span class="number">1</span>.明确输入的键值是什么类型,输出的键值是什么类型</span><br><span class="line">案例:</span><br><span class="line"> * KEYIN ：是map task读取到的数据的key的类型，是一行的起始偏移量Long</span><br><span class="line"> * VALUEIN:是map task读取到的数据的value的类型，是一行的内容String</span><br><span class="line"> * </span><br><span class="line"> * KEYOUT：是用户的自定义map方法要返回的结果kv数据的key的类型，在wordcount逻辑中，我们需要返回的是单词String</span><br><span class="line"> * VALUEOUT:是用户的自定义map方法要返回的结果kv数据的value的类型，在wordcount逻辑中，我们需要返回的是整数Integer</span><br><span class="line"></span><br><span class="line">map_task的数量会根据切片的大小自动分配,reduce_task的数量可以指定,默认<span class="number">1</span></span><br><span class="line"></span><br><span class="line">Map是对分块的每一行操作还是需要遍历?是对每一行操作的,不需要遍历</span><br><span class="line"></span><br><span class="line">map和reduce间的分区,默认的是键的hash值与reducetask的数量取模得到,也可以通过partitioner自定义划分到哪一个分区(分区数等于reduce_task数量),通常一个reduce任务中数据已经经过键排序过了,当需要全局排序,一方面可通过一个reduce task实现,但是会影响整体的效率,宁一方面就是重构parpartitioner来实现</span><br><span class="line"></span><br><span class="line">每个reduce_task 生成一个文件</span><br><span class="line"></span><br><span class="line">要点:输出对象,分区指定,序列化指定</span><br><span class="line"></span><br><span class="line">####################################job任务的执行流程##########################</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">多进程和多线程的区别</span><br><span class="line"><span class="number">1</span>.多进程占用内存多,cpu利用率低;多线程占用内存少,cpu利用率高</span><br><span class="line"><span class="number">2</span>.多线程进程间不会互相影响,多线程一个断了则全断</span><br></pre></td></tr></table></figure><h5 id="Yarn架构"><a href="#Yarn架构" class="headerlink" title="Yarn架构"></a>Yarn架构</h5><p><img src="/2022/02/21/hadoop入门/yarn架构图.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">yarn:是在hadoop1.0的基础上衍生出来的,为了缓解jobtracker的压力.主要进行资源调度和任务分配.</span><br><span class="line">yarn的三大组件:resourceManager(rm),nodemanager(nm),applicantionmaster</span><br><span class="line">rm主要进行资源分配,applicationmaster主要进行任务调度</span><br><span class="line"></span><br><span class="line"> ResourceManager主要有两个组件：Scheduler和ApplicationManager</span><br><span class="line"> Scheduler:负责资源的分配,纯调度</span><br><span class="line"> ApplicationManager:为应用分配container来运行applicantionmaster,并且负责监控applicantionmaster</span><br><span class="line"> </span><br><span class="line">NodeManager是yarn节点的一个“工作进程”代理，管理hadoop集群中独立的计算节点，主要负责与ResourceManager通信，负责启动和管理应用程序的container的生命周期，监控它们的资源使用情况（cpu和内存），跟踪节点的监控状态，管理日志等。并报告给RM。</span><br><span class="line"></span><br><span class="line">container:一个抽象资源对象,封装了程序运行需要的资源(如内存,cpu,磁盘等)</span><br><span class="line">    </span><br><span class="line">ApplicationMaster: ApplicationMaster负责与scheduler协商合适的container，跟踪应用程序的状态，以及监控它们的进度，ApplicationMaster是协调集群中应用程序执行的进程。每个应用程序都有自己的ApplicationMaster，负责与ResourceManager协商资源（container）和NodeManager协同工作来执行和监控任务 。</span><br></pre></td></tr></table></figure><h5 id="yarn的调度流程"><a href="#yarn的调度流程" class="headerlink" title="yarn的调度流程"></a>yarn的调度流程</h5><p><img src="/2022/02/21/hadoop入门/yarn流程图.png" alt></p><p><img src="/2022/02/21/hadoop入门/流程描述.png" alt></p><h5 id="Flume"><a href="#Flume" class="headerlink" title="Flume"></a>Flume</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Flume:海量日志采集、聚合和传输的系统。最主要的作用是实时读取服务器本地磁盘的数据，将数据写入到HDFS中。</span><br><span class="line">Flume架构:webserver---&gt;Agent----&gt;HDFS</span><br><span class="line">Agent(Source、channel、sink)</span><br><span class="line">    Agent：Jvm的一个进程，以事务的形式将数据从源头送到目的</span><br><span class="line">Source:责任是将数据传输到Flume Agent的一个组件;</span><br><span class="line">channel: 解耦合,具有缓冲的作用.Flume自带两个channel,一个memory channel 和File channel,前者存在内存,存在数据丢失风险,速度快.后者存在磁盘上,安全性高,速度慢</span><br><span class="line">sink:不断轮询channel并删除,然后将这些事件批量写入存储或者索引系统(如hdfs,hbase,avro等)</span><br><span class="line">        一个source对应多个channel,一个sink只能对应一个channel,一个channel对应多个sink</span><br><span class="line">    channel功能:一个是数据传输的可靠性,一个是数据流入流出的异步执行.前面一句是因为只有当数据确认到到目的地或者下一个agent时才会删除channel内对应的event.</span><br><span class="line">source可实现扇出,即一个source对应多个channel,然后方式有两种,一个是复制,即每个channel的数据都一样.一个是选择(多路复用),即event有选择的流入哪个channel</span><br></pre></td></tr></table></figure><p><img src="/2022/02/21/hadoop入门/1646213144225.png" alt="1646213144225"></p><h5 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">快速了解:https:<span class="comment">//max.book118.com/html/2021/1027/8005064135004025.shtm</span></span><br><span class="line">定义:一个分布式的流媒体平台(需要具备三个功能)</span><br><span class="line">    <span class="number">1</span>.发布和订阅记录流</span><br><span class="line">    <span class="number">2</span>.以容错的方式永久订阅记录流</span><br><span class="line">    <span class="number">3</span>.记录发生时处理流</span><br><span class="line">通用:用在实时数据平台上,由flume到kafka到storm</span><br><span class="line">kafka应用场景:</span><br><span class="line">kafaka特点:</span><br><span class="line"><span class="number">1</span>. poll模式.消费的速率由下游的消费者(计算框架决定)</span><br><span class="line">    <span class="number">2</span>. Kafka提供了消费的持久化机制,无论消费者是否消费都会存储,通过副本冗余机制提供数据的冗余机制</span><br></pre></td></tr></table></figure><h4 id="hive"><a href="#hive" class="headerlink" title="hive"></a>hive</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">hive是数据仓库的一种</span><br><span class="line">数据仓库的特点:</span><br><span class="line"><span class="number">1</span>.存放的是历史数据</span><br><span class="line"><span class="number">2</span>. 存储大容量数据,gb,tb甚至pb</span><br><span class="line">hive本身并不存储数据,而是hadoop中hdfs的映射,进行hql操作时候实际操作的是hdfs的文件夹,且数据源需要配置mysql,hql默认会使用mr,针对数据倾斜问题,一个是group by 一个是join,只需要在当前session改两个配置即可.然后分成外部表和内部表.分区表既可以是外部表也可以是内部表,通常是以时间来作为分区依据,分区的好处是避免全表扫描,(实际上是每个分区键都有对应的文件夹,只到对应文件夹下去读取数据.</span><br><span class="line"></span><br><span class="line">hive知识点梳理</span><br><span class="line"><span class="number">1</span>. 内部表、外部表 和分桶表（用来随机抽样用的）</span><br><span class="line"><span class="number">2</span>. metastore： hive元数据，存放在关系型数据库中，如derby和mysql</span><br><span class="line"><span class="number">3</span>. hive复杂数据结构：array、map、struct</span><br><span class="line"><span class="number">4</span>. hive常用的字符串操作函数</span><br><span class="line"><span class="number">5</span>. hive 的udf函数</span><br><span class="line"><span class="number">6</span>. hive数据倾斜问题及优化（①group by ②join ③count)</span><br><span class="line"><span class="number">7</span>. hive 的优化:大概七八个吧①map参数 ②reduce参数 ③jvm重用 ④严格模式</span><br><span class="line"><span class="number">8</span>. sqoop mysql&lt;-&gt;hdfs</span><br><span class="line"><span class="number">9</span>. hive api接口:①client ②代码jdbc ③可视化 webui</span><br></pre></td></tr></table></figure><p>sqoop既可以实现数仓到关系型数据库,也可以实现关系型数据库到数仓</p><p>大数据创建总共分成两种一种是离线批处理一种是实时处理</p><p>离线批处理流程:</p><pre><code>  1. 日志通过flume进行采集2. 将数据存入hdfs中  3. 通过hive进行处理    1. 建立总表  4. 建立清洗表,实现etl  5. 建立业务表,清洗业务字段  6. 建立多维度表  7. sqoop将清洗完的数据导入mysql,进行可视化</code></pre><p>####Scala</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">函数定义:</span><br><span class="line"><span class="keyword">var</span> f1 = (x:<span class="type">Int</span>) =&gt; x*<span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> f2 : (<span class="type">Int</span>,<span class="type">Int</span>)=&gt;(<span class="type">Int</span>) = (x,y) =&gt; x*y</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fu</span></span>(name:<span class="type">String</span>):<span class="type">Unit</span> = &#123;println(name)&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> <span class="keyword">case</span>  <span class="keyword">break</span>,<span class="keyword">continue</span> (导包:<span class="keyword">import</span> util.control.<span class="type">Breaks</span>._)</span><br><span class="line">kl <span class="keyword">match</span>&#123;<span class="keyword">case</span> <span class="string">"kl"</span> =&gt; println(<span class="number">2</span>) <span class="keyword">case</span> <span class="string">"sd"</span> =&gt; println(<span class="number">3</span>)&#125;</span><br><span class="line"><span class="keyword">break</span>写法:</span><br><span class="line">    <span class="type">Breaks</span>.breakable(</span><br><span class="line">     |       <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">10</span>)&#123;</span><br><span class="line">     |         <span class="keyword">if</span> (i==<span class="number">5</span>)&#123;</span><br><span class="line">     |           <span class="type">Breaks</span>.<span class="keyword">break</span>()</span><br><span class="line">     |         &#125;</span><br><span class="line">     |         println(i)</span><br><span class="line">     |       &#125;</span><br><span class="line">     |     )</span><br><span class="line"><span class="keyword">continue</span>写法:</span><br><span class="line"><span class="keyword">for</span> (i&lt;- <span class="number">1</span> to <span class="number">5</span>)</span><br><span class="line">     |     &#123;<span class="type">Breaks</span>.breakable(<span class="keyword">if</span> (i==<span class="number">3</span>) <span class="type">Breaks</span>.<span class="keyword">break</span>() <span class="keyword">else</span> println(i))&#125;</span><br><span class="line">区别就是<span class="keyword">break</span>是写在循环外的,cntinue是写在循环里的,写法是一样的</span><br><span class="line"><span class="keyword">try</span> <span class="keyword">catch</span> <span class="keyword">finally</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//==============================函数===========================</span></span><br><span class="line">可变参数    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">people</span></span>(name:<span class="type">String</span>*)===&gt;在类型后加一个星号表示可变,实际是个容器,放了同一类型的多个数据,可通过</span><br><span class="line">遍历获取出来   </span><br><span class="line">函数返回值:<span class="type">Unit</span>表示没有返回值,可以不写返回值的类型,会自己推断(前提是有等号,等号不写,全都默认没有返回值)</span><br><span class="line">scala的泛型使用中括号[],不同于java的尖括号&lt;&gt;</span><br><span class="line">函数体只有一行的时候可以简写</span><br><span class="line">匿名函数  <span class="keyword">var</span> a = (x:<span class="type">Int</span>,y:<span class="type">Int</span>)=&gt;x*y    (x,y)=&gt;x*y  x=&gt;x**<span class="number">2</span>   </span><br><span class="line">函数支持公开</span><br><span class="line">函数中调用匿名函数</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span></span>(a:<span class="type">Int</span>,b:<span class="type">Int</span>,f:(<span class="type">Int</span>,<span class="type">Int</span>)=&gt;&#123;<span class="type">Int</span>&#125;) = &#123;f(a,b)&#125;</span><br><span class="line"></span><br><span class="line">f2(<span class="number">2</span>,<span class="number">3</span>,(x,y)=&gt;x+y)</span><br><span class="line">最简化版本: f2(<span class="number">2</span>,<span class="number">3</span>,_*_)   其中_指代的是参数</span><br><span class="line">匿名函数和高阶函数</span><br><span class="line"></span><br><span class="line">println(<span class="string">s"Lines with a: <span class="subst">$numAs</span>, Lines with b: <span class="subst">$numBs</span>"</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">scala完全面向对象,因而去掉了java中的非面向对象的元素,如static和void</span><br><span class="line">scala无static关键字,通过<span class="class"><span class="keyword">object</span><span class="title">实现类似静态方法的功能</span></span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">无返回值scala通过Unit实现</span></span></span><br><span class="line"><span class="class"><span class="title">类中使用BeanProperty修饰表示该变量会自动生成get和set方法</span> <span class="title">@BeanProperty</span> <span class="title">var</span> <span class="title">age</span> </span>= <span class="number">20</span></span><br><span class="line"></span><br><span class="line">伴生类和伴生对象,名称相同,伴生对象可以使用伴生类的所有东西(即<span class="class"><span class="keyword">object</span><span class="title">和class</span>),<span class="title">又因为不支持静态方法</span>,<span class="title">这样在编译时候就会生成两个同名的文件</span>,<span class="title">加$符号的是伴生对象的生成类</span>,<span class="title">不加$是入口类</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">scala的数据类型</span></span>:<span class="type">Any</span>:包含<span class="type">Anyval</span>和<span class="type">Anyref</span>(即引用和数值),anyref包含:scala classes 和 other scala classes 和 all java classes.然后all java classes又包含<span class="literal">null</span>,<span class="literal">null</span>的下一级为<span class="type">Nothing</span></span><br><span class="line">anyval:包含<span class="type">Unit</span>、stringops（java中string的增强）、char、boolean、<span class="type">Double</span>（下属float-&gt;long-&gt;int&gt;short-&gt;byte）下一级为<span class="type">Nothing</span></span><br><span class="line">通常<span class="type">Unit</span>表示函数没有返回值,<span class="type">Null</span>表示的是对象为空(必须是引用类型),<span class="type">Nothing</span>表示没有任何返回值,不同于<span class="literal">null</span>和<span class="type">Unit</span>,通常用在函数内抛出异常时使用</span><br><span class="line">数据类型转化分为隐式转换和显示转换,隐式转换表名低阶可以自动转换成高阶,高阶转换成低阶需要调用方法如toInt等</span><br><span class="line"></span><br><span class="line">数值转换成字符串 ①<span class="number">2.</span>toString ②<span class="number">2</span>+<span class="string">""</span></span><br><span class="line"></span><br><span class="line">scala循环推荐使用<span class="keyword">for</span>循环而非<span class="keyword">while</span>和do <span class="keyword">while</span>,且scala中没有<span class="keyword">break</span>和<span class="keyword">continue</span>关键字,要想实现需要调用方法:scala终止循环实际上是通过抛出异常实现的,不同的是调方法是进行了封装</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">10</span>; j = <span class="number">20</span> - i)&#123;</span><br><span class="line">          <span class="keyword">if</span> (i == <span class="number">9</span>)&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span></span><br><span class="line">          &#125;</span><br><span class="line">        println(<span class="string">"i+j="</span>+i+j)</span><br><span class="line">  &#125;&#125; <span class="keyword">catch</span> &#123;<span class="keyword">case</span> exception: <span class="type">Exception</span> =&gt;&#125;</span><br><span class="line">    println(<span class="string">"结束了"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="type">Breaks</span>.breakable(</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">1</span> until <span class="number">10</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (i ==<span class="number">6</span>)&#123;</span><br><span class="line">        <span class="type">Breaks</span>.<span class="keyword">break</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      println(i)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">匿名函数化简:</span><br><span class="line"><span class="number">1.</span>参数类型可以省略 (x:<span class="type">Int</span>)=&gt;&#123;x+<span class="number">1</span>&#125; 变成(x)=&gt;&#123;x+<span class="number">1</span>&#125;</span><br><span class="line"><span class="number">2.</span>参数只有一个时候括号可以省略 x=&gt;&#123;x+<span class="number">1</span>&#125;</span><br><span class="line"><span class="number">3.</span>函数体只有一行,花括号可以省略 x =&gt; x+<span class="number">1</span></span><br><span class="line"><span class="number">4.</span>如果参数只出现一次可以使用_代替  (x,y) =&gt; x+y 变成 _ + _</span><br><span class="line">闭包和柯里化</span><br><span class="line">scala导包 com.公司名.项目名.模块名  或者<span class="keyword">package</span>&#123;&#125;三层嵌套也可以</span><br><span class="line"></span><br><span class="line">面向对象:</span><br><span class="line"> scala的构造器分为主构造器和辅助构造器,主构造器是在类名上加参数,辅助构造器是重载<span class="keyword">this</span>方法</span><br><span class="line">构造器参数修饰,<span class="keyword">var</span>可变参数,<span class="keyword">val</span>不可变参数,只能访问不能修改</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">集合:</span><br><span class="line"><span class="type">Array</span>:</span><br><span class="line">可变的添加:a.+=(<span class="number">2</span>) 或者a.append(<span class="number">2</span>)</span><br><span class="line">插入:a.insert(<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">赋值:a(<span class="number">1</span>) = <span class="number">3</span></span><br><span class="line">可变与不可变的转换a.toBuffer a.toArray</span><br><span class="line">创建多维矩阵 <span class="type">Array</span>.ofDim[<span class="type">Double</span>](<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><h4 id="spark操作"><a href="#spark操作" class="headerlink" title="spark操作"></a>spark操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val a = sc.parallelize(Array((<span class="number">1</span>,<span class="string">"xaioming"</span>),(<span class="number">2</span>,<span class="string">"dsada"</span>),(<span class="number">3</span>,<span class="string">"sda"</span>)))</span><br><span class="line">val b = a.toDF(<span class="string">"ID"</span>,<span class="string">"name"</span>)</span><br><span class="line">b.filter($<span class="string">"name"</span> === <span class="string">"sda"</span>).show()</span><br><span class="line">b.filter($<span class="string">"name"</span>.isin(<span class="string">"sads"</span>,<span class="string">"dsda"</span>))</span><br><span class="line">b.filter($<span class="string">"name"</span>.contains(<span class="string">"sads"</span>))</span><br></pre></td></tr></table></figure><h5 id="自定义Spark累加器"><a href="#自定义Spark累加器" class="headerlink" title="自定义Spark累加器"></a>自定义Spark累加器</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.benying.spark</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.util.<span class="type">AccumulatorV2</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang</span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"></span><br><span class="line"><span class="comment">/*accumulator自定义操作*/</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Accumulator_learning</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> conf: <span class="type">SparkConf</span> = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"spark"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line">    <span class="keyword">val</span> rdd1 = sc.makeRDD(<span class="type">List</span>(<span class="string">"Hello"</span>,<span class="string">"Spark"</span>,<span class="string">"Scala"</span>,<span class="string">"hello"</span>,<span class="string">"Spark"</span>),<span class="number">2</span>)</span><br><span class="line">    <span class="comment">//自定义累加器</span></span><br><span class="line">    <span class="keyword">val</span> myacc = <span class="keyword">new</span> <span class="type">MyAccumulator_</span>()</span><br><span class="line">    sc.register(myacc,<span class="string">"spark_ACC"</span>)</span><br><span class="line"></span><br><span class="line">    rdd1.foreach(word=&gt;myacc.add(word))</span><br><span class="line"></span><br><span class="line">    println(myacc.value)</span><br><span class="line">    <span class="comment">//关闭</span></span><br><span class="line">    sc.stop()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MyAccumulator_</span> <span class="keyword">extends</span> <span class="title">AccumulatorV2</span>[<span class="type">String</span>, mutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">Long</span>]]</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> word_map = mutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">Long</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isZero</span></span>: <span class="type">Boolean</span> = &#123;</span><br><span class="line">      word_map.isEmpty</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">copy</span></span>(): <span class="type">AccumulatorV2</span>[<span class="type">String</span>, mutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">Long</span>]] = &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="type">MyAccumulator_</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">      word_map.clear()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(word: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> num:<span class="type">Long</span> = word_map.getOrElse(word,<span class="number">0</span>L) + <span class="number">1</span></span><br><span class="line">      word_map.update(word,num)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(other: <span class="type">AccumulatorV2</span>[<span class="type">String</span>, mutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">Long</span>]]): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> other_value: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>] = other.value</span><br><span class="line">      other_value.foreach&#123;</span><br><span class="line">        <span class="keyword">case</span> (word,num) =&gt;</span><br><span class="line">          <span class="keyword">val</span> new_num:<span class="type">Long</span> = word_map.getOrElse(word,<span class="number">0</span>L) + num</span><br><span class="line">          word_map.update(word,new_num)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">value</span></span>: mutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">Long</span>] = &#123;</span><br><span class="line">      word_map</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FLUME–HIVE–KAFKA–HBASE–STORM–SPARK</p><p>zookeeper:贯穿全部</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java学习code</title>
      <link href="/2022/01/07/java%E5%AD%A6%E4%B9%A0code/"/>
      <url>/2022/01/07/java%E5%AD%A6%E4%B9%A0code/</url>
      
        <content type="html"><![CDATA[<p>####代码1：大象放冰箱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day1;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">elephone</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">put</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">icebox</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开了冰箱"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"放入"</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"关闭了冰箱"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">day1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        icebox ice = <span class="keyword">new</span> icebox(); <span class="comment">//实例化对象</span></span><br><span class="line">        ice.open();  <span class="comment">//调用打开方法</span></span><br><span class="line">        elephone ele = <span class="keyword">new</span> elephone();</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        ele.name = sc.next();</span><br><span class="line">        String name = ele.put();</span><br><span class="line">        ice.save(name);</span><br><span class="line">        ice.close();<span class="comment">//调用关闭方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码2：小汽车"><a href="#代码2：小汽车" class="headerlink" title="代码2：小汽车"></a>代码2：小汽车</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day1;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    String color;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"汽车运行,颜色为"</span>+color+<span class="string">",车轮数"</span>+num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">day1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/*代码2:小汽车*/</span></span><br><span class="line">        Car car = <span class="keyword">new</span> Car();</span><br><span class="line">        car.color = <span class="string">"绿色"</span>;</span><br><span class="line">        car.num = <span class="number">4</span>;</span><br><span class="line">        car.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####代码3：局部变量和成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">day1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/*局部变量和成员变量*/</span></span><br><span class="line">        <span class="keyword">int</span> day = <span class="number">4</span>;</span><br><span class="line">        day1 day_ = <span class="keyword">new</span> day1();</span><br><span class="line">        day_.get_num();</span><br><span class="line">        System.out.println(day);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get_num</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        day = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> day2;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"是打算大"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set_age</span><span class="params">(<span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get_age</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set_name</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get_name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get_info</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        name = <span class="keyword">this</span>.get_name();</span><br><span class="line">        age = <span class="keyword">this</span>.get_age();</span><br><span class="line">        System.out.println(name + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">get_set</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.get_info();</span><br><span class="line">        person.set_age(<span class="number">25</span>);</span><br><span class="line">        person.set_name(<span class="string">"小米"</span>);</span><br><span class="line">        System.out.println(person.get_age());</span><br><span class="line">        person.get_info();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码4-判断是否是同一个人"><a href="#代码4-判断是否是同一个人" class="headerlink" title="代码4:判断是否是同一个人"></a>代码4:判断是否是同一个人</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">数值相等判断用 = ,字符串相等用equals A.equals(B)</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> day2;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person_</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">Person_</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get_name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get_age</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">new_Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] agrs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Person_ person1 = <span class="keyword">new</span> Person_(<span class="string">"张三"</span>,<span class="number">20</span>);</span><br><span class="line">        Person_ person2 = <span class="keyword">new</span> Person_(<span class="string">"张三"</span>,<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">if</span> ((person1.get_name().equals(person2.get_name()))&amp;&amp;((person1.get_age() == (person2.get_age())))) &#123;System.out.println(<span class="string">"人一样"</span>);&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码5-随机点名"><a href="#代码5-随机点名" class="headerlink" title="代码5:随机点名"></a>代码5:随机点名</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day2;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">//public class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    <span class="comment">//设置姓名\年龄,即可以使用构造.也可以set和get</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取名字</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getname</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取年龄</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] agrs)</span></span>&#123;</span><br><span class="line">        <span class="comment">//随机点名分三步</span></span><br><span class="line">        <span class="comment">//第一步,录入学生信息</span></span><br><span class="line">        ArrayList&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line">        setmessage(list);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">        <span class="comment">//第二步:打印所有学生信息</span></span><br><span class="line">        Pintlist(list);</span><br><span class="line">        <span class="comment">//第三步:随机取数打印</span></span><br><span class="line">        randomstudent(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setmessage</span><span class="params">(ArrayList&lt;Student&gt; list)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            System.out.println(<span class="string">"请录入中文名"</span>);</span><br><span class="line">            String name = sc.next();</span><br><span class="line">            System.out.println(<span class="string">"请录入年龄"</span>);</span><br><span class="line">            <span class="keyword">int</span> age = sc.nextInt();</span><br><span class="line">            Student student = <span class="keyword">new</span> Student(name,age);</span><br><span class="line">            list.add(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Pintlist</span><span class="params">(ArrayList&lt;Student&gt; list)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Student i:list)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"姓名是"</span>+i.getname()+<span class="string">",年龄是"</span>+i.getage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">randomstudent</span><span class="params">(ArrayList&lt;Student&gt; list)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="keyword">new</span> Random().nextInt(list.size());</span><br><span class="line">        System.out.println(<span class="string">"中奖劳斯莱斯的姓名是"</span>+list.get(i).getname()+<span class="string">",年龄是"</span>+list.get(i).getage());    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####代码6:最基本 的继承方法调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        algo name = <span class="keyword">new</span> algo();</span><br><span class="line">        name.name = <span class="string">"小明"</span>;</span><br><span class="line">        name.get_name();</span><br><span class="line">        name.work();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"在工作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">algo</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get_name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"姓名是:"</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码7-子类调用父类同名属性"><a href="#代码7-子类调用父类同名属性" class="headerlink" title="代码7:子类调用父类同名属性"></a>代码7:子类调用父类同名属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        algo2 al = <span class="keyword">new</span> algo2();</span><br><span class="line">        al.print_();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">eploee</span></span>&#123;</span><br><span class="line">    String name = <span class="string">"小明"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">algo2</span> <span class="keyword">extends</span> <span class="title">eploee</span></span>&#123;</span><br><span class="line">    String name = <span class="string">"小志"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print_</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">        System.out.println(<span class="keyword">super</span>.name); <span class="comment">//同名调用父类的属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#####代码8:方法的重载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        algo2 al = <span class="keyword">new</span> algo2();</span><br><span class="line">        al.print_();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">eploee</span></span>&#123;</span><br><span class="line">    String name = <span class="string">"小明"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print_</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">algo2</span> <span class="keyword">extends</span> <span class="title">eploee</span></span>&#123;</span><br><span class="line">    String name = <span class="string">"小志"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print_</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);  <span class="comment">//输出小志</span></span><br><span class="line">        eploee el = <span class="keyword">new</span> eploee();</span><br><span class="line">        el.print_();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通常是为了扩展功能,或者该方法不符合需求了,但是不能在原方法上修改,避免引起一系列反应</span></span><br></pre></td></tr></table></figure><p>####代码9:方法覆盖手机案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day3;</span><br><span class="line"><span class="comment">//    a:案例:比如手机，当描述一个手机时，它具有发短信，打电话，显示来电号码功能，</span></span><br><span class="line"><span class="comment">//            后期由于手机需要在来电显示功能中增加显示姓名和头像，</span></span><br><span class="line"><span class="comment">//            这时可以重新定义一个类描述智能手机，并继承原有描述手机的类。</span></span><br><span class="line"><span class="comment">//            并在新定义的类中覆盖来电显示功能，在其中增加显示姓名和头像功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    new_phone phone = <span class="keyword">new</span> new_phone();</span><br><span class="line">    phone.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发短信"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"显示号码"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">new_phone</span> <span class="keyword">extends</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="comment">//扩展</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"显示号码:显示头像:显示姓名"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意:方法覆盖,子类中的方法权限必须大于父类,如上show方法,new_phone必须是public否则报错</span></span><br><span class="line">权限:<span class="keyword">public</span> &gt;默认=<span class="keyword">protected</span>&gt;<span class="keyword">private</span></span><br><span class="line"> b:方法定义:子类方法和要重写的父类的方法:方法的方法名和参数列表都要一样。</span><br><span class="line">   关于方法的返回值:</span><br><span class="line">     如果是基本数据类型,子类的方法和重写的父类的方法返回值类型必须相同</span><br><span class="line">     如果是引用数据类型,子类的方法和重写的父类的方法返回值类型可以相同或者子类方法的返回值类型是父类方法返回值类型的子类</span><br></pre></td></tr></table></figure><h3 id="代码10-初识抽象类"><a href="#代码10-初识抽象类" class="headerlink" title="代码10:初识抽象类"></a>代码10:初识抽象类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> android().work();</span><br><span class="line">        <span class="keyword">new</span> algo3().work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Develop</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;<span class="comment">//抽象类没法确定主体方法内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">android</span> <span class="keyword">extends</span> <span class="title">Develop</span></span>&#123;  <span class="comment">//子类必须重载抽象类中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"你奶奶的"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">algo3</span> <span class="keyword">extends</span> <span class="title">Develop</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"你妹的"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类和抽象方法都需要被abstract修饰。抽象方法一定要定义在抽象类中。</span></span><br><span class="line"><span class="comment">//抽象类不可以直接创建对象，原因：调用抽象方法没有意义。</span></span><br><span class="line"><span class="comment">//抽象类的作用:继承的体系抽象类,强制子类重写抽象的方法</span></span><br><span class="line"><span class="comment">//抽象类下要也可以创建方法和对应的主体,但没有什么实际意义,可调用</span></span><br></pre></td></tr></table></figure><p>####代码11:员工类(this)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        javaee java = <span class="keyword">new</span> javaee(<span class="string">"小明"</span>,<span class="number">66</span>);</span><br><span class="line">        java.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee2</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee2</span><span class="params">(String name, <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.id =  id;</span><br><span class="line">     <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get_name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get_id</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">javaee</span> <span class="keyword">extends</span> <span class="title">Employee2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">javaee</span><span class="params">(String name, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"JavaEE的工程师开发淘宝"</span>+ <span class="keyword">super</span>.get_name()+<span class="string">".."</span>+<span class="keyword">super</span>.get_id());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####代码12:员工类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String [] agrs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        javaee2 java =   <span class="keyword">new</span> javaee2();</span><br><span class="line">        java.setName(<span class="string">"小明"</span>);</span><br><span class="line">        java.setId(<span class="number">66</span>);</span><br><span class="line">        java.work();</span><br><span class="line"></span><br><span class="line">        ceshi ceshi_ = <span class="keyword">new</span> ceshi();</span><br><span class="line">        ceshi_.setId(<span class="number">99</span>);</span><br><span class="line">        ceshi_.setName(<span class="string">"笑话"</span>);</span><br><span class="line">        ceshi_.work();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">employee</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="comment">//存取名字id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getid</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getname</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Develop2</span> <span class="keyword">extends</span> <span class="title">employee</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mainter</span> <span class="keyword">extends</span> <span class="title">employee</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">javaee2</span> <span class="keyword">extends</span> <span class="title">Develop2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"JAVA员工"</span>+getname()+<span class="string">"id"</span>+getid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ceshi</span> <span class="keyword">extends</span> <span class="title">Mainter</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"测试员工"</span>+getname()+<span class="string">"id"</span>+getid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####代码13:犬和缉毒功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day4;</span><br><span class="line"><span class="comment">//接口和抽象类:抽象类是对类的抽象,即单一的类无法描述所有情况的时候,而接口是一种扩展的功能,不是所有都使用</span></span><br><span class="line"><span class="comment">//一个类智能继承一个父类,但是可以继承多个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        home_dog dog = <span class="keyword">new</span> home_dog();</span><br><span class="line">        dog.laugh();</span><br><span class="line">        dog.eat();</span><br><span class="line">        dog.drug_();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//犬和缉毒</span></span><br><span class="line"><span class="comment">//犬定义为抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">dog</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">laugh</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缉毒</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">drug</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drug_</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">home_dog</span> <span class="keyword">extends</span> <span class="title">dog</span> <span class="keyword">implements</span> <span class="title">drug</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drug_</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"狗会缉毒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">laugh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"家园狗大脚"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃牛肉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码14-多态"><a href="#代码14-多态" class="headerlink" title="代码14:多态"></a>代码14:多态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day4;</span><br><span class="line"><span class="comment">//调用属性时使用的是父类的,调用方法编译时使用的是父类,执行时使用的是子类,因为被重载了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Fu fu = <span class="keyword">new</span> Zi();</span><br><span class="line">        System.out.println(fu.num);</span><br><span class="line">        fu.get_num();</span><br><span class="line">        Zi zi = <span class="keyword">new</span> Zi();</span><br><span class="line">        System.out.println(zi.num);</span><br><span class="line">        zi.get_num();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get_num</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"数字是"</span>+num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">6</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get_num</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"数字是"</span>+num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####代码15:向上转型和向下转型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向上转型:将子类对象转换成父类对象.可以调用父类的属性和子类的方法(都有的,会重载,子类中独有的无法调用,会报错)</span></span><br><span class="line"><span class="comment">//向下转型:父类对象转为子类对象====前提是向上转型,否则会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////向上转型</span></span><br><span class="line"><span class="keyword">package</span> day4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> dog2();</span><br><span class="line">        System.out.println(animal.age);</span><br><span class="line">        animal.eat();</span><br><span class="line">        animal.work();<span class="comment">//baocuo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"chifan"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"kaisgongzuossss"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dog2</span> <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"chifansssss"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////向下转型</span></span><br></pre></td></tr></table></figure><p>####代码16:笔记本电脑案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day7;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标空值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"鼠标开启"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鼠标关闭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//键盘控住</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">keyboard</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"键盘开启"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"键盘关闭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//笔记本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Notebook</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开启笔记本"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useusb</span><span class="params">(USB usb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (usb != <span class="keyword">null</span>)&#123;</span><br><span class="line">            usb.open();</span><br><span class="line">            usb.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shut</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"笔记本关闭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Notebook note = <span class="keyword">new</span> Notebook();</span><br><span class="line">        note.run();</span><br><span class="line">        keyboard ky = <span class="keyword">new</span> keyboard();</span><br><span class="line">        note.useusb(ky);</span><br><span class="line">        Mouse mu = <span class="keyword">new</span> Mouse();</span><br><span class="line">        note.useusb(mu);</span><br><span class="line">        note.shut();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码17-this构造方法的使用"><a href="#代码17-this构造方法的使用" class="headerlink" title="代码17:this构造方法的使用"></a>代码17:this构造方法的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//局部变量和成员变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        demo3 de = <span class="keyword">new</span> demo3(<span class="string">"小明"</span>,<span class="number">26</span>);</span><br><span class="line">        de.get_name_age();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">demo3</span><span class="params">(String na)</span></span>&#123;</span><br><span class="line">        name = na;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造方法this,this指代当前对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">demo3</span><span class="params">(String na,<span class="keyword">int</span> ag)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(na);  <span class="comment">//指代的就是创建的对象</span></span><br><span class="line">        age = ag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get_name_age</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"姓名是"</span>+name+<span class="string">"年纪是"</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##进一步,数值比较</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        demo4 de = <span class="keyword">new</span> demo4(<span class="string">"小明"</span>,<span class="number">26</span>);</span><br><span class="line">        de.get_name_age();</span><br><span class="line">        demo4 de2 = <span class="keyword">new</span> demo4(<span class="string">"小明"</span>,<span class="number">26</span>);</span><br><span class="line">        System.out.println(<span class="string">"是否同岁:"</span>+de.judge_age(de2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">demo4</span><span class="params">(String na)</span></span>&#123;</span><br><span class="line">        name = na;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造方法this,this指代当前对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">demo4</span><span class="params">(String na,<span class="keyword">int</span> ag)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(na);  <span class="comment">//指代的就是创建的对象</span></span><br><span class="line">        age = ag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get_name_age</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"姓名是"</span>+name+<span class="string">"年纪是"</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge_age</span><span class="params">(demo4 d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age == d.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##构造方法继承时候自动调用父类</span><br><span class="line"><span class="keyword">package</span> day9;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承的构造方法:会自动调用父类的,有个隐式的super执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Zi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fu</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"到爸爸这来"</span>);</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//有个隐式super</span></span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码18-综合案例—完整的员工类"><a href="#代码18-综合案例—完整的员工类" class="headerlink" title="代码18:综合案例—完整的员工类"></a>代码18:综合案例—完整的员工类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        JavaEE ja = <span class="keyword">new</span> JavaEE(<span class="string">"小米"</span>,<span class="number">25</span>);</span><br><span class="line">        ja.work();</span><br><span class="line">        JavaEE ja2 = <span class="keyword">new</span> JavaEE();</span><br><span class="line">        ja2.set_age(<span class="number">20</span>);</span><br><span class="line">        ja2.set_name(<span class="string">"笑话"</span>);</span><br><span class="line">        ja2.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工人类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"四大神兽多所"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">26</span>;</span><br><span class="line">    <span class="comment">//无参数构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//含参</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取姓名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get_name</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置姓名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set_name</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取年龄</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get_age</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置年龄</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set_age</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抽象类工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//研发类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Develop</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Develop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Develop</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name,age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name,age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavaEE</span> <span class="keyword">extends</span> <span class="title">Develop</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"java员工"</span>+get_name()+<span class="string">"年龄"</span>+get_age());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavaEE</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name,age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavaEE</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以此类推</span></span><br></pre></td></tr></table></figure><h4 id="code19-内部类的的访问及定义"><a href="#code19-内部类的的访问及定义" class="headerlink" title="code19.内部类的的访问及定义"></a>code19.内部类的的访问及定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        body.heart h = <span class="keyword">new</span> body().new heart();</span><br><span class="line">        System.out.println(h.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">body</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">heart</span></span>&#123;</span><br><span class="line">        String name = <span class="string">"心脏"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="code20-打牌"><a href="#code20-打牌" class="headerlink" title="code20.打牌"></a>code20.打牌</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 斗地主洗牌发牌排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备花色</span></span><br><span class="line">ArrayList&lt;String&gt; color = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">color.add(<span class="string">"♠"</span>);</span><br><span class="line">color.add(<span class="string">"♥"</span>);</span><br><span class="line">color.add(<span class="string">"♦"</span>);</span><br><span class="line">color.add(<span class="string">"♣"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备数字</span></span><br><span class="line">ArrayList&lt;String&gt; number = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">Collections.addAll(number,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>,<span class="string">"10"</span>,<span class="string">"J"</span>,<span class="string">"Q"</span>,<span class="string">"K"</span>,<span class="string">"A"</span>,<span class="string">"2"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个map集合：用来将数字与每一张牌进行对应</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (String thisNumber : number) &#123;</span><br><span class="line"><span class="keyword">for</span> (String thisColor : color) &#123;</span><br><span class="line">map.put(index++, thisColor+thisNumber);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加入大小王</span></span><br><span class="line">map.put(index++, <span class="string">"小☺"</span>);</span><br><span class="line">map.put(index++, <span class="string">"大☻"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//一副54张的牌 ArrayList里边为0-53的数的新牌</span></span><br><span class="line">ArrayList&lt;Integer&gt; cards = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">53</span>; i++) &#123;</span><br><span class="line">cards.add(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//洗牌</span></span><br><span class="line">Collections.shuffle(cards);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建三个玩家和底牌</span></span><br><span class="line">ArrayList&lt;Integer&gt; iPlayer = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; iPlayer2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; iPlayer3 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; itCards = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历这副洗好的牌，遍历过程中，将牌发到三个玩家和底牌中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cards.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=<span class="number">51</span>) &#123;</span><br><span class="line">iCards.add(cards.get(i));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>) &#123;</span><br><span class="line">iPlayer.add(cards.get(i));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">1</span>) &#123;</span><br><span class="line">iPlayer2.add(cards.get(i));</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">iPlayer3.add(cards.get(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对每个人手中的牌排序</span></span><br><span class="line">Collections.sort(iPlayer);</span><br><span class="line">Collections.sort(iPlayer2);</span><br><span class="line">Collections.sort(iPlayer3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对应数字形式的每个人手中的牌，定义字符串形式的牌</span></span><br><span class="line">ArrayList&lt;String&gt; sPlayer = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ArrayList&lt;String&gt; sPlayer2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ArrayList&lt;String&gt; sPlayer3 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ArrayList&lt;String&gt; sCards = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Integer key : iPlayer) &#123;</span><br><span class="line">sPlayer.add(map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Integer key : iPlayer2) &#123;</span><br><span class="line">sPlayer2.add(map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Integer key : iPlayer3) &#123;</span><br><span class="line">sPlayer3.add(map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Integer key : iCards) &#123;</span><br><span class="line">sCards.add(map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//看牌</span></span><br><span class="line">System.out.println(sPlayer);</span><br><span class="line">System.out.println(sPlayer2);</span><br><span class="line">System.out.println(sPlayer3);</span><br><span class="line">System.out.println(sCards);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="code21-异常"><a href="#code21-异常" class="headerlink" title="code21:异常"></a>code21:异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;<span class="keyword">int</span> num = <span class="number">2</span>; <span class="keyword">try</span>&#123; test(num); &#125;<span class="keyword">catch</span> (Exception e)&#123;System.out.println(test2(num));&#125;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;<span class="keyword">int</span> a = num/<span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;<span class="keyword">int</span> b;b = num/<span class="number">1</span>;<span class="keyword">return</span> b; &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//try catch()</span></span><br></pre></td></tr></table></figure><h4 id="code22-加法运算"><a href="#code22-加法运算" class="headerlink" title="code22:加法运算"></a>code22:加法运算</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"请输入2个加数"</span>);</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = add();</span><br><span class="line">        System.out.println(<span class="string">"结果:"</span>+result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取输入的2个整数返回</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">getInputNumbers</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = scan.nextInt();</span><br><span class="line">        <span class="keyword">int</span> num2 = scan.nextInt();</span><br><span class="line">        nums.add(<span class="keyword">new</span> Integer(num1));</span><br><span class="line">        nums.add(<span class="keyword">new</span> Integer(num2));</span><br><span class="line">    &#125;<span class="keyword">catch</span>(InputMismatchException immExp)&#123;</span><br><span class="line">        <span class="keyword">throw</span> immExp;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行加法计算</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; nums =getInputNumbers();</span><br><span class="line">        result = nums.get(<span class="number">0</span>)  + nums.get(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(InputMismatchException immExp)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"计算失败"</span>,immExp);  <span class="comment">/////////////////////////////链化:以一个异常对象为参数构造新的异常对象。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="集合框架下的List"><a href="#集合框架下的List" class="headerlink" title="集合框架下的List"></a>集合框架下的List</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">listdemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; name_list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        System.out.println(name_list.size());</span><br><span class="line">        name_list.add(<span class="string">"小米"</span>);<span class="comment">//增</span></span><br><span class="line">        name_list.add(<span class="string">"小花"</span>);<span class="comment">//增</span></span><br><span class="line">        name_list.add(<span class="number">1</span>,<span class="string">"小框"</span>);</span><br><span class="line">        System.out.println(name_list.size());</span><br><span class="line">        get_list(name_list);<span class="comment">//获取元素</span></span><br><span class="line">        name_list.remove(<span class="string">"小米"</span>);</span><br><span class="line">        get_list(name_list);</span><br><span class="line">        name_list.remove(<span class="number">1</span>);</span><br><span class="line">        get_list(name_list);</span><br><span class="line">        name_list.set(<span class="number">0</span>,<span class="string">"小狗"</span>);</span><br><span class="line">        get_list(name_list);</span><br><span class="line">        System.out.println(name_list.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get_list</span><span class="params">(List&lt;String&gt;  list)</span></span>&#123;</span><br><span class="line">        ListIterator&lt;String&gt; it =  list.listIterator();</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">            <span class="keyword">if</span>(it.next().equals(<span class="string">"小花"</span>))&#123;</span><br><span class="line">                list.add(<span class="string">"小猪"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//vector和arraylist区别(vector加enum别arraylist和itertoor替代)</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">listdemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; ls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ls.add(<span class="string">"小明"</span>);</span><br><span class="line">        ls.add(<span class="string">"小李"</span>);</span><br><span class="line">        ls.add(<span class="string">"三大大三"</span>);</span><br><span class="line">        Iterator&lt;String&gt; it = ls.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Vector&lt;String&gt; ls2 = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        ls2.addElement(<span class="string">"笑了"</span>);</span><br><span class="line">        ls2.addElement(<span class="string">"是打算"</span>);</span><br><span class="line">        Enumeration&lt;String&gt; eu = ls2.elements();</span><br><span class="line">        <span class="keyword">while</span>(eu.hasMoreElements())&#123;</span><br><span class="line">            System.out.println(eu.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="hashset自定义元素"><a href="#hashset自定义元素" class="headerlink" title="hashset自定义元素"></a>hashset自定义元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        ThreadDemo td = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line">        td.start();</span><br><span class="line"><span class="comment">//        td.run();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//start表示启用多线程,run表示调用方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//***************************方法2*********************************</span></span><br><span class="line"><span class="keyword">package</span> day12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">runnerable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        run_demo run = <span class="keyword">new</span> run_demo();</span><br><span class="line">        Thread th = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        th.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">run_demo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线程池runnable"><a href="#线程池runnable" class="headerlink" title="线程池runnable"></a>线程池runnable</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> day12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">thread_pool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        run_thread th = <span class="keyword">new</span> run_thread();</span><br><span class="line">        service.submit(th);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">run_thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线程池callable"><a href="#线程池callable" class="headerlink" title="线程池callable"></a>线程池callable</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day12;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">callable_pool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        call_pool cl = <span class="keyword">new</span> call_pool();</span><br><span class="line">        service.submit(cl);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">call_pool</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程池实现两个数相加"><a href="#线程池实现两个数相加" class="headerlink" title="线程池实现两个数相加"></a>线程池实现两个数相加</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">add_by_thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        call_func cl = <span class="keyword">new</span> call_func(<span class="number">2</span>,<span class="number">10</span>);</span><br><span class="line">        call_func cl2 = <span class="keyword">new</span> call_func(<span class="number">20</span>,<span class="number">10</span>);</span><br><span class="line">        Future&lt;Integer&gt; res = service.submit(cl);</span><br><span class="line">        Future&lt;Integer&gt; res2 = service.submit(cl2);</span><br><span class="line">        Integer data = res.get();</span><br><span class="line">        System.out.println(data);</span><br><span class="line">        Integer data2 = res2.get();</span><br><span class="line">        System.out.println(data2);</span><br><span class="line">        service.shutdown();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">call_func</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">call_func</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程不同步案例,线程不安全</span></span><br><span class="line"><span class="keyword">package</span> day12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">buy_ticket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">    ticket t = <span class="keyword">new</span> ticket();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(t,<span class="string">"窗口1"</span>);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(t,<span class="string">"窗口2"</span>);</span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(t,<span class="string">"窗口3"</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ticket_num = <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticket_num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() +<span class="string">"正在卖票"</span>+ticket_num--);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决线程不安全问题</span></span><br><span class="line"><span class="keyword">package</span> day12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">buy_ticket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">    ticket t = <span class="keyword">new</span> ticket();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(t,<span class="string">"窗口1"</span>);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(t,<span class="string">"窗口2"</span>);</span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(t,<span class="string">"窗口3"</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ticket_num = <span class="number">100</span>;</span><br><span class="line">    Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticket_num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() +<span class="string">"正在卖票"</span>+ticket_num--);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><h5 id="map-reduce-案例"><a href="#map-reduce-案例" class="headerlink" title="map reduce 案例"></a>map reduce 案例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * KEYIN ：是map task读取到的数据的key的类型，是一行的起始偏移量Long</span></span><br><span class="line"><span class="comment"> * VALUEIN:是map task读取到的数据的value的类型，是一行的内容String</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * KEYOUT：是用户的自定义map方法要返回的结果kv数据的key的类型，在wordcount逻辑中，我们需要返回的是单词String</span></span><br><span class="line"><span class="comment"> * VALUEOUT:是用户的自定义map方法要返回的结果kv数据的value的类型，在wordcount逻辑中，我们需要返回的是整数Integer</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 但是，在mapreduce中，map产生的数据需要传输给reduce，需要进行序列化和反序列化，而jdk中的原生序列化机制产生的数据量比较冗余，就会导致数据在mapreduce运行过程中传输效率低下</span></span><br><span class="line"><span class="comment"> * 所以，hadoop专门设计了自己的序列化机制，那么，mapreduce中传输的数据类型就必须实现hadoop自己的序列化接口</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * hadoop为jdk中的常用基本类型Long String Integer Float等数据类型封住了自己的实现了hadoop序列化接口的类型：LongWritable,Text,IntWritable,FloatWritable</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ThinkPad</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordcountMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切单词</span></span><br><span class="line">        String line = value.toString();</span><br><span class="line">        String[] words = line.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(String word:words)&#123;</span><br><span class="line">            context.write(<span class="keyword">new</span> Text(word), <span class="keyword">new</span> IntWritable(<span class="number">1</span>));</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordcountReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values,Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        Iterator&lt;IntWritable&gt; iterator = values.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            </span><br><span class="line">            IntWritable value = iterator.next();</span><br><span class="line">            count += value.get();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        context.write(key, <span class="keyword">new</span> IntWritable(count));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码100-api-object克隆"><a href="#代码100-api-object克隆" class="headerlink" title="代码100:api:object克隆"></a>代码100:api:object克隆</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day5;</span><br><span class="line"><span class="comment">/*object克隆*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        demo1 dem = <span class="keyword">new</span> demo1();</span><br><span class="line">        dem.i  = <span class="number">10</span>;</span><br><span class="line">        demo1 dem2 = (demo1) dem.clone();</span><br><span class="line">        System.out.println(dem2.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm</title>
      <link href="/2021/11/02/jvm/"/>
      <url>/2021/11/02/jvm/</url>
      
        <content type="html"><![CDATA[<h4 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">类加载机制:</span><br><span class="line">  1.类加载器分类(主要用来加载不同的类)</span><br><span class="line">  2.类生命周期(可看成类加载过程)</span><br><span class="line">  ①加载</span><br><span class="line">     --</span><br><span class="line">     --</span><br><span class="line">     --</span><br><span class="line">  ②连接</span><br><span class="line">     --验证</span><br><span class="line">     --准备</span><br><span class="line">     --解析</span><br><span class="line">  ③初始化</span><br><span class="line">  ④使用</span><br><span class="line">  ⑤卸载</span><br><span class="line">运行时数据区(java内存区域)</span><br><span class="line">  方法区---</span><br><span class="line">  堆区---  这两个线程共用</span><br><span class="line">  程序计数器</span><br><span class="line">  栈区(本地方法栈,虚拟机栈)===&gt;线程私有</span><br><span class="line">  直接内存</span><br></pre></td></tr></table></figure><p><img src="/2021/11/02/jvm/./jvm\1635843809(1" alt>.jpg)</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动化操作鼠标键盘</title>
      <link href="/2021/09/03/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%93%8D%E4%BD%9C%E9%BC%A0%E6%A0%87%E9%94%AE%E7%9B%98/"/>
      <url>/2021/09/03/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%93%8D%E4%BD%9C%E9%BC%A0%E6%A0%87%E9%94%AE%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line">pyautogui.moveTo(<span class="number">36</span>,<span class="number">240</span>,<span class="number">1</span>,pyautogui.easeOutQuad)</span><br><span class="line">pyautogui.moveTo(<span class="number">1683</span>,<span class="number">126</span>,<span class="number">1</span>,pyautogui.easeOutQuad)</span><br><span class="line">pyautogui.moveTo(<span class="number">1798</span>,<span class="number">735</span>,<span class="number">1</span>,pyautogui.easeOutQuad)</span><br><span class="line">pyautogui.moveTo(<span class="number">188</span>,<span class="number">24</span>,<span class="number">1</span>,pyautogui.easeOutQuad)</span><br><span class="line">pyautogui.click()</span><br><span class="line">pyautogui.dragTo(<span class="number">257</span>,<span class="number">556</span>,duration=<span class="number">1</span>,button=<span class="string">'left'</span>)</span><br><span class="line">pyautogui.typewrite(message=<span class="string">'dongzixinshishazi'</span>,interval=<span class="number">0.5</span>)</span><br><span class="line">pyautogui.press(<span class="string">'5'</span>)</span><br><span class="line">pyautogui.press(<span class="string">'1'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链路预测</title>
      <link href="/2021/08/18/%E9%93%BE%E8%B7%AF%E9%A2%84%E6%B5%8B/"/>
      <url>/2021/08/18/%E9%93%BE%E8%B7%AF%E9%A2%84%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h5 id="典型的链路预测算法"><a href="#典型的链路预测算法" class="headerlink" title="典型的链路预测算法"></a>典型的链路预测算法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.CN,共同邻居</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.资源分配(RA)</span><br><span class="line"></span><br><span class="line">3.Katz指标</span><br><span class="line"></span><br><span class="line">4.平均通勤时间(ACT)</span><br><span class="line"></span><br><span class="line">5.有重启的随机游走(RWR)</span><br><span class="line"></span><br><span class="line">6.simrank指标(simr)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 研发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态网络</title>
      <link href="/2021/08/03/%E5%8A%A8%E6%80%81%E7%BD%91%E7%BB%9C/"/>
      <url>/2021/08/03/%E5%8A%A8%E6%80%81%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">很多网络是随时间发生变化的,即动态网络</span><br><span class="line">从抽象的数学模型来看,动态网络其实是一个有序的图序列,表示复杂系统在不同时刻的快照</span><br><span class="line">方向:拓扑特征分析、社团模式挖掘、子图模式挖掘以及模式预测问题</span><br></pre></td></tr></table></figure><p><img src="/2021/08/03/动态网络/C:/Users\ADMINI~1\AppData\Local\Temp\1627958952437.png" alt="1627958952437"></p><h3 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h3><h5 id="论文一-复杂网络动力学机器学习自动建模"><a href="#论文一-复杂网络动力学机器学习自动建模" class="headerlink" title="论文一:复杂网络动力学机器学习自动建模"></a>论文一:复杂网络动力学机器学习自动建模</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">介绍:</span><br><span class="line">1.网络上的动力学:大多数网络上的个体在网络上是相互作用的,他们的相互影响遵循着某种规则</span><br><span class="line">2.效果:对未来任意时刻的网络上的节点状态进行预测</span><br><span class="line">3.难点:①网络非常复杂②非线性动力学的困难</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java大数据</title>
      <link href="/2021/07/13/java%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
      <url>/2021/07/13/java%E5%A4%A7%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h5 id="java基本了解"><a href="#java基本了解" class="headerlink" title="java基本了解"></a>java基本了解</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jvm:java虚拟机,java跨平台的关键,实现将程序转换成操作系统可识别的指令</span><br><span class="line">jre:java runtime environment,java运行环境,包含jvm</span><br><span class="line">jdk:java development kit,java扩展包</span><br><span class="line">java1.0-java15版本的发展及LTS版本,目前java8和11用的最多</span><br><span class="line">java se:java 标准版,最基本的 ----&gt;可认为做电脑上软件的</span><br><span class="line">java ee:java 企业版 ------&gt;可认为做网站的</span><br><span class="line">java me:java 微型版,嵌入式开发,现在用的少,如安卓是基于me开发的------&gt;可认为做手机软件的</span><br></pre></td></tr></table></figure><h5 id="视频学习流程"><a href="#视频学习流程" class="headerlink" title="视频学习流程"></a>视频学习流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java基本数据类型---&gt;面向对象,什么继承、封装、多态、构造方法、抽象类、接口、关键字---&gt;常见的包,object,string,date,time,Arrays---&gt;接口List(arraylist、linkedlist、vector）和Set（hashset、linkedhashset）---&gt;collection和map(类似于字典,由键值构成,键不能相同)，</span><br><span class="line"></span><br><span class="line">常用的工具:datax(拉数据),dolphinscheduler</span><br></pre></td></tr></table></figure><h5 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.四舍五入,(<span class="keyword">int</span>)为强制类型转换</span><br><span class="line"><span class="keyword">float</span> a = <span class="number">1.5f</span>;</span><br><span class="line"><span class="keyword">int</span> b = (<span class="keyword">int</span>)(a+<span class="number">0.5</span>) </span><br><span class="line"><span class="number">2</span>.不会自动转换类型</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">1.2</span> + <span class="number">24</span> / <span class="number">5</span>; <span class="comment">// 5.2</span></span><br><span class="line">可强制:<span class="keyword">double</span> d = <span class="number">1.2</span> + (<span class="keyword">double</span>)<span class="number">24</span> / <span class="number">5</span>;</span><br><span class="line"><span class="number">3</span>.基本的逻辑判断形如<span class="keyword">if</span>-<span class="keyword">else</span></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line">System.out.println(a==<span class="number">2</span>?<span class="string">"通过"</span>:<span class="string">"失败"</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.除法规范</span><br><span class="line">整数相处,除数不能为<span class="number">0</span></span><br><span class="line">浮点数相除,除数可以为<span class="number">0</span></span><br><span class="line">NaN表示Not a Number <span class="number">0</span>/<span class="number">0.0</span></span><br><span class="line">Infinity表示无穷大 <span class="number">2</span>/<span class="number">0.0</span></span><br><span class="line">-Infinity表示负无穷大 -<span class="number">2</span>/<span class="number">0.0</span></span><br><span class="line"><span class="number">5</span>.三元运算符:b ? x : y</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>.字符串变量命名,假如先定义了一个a=<span class="string">"66"</span>,然后在重新赋值a=<span class="string">"77"</span>,实际上<span class="number">66</span>并没有被删除,只是无法获取到</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>.空字符串不等于空值<span class="keyword">null</span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span>.数组操作</span><br><span class="line"><span class="keyword">int</span>[] a <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>] <span class="comment">//创建数组a,长度为5</span></span><br><span class="line">a.length <span class="comment">//数组长度</span></span><br><span class="line">a[<span class="number">0</span>] <span class="comment">//获取指定索引的元素</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">或者直接<span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] b = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="number">9</span>.逻辑控制:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">if</span> (a==<span class="number">20</span>) System.out.println(<span class="string">"正确"</span>);</span><br><span class="line"><span class="keyword">if</span> (b==<span class="number">10</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"进来了"</span>+b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c&gt;<span class="number">85</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"非常棒"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (c&gt;<span class="number">60</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"还行"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (c&gt;<span class="number">30</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"不太行"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"垃圾"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">10</span>.<span class="keyword">switch</span> <span class="keyword">case</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">switch</span>(a)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            System.out.println(<span class="string">"10"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">"2"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">11</span>.<span class="keyword">while</span> 先判断条件在循环</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (a &lt; <span class="number">20</span>) &#123;</span><br><span class="line">sum+=a;</span><br><span class="line">a+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12</span>.<span class="keyword">do</span> <span class="keyword">while</span> 先循环在判断条件    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">a+=<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">while</span>(a &gt;<span class="number">15</span>);</span><br><span class="line">System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">13</span>.<span class="keyword">for</span>循环</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> b=<span class="number">1</span>;b&lt;=a;b++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">14</span>.遍历列表</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] ns = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a=<span class="number">0</span>;a &lt; ns.length;a++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> b = ns[a];</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">15</span>.排序</span><br><span class="line">冒泡排序</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] ns = &#123;<span class="number">23</span>,<span class="number">34</span>,<span class="number">12</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">25</span>&#125;;</span><br><span class="line">    System.out.println(Arrays.toString(ns));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;ns.length-<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; ns.length-i-<span class="number">1</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span> (ns[j]&gt;ns[j+<span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = ns[j+<span class="number">1</span>];</span><br><span class="line">    ns[j+<span class="number">1</span>] = ns[j];</span><br><span class="line">    ns[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">16</span>.双层数组</span><br><span class="line"><span class="comment">//两层数组</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[][] ns = &#123;</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(Arrays.toString(ns[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.name = <span class="string">"xiaoliang"</span>;</span><br><span class="line">person.a = <span class="number">10</span>;</span><br><span class="line">System.out.println(person.name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.成员变量和局部变量</span><br><span class="line">定理在类中属性位置的称为成员变量,为所有成员共有.定位在方法下的属性称为局部变量</span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>.三大特性：继承、封装、多态</span><br><span class="line">封装：</span><br><span class="line">    <span class="number">1</span>.代码复用性高</span><br><span class="line">        <span class="number">2</span>.整合起来，提供输出的接口，别人看不到具体的实现细节</span><br><span class="line">        <span class="number">3</span>.安全</span><br><span class="line"><span class="number">3</span>.<span class="keyword">private</span>私有属性</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">对象内的私有化后,无法提供外部获取途径是不合理的,因为可以通过内部方法调用来实现</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.ArrayList&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;Student&gt;(); <span class="comment">//1.1创建一个可以存储多个同学名字的容器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">抽象类没法直接<span class="keyword">new</span>，抽象类下的抽象方法没有发括号、抽象类中不一定包含抽象方法、抽象类的子类必须重载所有的抽象方法</span><br><span class="line">案例:</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;<span class="comment">//抽象方法,内容不确定,没有发括号</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">normalMethod</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cat eat fish"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cat cat = <span class="keyword">new</span> Cat();</span><br><span class="line">        cat.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">接口:定义上和类定义一致,可理解为是一个特殊的抽象类，但它不是类，是一个接口</span><br><span class="line">接口最重要的体现：解决多继承的弊端。将多继承这种机制在java中通过多实现完成了。</span><br><span class="line">接口:比抽象类更抽象的一个数据类型,接口类里只描述方法,具体实现通过子类.接口定义,类去实现(类似于继承不同的是一个是extends一个是implement)</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fu1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fu2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">implements</span> <span class="title">Fu1</span>,<span class="title">Fu2</span>// 多实现。同时实现多个接口。</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="接口案例"><a href="#接口案例" class="headerlink" title="接口案例"></a>接口案例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">USB</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;<span class="comment">// 开启功能</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;<span class="comment">// 关闭功能</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">implements</span> <span class="title">USB</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"鼠标开启"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"鼠标关闭"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KeyBoard</span> <span class="keyword">implements</span> <span class="title">USB</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"键盘开启"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"键盘关闭"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoteBook</span> </span>&#123;</span><br><span class="line"><span class="comment">// 笔记本开启运行功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"笔记本运行"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 笔记本使用usb设备，这时当笔记本对象调用这个功能时，必须给其传递一个符合USB规则的USB设备</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useUSB</span><span class="params">(USB usb)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断是否有USB设备</span></span><br><span class="line"><span class="keyword">if</span> (usb != <span class="keyword">null</span>) &#123;</span><br><span class="line">usb.open();</span><br><span class="line">usb.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"笔记本关闭"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建笔记本实体对象</span></span><br><span class="line">NoteBook nb = <span class="keyword">new</span> NoteBook();</span><br><span class="line"><span class="comment">// 笔记本开启</span></span><br><span class="line">nb.run();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建鼠标实体对象</span></span><br><span class="line">Mouse m = <span class="keyword">new</span> Mouse();</span><br><span class="line"><span class="comment">// 笔记本使用鼠标</span></span><br><span class="line">nb.useUSB(m);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建键盘实体对象</span></span><br><span class="line">KeyBoard kb = <span class="keyword">new</span> KeyBoard();</span><br><span class="line"><span class="comment">// 笔记本使用键盘</span></span><br><span class="line">nb.useUSB(kb);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 笔记本关闭</span></span><br><span class="line">nb.shutDown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">修饰符:<span class="keyword">final</span> 固定</span><br><span class="line"><span class="keyword">static</span> 静态</span><br><span class="line"><span class="keyword">static</span> 静态修饰符,如在类中修饰属性,则实例化多个对象时是共享这个值</span><br><span class="line"><span class="keyword">private</span>、<span class="keyword">protected</span>、<span class="keyword">default</span>、<span class="keyword">public</span></span><br><span class="line">要想仅能在本类中访问使用<span class="keyword">private</span>修饰；</span><br><span class="line">要想本包中的类都可以访问不加修饰符即可；</span><br><span class="line">要想本包中的类与其他包中的子类可以访问使用<span class="keyword">protected</span>修饰</span><br><span class="line">要想所有包中的所有类都可以访问使用<span class="keyword">public</span>修饰。</span><br><span class="line"></span><br><span class="line">常用来修饰类、方法、变量的修饰符如下：</span><br><span class="line"><span class="keyword">public</span> 权限修饰符，公共访问, 类,方法,成员变量</span><br><span class="line"><span class="keyword">protected</span> 权限修饰符，受保护访问, 方法,成员变量</span><br><span class="line">默认什么也不写 也是一种权限修饰符，默认访问, 类,方法,成员变量</span><br><span class="line"><span class="keyword">private</span> 权限修饰符，私有访问, 方法,成员变量</span><br><span class="line"><span class="keyword">static</span> 静态修饰符  方法,成员变量</span><br><span class="line"><span class="keyword">final</span> 最终修饰符   类,方法,成员变量,局部变量</span><br><span class="line"><span class="keyword">abstract</span> 抽象修饰符  类 ,方法</span><br><span class="line"></span><br><span class="line">我们编写程序时，权限修饰符一般放于所有修饰符之前，不同的权限修饰符不能同时使用；</span><br><span class="line">同时，<span class="keyword">abstract</span>与<span class="keyword">private</span>不能同时使用；</span><br><span class="line">同时，<span class="keyword">abstract</span>与<span class="keyword">static</span>不能同时使用；</span><br><span class="line">同时，<span class="keyword">abstract</span>与<span class="keyword">final</span>不能同时使用。</span><br><span class="line"></span><br><span class="line">☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆</span><br><span class="line">注意：如果类用<span class="keyword">public</span>修饰，则类名必须与文件名相同。一个文件中只能有一个<span class="keyword">public</span>修饰的类。</span><br><span class="line">☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆</span><br><span class="line">继承:一个子类只能有一个父类,但是可以有多层结构c继承b,b继承a.自己有的优先调用自己的,没有才去父类调</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口和抽象类:抽象类是对类的抽象,即单一的类无法描述所有情况的时候,而接口是一种扩展的功能,不是所有都使用</span></span><br><span class="line"><span class="comment">//一个类智能继承一个父类,但是可以继承多个接口implement a,b,c  extends a</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">多态的体现:父类引用变量可以指向子类对象,相同的事物在不同的类有不同的含义(如既是老师也是学生)====变量调用的 是父类的变量,方法调用的是子类重载的方法</span><br><span class="line">成员变量，静态方法看左边；非静态方法：编译看左边，运行看右边。”意思是：当父类变量引用子类对象时,Fu f = <span class="keyword">new</span> Zi();在这个引用变量f指向的对象中，他的成员变量和静态方法与父类是一致的，他的非静态方法，在编译时是与父类一致的，运行时却与子类一致（发生了复写）</span><br><span class="line"></span><br><span class="line">继承时候,构造方法父类的会先执行,默认含有一个隐式的<span class="keyword">super</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关键词解释:</span><br><span class="line"><span class="keyword">final</span>:写在类前,表示该类不能被继承.写在方法前,表示该方法不能被重载.写在变量前表示该变量不能被二次赋值,否则会报错.</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>:静态修饰符,放在成员变量前,表示该变量是静态变量,<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">2</span>,可通过类名+变量获取,同时静态变量是所有实例化的对象共享的,一个改变则都跟着改变.  放在方法前表示该方法是静态方法,静态方法中只能访问静态变量或静态方法,同时不能使用<span class="keyword">super</span>和<span class="keyword">this</span>关键字</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(person.get_name());  <span class="comment">//调用静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String name = <span class="string">"xixom"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">get_name</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">注意:接口中的每个成员变量都默认使用<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>修饰。</span><br><span class="line">所有接口中的成员变量已是静态常量，由于接口没有构造方法，所以必须显示赋值。可以直接用接口名访问。Inter.COUNT</span><br><span class="line"></span><br><span class="line">匿名对象:实例化的对象没有赋值给变量 如<span class="keyword">new</span> person()</span><br></pre></td></tr></table></figure><p>面向对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">scala是完全面向对象的,为了实现static,通过伴生对象实现</span><br><span class="line"></span><br><span class="line">抽象类:里面既可以包含抽象属性、抽象方法、非抽象属性和非抽象方法,针对私有化的属性,可以通过伴生类去调用,在通过伴生类来进行调用.父类中的var属性在子类中可以直接修改,不需要override,会报错,子类继承的时候针对抽象方法可以不写override,针对非抽象方法必须写override</span><br><span class="line"></span><br><span class="line">特质trait也是抽象类,类似于java的接口,可以看成是方法的补充,区别是不能初始化属性,mixin混入,即可以wit很多特质</span><br><span class="line"></span><br><span class="line">类型判断和类型转换isinstanceof和asinstanceof</span><br><span class="line"></span><br><span class="line">枚举类对象和应用类</span><br><span class="line">object WorkDay extends Enumeration&#123;</span><br><span class="line">val Monday = value(1,&quot;MONDAY&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">应用类 </span><br><span class="line">object test extends APP&#123;&#125;===&gt;省略main方法</span><br><span class="line"></span><br><span class="line">自定义类型</span><br><span class="line">type Mystring = String 则Mystring可以当做string来使用</span><br></pre></td></tr></table></figure><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">分为三大类seq、set、和map</span><br><span class="line">创建数组</span><br><span class="line">new Array[Int](10)==&gt;简化Array(1,2,3,4,5...)==&gt;实际上调用的apply方法,apply可省略</span><br><span class="line"></span><br><span class="line">不可变数组追加数据 array1.:+(2)==&gt;往后追加array1 +: 2</span><br><span class="line">array1.+:(3)===&gt;往前追加 2 +:</span><br><span class="line">数组、可变数组的增删改查</span><br><span class="line">互相转换 arrai.toBuffer,arra2.toArray</span><br></pre></td></tr></table></figure><h2 id="接口API"><a href="#接口API" class="headerlink" title="接口API"></a>接口API</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">api:applicantion promming interfaces 应用程序接口</span><br><span class="line">类说明:</span><br><span class="line">##########################object#######################</span><br><span class="line"><span class="number">1</span>.clone:复制产生的是一个新对象,属性跟原本一样,只能在子类中用</span><br><span class="line"><span class="number">2</span>.getclass</span><br><span class="line"><span class="number">3</span>.finalize</span><br><span class="line"><span class="number">4</span>.equals:重构问题※※※※※</span><br><span class="line"><span class="number">5</span>.tostring:重构问题※※※※</span><br><span class="line">ogject是一切类的父类</span><br><span class="line">jdk中含有包的说明</span><br><span class="line">##########################string#######################</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#############################map##################</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建Map对象</span></span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line"><span class="comment">//给map中添加元素</span></span><br><span class="line">map.put(<span class="string">"邓超"</span>, <span class="string">"孙俪"</span>);</span><br><span class="line">map.put(<span class="string">"李晨"</span>, <span class="string">"范冰冰"</span>);</span><br><span class="line">map.put(<span class="string">"刘德华"</span>, <span class="string">"柳岩"</span>);</span><br><span class="line"><span class="comment">//获取Map中的所有key</span></span><br><span class="line">Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line"><span class="comment">//遍历存放所有key的Set集合</span></span><br><span class="line">Iterator&lt;String&gt; it =keySet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line"><span class="comment">//得到每一个key</span></span><br><span class="line">String key = it.next();</span><br><span class="line"><span class="comment">//通过key获取对应的value</span></span><br><span class="line">String value = map.get(key);</span><br><span class="line">System.out.println(key+<span class="string">"="</span>+value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">######排序和打乱</span><br><span class="line">collections.sort() 和collections.shuffle()</span><br></pre></td></tr></table></figure><h5 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.集合框架(类似Python的容器)分成collection(集合)===&gt;元素的集合,和map(图)===&gt;键值对的形式.</span><br><span class="line"><span class="number">2</span>.集合框架下分成list、set和queue</span><br><span class="line"><span class="number">3</span>.list下分成arraylist（数组），linkedlist（链表）、vector(抛弃了,被Arraylist和itertool替代了).(list集合下根据数据结构的不同可分成多部分,如栈、队列、数组、链表，其中数组取元素快，增删麻烦。链表增删数据简单，取数据慢---需要一个一个找，手拉手)</span><br><span class="line"><span class="number">4</span>.list下最常用的还是Arraylist</span><br><span class="line"><span class="number">5</span>.声明  List&lt;String&gt; = <span class="keyword">new</span> Arraylist&lt;String&gt;;</span><br><span class="line"><span class="number">6</span>.因为List中会允许存在重复数据,这时候需要去重,使用的是Set</span><br><span class="line"><span class="number">7</span>.set内分成hashset和linkedhashset</span><br><span class="line"><span class="number">8</span>.hashset去重的原则是hashcode和equals,如果输入的是自定义的对象,则需要重写hashcode和equals方法</span><br><span class="line"><span class="number">9</span>.哈希表:又名哈希数组,底层使用的是数组存放对象,然后会根据对象的特有数据和特定的算法,计算出对象在数组中未位置,然后把对象存放在数据中.</span><br><span class="line"><span class="number">10</span>.linkedhashset是hashset下的一个结构,可实现去重及排序,使用的是哈希表和链表实现的</span><br></pre></td></tr></table></figure><h4 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">进程是程序执行的最小单位,线程是资源调度的最小单位</span><br><span class="line">每个核同时只能执行一个线程,window默认只使用一个核,只是切换的速度超过人眼反应,因而可以同时开很多个程序.且速度和核数并非成线性的,开四个核实际提升可能只有<span class="number">2</span>倍左右.</span><br><span class="line"></span><br><span class="line">线程实现的两种方式一个是继承thread ,另一个是使用接口runnable接口.更多的是使用第二个,因为第一个存在单继承的局限性.</span><br><span class="line">    线程池:减少线程的创建和销毁的资源消耗,有放回的获取线程</span><br><span class="line"></span><br><span class="line">线程安全:针对全局变量如果多个线程只有读的操作,则认为是线程安全的.如果多某个变量进行写操作,需要多个线程同步,否则就是不安全的.</span><br><span class="line">    </span><br><span class="line">解决线程不安全问题: 使线程同步Synchronized</span><br><span class="line">实现方式:</span><br><span class="line"><span class="number">1</span>.同步代码块</span><br><span class="line">在可能会出现线程不安全的代码前加上Synchronized(锁对象)&#123;代码内容&#125;即可</span><br><span class="line"><span class="number">2</span>.同步方法</span><br><span class="line">将可能会出现问题的代码写成方法,<span class="function"><span class="keyword">public</span> Synchronized <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;内容&#125;</span><br><span class="line"><span class="number">3</span>.同步静态方法: 在方法前加上<span class="keyword">static</span> 。<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Synchronized <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;内容&#125;</span><br><span class="line"></span><br><span class="line">死锁:独木桥案例,抢资源谁也不让谁</span><br><span class="line">通常是一个线程锁定了一个资源A，而又想去锁定资源B；在另一个线程中，锁定了资源B，而又想去锁定资源A以完成自身的操作，两个线程都想得到对方的资源，而不愿释放自己的资源，造成两个线程都在等待</span><br><span class="line"><span class="number">1</span>.有多把锁</span><br><span class="line"><span class="number">2</span>.有多个线程</span><br><span class="line"><span class="number">3</span>.同步代码快嵌套</span><br><span class="line">通俗:两个线程,一个线程拿到了锁A,想拿锁B.但是宁外一个线程拿到了锁B,想要拿锁A.对方不释放则都拿不到,就这样僵持,造成了</span><br></pre></td></tr></table></figure><h5 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.几个关键词:<span class="keyword">throw</span>、<span class="keyword">throws</span>、<span class="keyword">finally</span>、<span class="keyword">try</span>、<span class="keyword">catch</span></span><br><span class="line"><span class="number">2</span>.通常<span class="keyword">try</span>&#123;&#125; <span class="keyword">catch</span>（）&#123;&#125;；类似python <span class="keyword">try</span> except</span><br><span class="line"><span class="number">3</span>.<span class="keyword">throws</span>的作用通常是修饰方法的，表面了该方法可能会抛出的异常，需要自己解决</span><br><span class="line"><span class="number">4</span>.<span class="keyword">finally</span>不管是<span class="keyword">try</span>还是<span class="keyword">catch</span>后,都会执行,除非遇到system.exit(),通常是用来释放资源,关闭连接的</span><br><span class="line"><span class="number">5</span>.执行顺序,首先执行<span class="keyword">try</span>,如果有异常则执行<span class="keyword">catch</span>,若没有<span class="keyword">catch</span>,则先执行<span class="keyword">finally</span>,然后再去找合适的<span class="keyword">catch</span></span><br><span class="line"><span class="number">6</span>. <span class="keyword">throw</span> 手动抛出异常 <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"w"</span>);</span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">构造方法的执行流程:</span><br><span class="line">1. 在栈中执行main方法,在堆中创建对象,并对属性值进行默认值赋予.栈中存放着对象的地址.</span><br><span class="line">2. 使用构造方法,会将传入的值赋给对象的参数</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识总结</title>
      <link href="/2021/07/07/%E5%85%86%E5%B0%B9%E7%A7%91%E6%8A%80%E8%AF%95%E7%94%A8%E6%9C%9F%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/07/07/%E5%85%86%E5%B0%B9%E7%A7%91%E6%8A%80%E8%AF%95%E7%94%A8%E6%9C%9F%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="核心要点"><a href="#核心要点" class="headerlink" title="核心要点"></a>核心要点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sql的规范非常重要：</span><br><span class="line">1. sql语法使用的是clickhouse（目前使用ch）</span><br><span class="line">2. 需要输入的参数使用&#123;&#125;括起来</span><br><span class="line">3. 参数以sql_开头的会将传入的参数值作为整个sql的一部分,如BENCHMARK_IDS=&quot;333,444,555&quot;会将它转换生成注入参数sql_BENCHMARK_IDS=&quot;(a.BENCHMARK_ID = &apos;333&apos; or a.BENCHMARK_ID = &apos;444&apos; or a.BENCHMARK_ID = &apos;555&apos;)&quot;)</span><br><span class="line">①注意sql_后面的名字需要和字段的名字一样,且会加一个s结尾,这样表示会传入多个参数,python转换的时候自动转换成or的形式去匹配数据</span><br><span class="line">②在参数设置-其他里面需要选择左连接还是右连接的参数设置</span><br><span class="line">4. 最外层字段名要使用AS,且目前看到的字段名全是大写的</span><br></pre></td></tr></table></figure><h4 id="中台系统"><a href="#中台系统" class="headerlink" title="中台系统"></a>中台系统</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 核心要点是某些无法直接查询或者通过sql写出来得指标</span><br><span class="line">2. 计算这些指标,首先需要明确需要用到哪些数据,以及计算的公式,然后通过公式将数据转换成模型,将它生成api即可</span><br></pre></td></tr></table></figure><h4 id="金融指标开发-核心要点-按照模板修改metadata和公式输入输出"><a href="#金融指标开发-核心要点-按照模板修改metadata和公式输入输出" class="headerlink" title="金融指标开发:核心要点:按照模板修改metadata和公式输入输出"></a>金融指标开发:核心要点:按照模板修改metadata和公式输入输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. 静态指标开发:定期需要跑的指标===&gt;跑批等---&gt;变化不大的指标===&gt;结果存在数据库里</span><br><span class="line">注意事项:</span><br><span class="line">1. 操作数据库使用dao里面的类,不要直接访问数据源</span><br><span class="line">2. 指标发布需要先写代码,写代码建议在元静态模板的基础上修改</span><br><span class="line">3. 静态指标发布:需要将指标在配置文件中进行添加(config文件夹下)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 动态指标开发:需要实时计算的===&gt;由前端发起请求,调用notebook的代码实现</span><br><span class="line">1. 复制模板代码,在模板代码的基础上进行修改</span><br><span class="line">2. 动态指标建议使用olap_开头</span><br><span class="line">3. 函数输出的metadata也需要包含输入的参数</span><br><span class="line">4. 动态指标的发布: 同静态,需要在配置文件里添加(config文件夹下)</span><br><span class="line">5. 转换成py代码,都需要在http://localhost:8000/下进行生成</span><br><span class="line">6.动态指标是否创建好,需要在jobs中的indicators_olpa.py文件下查看是否已经包含需要的函数</span><br><span class="line">7.动态指标发布完后可以通过postman进行测试</span><br></pre></td></tr></table></figure><p>疑问的地方: </p><pre><code>1. locallhost:8000怎么通过api接口自测1. postman的使用在哪里</code></pre><h4 id="代码整体介绍"><a href="#代码整体介绍" class="headerlink" title="代码整体介绍"></a>代码整体介绍</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">1. 代码里的api_mode apiext apis对应了三个版本的api接口,api_model对应了roboat_api,apis对应了跑批的api</span><br><span class="line">2. 跑批程序需要在config/job_conf.json进行配置,否则不会进行代码转换,olap的配置目前看到是不用了所以不用进行配置</span><br><span class="line">3. 跑批的py代码生成后(点击),可以在中台批处理任务/任务管理进行新建任务时候,任务方法里面可以看到跑批的算法列表(由跑批的api列表那个提供)</span><br><span class="line">4. 接口里面olap实时生成目前已经不用了,在光大版本时候使用的</span><br><span class="line">5. 接口里面tool也是光大版本使用的目前已经不用</span><br><span class="line">5. 接口里面ext_tool只要是下载保存使用的</span><br><span class="line">6. 接口面的robot_tool是邮储版本使用的,负责生成平铺指标函数类和聚合指标函数类==驼峰命名法,同时会将平铺和聚合类的ipynb代码转换成py代码,平铺转换后的代码在functions/ind下,聚合转换后的代码在functions/ind_agg下</span><br><span class="line">7. metadata的作用是告诉中台由哪些参数</span><br><span class="line">8. 操作数据模型进行数据读写,在inds_function/agg聚合里面有样例</span><br><span class="line">9. agg类的聚合算法模型ipynb会生成对应的驼峰命名法类的算法模型,可在API管理的算法模型通过类名搜索到对应的模型,也可以在指标库管理里面搜到</span><br><span class="line">10. 不同的级别:什么组合\组合树级别的,不知道什么意思,在meta_data中有定义agg-layers(里面有port\port-tree等这些划分)</span><br><span class="line">11. 服务启动的时候会自动转换所有模型.除非有新增才需要手动去api生成.重启不考虑</span><br><span class="line">12. 中台数据模型里面,目前只用到了单源模型和数据源,复合模型目前还没有开始使用.单源模型是md结尾的,复合模型是cmd结尾的</span><br><span class="line">13. 在中台创建的单元数据模型,每次启动服务时候都会自动生成对应的类的py代码,使得可以直接在代码里使用了,不用进行数据库的读取操作了,也可以自己生成通过/robot_tool/model_to_ind_funcs接口</span><br><span class="line">14. 聚合类本来只有那些自带的方法(光大版)==&gt;在api管理的数据分组那里,后来添加了自定义agg的算法模型</span><br><span class="line">15. 数据中台的指标库指标的操作在apiext下的api_data_utils.py代码里,进行实例化操作</span><br><span class="line">16. 同一指标的时间维度配置,名称可以相同(在指标库/指标设置/新增指标/时间维度)==&gt;循环跑,代码在api_data_utils部分</span><br><span class="line">17. 共通参数名在common下的constants.py代码里,否则组合树那些可能无法解析,无法转换</span><br><span class="line">18. 字典代码在commmon下的sys_dicts</span><br><span class="line">19. dao数据库处理相关的</span><br><span class="line">20. settings里面的sql配置是给dao里面的sql使用的,不是给数据模型使用的,数据模型使用的是数据源的配置的连接.在dao/models/data_source_init.py文件下</span><br><span class="line">21. dao/data_model.py下负责解析大json,然后解析成文件</span><br><span class="line">22. 层级类型的理解,什么组合树啊,port_ids啊</span><br><span class="line">23. 单源模型的参数设置时候默认值填 1=1, 多个数据时候通常选在,左字段里面得选择表名.字段名</span><br><span class="line">24. 汇总级别里面,组合树、组合、资产树、期间、资产等区别是什么</span><br><span class="line">25. 测试流程:</span><br><span class="line">1. 本地测试</span><br><span class="line">①启动py服务,写jupyter代码,假数据测试</span><br><span class="line">2. 服务器测试</span><br><span class="line">①在服务器写完ipynb代码,或者更新最新的代码上去,重启服务(上传,生成也可以)</span><br><span class="line">②在api管理里面新建算法模型的api接口</span><br><span class="line">③通过api接口返回的json去python的某个接口获取大json</span><br><span class="line">④把大json传给模型接口,完成</span><br><span class="line">26. jupyter仅仅作为一个写代码的工具,无法和中台那些连起来</span><br><span class="line">27. 组合代码:port_ids = &apos;ZY_HB001,ZY_JZ001,ZYB&apos;</span><br><span class="line">28. 配置中台数据源连接在dao/data_source_init.py下</span><br><span class="line">29. 写代码流程: 目前是在原有代码的基础上修改,添加字段等操作</span><br><span class="line">批处理代码流程:</span><br><span class="line">1. 本地修改代码,添加字段,新建文件还需要添加到配置文件里</span><br><span class="line">2. 重新生成批处理的文件,execute</span><br><span class="line">3. 使用postman的/job/run_batch/&#123;job_name&#125;跑一下该任务</span><br><span class="line">4. 断点调试,通过debug模式启动任务,然后在py代码里大断点</span><br><span class="line">5. 运行postman跑批任务的接口,跑代码</span><br><span class="line">6. 去数据库通过sql查询插入的数据是否正确,没问题则将修改的代码上传</span><br><span class="line">30. 参数sql_port_ids等样式的特殊</span><br><span class="line">31. 输出字符的name决定了输出字段的名字,是中文则是中文</span><br><span class="line">32. 有后置过滤处理因而返回的参数不要与传入的参数有重叠</span><br><span class="line">33. 重启服务:</span><br><span class="line">cd /home/tams/docker_deploy/dc-start/</span><br><span class="line">docker ps</span><br><span class="line">docker restart 79f4e307d214</span><br></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 组合、资产</span><br><span class="line">2. 源数据表里放的是哪些数据</span><br><span class="line">①Bond\dwd\HK\LC\QT\sst等分别代表的含义</span><br><span class="line">3. 指标设置里面的参数设置控件,怎么选择的问题</span><br></pre></td></tr></table></figure><p>最早的投资时间小于平台日会报错</p><p>什么时候看完,什么时候开发完</p><h4 id="本地调试代码修改"><a href="#本地调试代码修改" class="headerlink" title="本地调试代码修改"></a>本地调试代码修改</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sql_util_instance</span><span class="params">(cls, data_source_id: str)</span> -&gt; DbUtils:</span>   <span class="comment">#####本地重载的,源代码是下面那个,不要动</span></span><br><span class="line">    logger.debug(str(cls))</span><br><span class="line">    <span class="keyword">if</span> data_source_id <span class="keyword">in</span> db_utils_dict:</span><br><span class="line">        <span class="keyword">return</span> db_utils_dict[data_source_id]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data_source_lock.acquire()</span><br><span class="line">        <span class="comment"># 实时请求中台</span></span><br><span class="line">        <span class="keyword">if</span> data_source_id:</span><br><span class="line">            ds_dict = rest_post(s.GET_ALL_DB_CONN_URL, &#123;<span class="string">'dataSourceId'</span>: <span class="string">''</span>&#125;)</span><br><span class="line">            <span class="keyword">if</span> ds_dict:</span><br><span class="line">                source_ids =[i <span class="keyword">for</span> i <span class="keyword">in</span> rest_post(<span class="string">'/dataModel/getAllDbConnList'</span>, &#123;<span class="string">'dataSourceId'</span>: <span class="string">''</span>&#125;)[<span class="string">'list'</span>] <span class="keyword">if</span> i[<span class="string">'dataSourceId'</span>] == data_source_id]</span><br><span class="line">                ds_dict = &#123;<span class="string">'size'</span>:len(source_ids),<span class="string">'list'</span>:source_ids&#125;</span><br><span class="line">            <span class="keyword">if</span> ds_dict <span class="keyword">and</span> (<span class="string">'size'</span> <span class="keyword">in</span> ds_dict) <span class="keyword">and</span> (ds_dict[<span class="string">'size'</span>] == <span class="number">1</span>):</span><br><span class="line">                data_s = __format_ds(ds_dict[<span class="string">'list'</span>][<span class="number">0</span>])</span><br><span class="line">                data_source_config[data_s[<span class="string">'dataSourceId'</span>]] = data_s</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 实时创建连接池和db_utils</span></span><br><span class="line">                db_utils = create_db_utils(data_s[<span class="string">'dbType'</span>], data_s)</span><br><span class="line">                db_utils_dict[data_source_id] = db_utils</span><br><span class="line">                <span class="keyword">return</span> db_utils</span><br><span class="line">    <span class="keyword">except</span> ConnectionResetError <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(repr(e))</span><br><span class="line">        msg = <span class="string">'%s 无法访问，可能是服务未正常启动或网络不通。'</span> % s.EUREKA_DATA_MID_NAME</span><br><span class="line">        logger.error(msg)</span><br><span class="line">        <span class="keyword">raise</span> DataSourceNotFoundError(msg=msg)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        data_source_lock.release()</span><br><span class="line"></span><br><span class="line">    logger.error(<span class="string">'找不到数据源：%s的配置信息。'</span> % data_source_id)</span><br><span class="line">    <span class="keyword">raise</span> DataSourceNotFoundError(data_source_id)</span><br></pre></td></tr></table></figure><h4 id="取模型数据"><a href="#取模型数据" class="headerlink" title="取模型数据"></a>取模型数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PORT_IDS = &apos;DL1,DL2&apos;</span><br><span class="line">START_DATE = &apos;2000-01-01&apos;</span><br><span class="line">END_DATE = &apos;2020-01-01&apos;</span><br><span class="line">BENCHMARK_TYPE = &apos;1&apos;</span><br><span class="line">BENCHMARK_ID = &apos;2&apos;</span><br><span class="line">ind_instance = get_ind_instance(&#123;</span><br><span class="line">    gCp.AGG_IND_CLASS_NAME.value: &apos;PortfolioPeriodReturnAgg&apos;,</span><br><span class="line">    &apos;PORT_IDS&apos;: PORT_IDS, </span><br><span class="line">    &apos;START_DATE&apos;: START_DATE, </span><br><span class="line">    &apos;END_DATE&apos;: END_DATE,</span><br><span class="line">    &apos;BENCHMARK_TYPE&apos;:BENCHMARK_TYPE,</span><br><span class="line">    &apos;BENCHMARK_ID&apos;:BENCHMARK_ID</span><br><span class="line">&#125;)</span><br><span class="line">df_list = ind_instance.get_source_df_list()</span><br><span class="line">df = ind_instance.calc_port_return(df_list)</span><br><span class="line">df</span><br></pre></td></tr></table></figure><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PORT_IDS = &apos;DL71,NYLY-6MDK&apos;</span><br><span class="line">END_DATE = &apos;2020-01-01&apos;</span><br><span class="line">START_DATE = &apos;2000-01-01&apos;  </span><br><span class="line">BENCHMARK_TYPE=&apos;CONTRACT&apos;</span><br><span class="line">BENCHMARK_ID=&apos;GZ001&apos;</span><br><span class="line">CALC_BENCHMARK_ID = &apos;01&apos;</span><br><span class="line">NO_RISK_BENCHMARK_ID = &apos;02&apos;</span><br><span class="line">is_test=False</span><br><span class="line">calc_return2(get_source_data(PORT_IDS, START_DATE, END_DATE, BENCHMARK_TYPE=&apos;CONTRACT&apos;,BENCHMARK_ID = BENCHMARK_ID,BENCHMARK_IDS = [&apos;GZ001&apos;,&apos;GZ002&apos;,&apos;GZ003&apos;], CALC_BENCHMARK_ID = CALC_BENCHMARK_ID, NO_RISK_BENCHMARK_ID = NO_RISK_BENCHMARK_ID))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">df_list = get_source_data(&apos;NYLY-10MDK&apos;, &apos;2019-01-01&apos;, &apos;2019-12-17&apos;,BENCHMARK_IDS = &apos;GY001&apos;, CALC_BENCHMARK_ID = &quot;000007_CNSESH&quot;, NO_RISK_BENCHMARK_ID = &apos;GZ001&apos;)</span><br></pre></td></tr></table></figure><h3 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">job_convert.py 代码里主要讲述了jupyter代码 转换成python代码的实现过程</span><br><span class="line">apiext/api_data_utils.py 方法生成</span><br></pre></td></tr></table></figure><p><img src="/2021/07/07/兆尹科技试用期学习/C:/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220917101635133.png" alt="image-20220917101635133"></p><p>这个意思是根据使用组合和组合树的不同可以返回不同的指标,要在这里面标明,下面source是为了字段溯源使用的(血缘关系-光大版本的)目前直接读的数据模型不需要考虑来源于哪个表了,所以不用写</p><p><img src="/2021/07/07/兆尹科技试用期学习/C:/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220917103836858.png" alt="image-20220917103836858"></p><p>平铺类算法指标想要实现多进程可以在meta_data里面写(这里说的是传入很多个组合的时候的情况),这里的写法意思是多进程跑方法</p><p><img src="/2021/07/07/兆尹科技试用期学习/C:/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220917104849624.png" alt="image-20220917104849624"></p><p>这里是一个优化的点,通过测试查看多进程是否可以快一点</p><p><img src="/2021/07/07/兆尹科技试用期学习/C:/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220917163759789.png" alt="image-20220917163759789"></p><p>df1 = pd.DataFrame([[‘2019-01-01’,10],[‘2019-01-02’,10],[‘2019-01-10’,10]],columns = [‘month_date’,’values’])<br>df2 = pd.DataFrame([[‘2019-01-13’,10],[‘2019-01-10’,10],[‘2019-01-15’,10]],columns = [‘month_date’,’values’])<br>start_date = min(df1.month_date.min(),df2.month_date.min())<br>end_date = max(df1.month_date.max(),df2.month_date.max())<br>month_num = len(pd.date_range(start_date,end_date,freq = ‘D’,closed = ‘left’))<br>date_df = pd.DataFrame(pd.date_range(start_date,freq = ‘D’,periods = month_num+1),columns = [‘month_date’])<br>date_df[‘month_date’] = date_df[‘month_date’].apply(lambda x:str(x)[:10])<br>date_df_all = date_df.merge(df1,on = ‘month_date’,how = ‘left’).merge(df2,on = ‘month_date’,how = ‘left’)</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识总结</title>
      <link href="/2021/07/07/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/2021/07/07/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Python:基础知识,mysql操作,爬虫,机器学习算法,numpy,pandas,数据分析,cython,numba,pypy,dask,pp了解,xgboost,clickhouse,nlp基础了解,pandarallel,pyspark,linux基础命令,数据结构与算法,复杂网络了解,接口了解,特征工程,Python操作excel指定格式存数据</span><br><span class="line">其他:联邦学习</span><br><span class="line">java、hadoop相关架构</span><br></pre></td></tr></table></figure><h3 id="del"><a href="#del" class="headerlink" title="del"></a>del</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用del可以将对象占用内存空间的引用计数值置零（Deletion of a name removes the binding of that name from the local or global namespace）。它并不能让对象占用的内存被回收，但一段内存的引用计数变为零，就说明它可以再次被重新使用了（所以del后，不必要GC介入）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文本预处理代码案例</title>
      <link href="/2021/05/27/%E6%96%87%E6%9C%AC%E9%A2%84%E5%A4%84%E7%90%86%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B/"/>
      <url>/2021/05/27/%E6%96%87%E6%9C%AC%E9%A2%84%E5%A4%84%E7%90%86%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nlp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连接服务器的jupyter</title>
      <link href="/2021/04/15/%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84jupyter/"/>
      <url>/2021/04/15/%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84jupyter/</url>
      
        <content type="html"><![CDATA[<h5 id="整体概括"><a href="#整体概括" class="headerlink" title="整体概括"></a>整体概括</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pip3 install jupyter notebook</span><br><span class="line"></span><br><span class="line">1.在服务器安装jupyter notebook 并启动服务(jupyter notebook --ip 0.0.0.0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.在windows浏览器输入地址,具体可看上面第一步的打印信息</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jupyter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>联邦学习</title>
      <link href="/2021/04/08/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/04/08/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="联邦学习概念理解"><a href="#联邦学习概念理解" class="headerlink" title="联邦学习概念理解"></a>联邦学习概念理解</h4><p><img src="/2021/04/08/联邦学习/联邦学习基础.png" alt="联邦学习基础"></p><p>####PHE加密 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from phe import paillier</span><br><span class="line">public_key, private_key = paillier.generate_paillier_keypair() #创建公钥和私钥</span><br><span class="line">secret_number_list = [3.141592653, 300, -4.6e-12]</span><br><span class="line">encrypted_number_list = [public_key.encrypt(x) for x in secret_number_list] #加密</span><br><span class="line">[private_key.decrypt(x) for x in encrypted_number_list] #使用私钥解密</span><br><span class="line">a, b, c = encrypted_number_list</span><br><span class="line">a_plus_5 =a + 5</span><br></pre></td></tr></table></figure><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">fromphe <span class="keyword">import</span> paillier</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_diabetes</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.utils <span class="keyword">import</span> shuffle</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, config)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">## 模型参数</span></span><br><span class="line"></span><br><span class="line">        self.config = config</span><br><span class="line"></span><br><span class="line">        <span class="comment">## 中间计算结果</span></span><br><span class="line"></span><br><span class="line">        self.data = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">## 与其他节点的连接状况</span></span><br><span class="line"></span><br><span class="line">        self.other_client = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 与其他参与方建立连接</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, client_name, target_client)</span>:</span></span><br><span class="line"></span><br><span class="line">        self.other_client[client_name] = target_client</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 向特定参与方发送数据</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_data</span><span class="params">(self, data, target_client)</span>:</span></span><br><span class="line"></span><br><span class="line">        target_client.data.update(data)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientA</span><span class="params">(Client)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, X, config)</span>:</span></span><br><span class="line"></span><br><span class="line">        super().__init__(config)</span><br><span class="line"></span><br><span class="line">        self.X = X</span><br><span class="line"></span><br><span class="line">        self.weights = np.zeros(X.shape[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_z_a</span><span class="params">(self)</span>:</span></span><br><span class="line">        z_a = np.dot(self.X, self.weights)</span><br><span class="line">        <span class="keyword">return</span> z_a</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">compute_encrypted_dJ_a</span><span class="params">(self, encrypted_u)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> encrypted_dJ_a</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">update_weight</span><span class="params">(self, dJ_a)</span>:</span></span><br><span class="line">    self.weights = self.weights - self.config[<span class="string">"lr"</span>] *dJ_a / len(self.X)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## A: step2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task_1</span><span class="params">(self, client_B_name)</span>:</span></span><br><span class="line">        dt = self.data</span><br><span class="line">        public_key = dt[<span class="string">'public_key'</span>]</span><br><span class="line"></span><br><span class="line">        z_a = self.compute_z_a()</span><br><span class="line"></span><br><span class="line">        u_a = <span class="number">0.25</span> * z_a</span><br><span class="line"></span><br><span class="line">        z_a_square =z_a ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        encrypted_u_a = np.asarray([public_key.encrypt(x) forx <span class="keyword">in</span> u_a])</span><br><span class="line"></span><br><span class="line">        encrypted_z_a_square = np.asarray([public_key.encrypt(x) forx <span class="keyword">in</span> z_a_square])</span><br><span class="line">dt.update(&#123;<span class="string">"encrypted_u_a"</span>: encrypted_u_a&#125;)</span><br><span class="line">        data_to_B = &#123;<span class="string">"encrypted_u_a"</span>: encrypted_u_a, <span class="string">"encrypted_z_a_square"</span>: encrypted_z_a_square&#125;</span><br><span class="line">        self.send_data(data_to_B, self.other_client[client_B_name])</span><br><span class="line">        </span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">task_2</span><span class="params">(self, client_C_name)</span>:</span></span><br><span class="line">        dt = self.data</span><br><span class="line">        encrypted_u_b = dt[<span class="string">'encrypted_u_b'</span>]</span><br><span class="line"></span><br><span class="line">        encrypted_u =encrypted_u_b + dt[<span class="string">'encrypted_u_a'</span>]</span><br><span class="line"></span><br><span class="line">        encrypted_dJ_a = self.compute_encrypted_dJ_a(encrypted_u)</span><br><span class="line"></span><br><span class="line">        mask = np.random.rand(len(encrypted_dJ_a))</span><br><span class="line"></span><br><span class="line">        encrypted_masked_dJ_a =encrypted_dJ_a + mask</span><br><span class="line">        dt.update(&#123;<span class="string">"mask"</span>: mask&#125;)</span><br><span class="line">        data_to_C = &#123;<span class="string">'encrypted_masked_dJ_a'</span>: encrypted_masked_dJ_a&#125;</span><br><span class="line"></span><br><span class="line">    self.send_data(data_to_C, self.other_client[client_C_name])</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task_3</span><span class="params">(self)</span>:</span></span><br><span class="line">        dt = self.data</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clickhouse底层知识</title>
      <link href="/2021/04/01/clickhouse%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/"/>
      <url>/2021/04/01/clickhouse%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>clickhouse:列式存储,一个用于(OLAP–&gt;联机分析)的列式数据库管理系统(DBMS)</p><p>clickhouse为啥快:</p><p>​    1.有多少CPU吃多少资源</p><p>​    2.Clickhouse不支持事务,不存在隔离级别</p><p>​    3.IO方面,mysql是行存储,Clickhouse是列存储.mysql需要大量的随机io.clickhouse基本是顺序io.(顺序io,磁头顺序访问.随机IO,需要先寻址===通俗就是顺序io,找到第一块数据后,其他数据都在这块数据后就不需要寻址了,依次获取即可,随机IO重复到不同的扇区找不同的数据,所以慢)</p><p>​    4.列式存储,向量化引擎</p><p>数据处理:</p><p>​    OLAP:联机分析处理,—-&gt;数据的聚合,上钻,下钻等==&gt;上,获取数据上一级数据,下,获取更细节的数据</p><p>​    OLTP:联机事务处理,—&gt;数据的增删改查等</p><p>#####按行存储和按列存储</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.只访问查询的列,大大降低IO</span><br><span class="line">2.由于查询是通过列实现的,整个数据库是自动索引化的</span><br><span class="line">3.按行存储没有索引会使用大量的IO,而建立索引有需要花费大量时间和资源</span><br><span class="line">4.按列存储有效减少了扫描的数据量.,按行扫描会获取所有字段,而按列则只获取指定字段</span><br><span class="line">5.列式存储除了降低了IO和存储的压力(数据压缩),还为向量化做好了铺垫</span><br></pre></td></tr></table></figure><h5 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Int:Int8,Int16,Int32,Int64                                     toInt32</span><br><span class="line">Float:Float32,Float64                                          toFloat32</span><br><span class="line">Decimal:Decimal32,Decimal64,Decimal128======&gt;保留小数位数       toDecimal32</span><br><span class="line">String: String,FixedString 定长,UUID 直接定义为主键              toString</span><br><span class="line">Date:DateTime,DateTime64,Date 时间精度不同,Date到天,DateTime到秒,DateTime64到亚秒  toDate</span><br></pre></td></tr></table></figure><h5 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数组 Array ,数组内的数据类型可以不同,但是不能冲突,如int和float是可以的,但是不能和String组成</span><br><span class="line"></span><br><span class="line">元组 Tuple ,比array强一点,可以支持不同的数据类型,即元组内可以同时出现整形和字符串===但是定义的时候还是需要指定数据类型,如果插入数据类型不匹配仍会出错</span><br><span class="line"></span><br><span class="line">枚举 Enum ,键值对的形式,a=2,b=3等</span><br><span class="line"></span><br><span class="line">嵌套 Nested 可以让多个字段嵌套在一个字段下,如dept.id,dept.name,dept.age这种形成字段,字段内为数组,且长度都得一致,且一一对应</span><br></pre></td></tr></table></figure><p>#####特殊数据类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Nullable===&gt;辅助修饰,让某些字段可以写入NULL值如:Nullable(String)-----&gt;慎用,会影响性能.只能和基础数据类型搭配不能搭配符合数据类型 Nullable(Array(String))不可行.Array(Nullable(String)) 可行</span><br><span class="line"></span><br><span class="line">Domain====&gt;分为IPv4和IPv6两种,直接定义数据类型即可  </span><br><span class="line">ip IPv4</span><br><span class="line">用处:自带检查功能,是否符合规范</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> clickhouse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clickhouse安装配置</title>
      <link href="/2021/03/23/clickhouse%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/03/23/clickhouse%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h5 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.安装curl系统包</span><br><span class="line">yum install -y curl</span><br><span class="line">2.安装clickhouse repositories</span><br><span class="line">sudo yum install -y clickhouse-server clickhouse-client</span><br><span class="line">3.查询clickhouse包</span><br><span class="line">yum list &apos;clickhouse*&apos;</span><br><span class="line">4.安装clickhouse包</span><br><span class="line">yum install -y &apos;clickhouse*&apos;</span><br></pre></td></tr></table></figure><h4 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2.修改配置文件"></a>2.修改配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件位置 /etc/clickhouse-server</span><br></pre></td></tr></table></figure><h5 id="2-1-远程可访问配置"><a href="#2-1-远程可访问配置" class="headerlink" title="2.1.远程可访问配置"></a>2.1.远程可访问配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">将config.xml文件下的一行代码注释打开</span><br><span class="line"></span><br><span class="line">找到&lt;!-- &lt;listen_host&gt;::&lt;/listen_host&gt; --&gt;  打开注释之后变成这样&lt;listen_host&gt;::&lt;/listen_host&gt;</span><br><span class="line">重启</span><br><span class="line"></span><br><span class="line">service clickhouse-server restart</span><br></pre></td></tr></table></figure><p>#####2.2..创建角色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">对config.xml修改</span><br><span class="line">在最后一行加上下面的代码，用于接收创建的角色信息，加完代码之后记得创建这个文件</span><br><span class="line"></span><br><span class="line">&lt;access_control_path&gt;/data/work/clickhouse/access/&lt;/access_control_path&gt;</span><br><span class="line">对users.xml 的配置修改</span><br><span class="line">&lt;profiles&gt;</span><br><span class="line">    &lt;!-- Default settings. --&gt;</span><br><span class="line">    &lt;default&gt;</span><br><span class="line">        &lt;!-- Maximum memory usage for processing single query, in bytes. --&gt;</span><br><span class="line">        &lt;max_memory_usage&gt;10000000000&lt;/max_memory_usage&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- Use cache of uncompressed blocks of data. Meaningful only for processing many of very short queries. --&gt;</span><br><span class="line">        &lt;use_uncompressed_cache&gt;0&lt;/use_uncompressed_cache&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- How to choose between replicas during distributed query processing.</span><br><span class="line">             random - choose random replica from set of replicas with minimum number of errors</span><br><span class="line">             nearest_hostname - from set of replicas with minimum number of errors, choose replica</span><br><span class="line">              with minimum number of different symbols between replica&apos;s hostname and local hostname</span><br><span class="line">              (Hamming distance).</span><br><span class="line">             in_order - first live replica is chosen in specified order.</span><br><span class="line">             first_or_random - if first replica one has higher number of errors, pick a random one from replicas with minimum number of errors.</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;load_balancing&gt;random&lt;/load_balancing&gt;</span><br><span class="line">    &lt;/default&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Profile that allows only read queries. --&gt;</span><br><span class="line">    &lt;readonly&gt;</span><br><span class="line">        &lt;readonly&gt;1&lt;/readonly&gt;</span><br><span class="line">    &lt;/readonly&gt;</span><br><span class="line"></span><br><span class="line">    &lt;authority_r&gt;  </span><br><span class="line">        &lt;readonly&gt;1&lt;/readonly&gt;</span><br><span class="line">        &lt;allow_ddl&gt;0&lt;/allow_ddl&gt;</span><br><span class="line">    &lt;/authority_r&gt;</span><br><span class="line"></span><br><span class="line">    &lt;authority_rw&gt;</span><br><span class="line">        &lt;readonly&gt;2&lt;/readonly&gt;</span><br><span class="line">        &lt;allow_ddl&gt;0&lt;/allow_ddl&gt;</span><br><span class="line">    &lt;/authority_rw&gt;</span><br><span class="line"></span><br><span class="line">    &lt;authority_rwd&gt;</span><br><span class="line">        &lt;readonly&gt;0&lt;/readonly&gt;</span><br><span class="line">        &lt;allow_ddl&gt;1&lt;/allow_ddl&gt;</span><br><span class="line">    &lt;/authority_rwd&gt;      </span><br><span class="line"></span><br><span class="line">&lt;/profiles&gt;</span><br><span class="line">&lt;users&gt;</span><br><span class="line">      &lt;admin&gt;  ## clickhouse自带default用户，但是该用户拥有所有权限且没有设置登陆密码和开启RBAC</span><br><span class="line">        &lt;password&gt;123456&lt;/password&gt;                        ## 自定义密码</span><br><span class="line">        &lt;access_management&gt;1&lt;/access_management&gt;         ### 默认为0，修改成1 开启RBAC权限控制</span><br><span class="line">        &lt;networks incl=&quot;networks&quot; replace=&quot;replace&quot;&gt;</span><br><span class="line">                &lt;ip&gt;::/0&lt;/ip&gt;</span><br><span class="line">        &lt;/networks&gt;</span><br><span class="line">        &lt;profile&gt;default&lt;/profile&gt;                     ## 使用的用户配置。直接写名称default 认为已经引用了所有default的配置</span><br><span class="line">        &lt;quota&gt;default&lt;/quota&gt;                        ## 资源限额，引用default的全部设置</span><br><span class="line">      &lt;/admin&gt;</span><br><span class="line">&lt;/users&gt;   </span><br><span class="line">profiles下的对象是对权限的具体定义，users可继承profile中对象的属性这里创建的admin账号全部引用的default的配置 readonly 有三种状态 0不做限制 1可读（select，exists，show，describe） 2可读可设置（比1多了set） allow_ddl 有两种状态 0不允许ddl 1允许ddl</span><br></pre></td></tr></table></figure><p>#####删除clickhouse配置和文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yum list installed | grep clickhouse</span><br><span class="line"> </span><br><span class="line">yum remove -y clickhouse-common-static</span><br><span class="line"> </span><br><span class="line">yum remove -y clickhouse-server-common</span><br><span class="line"> </span><br><span class="line">rm -rf /var/lib/clickhouse</span><br><span class="line"> </span><br><span class="line">rm -rf /etc/clickhouse-*</span><br><span class="line"> </span><br><span class="line">rm -rf /var/log/clickhouse-server</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> clickhouse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spark-sql</title>
      <link href="/2021/02/24/spark-sql/"/>
      <url>/2021/02/24/spark-sql/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.rdd转换成dataframe ----&gt;rdd需要时列表或者元组构成的</span><br><span class="line">rdd1 = sc.parallelize([(<span class="string">'a'</span>,<span class="number">1</span>),(<span class="string">'b'</span>,<span class="number">2</span>)])</span><br><span class="line">df = spark.createDataFrame(rdd1)</span><br><span class="line">df.show()</span><br><span class="line">输出结果:</span><br><span class="line">+---+---+</span><br><span class="line">| _1| _2|</span><br><span class="line">+---+---+</span><br><span class="line">|  a|  <span class="number">1</span>|</span><br><span class="line">|  b|  <span class="number">2</span>|</span><br><span class="line">+---+---+</span><br><span class="line"></span><br><span class="line">df.first():</span><br><span class="line">Row(_1=<span class="string">'a'</span>, _2=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">df.printSchema() ===&gt;查看df的列字段类型同pandas的info</span><br><span class="line">root</span><br><span class="line"> |-- _1: string (nullable = true)</span><br><span class="line"> |-- _2: long (nullable = true)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rdd操作</title>
      <link href="/2021/02/23/Rdd%E6%93%8D%E4%BD%9C/"/>
      <url>/2021/02/23/Rdd%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>#####基本的RDD转换操作—————-&gt;将一个Rdd转换成宁一个Rdd</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">1.map()---&gt;最基本的转换操作========================&gt;对rdd的每一个元素做处理</span><br><span class="line">word = sc.parallelize([<span class="string">'a b'</span>,<span class="string">'c d'</span>])</span><br><span class="line">word.map(<span class="keyword">lambda</span> x:x.split(<span class="string">' '</span>)).collect()</span><br><span class="line">返回结果:</span><br><span class="line">[[<span class="string">'a'</span>, <span class="string">'b'</span>], [<span class="string">'c'</span>, <span class="string">'d'</span>]]</span><br><span class="line"></span><br><span class="line">2.flatMap()---&gt;先map然后flat平铺========&gt;注意M是大写的</span><br><span class="line">word = sc.parallelize([<span class="string">'a b'</span>,<span class="string">'c d'</span>])</span><br><span class="line">word.flatMap(<span class="keyword">lambda</span> x:x.split(<span class="string">' '</span>)).collect()</span><br><span class="line">返回结果:</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">3.filter()---&gt;过滤操作===============&gt;筛掉不符合条件的</span><br><span class="line">word = sc.parallelize([<span class="string">'a b'</span>,<span class="string">'c d'</span>])</span><br><span class="line">word.filter(<span class="keyword">lambda</span> x:len(x) == <span class="number">1</span>).collect()</span><br><span class="line">返回结果:</span><br><span class="line">[]</span><br><span class="line"></span><br><span class="line">4.distinct()----&gt;去重操作============&gt;去重rdd</span><br><span class="line">word = sc.parallelize([<span class="string">'a b'</span>,<span class="string">'c d'</span>,<span class="string">'a b'</span>])</span><br><span class="line">word.distinct().collect()</span><br><span class="line"></span><br><span class="line">5.groupBy()-----&gt;按照指定条件对RDD分组==============&gt;B大写,且一般不使用这种方法(要求键对应的值可以全部放入内存中)==========&gt;推荐更高效的aggregateByKey()和reduceByKey()等</span><br><span class="line">word = sc.parallelize([(<span class="string">'a'</span>,<span class="number">1</span>),(<span class="string">'a'</span>,<span class="number">2</span>),(<span class="string">'b'</span>,<span class="number">3</span>)])</span><br><span class="line">word.groupBy(<span class="keyword">lambda</span> x:x[<span class="number">0</span>]).collect()</span><br><span class="line">返回结果:</span><br><span class="line">[(<span class="string">'b'</span>, &lt;pyspark.resultiterable.ResultIterable object at <span class="number">0x7f7064cfa7b8</span>&gt;), (<span class="string">'a'</span>, &lt;pyspark.resultiterable.ResultIterable object at <span class="number">0x7f7064cfa1d0</span>&gt;)]</span><br><span class="line"></span><br><span class="line">6.sortBy()------&gt;按照指定键进行排序</span><br><span class="line">word = sc.parallelize([<span class="string">'a b'</span>,<span class="string">'c d'</span>,<span class="string">'a b'</span>,<span class="string">'a c'</span>]) </span><br><span class="line">word.sortBy(<span class="keyword">lambda</span> x:x[<span class="number">1</span>],ascending=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">7. cartesian------&gt;求两个rdd的笛卡尔乘积</span><br><span class="line">a.cartesian(a).collect()</span><br><span class="line"></span><br><span class="line">8. glom -----&gt;以列表的形式查看各个分区的数据</span><br><span class="line">a = sc.parallelize([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],<span class="number">2</span>)</span><br><span class="line">a.glom().collect()</span><br><span class="line"></span><br><span class="line">9.coalesce----&gt;降低rdd 的分区数(小于等于之前分区数)</span><br><span class="line">a.coalesce(<span class="number">1</span>).glom().collect()</span><br><span class="line"></span><br><span class="line"><span class="number">10.</span> cogroup ----将两个pairrdd 中相同键的值放在一起</span><br><span class="line">a = sc.parallelize([(<span class="string">"a"</span>,<span class="number">2</span>)])</span><br><span class="line">b = sc.parallelize([(<span class="string">"a"</span>,<span class="number">3</span>),(<span class="string">"b"</span>,<span class="number">2</span>)])</span><br><span class="line">[(x,tuple([list(i) <span class="keyword">for</span> i <span class="keyword">in</span> y])) <span class="keyword">for</span> x,y <span class="keyword">in</span> a.cogroup(b).collect()]</span><br><span class="line">输出:[(<span class="string">'b'</span>, ([], [<span class="number">2</span>])), (<span class="string">'a'</span>, ([<span class="number">2</span>], [<span class="number">3</span>]))]</span><br><span class="line"></span><br><span class="line"><span class="number">10.1</span> groupWith ------将多个pair rdd中相同的键的值放一起,效果同cogroup</span><br><span class="line">a = sc.parallelize([(<span class="string">"a"</span>,<span class="number">2</span>)])</span><br><span class="line">b = sc.parallelize([(<span class="string">"a"</span>,<span class="number">3</span>),(<span class="string">"b"</span>,<span class="number">2</span>)])</span><br><span class="line">c = sc.parallelize([(<span class="string">"a"</span>,<span class="number">3</span>),(<span class="string">"b"</span>,<span class="number">2</span>)])</span><br><span class="line">[(x,tuple([list(i) <span class="keyword">for</span> i <span class="keyword">in</span> y])) <span class="keyword">for</span> x,y <span class="keyword">in</span> a.groupWith(b,c).collect()]</span><br><span class="line">输出: [(<span class="string">'a'</span>, ([<span class="number">2</span>], [<span class="number">3</span>], [<span class="number">3</span>])), (<span class="string">'b'</span>, ([], [<span class="number">2</span>], [<span class="number">2</span>]))]</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">11. union ----&gt;合并两个rdd</span><br><span class="line">a = sc.parallelize([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">b = sc.parallelize([<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">a.union(b)</span><br><span class="line"></span><br><span class="line">12. countByValue() ----&gt;返回RDD值出现的次数,而非pairrdd的键值对应的值</span><br><span class="line">x = [(<span class="string">'a'</span>, <span class="number">2</span>), (<span class="string">'a'</span>, <span class="number">2</span>), (<span class="string">'b'</span>, <span class="number">1</span>)]</span><br><span class="line">x.countByValue()  输出:&#123;(<span class="string">'a'</span>, <span class="number">2</span>): <span class="number">2</span>, (<span class="string">'b'</span>, <span class="number">1</span>): <span class="number">1</span>&#125;</span><br><span class="line">    </span><br><span class="line">13. countByKey() -----&gt;针对pairrdd 按照key聚合===&gt;这个得是pairrdd</span><br><span class="line">x.countByKey()</span><br><span class="line"></span><br><span class="line">14. getNumPartitions -----&gt;获取rdd的分区个数,查看具体的分区可以使用glom</span><br><span class="line"></span><br><span class="line">15. groupby ------&gt;按照传入参数的[返回值]进行聚合</span><br><span class="line">a = sc.parallelize([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">a.groupBy(<span class="keyword">lambda</span> x:x%<span class="number">2</span> == <span class="number">0</span>).map(<span class="keyword">lambda</span> x:&#123;x[<span class="number">0</span>]:list(x[<span class="number">1</span>])&#125;).collect()</span><br><span class="line">[&#123;<span class="literal">False</span>: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]&#125;, &#123;<span class="literal">True</span>: [<span class="number">2</span>, <span class="number">4</span>]&#125;]</span><br><span class="line"></span><br><span class="line">16. groupByKey -----&gt;pair rdd 按照键进行聚合,值聚合成迭代器</span><br><span class="line">a = sc.parallelize([(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">4</span>)])</span><br><span class="line">a.groupByKey().mapValues(list).collect()</span><br><span class="line">输出:[(<span class="number">1</span>, [<span class="number">2</span>, <span class="number">4</span>]), (<span class="number">2</span>, [<span class="number">3</span>])]</span><br><span class="line">    </span><br><span class="line">17. mapValues ------&gt; 对pair rdd 的值操作</span><br><span class="line">a = sc.parallelize([(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">4</span>)])</span><br><span class="line">a.mapValues(<span class="keyword">lambda</span> x:x+<span class="number">2</span>).collect()</span><br><span class="line">输出：[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">1</span>, <span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line">18. intersection -----&gt;求两个rdd的交集</span><br><span class="line">a = sc.parallelize([(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">4</span>)])</span><br><span class="line">a.intersection(a).collect()</span><br><span class="line"></span><br><span class="line">19. isEmpty -----&gt;判断rdd 是否为空</span><br><span class="line">sc.parallelize([]).isEmpty() </span><br><span class="line"></span><br><span class="line">20. mapPartitions  -------&gt;对rdd 的每个分区做处理,返回各个分区的结果</span><br><span class="line">a = sc.parallelize([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],<span class="number">2</span>)</span><br><span class="line">a.mapPartitions(<span class="keyword">lambda</span> x:[len(list(x))]).collect()</span><br><span class="line">返回结果:[<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line"> </span><br><span class="line">21. zip -----&gt; 生成pair rdd,x和y的长度需要一致</span><br><span class="line">x.zip(y).collect()</span><br></pre></td></tr></table></figure><p>#####基本RDD的行动操作———&gt;进行求值或计算或输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">1.count() ------&gt;计数=======&gt;rdd中元素的个数</span><br><span class="line">word = sc.parallelize([(<span class="string">'a'</span>,<span class="number">1</span>),(<span class="string">'a'</span>,<span class="number">2</span>),(<span class="string">'b'</span>,<span class="number">3</span>)])</span><br><span class="line">word.count()</span><br><span class="line">返回结果:</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">2.collect() ------&gt;输出======&gt;返回rdd元素构成的列表</span><br><span class="line">word = sc.parallelize([(<span class="string">'a'</span>,<span class="number">1</span>),(<span class="string">'a'</span>,<span class="number">2</span>),(<span class="string">'b'</span>,<span class="number">3</span>)])</span><br><span class="line">word.collect()</span><br><span class="line">输出结果:</span><br><span class="line">[(<span class="string">'a'</span>,<span class="number">1</span>),(<span class="string">'a'</span>,<span class="number">2</span>),(<span class="string">'b'</span>,<span class="number">3</span>)]  </span><br><span class="line"></span><br><span class="line">3.take() -------&gt;输出=====&gt;返回RDD指定个数的元素,返回的元素不固定.选元素没特定的顺序</span><br><span class="line">word = sc.parallelize([(<span class="string">'a'</span>,<span class="number">1</span>),(<span class="string">'a'</span>,<span class="number">2</span>),(<span class="string">'b'</span>,<span class="number">3</span>)])</span><br><span class="line">word.take(<span class="number">1</span>)</span><br><span class="line">输出结果:</span><br><span class="line">[(<span class="string">'a'</span>,<span class="number">1</span>)] </span><br><span class="line"></span><br><span class="line">4.top() ------&gt;输出======&gt;返回降序排序好的前N个元素</span><br><span class="line">word = sc.parallelize([(<span class="string">'a'</span>,<span class="number">1</span>),(<span class="string">'a'</span>,<span class="number">2</span>),(<span class="string">'b'</span>,<span class="number">3</span>),(<span class="string">'b'</span>,<span class="number">1</span>)])</span><br><span class="line">word.top(<span class="number">1</span>)</span><br><span class="line">输出结果:</span><br><span class="line">(<span class="string">'b'</span>,<span class="number">3</span>) </span><br><span class="line"></span><br><span class="line">5.first() -----&gt;输出====&gt;同take一样返回结果不固定,不同的是take返回的是列表#无参数</span><br><span class="line">word = sc.parallelize([(<span class="string">'a'</span>,<span class="number">1</span>),(<span class="string">'a'</span>,<span class="number">2</span>),(<span class="string">'b'</span>,<span class="number">3</span>),(<span class="string">'b'</span>,<span class="number">1</span>)])</span><br><span class="line">word.first() <span class="comment">#无参数</span></span><br><span class="line">输出结果:</span><br><span class="line">(<span class="string">'a'</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    ===================用以聚合的行动操作reduce和fold====================</span><br><span class="line">6.reduce()------&gt;聚合========&gt;数据需要同一个类型,空的rdd会报错</span><br><span class="line">word = sc.parallelize([(<span class="string">'a'</span>,<span class="number">1</span>),(<span class="string">'a'</span>,<span class="number">2</span>),(<span class="string">'b'</span>,<span class="number">3</span>),(<span class="string">'b'</span>,<span class="number">1</span>)])</span><br><span class="line">word.reduce(<span class="keyword">lambda</span> x,y:x+y)</span><br><span class="line">输出结果</span><br><span class="line">(<span class="string">'a'</span>, <span class="number">1</span>, <span class="string">'a'</span>, <span class="number">2</span>, <span class="string">'b'</span>, <span class="number">3</span>, <span class="string">'b'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">7.fold()-------&gt;聚合======&gt;需要给定初始值,且空的rdd不会报错</span><br><span class="line">word = sc.parallelize([(<span class="string">'a'</span>,<span class="number">1</span>),(<span class="string">'a'</span>,<span class="number">2</span>),(<span class="string">'b'</span>,<span class="number">3</span>),(<span class="string">'b'</span>,<span class="number">1</span>)])</span><br><span class="line">word.fold((),<span class="keyword">lambda</span> x,y:x+y)  <span class="comment">#加法0,乘法1等</span></span><br><span class="line">输出结果:</span><br><span class="line">(<span class="string">'a'</span>, <span class="number">1</span>, <span class="string">'a'</span>, <span class="number">2</span>, <span class="string">'b'</span>, <span class="number">3</span>, <span class="string">'b'</span>, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">8.foreach()-----&gt;把函数应用到所有元素上======&gt;不允许对rdd进行操作</span><br><span class="line">word = sc.parallelize([(<span class="string">'a'</span>,<span class="number">1</span>),(<span class="string">'a'</span>,<span class="number">2</span>),(<span class="string">'b'</span>,<span class="number">3</span>),(<span class="string">'b'</span>,<span class="number">1</span>)])</span><br><span class="line">word.foreach(<span class="keyword">lambda</span> x:print(x))  <span class="comment">#加法0,乘法1等</span></span><br><span class="line">输出结果:</span><br><span class="line">(<span class="string">'a'</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'b'</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'b'</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="string">'a'</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">8.1</span> foreachPartition() 按照分区执行foreach</span><br><span class="line">a = sc.parallelize([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">9.aggregate() ------&gt;二次聚合,分成两步执行,第一次是分区执行,第二次是对上一步结果再聚合</span><br><span class="line">求均值(函数解释详见https://blog.csdn.net/qingyang0320/article/details/<span class="number">51603243</span>)</span><br><span class="line">nums = sc.parallelize([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">21</span>],<span class="number">2</span>)</span><br><span class="line">nums.aggregate((<span class="number">0</span>,<span class="number">0</span>),<span class="keyword">lambda</span> x,y:(x[<span class="number">0</span>]+y,x[<span class="number">1</span>]+<span class="number">1</span>),<span class="keyword">lambda</span> x,y:(x[<span class="number">0</span>]+y[<span class="number">0</span>],x[<span class="number">1</span>]+y[<span class="number">1</span>]))  得到(<span class="number">36</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">10. aggregateByKey()------&gt;也是进行二次聚合,第一次是分区计算(相同key的),第二次是对不同分区处理后的结果进行相同key聚合处理</span><br><span class="line">b = sc.parallelize([(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">1</span>,<span class="number">4</span>),(<span class="number">2</span>,<span class="number">7</span>),(<span class="number">3</span>,<span class="number">6</span>)],<span class="number">2</span>) 分成了两个区</span><br><span class="line">b.aggregateByKey(<span class="number">0</span>,<span class="keyword">lambda</span> x,y:max(x,y),<span class="keyword">lambda</span> x,y:x+y).collect()</span><br><span class="line">解释:各个分区相同key的先取出各个分区值的最大值,然后不同分区再把结果值相加</span><br><span class="line">得到结果:[(<span class="number">2</span>, <span class="number">10</span>), (<span class="number">1</span>, <span class="number">7</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure><h5 id="键值对Rdd的行动操作"><a href="#键值对Rdd的行动操作" class="headerlink" title="键值对Rdd的行动操作"></a>键值对Rdd的行动操作</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">1.keys()-----&gt;获取键</span><br><span class="line">per_info = sc.parallelize([(<span class="string">'city'</span>,<span class="string">'hefei'</span>),(<span class="string">'age'</span>,<span class="number">25</span>),(<span class="string">'name'</span>,<span class="string">'kuailiang'</span>)])</span><br><span class="line">per_info.keys().collect()</span><br><span class="line">输出结果:</span><br><span class="line">[<span class="string">'city'</span>, <span class="string">'age'</span>, <span class="string">'name'</span>]</span><br><span class="line">    </span><br><span class="line">2.values()-----&gt;获取值</span><br><span class="line">per_info = sc.parallelize([(<span class="string">'city'</span>,<span class="string">'hefei'</span>),(<span class="string">'age'</span>,<span class="number">25</span>),(<span class="string">'name'</span>,<span class="string">'kuailiang'</span>)])</span><br><span class="line">per_info.values().collect()</span><br><span class="line">输出结果:</span><br><span class="line">[<span class="string">'hefei'</span>, <span class="number">25</span>, <span class="string">'kuailiang'</span>]</span><br><span class="line"></span><br><span class="line">3.keyBy() -----&gt;构建pairRDD类型的数据=======&gt;指定元组中的指定索引数据作为键,原来的援助作为值构成新的pairRDD</span><br><span class="line">per_info = sc.parallelize([(<span class="string">'city'</span>,<span class="string">'hefei'</span>),(<span class="string">'age'</span>,<span class="number">25</span>),(<span class="string">'name'</span>,<span class="string">'kuailiang'</span>)])</span><br><span class="line">per_info.keyBy(<span class="keyword">lambda</span> x:x[<span class="number">0</span>]).collect()</span><br><span class="line">输出结果:</span><br><span class="line">[(<span class="string">'city'</span>, (<span class="string">'city'</span>, <span class="string">'hefei'</span>)), (<span class="string">'age'</span>, (<span class="string">'age'</span>, <span class="number">25</span>)), (<span class="string">'name'</span>, (<span class="string">'name'</span>, <span class="string">'kuailiang'</span>))]</span><br><span class="line"></span><br><span class="line">4.mapValues()----&gt;对pairRdd的值统一处理==========&gt;V大写,相当于普通rdd的map</span><br><span class="line">per_info = sc.parallelize([(<span class="string">'city'</span>,<span class="string">'hefei'</span>),(<span class="string">'age'</span>,<span class="number">25</span>),(<span class="string">'name'</span>,<span class="string">'kuailiang'</span>)])</span><br><span class="line">per_info.mapValues(<span class="keyword">lambda</span> x:str(x)+<span class="string">'1'</span>).collect()</span><br><span class="line">输出结果:</span><br><span class="line">[(<span class="string">'city'</span>, <span class="string">'hefei1'</span>), (<span class="string">'age'</span>, <span class="string">'251'</span>), (<span class="string">'name'</span>, <span class="string">'kuailiang1'</span>)]</span><br><span class="line"></span><br><span class="line">5.flatMapValues()----&gt;对pairRdd的值统一处理,并拍平======&gt;先把键对应的值拍开然后mapvalues==========&gt;就是先对k,v中的value使用函数处理,然后相同的键按照value拆开,value通常为列表</span><br><span class="line">y = sc.parallelize([(<span class="string">'a'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])])</span><br><span class="line">y.flatMapValues(<span class="keyword">lambda</span> x:[i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> x]).collect()</span><br><span class="line">输出结果:</span><br><span class="line">[(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'a'</span>, <span class="number">4</span>), (<span class="string">'a'</span>, <span class="number">9</span>)]</span><br><span class="line"></span><br><span class="line">6.groupByKey()-----&gt;按照键进行聚合=========&gt;聚合后返回的是一个迭代器===&gt;推荐使用reduceByKey和foldByKey</span><br><span class="line">per_info = sc.parallelize([(<span class="string">'city'</span>,<span class="string">'hefei'</span>),(<span class="string">'age'</span>,<span class="number">25</span>),(<span class="string">'name'</span>,<span class="string">'kuailiang'</span>),(<span class="string">'city'</span>,<span class="string">'beijing'</span>),(<span class="string">'age'</span>,<span class="number">28</span>)])</span><br><span class="line">per_info.groupByKey().mapValues(<span class="keyword">lambda</span> x:list(x)).collect()</span><br><span class="line">输出结果:</span><br><span class="line">[(<span class="string">'name'</span>, [<span class="string">'kuailiang'</span>]), (<span class="string">'age'</span>, [<span class="number">25</span>, <span class="number">28</span>]), (<span class="string">'city'</span>, [<span class="string">'hefei'</span>, <span class="string">'beijing'</span>])]</span><br><span class="line"></span><br><span class="line">7.reduceByKey()------&gt;按照键聚合===========&gt;和reduce一样是一个一个处理的</span><br><span class="line">per_info = sc.parallelize([(<span class="string">'city'</span>,<span class="string">'hefei'</span>),(<span class="string">'age'</span>,<span class="number">25</span>),(<span class="string">'name'</span>,<span class="string">'kuailiang'</span>),(<span class="string">'city'</span>,<span class="string">'beijing'</span>),(<span class="string">'age'</span>,<span class="number">28</span>)])</span><br><span class="line">per_info.reduceByKey(<span class="keyword">lambda</span> x,y:x + [y] <span class="keyword">if</span> type(x) == list <span class="keyword">else</span> [x,y]).collect()</span><br><span class="line">输出结果:</span><br><span class="line">[(<span class="string">'name'</span>, <span class="string">'kuailiang'</span>), (<span class="string">'age'</span>, [<span class="number">25</span>, <span class="number">28</span>, <span class="number">30</span>]), (<span class="string">'city'</span>, [<span class="string">'hefei'</span>, <span class="string">'beijing'</span>])]</span><br><span class="line"></span><br><span class="line">8.foldByKey()--------&gt;按照键聚合======&gt;需要给定初始值</span><br><span class="line">per_info = sc.parallelize([(<span class="string">'age'</span>,<span class="number">25</span>),(<span class="string">'name'</span>,<span class="number">11</span>),(<span class="string">'age'</span>,<span class="number">28</span>),(<span class="string">'name'</span>,<span class="number">22</span>)])</span><br><span class="line">per_info.foldByKey(<span class="number">0</span>,<span class="keyword">lambda</span> x,y:x+y).collect()</span><br><span class="line">输出结果:</span><br><span class="line">[(<span class="string">'name'</span>, <span class="number">33</span>), (<span class="string">'age'</span>, <span class="number">53</span>)]   </span><br><span class="line"> </span><br><span class="line">9.sortByKey()------&gt;按照键排序</span><br><span class="line">per_info = sc.parallelize([(<span class="string">'age'</span>,<span class="number">25</span>),(<span class="string">'name'</span>,<span class="number">11</span>),(<span class="string">'age'</span>,<span class="number">28</span>),(<span class="string">'name'</span>,<span class="number">22</span>)])</span><br><span class="line">per_info.sortByKey(<span class="number">0</span>,<span class="keyword">lambda</span> x,y:x+y).collect()</span><br><span class="line">输出结果:</span><br><span class="line">[(<span class="string">'age'</span>, <span class="number">25</span>), (<span class="string">'age'</span>, <span class="number">28</span>), (<span class="string">'name'</span>, <span class="number">11</span>), (<span class="string">'name'</span>, <span class="number">22</span>)]</span><br><span class="line"></span><br><span class="line">10.collectAsMap()------&gt;将pairrdd输出为字典</span><br><span class="line">m = sc.parallelize([(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>)]).collectAsMap() ,相同键value为最后一次出现的值</span><br><span class="line"></span><br><span class="line">11.reduceByKey()------&gt;按照key聚合处理,总共三个参数,第一参数表示当遍历到的键从未出现过的时候执行第一个函数,当出现过的时候执行第二个参数,第三个参数表示对相同键的不同分区的结果进行聚合</span><br><span class="line">x = sc.parallelize([(<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"b"</span>, <span class="number">1</span>), (<span class="string">"a"</span>, <span class="number">2</span>)],<span class="number">2</span>)</span><br><span class="line">x.combineByKey(<span class="keyword">lambda</span> x:[x],<span class="keyword">lambda</span> x,y:x.append(y),<span class="keyword">lambda</span> x,y:x+y).collect()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">12.</span> 对pair rdd的各种join操作</span><br><span class="line"></span><br><span class="line">①join:内连接,共有的键才会连接</span><br><span class="line">②leftOuterJoin</span><br><span class="line">③rightOuterJoin</span><br><span class="line">④fullOuterJoin</span><br><span class="line">⑤union: 合并两个rdd</span><br></pre></td></tr></table></figure><h5 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">1.min()------&gt;返回符合要求的最小值</span><br><span class="line">test1 = sc.parallelize([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">56</span>,<span class="number">123</span>,<span class="number">123</span>,<span class="number">23</span>,<span class="number">5</span>])</span><br><span class="line">test1.min(<span class="keyword">lambda</span> x:<span class="number">1</span>/x)</span><br><span class="line">输出结果:</span><br><span class="line"><span class="number">123</span></span><br><span class="line"></span><br><span class="line">2.max() ------&gt;返回最大值</span><br><span class="line">test1 = sc.parallelize([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">56</span>,<span class="number">123</span>,<span class="number">123</span>,<span class="number">23</span>,<span class="number">5</span>])</span><br><span class="line">test1.max(<span class="keyword">lambda</span> x:x//<span class="number">2</span>)</span><br><span class="line">输出结果:</span><br><span class="line"><span class="number">123</span></span><br><span class="line"></span><br><span class="line">3.mean()------&gt;返回均值</span><br><span class="line">test1 = sc.parallelize([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">56</span>,<span class="number">123</span>,<span class="number">123</span>,<span class="number">23</span>,<span class="number">5</span>])</span><br><span class="line">test1.mean()</span><br><span class="line">输出结果:</span><br><span class="line"><span class="number">42.125</span></span><br><span class="line"></span><br><span class="line">4.sum()---------&gt;求和</span><br><span class="line">test1 = sc.parallelize([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">56</span>,<span class="number">123</span>,<span class="number">123</span>,<span class="number">23</span>,<span class="number">5</span>])</span><br><span class="line">test1.sum()</span><br><span class="line">输出结果:</span><br><span class="line"><span class="number">337</span></span><br><span class="line"></span><br><span class="line">5.stdev()-------&gt;求标准差</span><br><span class="line">test1 = sc.parallelize([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">56</span>,<span class="number">123</span>,<span class="number">123</span>,<span class="number">23</span>,<span class="number">5</span>])</span><br><span class="line">test1.stdev()</span><br><span class="line">输出结果:</span><br><span class="line"><span class="number">49.71528311294224</span></span><br><span class="line"></span><br><span class="line">6.variance()----&gt;方差</span><br><span class="line">test1 = sc.parallelize([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">56</span>,<span class="number">123</span>,<span class="number">123</span>,<span class="number">23</span>,<span class="number">5</span>])</span><br><span class="line">test1.variance()</span><br><span class="line">输出结果:</span><br><span class="line"><span class="number">2471.609375</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7.stats()------&gt;所有的结构,如min,max,sum等等</span><br><span class="line">test1 = sc.parallelize([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">56</span>,<span class="number">123</span>,<span class="number">123</span>,<span class="number">23</span>,<span class="number">5</span>])</span><br><span class="line">test1.stats()</span><br><span class="line">输出结果:</span><br><span class="line">(count: <span class="number">8</span>, mean: <span class="number">42.125</span>, stdev: <span class="number">49.71528311294224</span>, max: <span class="number">123.0</span>, min: <span class="number">1.0</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyspark遇到的问题及解决</title>
      <link href="/2021/02/01/pyspark%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
      <url>/2021/02/01/pyspark%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>1.当写代码的时候会出现: java.lang.OutOfMemoryError: Java heap space</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解决方法:</span><br><span class="line">配置文件里的spark.driver.memory改大一点</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/Alien_lily/article/details/82018231" target="_blank" rel="noopener">https://blog.csdn.net/Alien_lily/article/details/82018231</a></p><p>2.Caused by: java.sql.SQLException: GC overhead limit exceeded</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">需要调大参数:</span><br><span class="line">export SPARK_EXECUTOR_MEMORY=6000M</span><br><span class="line">export SPARK_DRIVER_MEMORY=7000M</span><br></pre></td></tr></table></figure><p>3.apply无法使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">降低java的jdk版本,测试是jdk15和11都不行,只有8可以</span><br></pre></td></tr></table></figure><p>4.bigger than spark.driver.maxResultSize (1024.0 MiB)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5.驱动不起作用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyspark --jars /usr/hdp/3.0.1.0-187/spark2/jars/postgresql-42.2.5.jar</span><br></pre></td></tr></table></figure><p>6.java.lang.UnsupportedOperationException: sun.misc.Unsafe or java.nio.DirectByteBuffer.<init>(long, int) not avail</init></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pyspark --conf spark.driver.extraJavaOptions=&apos;-Dio.netty.tryReflectionSetAccessible=true&apos;</span><br><span class="line"></span><br><span class="line">次要:spark.executor.extraJavaOptions=&apos;-Dio.netty.tryReflectionSetAccessible=true&apos;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyspark_dataframe</title>
      <link href="/2021/01/27/pyspark-dataframe/"/>
      <url>/2021/01/27/pyspark-dataframe/</url>
      
        <content type="html"><![CDATA[<h5 id="生成dataframe"><a href="#生成dataframe" class="headerlink" title="生成dataframe"></a>生成dataframe</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pandas</span>和<span class="type">Spark</span>的<span class="type">DataFrame</span>两者互相转换：</span><br><span class="line">pandas_df = spark_df.toPandas()---&gt;也会将所有数据收集到驱动器,容易造成memory error</span><br><span class="line">spark_df = sqlContext.createDataFrame(pandas_df)</span><br><span class="line">与<span class="type">RDD</span>之间的相互转换</span><br><span class="line">rdd_df = df.rdd</span><br><span class="line">rdd_df.toDF()</span><br><span class="line"><span class="number">1.</span>rdd.toDF()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">####空<span class="type">DF</span></span><br><span class="line">schema = <span class="type">StructType</span>([</span><br><span class="line">                     <span class="type">StructField</span>(<span class="string">"列名1"</span>, <span class="type">StringType</span>(), <span class="type">True</span>),</span><br><span class="line">                     <span class="type">StructField</span>(<span class="string">"列名2"</span>, <span class="type">StringType</span>(), <span class="type">True</span>),</span><br><span class="line">                     <span class="type">StructField</span>(<span class="string">"列名3"</span>, <span class="type">StringType</span>(), <span class="type">True</span>),</span><br><span class="line">                     <span class="type">StructField</span>(<span class="string">"列名4"</span>, <span class="type">StringType</span>(), <span class="type">True</span>)</span><br><span class="line">                    ])</span><br><span class="line">df_new = spark.createDataFrame(spark.sparkContext.emptyRDD(),schema)</span><br><span class="line"></span><br><span class="line">df = spark.createDataFrame([(<span class="number">1</span>, <span class="number">1.0</span>), (<span class="number">1</span>, <span class="number">2.0</span>), (<span class="number">2</span>, <span class="number">3.0</span>), (<span class="number">2</span>, <span class="number">5.0</span>), (<span class="number">2</span>, <span class="number">10.0</span>)],(<span class="string">"id"</span>, <span class="string">"v"</span>))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.collect(),会将所有程序的数据收集到驱动上,如果数据集过大会出现memory error  --&gt;所以尽量少用,推荐take,tail</span><br></pre></td></tr></table></figure><h5 id="打印数据"><a href="#打印数据" class="headerlink" title="打印数据"></a>打印数据</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.show()  <span class="comment">#默认20行</span></span><br><span class="line">df.show(<span class="number">30</span>)</span><br></pre></td></tr></table></figure><h5 id="查看前几行"><a href="#查看前几行" class="headerlink" title="查看前几行"></a>查看前几行</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.head(<span class="number">3</span>)</span><br><span class="line">df.take(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h5 id="查看dataframe的总行数"><a href="#查看dataframe的总行数" class="headerlink" title="查看dataframe的总行数"></a>查看dataframe的总行数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.count()</span><br></pre></td></tr></table></figure><h5 id="查看列名"><a href="#查看列名" class="headerlink" title="查看列名"></a>查看列名</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.columns</span><br></pre></td></tr></table></figure><h5 id="重新设置列名"><a href="#重新设置列名" class="headerlink" title="重新设置列名"></a>重新设置列名</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.select(df.age.alias(<span class="string">'age_value'</span>),<span class="string">'name'</span>)</span><br><span class="line">df.withColumnRenamed(”原列名“,<span class="string">"新列名"</span>)</span><br></pre></td></tr></table></figure><h5 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.drop_duplicates([<span class="string">'app_text'</span>])</span><br><span class="line">df.select(<span class="string">'app_texts'</span>).distinct()</span><br></pre></td></tr></table></figure><h5 id="随机抽样"><a href="#随机抽样" class="headerlink" title="随机抽样"></a>随机抽样</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.sample(<span class="literal">False</span>,<span class="number">0.5</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h5 id="选取列"><a href="#选取列" class="headerlink" title="选取列"></a>选取列</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df.age</span><br><span class="line">df[<span class="string">'age'</span>]</span><br><span class="line">df.select(<span class="string">'age'</span>)</span><br><span class="line">df.select(df[<span class="string">'age'</span>])</span><br><span class="line">df.select(df.age,df.name)  <span class="comment">#选取多列</span></span><br></pre></td></tr></table></figure><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.orderBy(<span class="string">'group_name'</span>,ascending=<span class="literal">False</span>)  按指定字段升序</span><br><span class="line">df.sort(<span class="string">'age'</span>,ascending=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h5 id="按条件筛选"><a href="#按条件筛选" class="headerlink" title="按条件筛选"></a>按条件筛选</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> functions</span><br><span class="line">df.select(df.name,functions.when(df.age &gt; <span class="number">4</span>,<span class="number">1</span>).when(df.age&lt;<span class="number">3</span>,<span class="number">-1</span>).otherwise(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">df.select(df.name, df.age.between(<span class="number">2</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><h5 id="过滤数据-两者等价"><a href="#过滤数据-两者等价" class="headerlink" title="过滤数据=两者等价"></a>过滤数据=两者等价</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.filter(df.age&gt;<span class="number">21</span>)  </span><br><span class="line">df.where(df.age&gt;<span class="number">21</span>)</span><br></pre></td></tr></table></figure><h5 id="数据分割"><a href="#数据分割" class="headerlink" title="数据分割"></a>数据分割</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/intersting/article/details/<span class="number">84500978</span></span><br><span class="line">df = spark.createDataFrame([</span><br><span class="line">        (<span class="number">1</span>, <span class="number">144.5</span>,<span class="string">'5.9 2032'</span>, <span class="number">33</span>, <span class="string">'M'</span>),</span><br><span class="line">        (<span class="number">2</span>, <span class="number">167.2</span>, <span class="string">'5.4 2012'</span>, <span class="number">45</span>, <span class="string">'M'</span>),</span><br><span class="line">        (<span class="number">3</span>, <span class="number">124.1</span>, <span class="string">'5.2 2013'</span>, <span class="number">23</span>, <span class="string">'F'</span>),</span><br><span class="line">        (<span class="number">4</span>, <span class="number">144.5</span>, <span class="string">'5.9 2014'</span>, <span class="number">33</span>, <span class="string">'M'</span>),</span><br><span class="line">        (<span class="number">5</span>, <span class="number">133.2</span>, <span class="string">'5.7 2015'</span>, <span class="number">54</span>, <span class="string">'F'</span>),</span><br><span class="line">        (<span class="number">3</span>, <span class="number">124.1</span>, <span class="string">'5.2 2011'</span>, <span class="number">23</span>, <span class="string">'F'</span>),</span><br><span class="line">        (<span class="number">5</span>, <span class="number">129.2</span>, <span class="string">'5.3 2010'</span>, <span class="number">42</span>, <span class="string">'M'</span>),</span><br><span class="line">    ], [<span class="string">'id'</span>, <span class="string">'weight'</span>, <span class="string">'height'</span>, <span class="string">'age'</span>, <span class="string">'gender'</span>])</span><br><span class="line">df = df.withColumn("s", split(df['height'], " ")).show()===&gt;如果列已存在新数据会替换原来的列</span><br><span class="line">==========df.withColumn类似于形成一个新的列,但是参数必须是column...====</span><br></pre></td></tr></table></figure><h5 id="正则表达式匹配列名colRegex"><a href="#正则表达式匹配列名colRegex" class="headerlink" title="正则表达式匹配列名colRegex"></a>正则表达式匹配列名colRegex</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = spark.createDataFrame([(<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"b"</span>, <span class="number">2</span>), (<span class="string">"c"</span>,  <span class="number">3</span>)], [<span class="string">"Col1"</span>, <span class="string">"Col2"</span>])</span><br><span class="line">df.select(df.colRegex(<span class="string">"`(Col)?.+`"</span>)).show()</span><br></pre></td></tr></table></figure><h5 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.collect()</span><br><span class="line"><span class="comment">#返回列表形式的一个个Row对象</span></span><br></pre></td></tr></table></figure><h5 id="相关性"><a href="#相关性" class="headerlink" title="相关性"></a>相关性</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_as2.corr(<span class="string">'v1'</span>,<span class="string">'v2'</span>,method=<span class="string">'pearson'</span>)</span><br></pre></td></tr></table></figure><h5 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.cov(<span class="string">'a'</span>,<span class="string">'b'</span>)</span><br></pre></td></tr></table></figure><h5 id="列表中取出"><a href="#列表中取出" class="headerlink" title="列表中取出"></a>列表中取出</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/intersting/article/details/<span class="number">84500978</span></span><br><span class="line">df.s.getItem(0)====&gt;已知df某一列每个数据都是列表,每个列表取出第0个元素</span><br><span class="line">df.withColumn(<span class="string">"ss"</span>,df.s.getItem(<span class="number">0</span>))</span><br></pre></td></tr></table></figure><h5 id="一行分成多行-gt-类似于df的-split-stack"><a href="#一行分成多行-gt-类似于df的-split-stack" class="headerlink" title="一行分成多行===&gt;类似于df的.split().stack()"></a>一行分成多行===&gt;类似于df的.split().stack()</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/intersting/article/details/<span class="number">84500978</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> explode,split</span><br><span class="line">df_new.withColumn(<span class="string">"res"</span>,explode(split(df_new.height,<span class="string">' '</span>))).show()</span><br></pre></td></tr></table></figure><h5 id="保留位数"><a href="#保留位数" class="headerlink" title="保留位数"></a>保留位数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.sql.functions import bround</span><br><span class="line">bround(df_join.count1/df_join[&apos;count&apos;],4)</span><br></pre></td></tr></table></figure><h5 id="列数据合并"><a href="#列数据合并" class="headerlink" title="列数据合并"></a>列数据合并</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>不添加分隔符</span><br><span class="line">df_new.withColumn(<span class="string">'concat_res'</span>,cancat(df_new.gender,df_new.age))</span><br><span class="line"><span class="number">2.</span>添加分隔符</span><br><span class="line">df_new.withColumn(<span class="string">"concat_res"</span>,concat_ws(<span class="string">' '</span>,df_new.gender,df_new.age))</span><br></pre></td></tr></table></figure><h5 id="把一列的所有行合并"><a href="#把一列的所有行合并" class="headerlink" title="把一列的所有行合并"></a>把一列的所有行合并</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.sql.functions import collect_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">df = spark.createDataFrame([(&apos;abcd&apos;,&apos;123&apos;),(&apos;xyz&apos;,&apos;123&apos;)], [&apos;s&apos;, &apos;d&apos;])</span><br><span class="line">df.show()</span><br><span class="line">df.groupBy(&quot;d&quot;).agg(collect_list(&apos;s&apos;).alias(&apos;newcol&apos;)).show()</span><br></pre></td></tr></table></figure><h5 id="多行转多列"><a href="#多行转多列" class="headerlink" title="多行转多列"></a>多行转多列</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">df=spark.sparkContext.parallelize([[<span class="number">15</span>,<span class="number">399</span>,<span class="number">2</span>], \</span><br><span class="line">                                   [<span class="number">15</span>,<span class="number">1401</span>,<span class="number">5</span>], \</span><br><span class="line">                                   [<span class="number">15</span>,<span class="number">1608</span>,<span class="number">4</span>], \</span><br><span class="line">                                   [<span class="number">15</span>,<span class="number">20</span>,<span class="number">4</span>], \</span><br><span class="line">                                   [<span class="number">18</span>,<span class="number">100</span>,<span class="number">3</span>], \</span><br><span class="line">                                   [<span class="number">18</span>,<span class="number">1401</span>,<span class="number">3</span>], \</span><br><span class="line">                                   [<span class="number">18</span>,<span class="number">399</span>,<span class="number">1</span>]])\</span><br><span class="line">                    .toDF([<span class="string">"userID"</span>,<span class="string">"movieID"</span>,<span class="string">"rating"</span>])</span><br><span class="line">df.groupby(<span class="string">'userID'</span>).pivot(<span class="string">'movieID'</span>).sum(<span class="string">'rating'</span>).na.fill(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h5 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df.drop(&apos;age&apos;)</span><br><span class="line">df.drop(df.age)</span><br><span class="line">df = df.na.drop()  # 扔掉任何列包含na的行</span><br></pre></td></tr></table></figure><h5 id="列截取字符串"><a href="#列截取字符串" class="headerlink" title="列截取字符串"></a>列截取字符串</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.name.substr(1,2)</span><br></pre></td></tr></table></figure><p>#####创建column</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lit(2)</span><br><span class="line">df.withColumn(&apos;xx&apos;,lit(0))  ====&gt;创造一列全是0</span><br></pre></td></tr></table></figure><h5 id="列操作withColumn"><a href="#列操作withColumn" class="headerlink" title="列操作withColumn"></a>列操作withColumn</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.withColumn(<span class="string">'xx'</span>,df.xx.cast(<span class="string">"Int"</span>))  <span class="comment">#修改列的类型</span></span><br></pre></td></tr></table></figure><h5 id="合并两个df-join"><a href="#合并两个df-join" class="headerlink" title="合并两个df==join"></a>合并两个df==join</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_left.join(df_right,df_left.key = df_right.key,&quot;inner&quot;)  </span><br><span class="line">df.join(df4, [&apos;name&apos;, &apos;age&apos;]).select(df.name, df.age).collect()</span><br></pre></td></tr></table></figure><h5 id="DF上下拼接"><a href="#DF上下拼接" class="headerlink" title="DF上下拼接"></a>DF上下拼接</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df1.unionALL(df2) #不删除重复数据</span><br><span class="line">df1.union(df2)  #会删除重复数据</span><br></pre></td></tr></table></figure><h5 id="查看数据类型"><a href="#查看数据类型" class="headerlink" title="查看数据类型"></a>查看数据类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.dtypes</span><br></pre></td></tr></table></figure><h5 id="groupBy-groupby"><a href="#groupBy-groupby" class="headerlink" title="groupBy===groupby"></a>groupBy===groupby</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df.groupBy(&quot;userID&quot;).avg(&quot;movieID&quot;).show()</span><br><span class="line">#应用多个函数</span><br><span class="line">df.groupBy(&quot;userID&quot;).agg(functions.avg(&quot;movieID&quot;), functions.min(&quot;rating&quot;),).show()</span><br><span class="line"></span><br><span class="line">###apply函数</span><br><span class="line">apply和applyInPandas名字不同意义相同....用的是pyspark.sql.functions.pandas_udf()</span><br></pre></td></tr></table></figure><h5 id="查询空值"><a href="#查询空值" class="headerlink" title="查询空值"></a>查询空值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.sql.functions import isnull</span><br><span class="line">from pyspark.sql.functions import isnan</span><br><span class="line">df.filter(isnull(&quot;userID&quot;))   #筛选空值的行</span><br><span class="line">df.where(isnan(&quot;userID&quot;))   #筛选空值的行</span><br></pre></td></tr></table></figure><h5 id="转json内容"><a href="#转json内容" class="headerlink" title="转json内容"></a>转json内容</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sql_context = SQLContext(sc)</span><br><span class="line">sql_context.read.json(df.rdd.map(lambda r: r.json))</span><br></pre></td></tr></table></figure><h5 id="col"><a href="#col" class="headerlink" title="col"></a>col</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_as1.join(df_as2, col(&quot;df_as1.name&quot;) == col(&quot;df_as2.name&quot;), &apos;inner&apos;)</span><br></pre></td></tr></table></figure><h5 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.json.contains(<span class="string">'a'</span>)</span><br></pre></td></tr></table></figure><h5 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.filter(df.gender.like(&apos;%M&apos;)).show()----&gt;sql的模糊匹配</span><br></pre></td></tr></table></figure><h5 id="以什么-开始-以什么-结束"><a href="#以什么-开始-以什么-结束" class="headerlink" title="以什么..开始,以什么..结束"></a>以什么..开始,以什么..结束</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.filter(df.gender.startswith(<span class="string">'M'</span>))</span><br><span class="line">df.filter(df.gender.endswith(<span class="string">'M'</span>))</span><br></pre></td></tr></table></figure><h5 id="条件筛选"><a href="#条件筛选" class="headerlink" title="条件筛选"></a>条件筛选</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> functions <span class="keyword">as</span> F</span><br><span class="line">df.select(df.id, F.when(df.age &gt; <span class="number">34</span>, <span class="number">1</span>).when(df.age &lt; <span class="number">34</span>, <span class="number">-1</span>).otherwise(<span class="number">0</span>)).show()</span><br></pre></td></tr></table></figure><h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.replace(<span class="number">1</span>,<span class="number">2</span>).show()</span><br><span class="line">df.na.replace(<span class="number">22</span>).show()</span><br></pre></td></tr></table></figure><h5 id="Row"><a href="#Row" class="headerlink" title="Row"></a>Row</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">====使用方法====</span><br><span class="line">Row(name=&quot;Alice&quot;, age=11) ====&gt;理解生成一行数据,字段分别为name和age,数据为..</span><br></pre></td></tr></table></figure><h5 id="pandas-udf"><a href="#pandas-udf" class="headerlink" title="pandas_udf"></a>pandas_udf</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">摘自:</span><br><span class="line">https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.sql.functions.pandas_udf.html<span class="comment">#pyspark.sql.functions.pandas_udf</span></span><br><span class="line"><span class="comment">#######################################案例1###################################################</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> pandas_udf</span><br><span class="line"><span class="meta">@pandas_udf('long')  #返回结果的数据类型,多参数也可("col1 string, col2 long")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_add</span><span class="params">(a:pd.Series)</span>-&gt;pd.Series:</span></span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">1</span></span><br><span class="line">df.withColumn(<span class="string">"one_processed"</span>, get_add(df[<span class="string">"a"</span>])).show()</span><br><span class="line"><span class="comment">#######################################案例2####################################################</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> pandas_udf</span><br><span class="line"><span class="meta">@pandas_udf("col1 string, col2 long") #返回的列类型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(s1: pd.Series, s2: pd.Series, s3: pd.DataFrame)</span> -&gt; pd.DataFrame:</span> <span class="comment">#传参类型和返回结果类型</span></span><br><span class="line">    s3[<span class="string">'col2'</span>] = s1 + s2.str.len()         <span class="comment">#针对结果是结构体,使用pd.DataFrame</span></span><br><span class="line">    <span class="keyword">return</span> s3</span><br><span class="line">df = spark.createDataFrame(</span><br><span class="line">    [[<span class="number">1</span>, <span class="string">"a string"</span>, (<span class="string">"a nested string"</span>,)]],</span><br><span class="line">    <span class="string">"long_col long, string_col string, struct_col struct&lt;col1:string&gt;"</span>)</span><br><span class="line">df.printSchema()</span><br><span class="line">df.select(func(<span class="string">"long_col"</span>, <span class="string">"string_col"</span>, <span class="string">"struct_col"</span>)).printSchema()</span><br><span class="line"><span class="comment">#######################################案例3####################################################</span></span><br><span class="line"><span class="meta">@pandas_udf("string")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_upper</span><span class="params">(s: pd.Series)</span> -&gt; pd.Series:</span></span><br><span class="line">    <span class="keyword">return</span> s.str.upper()</span><br><span class="line"></span><br><span class="line">df = spark.createDataFrame([(<span class="string">"John Doe"</span>,)], (<span class="string">"name"</span>,))</span><br><span class="line">df.select(to_upper(<span class="string">"name"</span>)).show()</span><br><span class="line"><span class="comment">#######################################案例4####################################################</span></span><br><span class="line"><span class="meta">@pandas_udf("first string, last string")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_expand</span><span class="params">(s: pd.Series)</span> -&gt; pd.DataFrame:</span></span><br><span class="line">    <span class="keyword">return</span> s.str.split(expand=<span class="literal">True</span>)</span><br><span class="line">df = spark.createDataFrame([(<span class="string">"John Doe"</span>,)], (<span class="string">"name"</span>,))</span><br><span class="line">df.select(split_expand(<span class="string">"name"</span>)).show()</span><br><span class="line"><span class="comment">#######################################案例5####################################################</span></span><br><span class="line"><span class="meta">@pandas_udf("long")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(iterator: Iterator[pd.Series])</span> -&gt; Iterator[pd.Series]:</span></span><br><span class="line">    <span class="comment"># Do some expensive initialization with a state</span></span><br><span class="line">    state = very_expensive_initialization()</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> iterator:</span><br><span class="line">        <span class="keyword">yield</span> calculate_with_state(x, state)</span><br><span class="line">df.select(calculate(<span class="string">"value"</span>)).show()</span><br><span class="line"><span class="comment">#######################################案例6####################################################</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Iterator</span><br><span class="line"><span class="meta">@pandas_udf("long")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plus_one</span><span class="params">(iterator: Iterator[pd.Series])</span> -&gt; Iterator[pd.Series]:</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> iterator:</span><br><span class="line">        <span class="keyword">yield</span> s + <span class="number">1</span></span><br><span class="line">df = spark.createDataFrame(pd.DataFrame([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], columns=[<span class="string">"v"</span>]))</span><br><span class="line">df.select(plus_one(df.v)).show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################案例7####################################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Iterator, Tuple</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> struct, col</span><br><span class="line"><span class="meta">@pandas_udf("long")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(iterator: Iterator[Tuple[pd.Series, pd.DataFrame]])</span> -&gt; Iterator[pd.Series]:</span></span><br><span class="line">    <span class="keyword">for</span> s1, df <span class="keyword">in</span> iterator:</span><br><span class="line">        <span class="keyword">yield</span> s1 * df.v</span><br><span class="line"></span><br><span class="line">df = spark.createDataFrame(pd.DataFrame([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], columns=[<span class="string">"v"</span>]))</span><br><span class="line">df.withColumn(<span class="string">'output'</span>, multiply(col(<span class="string">"v"</span>), struct(col(<span class="string">"v"</span>)))).show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################案例8####################################################</span></span><br><span class="line"><span class="meta">@pandas_udf("double")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mean_udf</span><span class="params">(v: pd.Series)</span> -&gt; float:</span></span><br><span class="line">    <span class="keyword">return</span> v.mean()</span><br><span class="line"></span><br><span class="line">df = spark.createDataFrame(</span><br><span class="line">    [(<span class="number">1</span>, <span class="number">1.0</span>), (<span class="number">1</span>, <span class="number">2.0</span>), (<span class="number">2</span>, <span class="number">3.0</span>), (<span class="number">2</span>, <span class="number">5.0</span>), (<span class="number">2</span>, <span class="number">10.0</span>)], (<span class="string">"id"</span>, <span class="string">"v"</span>))</span><br><span class="line">df.groupby(<span class="string">"id"</span>).agg(mean_udf(df[<span class="string">'v'</span>])).show()</span><br></pre></td></tr></table></figure><h5 id="mapInPandas"><a href="#mapInPandas" class="headerlink" title="mapInPandas"></a>mapInPandas</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############################################案例1#######################################</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pandas_filter_func</span><span class="params">(iterator)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> pandas_df <span class="keyword">in</span> iterator:</span><br><span class="line">        <span class="keyword">yield</span> pandas_df[pandas_df.a == <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">df.mapInPandas(pandas_filter_func, schema=df.schema).show()</span><br><span class="line"></span><br><span class="line"><span class="comment">############################################案例2#######################################</span></span><br><span class="line">df = spark.createDataFrame([</span><br><span class="line">    [<span class="string">'red'</span>, <span class="string">'banana'</span>, <span class="number">1</span>, <span class="number">10</span>], [<span class="string">'blue'</span>, <span class="string">'banana'</span>, <span class="number">2</span>, <span class="number">20</span>], [<span class="string">'red'</span>, <span class="string">'carrot'</span>, <span class="number">3</span>, <span class="number">30</span>],</span><br><span class="line">    [<span class="string">'blue'</span>, <span class="string">'grape'</span>, <span class="number">4</span>, <span class="number">40</span>], [<span class="string">'red'</span>, <span class="string">'carrot'</span>, <span class="number">5</span>, <span class="number">50</span>], [<span class="string">'black'</span>, <span class="string">'carrot'</span>, <span class="number">6</span>, <span class="number">60</span>],</span><br><span class="line">    [<span class="string">'red'</span>, <span class="string">'banana'</span>, <span class="number">7</span>, <span class="number">70</span>], [<span class="string">'red'</span>, <span class="string">'grape'</span>, <span class="number">8</span>, <span class="number">80</span>]], schema=[<span class="string">'color'</span>, <span class="string">'fruit'</span>, <span class="string">'v1'</span>, <span class="string">'v2'</span>])</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plus_mean</span><span class="params">(pandas_df)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> pandas_df.assign(v1=pandas_df.v1 - pandas_df.v1.mean())</span><br><span class="line"></span><br><span class="line">df.groupby(<span class="string">'color'</span>).applyInPandas(plus_mean, schema=df.schema).show()</span><br><span class="line"></span><br><span class="line"><span class="comment">############################################案例3#######################################</span></span><br><span class="line"></span><br><span class="line">df1 = spark.createDataFrame(</span><br><span class="line">    [(<span class="number">20000101</span>, <span class="number">1</span>, <span class="number">1.0</span>), (<span class="number">20000101</span>, <span class="number">2</span>, <span class="number">2.0</span>), (<span class="number">20000102</span>, <span class="number">1</span>, <span class="number">3.0</span>), (<span class="number">20000102</span>, <span class="number">2</span>, <span class="number">4.0</span>)],</span><br><span class="line">    (<span class="string">'time'</span>, <span class="string">'id'</span>, <span class="string">'v1'</span>))</span><br><span class="line"></span><br><span class="line">df2 = spark.createDataFrame(</span><br><span class="line">    [(<span class="number">20000101</span>, <span class="number">1</span>, <span class="string">'x'</span>), (<span class="number">20000101</span>, <span class="number">2</span>, <span class="string">'y'</span>)],</span><br><span class="line">    (<span class="string">'time'</span>, <span class="string">'id'</span>, <span class="string">'v2'</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asof_join</span><span class="params">(l, r)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> pd.merge_asof(l, r, on=<span class="string">'time'</span>, by=<span class="string">'id'</span>)</span><br><span class="line"></span><br><span class="line">df1.groupby(<span class="string">'id'</span>).cogroup(df2.groupby(<span class="string">'id'</span>)).applyInPandas(</span><br><span class="line">    asof_join, schema=<span class="string">'time int, id int, v1 double, v2 string'</span>).show()</span><br></pre></td></tr></table></figure><h5 id="UDF"><a href="#UDF" class="headerlink" title="UDF"></a>UDF</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> DoubleType</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> udf</span><br><span class="line">df = spark.createDataFrame([(<span class="number">1</span>, <span class="number">1.0</span>), (<span class="number">1</span>, <span class="number">2.0</span>), (<span class="number">2</span>, <span class="number">3.0</span>), (<span class="number">2</span>, <span class="number">5.0</span>), (<span class="number">2</span>, <span class="number">10.0</span>)],(<span class="string">"id"</span>, <span class="string">"v"</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalize</span><span class="params">(v)</span>:</span></span><br><span class="line"><span class="keyword">return</span> v+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">plus_one_udf = udf(normalize, returnType=DoubleType())</span><br><span class="line">df.withColumn(<span class="string">"one_processed"</span>, plus_one_udf(df[<span class="string">"v"</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">#######</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">################</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> functions <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> types <span class="keyword">as</span> T</span><br><span class="line"></span><br><span class="line">a = sc.parallelize([[<span class="number">1</span>, <span class="string">'a'</span>],</span><br><span class="line">                    [<span class="number">1</span>, <span class="string">'b'</span>],</span><br><span class="line">                    [<span class="number">1</span>, <span class="string">'b'</span>],</span><br><span class="line">                    [<span class="number">2</span>, <span class="string">'c'</span>]]).toDF([<span class="string">'id'</span>, <span class="string">'value'</span>])</span><br><span class="line">a.groupBy(<span class="string">'id'</span>).agg(F.collect_list(<span class="string">'value'</span>).alias(<span class="string">'value_list'</span>)).show()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_a</span><span class="params">(x)</span>:</span></span><br><span class="line">  <span class="string">"""Count 'a's in list."""</span></span><br><span class="line">  output_count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="string">'a'</span>:</span><br><span class="line">      output_count += <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> output_count</span><br><span class="line"></span><br><span class="line">find_a_udf = F.udf(find_a, T.IntegerType())</span><br><span class="line"></span><br><span class="line">a.groupBy(<span class="string">'id'</span>).agg(find_a_udf(F.collect_list(<span class="string">'value'</span>)).alias(<span class="string">'a_count'</span>)).show()</span><br><span class="line"></span><br><span class="line"><span class="comment">##################</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> functions <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> types <span class="keyword">as</span> T</span><br><span class="line"></span><br><span class="line">a = sc.parallelize([[<span class="number">1</span>, <span class="number">1</span>, <span class="string">'a'</span>],</span><br><span class="line">                    [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'a'</span>],</span><br><span class="line">                    [<span class="number">1</span>, <span class="number">1</span>, <span class="string">'b'</span>],</span><br><span class="line">                    [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'b'</span>],</span><br><span class="line">                    [<span class="number">2</span>, <span class="number">1</span>, <span class="string">'c'</span>]]).toDF([<span class="string">'id'</span>, <span class="string">'value1'</span>, <span class="string">'value2'</span>])</span><br><span class="line"></span><br><span class="line">a.groupBy(<span class="string">'id'</span>).agg(find_a_udf( F.collect_list(F.when(F.col(<span class="string">'value1'</span>) == <span class="number">1</span>, F.col(<span class="string">'value2'</span>)))).alias(<span class="string">'a_count'</span>)).show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#################################</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_func</span><span class="params">(key, pdf)</span>:</span></span><br><span class="line">    <span class="comment"># key is a tuple of two numpy.int64s, which is the values</span></span><br><span class="line">    <span class="comment"># of 'id' and 'ceil(df.v / 2)' for the current group</span></span><br><span class="line">    <span class="keyword">return</span> pd.DataFrame([key + (pdf.v.sum(),)])</span><br><span class="line">df.groupby(df.id, F.ceil(df.v / <span class="number">2</span>)).applyInPandas(</span><br><span class="line">    sum_func, schema=<span class="string">"id long, `ceil(v / 2)` long, v double"</span>).show()</span><br><span class="line"></span><br><span class="line"><span class="comment">################################</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> pandas_udf, PandasUDFType</span><br><span class="line">df = spark.createDataFrame(</span><br><span class="line">    [(<span class="number">1</span>, <span class="number">1.0</span>), (<span class="number">1</span>, <span class="number">2.0</span>), (<span class="number">2</span>, <span class="number">3.0</span>), (<span class="number">2</span>, <span class="number">5.0</span>), (<span class="number">2</span>, <span class="number">10.0</span>)],</span><br><span class="line">    (<span class="string">"id"</span>, <span class="string">"v"</span>))</span><br><span class="line"><span class="meta">@pandas_udf("id long, v double", PandasUDFType.GROUPED_MAP)  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalize</span><span class="params">(pdf)</span>:</span></span><br><span class="line">    v = pdf.v</span><br><span class="line">    <span class="keyword">return</span> pdf.assign(v=(v - v.mean()) / v.std())</span><br><span class="line">df.groupby(<span class="string">"id"</span>).apply(normalize).show() </span><br><span class="line"></span><br><span class="line"><span class="comment">################</span></span><br><span class="line"><span class="meta">@pandas_udf('group string,year int,app_texts string , app_num int ,high_apps string ,high_num int', PandasUDFType.GROUPED_MAP)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deal_func</span><span class="params">(df)</span>:</span></span><br><span class="line">    ls = []</span><br><span class="line">    year_early = min(df[<span class="string">'app_date'</span>])</span><br><span class="line">    gp = df[<span class="string">'group'</span>].values[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> year <span class="keyword">in</span> range(int(year_early), <span class="number">2022</span>):</span><br><span class="line">        res_year = df[(df.app_date &lt;= year) &amp; (df.ceased_date &gt;= year)]</span><br><span class="line">        <span class="comment"># 该年有效核心专利</span></span><br><span class="line">        high_value_year = res_year[res_year.xingji &gt;= <span class="number">4</span>][<span class="string">'app_text'</span>].unique()</span><br><span class="line">        ls.append([gp, year,str(list(res_year[<span class="string">'app_text'</span>].unique())), len(res_year[<span class="string">'app_text'</span>].unique()), str(list(high_value_year)), len(high_value_year)])</span><br><span class="line">    <span class="keyword">return</span>  pd.DataFrame(ls)</span><br><span class="line"></span><br><span class="line">df_sql_res2.groupby(<span class="string">'group'</span>).apply(deal_func).show()</span><br></pre></td></tr></table></figure><p>#####spark与pandas的dataframe对比,列举</p><table><thead><tr><th></th><th>Pandas</th><th>Spark</th></tr></thead><tbody><tr><td>行结构</td><td>Series结构</td><td>Row结构，属于Spark DataFrame结构</td></tr><tr><td>列结构</td><td>Series结构</td><td>Column结构</td></tr><tr><td>列名称</td><td>不允许重名</td><td>允许重名修改列名,采用alias方法</td></tr><tr><td>列添加</td><td>df[“xx”] = 0</td><td>df.withColumn(“xx”, functions.lit(0)).show()</td></tr><tr><td>排序</td><td>df.sort()</td><td>df.sort()</td></tr><tr><td></td><td>df.head(2)</td><td>df.head(2)或者df.take(2)</td></tr><tr><td></td><td>df.tail(2)</td><td></td></tr><tr><td>过滤</td><td>df[df[‘age’]&gt;21]</td><td>df.filter(df[‘age’]&gt;21) 或者 df.where(df[‘age’]&gt;21)</td></tr><tr><td></td><td>df.groupby(“age”) df.groupby(“A”).avg(“B”)</td><td>df.groupBy(“age”) df.groupBy(“A”).avg(“B”).show() df.groupBy(“A”).agg(functions.avg(“B”), functions.min(“B”), functions.max(“B”)).show()</td></tr><tr><td></td><td>df.count() 输出每一列的非空行数</td><td>df.count() 输出总行数</td></tr><tr><td></td><td>df.describe() 描述某些列的count, mean, std, min, 25%, 50%, 75%, max</td><td>df.describe() 描述某些列的count, mean, stddev, min, max</td></tr><tr><td>合并</td><td>concat</td><td></td></tr><tr><td>合并</td><td>merge</td><td></td></tr><tr><td>合并</td><td>join</td><td>df.join()</td></tr><tr><td>合并</td><td>append</td><td></td></tr><tr><td>fillna</td><td>df.fillna()</td><td>df.na.fill()</td></tr><tr><td>dropna</td><td>df.dropna()</td><td>df.na.drop()</td></tr><tr><td>两者互相转换</td><td>pandas_df = spark_df.toPandas()</td><td>spark_df = sqlContext.createDataFrame(pandas_df)</td></tr><tr><td>函数应用</td><td>df.apply(f）</td><td>df.foreach(f) 或者 df.rdd.foreach(f) 将df的每一列应用函数fdf.foreachPartition(f) 或者 df.rdd.foreachPartition(f) 将df的每一块应用函数f</td></tr></tbody></table><p>#####某一列去重返回列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.sql import Functions as F</span><br><span class="line">df.select(F.collect_set(&apos;applicant_name&apos;).alias(&apos;applicant&apos;))).first()[&apos;applicant&apos;]</span><br></pre></td></tr></table></figure><h5 id="按行转成字典"><a href="#按行转成字典" class="headerlink" title="按行转成字典"></a>按行转成字典</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_select4.rdd.map(lambda row: row.asDict(True)====&gt;跟pandas的to_dict(orient=&apos;records&apos;)一致</span><br></pre></td></tr></table></figure><h4 id="列总结"><a href="#列总结" class="headerlink" title="列总结"></a>列总结</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">df.name.startswith(&apos;Al&apos;)</span><br><span class="line">df.name.substr(1, 3)</span><br><span class="line">df.name.rlike(&apos;ice$&apos;)</span><br><span class="line">df.name.like(&apos;Al%&apos;)</span><br><span class="line">df.age.isin([1, 2, 3])</span><br><span class="line">df.height.isNull()</span><br><span class="line">df.height.isNotNull()</span><br><span class="line">df.d.getItem(&quot;key&quot;)</span><br><span class="line">df.r.getField(&quot;b&quot;)</span><br><span class="line">df.name.endswith(&apos;ice$&apos;)</span><br><span class="line">df.name.desc()</span><br><span class="line">df.name.contains(&apos;o&apos;)</span><br><span class="line">df.age.cast(&quot;string&quot;).alias(&apos;ages&apos;)</span><br><span class="line">df.age.between(2, 4)</span><br><span class="line">df.name.asc()=====&gt;df.select(df.name).orderBy(df.name.asc()).collect()</span><br><span class="line">df4.na.fill(50)</span><br><span class="line">df4.na.fill(&#123;&apos;age&apos;: 50, &apos;name&apos;: &apos;unknown&apos;&#125;).show()</span><br><span class="line">df4.na.replace(10, 20)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200801123103696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NjE1MTEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="二次学习"><a href="#二次学习" class="headerlink" title="二次学习"></a>二次学习</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">agg -----&gt;聚合操作</span><br><span class="line">df.groupby(<span class="string">'a'</span>).agg(&#123;<span class="string">"b"</span>:<span class="string">"min"</span>&#125;)</span><br><span class="line"></span><br><span class="line">alias -------&gt;表别名,实际指向的同一块数据</span><br><span class="line">df2 = df.alias(<span class="string">'df2'</span>) 效果等价于 df2 = df</span><br><span class="line"></span><br><span class="line">cache------&gt;df放到内存里,效果等价于persist</span><br><span class="line">df.cache()</span><br><span class="line"></span><br><span class="line">coalesce ------&gt;降低分区,效果等价于rdd 的 coalesce</span><br><span class="line">df.coalesce(<span class="number">1</span>).rdd.getNumPartitions()</span><br><span class="line"></span><br><span class="line">colRegex --------&gt;写正则匹配符合条件的列数据</span><br><span class="line">df.select(df.colRegex(<span class="string">"`(Col1)?+.+`"</span>)).show()</span><br><span class="line"></span><br><span class="line">collect--------&gt;以列表形式返回所有的数据</span><br><span class="line">df.collect()</span><br><span class="line"></span><br><span class="line">corr() -----&gt;查看两列的相关性,只支持皮尔逊相关性,新版本才有该函数</span><br><span class="line">df.corr()</span><br><span class="line"></span><br><span class="line"><span class="comment">##创建视图表</span></span><br><span class="line">createGlobalTempView() //创建全局视图,重名会报错</span><br><span class="line">createOrReplaceGlobalTempView() //创建全局视图,重名会替换</span><br><span class="line">createReplaceTempView() //创建本地视图表,重名会替换</span><br><span class="line">createTempView()  //创建本地视图表,重名会报错</span><br><span class="line"></span><br><span class="line">distinct -----&gt;dataframe整体去重</span><br><span class="line"></span><br><span class="line">drop_duplicates(等价于dropduplicates,别名)------&gt;按照指定的列去重</span><br><span class="line"></span><br><span class="line">mapInPandas</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pyspark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/01/25/clickhouse/"/>
      <url>/2021/01/25/clickhouse/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> clickhouse_driver <span class="keyword">import</span> Client</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">client = Client(host=<span class="string">'192.168.0.246'</span>,port=<span class="string">'9000'</span>,user=<span class="string">'user_r'</span>, password=<span class="string">'1q2w3e4r'</span>, database=<span class="string">'default'</span>)</span><br><span class="line">sql = <span class="string">"select * from test02"</span></span><br><span class="line">df = client.execute(sql,columnar=<span class="literal">True</span>, with_column_types=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>#####账号和密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">192.168.0.246</span><br><span class="line">root</span><br><span class="line">密码abc.com123</span><br><span class="line">popo</span><br><span class="line">密码popo.com123</span><br><span class="line"></span><br><span class="line">clickhouse</span><br><span class="line">ip:192.168.0.246</span><br><span class="line">tcp端口8123</span><br><span class="line">http端口9000</span><br><span class="line"></span><br><span class="line">超管账号：default</span><br><span class="line">密码：123456</span><br><span class="line"></span><br><span class="line">读：user_r</span><br><span class="line">密码：1q2w3e4r</span><br><span class="line"></span><br><span class="line">读写：user_rw</span><br><span class="line">密码：1a2s3d4f</span><br><span class="line"></span><br><span class="line">读写删：user_rwd</span><br><span class="line">密码：1z2x3c4v</span><br></pre></td></tr></table></figure></p><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_clickhouse</span><span class="params">(data,tb_name)</span>:</span></span><br><span class="line">    client = Client(host=<span class="string">'192.168.0.246'</span>,port=<span class="string">'9000'</span>,user=<span class="string">'user_rwd'</span>, password=<span class="string">'1z2x3c4v'</span>, database=<span class="string">'default'</span>)</span><br><span class="line">    cols = <span class="string">','</span>.join(data.columns)</span><br><span class="line">    data_tup = tuple(map(tuple, data.values))</span><br><span class="line">    client.execute(<span class="string">f"DROP TABLE IF EXISTS %s;"</span>%(tb_name))</span><br><span class="line">    <span class="keyword">if</span> data.shape[<span class="number">1</span>]==<span class="number">2</span>:</span><br><span class="line">        client.execute(<span class="string">f"CREATE TABLE %s ( %s String, num UInt16, create_date Date DEFAULT toDate(now()) ) ENGINE = MergeTree(create_date,(%s), 8192);"</span>%(tb_name,data.columns[<span class="number">0</span>], data.columns[<span class="number">0</span>]) )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        client.execute(<span class="string">f"CREATE TABLE %s ( %s String, num UInt16, label UInt16, create_date Date DEFAULT toDate(now()) ) ENGINE = MergeTree(create_date,(%s), 8192);"</span>%(tb_name,data.columns[<span class="number">0</span>], data.columns[<span class="number">0</span>]) )</span><br><span class="line">    client.execute(<span class="string">f"INSERT INTO <span class="subst">&#123;tb_name&#125;</span> (<span class="subst">&#123;cols&#125;</span>) VALUES"</span>, data_tup, types_check=<span class="literal">True</span>)</span><br><span class="line">    client.disconnect()</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t1 = datetime.now()</span><br><span class="line">sql = <span class="string">'select applicant_name from company_20210208'</span></span><br><span class="line">client = Client(host=<span class="string">'192.168.0.246'</span>, port=<span class="string">'9000'</span>, user=<span class="string">'user_rwd'</span>, password=<span class="string">'1z2x3c4v'</span>, database=<span class="string">'pre_formal_1'</span>)</span><br><span class="line">df = client.execute(sql)</span><br><span class="line">print(datetime.now()-t1)</span><br><span class="line">t1 = datetime.now()</span><br><span class="line">df = pd.DataFrame(df)</span><br><span class="line">print(datetime.now()-t1)</span><br></pre></td></tr></table></figure><h4 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h4><h5 id="增"><a href="#增" class="headerlink" title="增"></a>增</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tuple_data = [tuple(i) for i in df_indus.values]</span><br><span class="line"></span><br><span class="line">client = Client(host=&apos;192.168.0.246&apos;, port=&apos;9000&apos;, user=&apos;user_rwd&apos;, password=&apos;1z2x3c4v&apos;, database=&apos;pre_formal_1&apos;)</span><br><span class="line">sql_save = &apos;INSERT INTO industry_company_wilson_20210208 (`industryId`,`companys`,`companysee`,`applicants`,`companyee_num`,`applicant_num`,`company_num`,`industryname`) VALUES&apos;</span><br><span class="line">client.execute(sql_save,tuple_data,types_check=True)</span><br><span class="line"></span><br><span class="line">集群方式创建表</span><br><span class="line">create table kl on cluster ch_cluster(id Int32,name String)ENGINE = MergeTree()</span><br></pre></td></tr></table></figure><h5 id="改"><a href="#改" class="headerlink" title="改"></a>改</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.添加新字段</span><br><span class="line">alter table test add column name String afer zone</span><br><span class="line">alter table test add column name String Default &apos;xiaoming&apos;</span><br><span class="line"></span><br><span class="line">#实现拼接字符串和表字段</span><br><span class="line">SELECT &apos;SELECT * FROM dwd_ptl_info where PORT_ID = \&apos;&apos;||PORT_ID||&apos;\&apos;;&apos; from dwd_ptl_info  </span><br><span class="line"></span><br><span class="line">2.修改数据类型</span><br><span class="line">alter table test modify column name name2 String</span><br><span class="line">  注意:修改类型实际调用的是类似toString的方法,如果将字符串转换为浮点数(不兼容),会报错</span><br><span class="line"></span><br><span class="line">3.添加字段备注</span><br><span class="line">alter table test comment column name &apos;姓名&apos;</span><br><span class="line"></span><br><span class="line">4.删除字段</span><br><span class="line">altet table test drop column if exists name</span><br><span class="line"></span><br><span class="line">5.清空表</span><br><span class="line">truncate table test</span><br><span class="line"></span><br><span class="line">6.重命名</span><br><span class="line">rename table algorithm.zl_zu_L_new_20210608 to algorithm.zl_zu_L_20210608</span><br></pre></td></tr></table></figure><h5 id="删"><a href="#删" class="headerlink" title="删"></a>删</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="查"><a href="#查" class="headerlink" title="查"></a>查</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">读全部字段数据</span><br><span class="line">select * from company_20210208</span><br><span class="line">读指定字段数据</span><br><span class="line">select applicant_name from company_20210208</span><br><span class="line">筛选指定字段的指定数据has:元素/hasAny:交集/hasAll:子集</span><br><span class="line">select app_text,app_date from zl_zu_L_20210208 where has(applicants,&apos;华为技术有限公司&apos;)</span><br><span class="line">筛选为空/不为空的数据(empty/notEmpty)</span><br><span class="line">select app_text,inventors,ceased_date from zl_zu_L_20210208 where empty(ceased_date)=1 </span><br><span class="line">返回数组长度</span><br><span class="line">select app_text,applicants,length(applicants) from zl_zu_L_20210208 limit 10</span><br><span class="line">数组拆分一行变多行</span><br><span class="line">select arrayJoin(applicants) as app1 from zl_zu_L_20210208 limit 10</span><br><span class="line">对数组内部去重(每一行数据)</span><br><span class="line">select applicants,arrayDistinct(applicants) from zl_zu_L_20210208 limit 10</span><br><span class="line">将数据转换为数组,按行</span><br><span class="line">select array(applicant_name) from company_20210208 limit 10</span><br><span class="line">select array(1,2,3,4)</span><br><span class="line">合并两列数据</span><br><span class="line">select arrayConcat(applicants,patentee_others) from zl_zu_L_20210208 limit 20</span><br><span class="line">SELECT arrayConcat([1, 2], [3, 4], [5, 6]) AS res</span><br><span class="line">结果:[1,2,3,4,5,6]</span><br><span class="line">数组中的元素计数</span><br><span class="line">select arrayCount([1,2,1])====&gt;3,同length ,但是arrayCount统计的是非0元素个数</span><br><span class="line">select arrayCount(x-&gt;x=1,[1,2,1])====&gt;2,数组中指定元素的个数  等价于 </span><br><span class="line">select countEqual([1,2,1],1)=====&gt;2</span><br><span class="line">获取数组中指定索引的元素</span><br><span class="line">select arrayElement(applicants,1) from zl_zu_L_20210208</span><br><span class="line">数组内部排序</span><br><span class="line">select arraySort(applicants) from zl_zu_L_20210208</span><br><span class="line">展平数组,合并列表成一个(列表嵌套)</span><br><span class="line">select arrayFlatten([[1,3,4],[2,3,4,5]])</span><br><span class="line">数组中连续出现的数据去重,数组内部数据类型须一致</span><br><span class="line">select arrayCompact([1,1,2,3,2])</span><br><span class="line">Python中的zip操作</span><br><span class="line">select arrayZip([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;],[1,2,3])</span><br><span class="line">对数据内部数据过滤arrayFill,下面是筛掉空值null</span><br><span class="line">select arrayFill(x -&gt; not isNull(x),applicants) from zl_zu_L_20210208 limit 10</span><br><span class="line">对数组切片从索引1开始切0个</span><br><span class="line">arraySlice(groupArray(app_text),1,0)</span><br><span class="line">截取字符串(从第一个位置开始往后截取2个)</span><br><span class="line">substring(x,1,2)</span><br><span class="line">数组内元素拼接</span><br><span class="line">arrayStringConcat(array1,&apos;,&apos;)</span><br><span class="line">聚合后某个字段转为列表</span><br><span class="line">select patentee,groupArray(app_text) from zl_zu group by patentee</span><br><span class="line"></span><br><span class="line">================================高阶函数==================</span><br><span class="line">x -&gt; 2 * x, str -&gt; str != Referer</span><br><span class="line">对数组每一个元素处理</span><br><span class="line">arrayMap(x -&gt; substring(x,1,2), groupArray(app_text))</span><br><span class="line"></span><br><span class="line">对数组过滤</span><br><span class="line">SELECT arrayFilter(x -&gt; x LIKE &apos;%World%&apos;, [&apos;Hello&apos;, &apos;abc World&apos;]) AS res</span><br><span class="line"></span><br><span class="line">拆分数组为多个数组</span><br><span class="line">SELECT arraySplit((x, y) -&gt; y, [1, 2, 3, 4, 5], [1, 0, 1, 1, 0]) AS res</span><br><span class="line">返回数组中最小数</span><br><span class="line">select arrayMin([1,2,3])</span><br><span class="line">返回数组中最大数</span><br><span class="line">select arrayMax([1,2,3])</span><br><span class="line">返回数组的求和</span><br><span class="line">select arraySum([1,2,3])</span><br><span class="line">返回数组均值</span><br><span class="line">select arrayAvg([1,2,3])</span><br><span class="line">对数组聚合</span><br><span class="line">select arrayReduce(&apos;max&apos;,[1,2,3])</span><br><span class="line">公募基金的底层持仓是不是在持仓表</span><br><span class="line">字符串条件判断处理</span><br><span class="line">multiIf(grant_date=&apos;&apos;,&apos;999999&apos;,grant_date)</span><br><span class="line">合并字符串concat</span><br><span class="line">concat(a,b,c,&apos;,&apos;,toString(d))</span><br><span class="line">将字符串转换成数组</span><br><span class="line">select applicant_name,splitByString(&apos;,&apos;,`groups`) from algorithm_dis.patent_num_L_20210608</span><br><span class="line"></span><br><span class="line">按照两列explode </span><br><span class="line">SELECT s, `nest.x`, `nest.y` FROM nested_test ARRAY JOIN nest;</span><br><span class="line">SELECT s, `nest.x`, `nest.y` FROM nested_test ARRAY JOIN `nest.x`, `nest.y`;</span><br><span class="line"></span><br><span class="line">其他方法:https://blog.csdn.net/u012111465/article/details/85250030</span><br><span class="line"></span><br><span class="line">①DECIMAL做除法运算的时候,分子的精度不能小于分母的精度</span><br><span class="line"></span><br><span class="line">创建分布式表:</span><br><span class="line">sql = &quot;CREATE TABLE IF NOT EXISTS algorithm_local.`&#123;&#125;` on cluster cluster_3shards_0replicas (`app_text` String, `pub_text` String,`app_date` Nullable(Date), `pub_date` Nullable(Date), `title` String, `inventors` Array(String), `applicants` Array(String),`patentee_others` Array(String), `ipc` Array(String),`group_name` Array(String),`grant_date` String, `ceased_date` String,`patent_type` String,`current_status` String,`main_family` Array(String),`zl_num_zong` Int64,`app_num_zong` Int64, `count_num` Int64,`paiming` String,`average` Float64,`sm` Float64,`xingji` Int8,`fwdcits` Array(String), `create_date` Date DEFAULT toDate(now())) ENGINE = ReplicatedReplacingMergeTree(&apos;/clickhouse/tables/ch170/&#123;&#123;shard&#125;&#125;/&#123;&#125;&apos;,&apos;&#123;&#123;replica&#125;&#125;&apos;) PRIMARY KEY app_text ORDER BY app_text SETTINGS index_granularity = 8192&quot;.format(zl_zu_L,zl_zu_L)</span><br><span class="line">client.execute(sql)</span><br><span class="line">sql = &quot;CREATE TABLE IF NOT EXISTS algorithm_dis.`&#123;&#125;` (`app_text` String, `pub_text` String,`app_date` Nullable(Date), `pub_date` Nullable(Date), `title` String, `inventors` Array(String), `applicants` Array(String),`patentee_others` Array(String), `ipc` Array(String),`group_name` Array(String),`grant_date` String, `ceased_date` String,`patent_type` String,`current_status` String,`main_family` Array(String),`zl_num_zong` Int64,`app_num_zong` Int64, `count_num` Int64,`paiming` String,`average` Float64,`sm` Float64,`xingji` Int8,`fwdcits` Array(String), `create_date` Date DEFAULT toDate(now())) ENGINE = Distributed(&apos;cluster_3shards_0replicas&apos;,&apos;algorithm_local&apos;,&apos;&#123;&#125;&apos;,halfMD5(app_text))&quot;.format(zl_zu_L,zl_zu_L)</span><br><span class="line">client.execute(sql)</span><br></pre></td></tr></table></figure><p>#####dataframe写入clickhouse<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">========================================<span class="number">1</span>===================================</span><br><span class="line"><span class="keyword">from</span> clickhouse_driver <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line">client = Client(<span class="string">'localhost'</span>)</span><br><span class="line">df = pandas.DataFrame.from_records([</span><br><span class="line">    &#123;<span class="string">'year'</span>: <span class="number">1994</span>, <span class="string">'first_name'</span>: <span class="string">'Vova'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'year'</span>: <span class="number">1995</span>, <span class="string">'first_name'</span>: <span class="string">'Anja'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'year'</span>: <span class="number">1996</span>, <span class="string">'first_name'</span>: <span class="string">'Vasja'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'year'</span>: <span class="number">1997</span>, <span class="string">'first_name'</span>: <span class="string">'Petja'</span>&#125;,</span><br><span class="line">])</span><br><span class="line"><span class="comment"># df processing blablabla...</span></span><br><span class="line">client.execute(<span class="string">"INSERT INTO your_table VALUES"</span>, df.to_dict(<span class="string">'records'</span>))</span><br><span class="line"></span><br><span class="line">========================================<span class="number">2</span>===================================</span><br><span class="line"><span class="keyword">import</span> pandahouse <span class="keyword">as</span> ph</span><br><span class="line"></span><br><span class="line">pdf = pd.DataFrame.from_records([</span><br><span class="line">    &#123;<span class="string">'year'</span>: <span class="string">'1994'</span>, <span class="string">'first_name'</span>: <span class="string">'Vova'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'year'</span>: <span class="string">'1995'</span>, <span class="string">'first_name'</span>: <span class="string">'Anja'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'year'</span>: <span class="string">'1996'</span>, <span class="string">'first_name'</span>: <span class="string">'Vasja'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'year'</span>: <span class="string">'1997'</span>, <span class="string">'first_name'</span>: <span class="string">'Petja'</span>&#125;,</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">connection = dict(database=<span class="string">'pre_formal_1'</span>,</span><br><span class="line">                  host=<span class="string">'http://192.168.0.246:8123'</span>,</span><br><span class="line">                  user=<span class="string">'user_rwd'</span>,</span><br><span class="line">                  password=<span class="string">'1z2x3c4v'</span>,</span><br><span class="line">                  )</span><br><span class="line">ph.to_clickhouse(pdf, <span class="string">'test_humans2'</span>, index=<span class="literal">False</span>, chunksize=<span class="number">100000</span>, connection=connection)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">======================================<span class="number">3</span>======================================</span><br><span class="line">client = Client(host=<span class="string">'192.168.0.170'</span>, port=<span class="string">'9000'</span>, user=<span class="string">'algorithm'</span>, password=<span class="string">'1a2s3d4f'</span>, database=<span class="string">'algorithm_dis'</span>,settings=&#123;<span class="string">'use_numpy'</span>: <span class="literal">True</span>&#125;)</span><br><span class="line"></span><br><span class="line">sql_insert = <span class="string">'insert into industryid_name_20211208 values'</span></span><br><span class="line">client.insert_dataframe(sql_insert,df)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">分区键:通常按照日期,存在不同的文件.我们这用不到,当版本数据存在一个表的时候可以用到</span><br><span class="line">分片:sharding,数据存储在不同的节点,那个distributed那种</span><br></pre></td></tr></table></figure><p>##client.query_dataframe(sql) 读成dataframe</p><p>####写dataframe到ch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client = Client(host=&apos;192.168.0.170&apos;, port=&apos;9000&apos;, user=&apos;algorithm&apos;, password=&apos;1a2s3d4f&apos;, database=&apos;algorithm_dis&apos;,settings=&#123;&apos;use_numpy&apos;: True&#125;)</span><br><span class="line">df[&apos;create_date&apos;] = &apos;20220111&apos;</span><br><span class="line">sql_insert = &apos;insert into industryid_name_20211208 values&apos;</span><br><span class="line">client.insert_dataframe(sql_insert,df)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start clickhouse-server</span><br><span class="line">systemctl stop clickhouse-server</span><br><span class="line">systemctl status clickhouse-server</span><br></pre></td></tr></table></figure><p><a href="https://github.com/mymarilyn/clickhouse-driver" target="_blank" rel="noopener">https://github.com/mymarilyn/clickhouse-driver</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spark视频笔记</title>
      <link href="/2021/01/12/spark%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/01/12/spark%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">宽依赖:一对多,必定会发生shuffle操作</span><br><span class="line">窄依赖:一对一</span><br><span class="line"></span><br><span class="line">一个DAG就是一个job,一个job分层很多个stage,stage划分的依据是宽依赖,task是由分区数决定的一个rdd分层三个区则对应三个task</span><br><span class="line">每个阶段的task的数量是最后一个rdd的分区数</span><br><span class="line">rdd转换操作和行动操作(也称为算子)</span><br><span class="line">转换操作:</span><br><span class="line">分为单value、双value和key-value的形式</span><br><span class="line">单value：</span><br><span class="line">map、mapPartitions、mapPartitionsWithIndex、flatMap、glom、groupBy、filter、sample、distinct、coalesce、repartition、sortBy、mapvalues</span><br><span class="line">双value：</span><br><span class="line">intersection、union、substract、zip</span><br><span class="line">key-value：</span><br><span class="line">partitionBy、reduceByKey、groupByKey、aggregateByKey、foldByKey、combineByKey、sortByKey、join、leftOuterJoin、cogroup、</span><br><span class="line">groupbyKey性能差于reducebyKey,因为reduce先分区操作了,然后再shuffle操作后,将分区间的数据合并再操作,这个两个算子shuffle过程都是写入文件的,防止数据量导致内存溢出,然后reducebykey的io数据量远远小于groupbykey,但是根据场景的不同可能存在并不需要聚合的情况,这会儿groupbykey就可以使用到了</span><br><span class="line"></span><br><span class="line">针对reducebykey区内和区间的操作都一样,当区内区外不一样的时候可以使用aggregrative,实现自定义</span><br><span class="line"></span><br><span class="line">持久化的三种方法cache、persist和checkpoint区别，chechpoint存在磁盘</span><br><span class="line">重写分区器</span><br><span class="line">累加器和broadcast[只写和只读]: 累加器的原理:分executor执行,然后driver在执行.executor之间互不影响,Accoumolotor支持自定义,累加器本身不执行,当遇到行动算子的时候才会执行,因而推荐放到行动算子里面,否则可能会多次执行: brocast用于闭包变量共享,否则多少线程数就需要复制多少份数据,现在是通过executor划分的,每个executor一份数据:广播变量用来高效分发较大的对象。向所有工作节点发送一个较大的只读值，以供一个</span><br><span class="line">或多个 Spark 操作使用</span><br><span class="line"></span><br><span class="line">framework框架:工程化代码,整体分为applciantion,controller,service,Dao四部分,再详细分为application: 控制层: 主要用于调度。</span><br><span class="line">service: 服务层: 主要用于执行逻辑。</span><br><span class="line">dao: 持久层: 主要用于数据交互。</span><br><span class="line">application: 应用层: 所有的应用程序从 application 开始启动。</span><br><span class="line">common: 用于存放共通类。</span><br><span class="line">util: 用于存放工具类。</span><br><span class="line">bean: 用于存放实体类。</span><br><span class="line"></span><br><span class="line">SCALA类里面main方法可以手写也可以继承自App</span><br><span class="line">scala的case用法不会:map&#123;&#125;写法</span><br></pre></td></tr></table></figure><h4 id="windows-spark-配置"><a href="#windows-spark-配置" class="headerlink" title="windows spark 配置"></a>windows spark 配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/l_dsj/article/details/109468288</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/01/11/spark%E7%BC%96%E7%A8%8B/"/>
      <url>/2021/01/11/spark%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h5 id="直接用pyspark-的配置"><a href="#直接用pyspark-的配置" class="headerlink" title="直接用pyspark 的配置"></a>直接用pyspark 的配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.vim ~/.bashrc</span><br><span class="line">2.spark_home补充上 SPARK_HOME=/home/kuailiang/spark/spark-3.0.1-bin-hadoop3.2</span><br><span class="line">3.export PATH=$PATH:$SPARK_HOME/bin</span><br><span class="line"></span><br><span class="line">4.export PYSPARK_PYTHON=python3</span><br><span class="line">source ~/.bashrc</span><br><span class="line"></span><br><span class="line">3.spark-env.sh-----&gt;conf下</span><br><span class="line">4.export PYSPARK_PYTHON=/usr/bin/python3</span><br></pre></td></tr></table></figure><h5 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spark-submit new.py</span><br><span class="line">spark-submit   --master spark://192.168.0.217:7077   pi.py   2000</span><br><span class="line">spark-submit wordcount.py file:///home/tst  #运行本地文件</span><br><span class="line">./bin/spark-submit examples/src/main/python/pi.py</span><br></pre></td></tr></table></figure><h5 id="基本须知"><a href="#基本须知" class="headerlink" title="基本须知"></a>基本须知</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.spark程序必须做的第一件事就是创建一个sparkcontext对象(Spark如何访问集群)</span><br><span class="line">2.数据还要使用则lineLengths.persist()</span><br><span class="line">export PATH</span><br><span class="line">export JAVA_HOME=/home/kuailiang/2020/java/jdk-15.0.1</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure><h5 id="RDD操作"><a href="#RDD操作" class="headerlink" title="RDD操作"></a>RDD操作</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">转换：</span><br><span class="line">    map</span><br><span class="line">    filter</span><br><span class="line">    flatmap</span><br><span class="line">    sample</span><br><span class="line">    groupByKey</span><br><span class="line">    reduceByKey</span><br><span class="line">    union</span><br><span class="line">    join</span><br><span class="line">    cogroup</span><br><span class="line">    crossProduct</span><br><span class="line">    mapValues</span><br><span class="line">    sort</span><br><span class="line">    partitionBy</span><br><span class="line">操作：</span><br><span class="line">    count</span><br><span class="line">    collect</span><br><span class="line">    reduce</span><br><span class="line">    lookup</span><br><span class="line">    save</span><br><span class="line">在转换方法中的函数执行完后生成的还是一个RDD结构</span><br></pre></td></tr></table></figure><h5 id="自带案例1"><a href="#自带案例1" class="headerlink" title="自带案例1"></a>自带案例1</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">textFile = spark.read.text(<span class="string">"README.md"</span>)</span><br><span class="line">textFile.count()</span><br><span class="line">textFile.first()</span><br><span class="line">linesWithSpark = textFile.filter(textFile.value.contains(<span class="string">"Spark"</span>))</span><br></pre></td></tr></table></figure><h5 id="查找包含最多单词的行"><a href="#查找包含最多单词的行" class="headerlink" title="查找包含最多单词的行"></a>查找包含最多单词的行</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> *</span><br><span class="line">textFile.select(size(split(textFile.value,<span class="string">"\s+"</span>)).name(<span class="string">"numWords"</span>)).agg(max(col(<span class="string">"numWords"</span>))).collect()</span><br><span class="line"></span><br><span class="line">wordCounts = textFile.select(explode(split(textFile.value,<span class="string">"\s+"</span>)).alias(<span class="string">"word"</span>)).groupBy(<span class="string">"word"</span>).count()</span><br><span class="line"></span><br><span class="line">wordCounts.collect()</span><br></pre></td></tr></table></figure><h5 id="spark操作mysql"><a href="#spark操作mysql" class="headerlink" title="spark操作mysql"></a>spark操作mysql</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">####注意对应版本的jar包要放在jars文件夹下https://mvnrepository.com/artifact/mysql/mysql-connector-java</span></span><br><span class="line">clickhouse包 https://mvnrepository.com/artifact/ru.yandex.clickhouse/clickhouse-jdbc/<span class="number">0.2</span><span class="number">.4</span></span><br><span class="line">============================读数据==================</span><br><span class="line">jdbcDF = spark.read.format(<span class="string">"jdbc"</span>).\</span><br><span class="line">option(<span class="string">"url"</span>, <span class="string">"jdbc:mysql://192.168.0.251:3306/pre_formal_2"</span>).\</span><br><span class="line">option(<span class="string">"driver"</span>,<span class="string">"com.mysql.jdbc.Driver"</span>).\</span><br><span class="line">option(<span class="string">"dbtable"</span>, <span class="string">"ipc_split_10000_c_list_v3"</span>).\</span><br><span class="line">option(<span class="string">"user"</span>, <span class="string">"user_rw"</span>).\</span><br><span class="line">option(<span class="string">"password"</span>, <span class="string">"1a2s3d4f"</span>).load()</span><br><span class="line"><span class="comment">####读指定字段</span></span><br><span class="line">industry_coms = spark.read.format(<span class="string">"jdbc"</span>).\</span><br><span class="line">option(<span class="string">"url"</span>, <span class="string">"jdbc:mysql://192.168.0.251:3306/pre_formal_1"</span>).\</span><br><span class="line">option(<span class="string">"driver"</span>,<span class="string">"com.mysql.jdbc.Driver"</span>).\</span><br><span class="line">option(<span class="string">"dbtable"</span>, <span class="string">"(select industryId,companyee_num from  industry_company_wilson_20210112) t"</span>).\</span><br><span class="line">option(<span class="string">"user"</span>, <span class="string">"user_rw"</span>).\</span><br><span class="line">option(<span class="string">"password"</span>, <span class="string">"1a2s3d4f"</span>).load()</span><br><span class="line"><span class="comment">#返回的是dataframe</span></span><br><span class="line">jdbcDF.show()</span><br><span class="line">============================存数据===================</span><br><span class="line">mysql_url = <span class="string">"jdbc:mysql://192.168.0.251:3306/pre_formal_2?user=user_rw&amp;password=1a2s3d4f"</span></span><br><span class="line">mysql_table = <span class="string">"people"</span></span><br><span class="line">jdbcDF.write.mode(<span class="string">"append"</span>).jdbc(mysql_url, mysql_table)</span><br></pre></td></tr></table></figure><h5 id="spark操作clickhouse"><a href="#spark操作clickhouse" class="headerlink" title="spark操作clickhouse"></a>spark操作clickhouse</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">companys = spark.read.format(<span class="string">"jdbc"</span>). \</span><br><span class="line">    option(<span class="string">"url"</span>, <span class="string">"jdbc:clickhouse://192.168.0.246:8123/pre_formal_1"</span>). \</span><br><span class="line">    option(<span class="string">"driver"</span>, <span class="string">"ru.yandex.clickhouse.ClickHouseDriver"</span>). \</span><br><span class="line">    option(<span class="string">"dbtable"</span>, <span class="string">f"(select applicant_name as applicant_other from  company_20210208) t"</span>). \</span><br><span class="line">    option(<span class="string">"user"</span>, <span class="string">"default"</span>). \</span><br><span class="line">    option(<span class="string">"password"</span>, <span class="string">"123456"</span>).load().cache()</span><br></pre></td></tr></table></figure><h5 id="spark存成不同格式-csv-json-text-parquet"><a href="#spark存成不同格式-csv-json-text-parquet" class="headerlink" title="spark存成不同格式(csv,json,text,parquet)"></a>spark存成不同格式(csv,json,text,parquet)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jdbcDF.select(&quot;names&quot;).write.text(&quot;/root/mimo/people_text&quot;)</span><br><span class="line"></span><br><span class="line">jdbcDF.write.csv(&quot;/root/mimo/people_text/people_csv&quot;, sep=&apos;:&apos;)</span><br><span class="line"></span><br><span class="line">jdbcDF.write.json(&quot;/root/mimo/people_text/people_json&quot;, mode=&apos;overwrite&apos;)</span><br><span class="line"></span><br><span class="line">peopledf.write.parquet(&quot;/root/mimo/people_text/people_parquet&quot;, mode=&apos;append&apos;)</span><br></pre></td></tr></table></figure><h5 id="Spark包"><a href="#Spark包" class="headerlink" title="Spark包"></a>Spark包</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pyspark.SparkContext:</span><br><span class="line">SparkContext表示与Spark集群的连接，可用于RDD在该集群上创建和广播变量</span><br></pre></td></tr></table></figure><h5 id="pyspark-sql"><a href="#pyspark-sql" class="headerlink" title="pyspark.sql"></a>pyspark.sql</h5><h5 id="统计成绩案例"><a href="#统计成绩案例" class="headerlink" title="统计成绩案例"></a>统计成绩案例</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#studentExample 例子 练习</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map_func</span><span class="params">(x)</span>:</span></span><br><span class="line">s = x.split()</span><br><span class="line"><span class="keyword">return</span> (s[<span class="number">0</span>], [int(s[<span class="number">1</span>]),int(s[<span class="number">2</span>]),int(s[<span class="number">3</span>])]) <span class="comment">#返回为（key,vaklue）格式，其中key:x[0],value:x[1]且为有三个元素的列表</span></span><br><span class="line"><span class="comment">#return (s[0],[int(s[1],s[2],s[3])]) #注意此用法不合法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">has100</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> x:</span><br><span class="line"><span class="keyword">if</span>(y == <span class="number">100</span>): <span class="comment">#把x、y理解为 x轴、y轴</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allis0</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="keyword">if</span>(type(x)==list <span class="keyword">and</span> sum(x) == <span class="number">0</span>): <span class="comment">#类型为list且总分为0 者为true；其中type(x)==list :判断类型是否相同</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subMax</span><span class="params">(x,y)</span>:</span></span><br><span class="line">m = [x[<span class="number">1</span>][i] <span class="keyword">if</span>(x[<span class="number">1</span>][i] &gt; y[<span class="number">1</span>][i]) <span class="keyword">else</span> y[<span class="number">1</span>][i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line"><span class="keyword">return</span>(<span class="string">'Maximum subject score'</span>, m)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumSub</span><span class="params">(x,y)</span>:</span></span><br><span class="line">n = [x[<span class="number">1</span>][i]+y[<span class="number">1</span>][i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line"><span class="comment">#或者 n = ([x[1][0]+y[1][0],x[1][1]+y[1][0],x[1][2]+y[1][2]])</span></span><br><span class="line"><span class="keyword">return</span>(<span class="string">'Total subject score'</span>, n)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumPer</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="keyword">return</span> (x[<span class="number">0</span>],sum(x[<span class="number">1</span>]))<span class="comment">#停止之前的SparkContext，不然重新运行或者创建工作会失败；另外，只有 sc.stop()也可以，但是首次运行会有误</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">sc.stop()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkContext <span class="comment">#导入模块</span></span><br><span class="line">sc=SparkContext(appName=<span class="string">'Student'</span>) <span class="comment">#命名</span></span><br><span class="line">lines=sc.textFile(<span class="string">"/home/kuailiang/spark/code/dtudent.txt"</span>).map(<span class="keyword">lambda</span> x:map_func(x)).cache() <span class="comment">#导入数据且保持在内存中，其中cache()：数据保持在内存中</span></span><br><span class="line">count=lines.count() <span class="comment">#对RDD中的数据个数进行计数；其中，RDD一行为一个数据集#RDD'转换'运算 （筛选 关键字filter）</span></span><br><span class="line">whohas100 = lines.filter(<span class="keyword">lambda</span> x: has100(x[<span class="number">1</span>])).collect() <span class="comment">#注意：处理的是value列表，也就是x[1]</span></span><br><span class="line">whois0 = lines.filter(<span class="keyword">lambda</span> x: allis0(x[<span class="number">1</span>])).collect()</span><br><span class="line">sumScore = lines.map(<span class="keyword">lambda</span> x: (x[<span class="number">0</span>],sum(x[<span class="number">1</span>]))).collect()</span><br><span class="line"><span class="comment">#‘动作’运算</span></span><br><span class="line">maxScore = max(sumScore,key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]) <span class="comment">#总分最高者</span></span><br><span class="line">minScore = min(sumScore,key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]) <span class="comment">#总分最低者</span></span><br><span class="line">sumSubScore = lines.reduce(<span class="keyword">lambda</span> x,y: sumSub(x,y))</span><br><span class="line">avgScore = [x/count <span class="keyword">for</span> x <span class="keyword">in</span> sumSubScore[<span class="number">1</span>]]<span class="comment">#单科成绩平均值</span></span><br><span class="line"><span class="comment">#RDD key-value‘转换’运算</span></span><br><span class="line">subM = lines.reduce(<span class="keyword">lambda</span> x,y: subMax(x,y))</span><br><span class="line">redByK = lines.reduceByKey(<span class="keyword">lambda</span> x,y: [x[i]+y[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]).collect() <span class="comment">#合并key相同的value值x[0]+y[0],x[1]+y[1],x[2]+y[2]</span></span><br><span class="line"><span class="comment">#RDD'转换'运算</span></span><br><span class="line">sumPerSore = lines.map(<span class="keyword">lambda</span> x: sumPer(x)).collect() <span class="comment">#每个人的总分 #sumSore = lines.map(lambda x: (x[0],sum(x[1]))).collect()</span></span><br><span class="line">sorted = lines.sortBy(<span class="keyword">lambda</span> x: sum(x[<span class="number">1</span>])) <span class="comment">#总成绩低到高的学生成绩排序</span></span><br><span class="line">sortedWithRank = sorted.zipWithIndex().collect()<span class="comment">#按总分排序</span></span><br><span class="line">first3 = sorted.takeOrdered(<span class="number">3</span>,key=<span class="keyword">lambda</span> x:-sum(x[<span class="number">1</span>])) <span class="comment">#总分前三者#限定以空格的形式输出到文件中</span></span><br><span class="line">first3RDD = sc.parallelize(first3)\</span><br><span class="line">.map(<span class="keyword">lambda</span> x:str(x[<span class="number">0</span>])+<span class="string">' '</span>+str(x[<span class="number">1</span>][<span class="number">0</span>])+<span class="string">' '</span>+str(x[<span class="number">1</span>][<span class="number">1</span>])+<span class="string">' '</span>+str(x[<span class="number">1</span>][<span class="number">2</span>])).saveAsTextFile(<span class="string">"result"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#print(lines.collect())</span></span><br><span class="line">print(<span class="string">"数据集个数（行）:"</span>,count)</span><br><span class="line">print(<span class="string">"单科满分者："</span>,whohas100)</span><br><span class="line">print(<span class="string">"单科零分者:"</span>,whois0)</span><br><span class="line">print(<span class="string">"单科最高分者："</span>,subM)</span><br><span class="line">print(<span class="string">"单科总分："</span>,sumSubScore)</span><br><span class="line">print(<span class="string">"合并名字相同的分数："</span>,redByK)</span><br><span class="line">print(<span class="string">"总分/（人）"</span>,sumPerSore)</span><br><span class="line">print(<span class="string">"最高总分者："</span>,maxScore)</span><br><span class="line">print(<span class="string">"最低总分者："</span>,minScore)</span><br><span class="line">print(<span class="string">"每科平均成绩："</span>,avgScore)</span><br><span class="line"><span class="comment"># print("总分倒序：",sortedWithRank)</span></span><br><span class="line">print(<span class="string">"总分前三者："</span>,first3)</span><br><span class="line">print(first3RDD)</span><br><span class="line">sc.stop()</span><br></pre></td></tr></table></figure><h5 id="saprk-sql和dataframe"><a href="#saprk-sql和dataframe" class="headerlink" title="saprk sql和dataframe"></a>saprk sql和dataframe</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">df.show() <span class="comment">#展示数据</span></span><br><span class="line">df.select(<span class="string">"name"</span>).show() <span class="comment">#挑选指定的列</span></span><br><span class="line">df.select(df[<span class="string">'name'</span>], df[<span class="string">'age'</span>] + <span class="number">1</span>).show() <span class="comment">#展示name和age字段并将age字段+1</span></span><br><span class="line">df.filter(df[<span class="string">'age'</span>] &gt; <span class="number">21</span>).show()  <span class="comment">#过滤,展示age字段大于21的数据</span></span><br><span class="line">df.groupBy(<span class="string">"age"</span>).count().show()</span><br><span class="line"><span class="keyword">import</span> pyspark.sql.functions <span class="keyword">as</span> func</span><br><span class="line">df.groupBy(<span class="string">"department"</span>).agg(df[<span class="string">"department"</span>], func.max(<span class="string">"age"</span>), func.sum(<span class="string">"expense"</span>))</span><br><span class="line">df.groupBy(<span class="string">"department"</span>).agg(func.max(<span class="string">"age"</span>), func.sum(<span class="string">"expense"</span>))</span><br><span class="line">sqlContext.setConf(<span class="string">"spark.sql.retainGroupColumns"</span>, <span class="string">"false"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> Row</span><br><span class="line">sc = spark.sparkContext</span><br><span class="line"><span class="comment"># Load a text file and convert each line to a Row.</span></span><br><span class="line">lines = sc.textFile(<span class="string">"examples/src/main/resources/people.txt"</span>)</span><br><span class="line">parts = lines.map(<span class="keyword">lambda</span> l: l.split(<span class="string">","</span>))</span><br><span class="line">people = parts.map(<span class="keyword">lambda</span> p: Row(name=p[<span class="number">0</span>], age=int(p[<span class="number">1</span>])))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Infer the schema, and register the DataFrame as a table.</span></span><br><span class="line">schemaPeople = spark.createDataFrame(people)   <span class="comment">#创建dataframe</span></span><br><span class="line">schemaPeople.createOrReplaceTempView(<span class="string">"people"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># SQL can be run over DataFrames that have been registered as a table.</span></span><br><span class="line">teenagers = spark.sql(<span class="string">"SELECT name FROM people WHERE age &gt;= 13 AND age &lt;= 19"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The results of SQL queries are Dataframe objects.</span></span><br><span class="line"><span class="comment"># rdd returns the content as an :class:`pyspark.RDD` of :class:`Row`.</span></span><br><span class="line">teenNames = teenagers.rdd.map(<span class="keyword">lambda</span> p: <span class="string">"Name: "</span> + p.name).collect()</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> teenNames:</span><br><span class="line">    print(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Spark SQL可以将Row对象的RDD转换为DataFrame，从而推断数据类型。通过将键/值对列表作为kwargs传递给Row类来构造行。该列表的键定义表的列名，并且通过对整个数据集进行采样来推断类型，类似于对JSON文件执行的推断。</span><br></pre></td></tr></table></figure><h5 id="createDataFrame"><a href="#createDataFrame" class="headerlink" title="createDataFrame"></a>createDataFrame</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">DataFrame从RDD，列表或创建一个pandas.DataFrame。</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> Row</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">rel = &#123;&#125;</span><br><span class="line">rel[<span class="string">'name'</span>] = x[<span class="number">0</span>]</span><br><span class="line">rel[<span class="string">'age'</span>] = x[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> rel</span><br><span class="line">peopleDF = sc.textFile(<span class="string">"examples/src/main/resources/people.txt"</span>).map(<span class="keyword">lambda</span> line : line.split(<span class="string">','</span>)).map(<span class="keyword">lambda</span> x: Row(**f(x))).toDF()</span><br><span class="line"></span><br><span class="line">peopleDF.createOrReplaceTempView(<span class="string">"people"</span>)  <span class="comment">#必须注册为临时表才能供下面的查询使用</span></span><br><span class="line">personsDF = spark.sql(<span class="string">"select * from people"</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">#########创建DataFrame########</span></span><br><span class="line">=====<span class="number">1</span></span><br><span class="line">l = [(<span class="string">'Alice'</span>, <span class="number">1</span>)]</span><br><span class="line">spark.createDataFrame(l, [<span class="string">'name'</span>, <span class="string">'age'</span>]).collect()</span><br><span class="line">=====<span class="number">2</span></span><br><span class="line">d = [&#123;<span class="string">'name'</span>: <span class="string">'Alice'</span>, <span class="string">'age'</span>: <span class="number">1</span>&#125;]</span><br><span class="line">spark.createDataFrame(d).collect()</span><br><span class="line">=====<span class="number">3</span></span><br><span class="line">l = [(<span class="string">'Alice'</span>, <span class="number">1</span>)]</span><br><span class="line">rdd = sc.parallelize(l)</span><br><span class="line">spark.createDataFrame(rdd).collect()</span><br><span class="line">spark.createDataFrame(rdd, [<span class="string">'name'</span>, <span class="string">'age'</span>]).collect()</span><br><span class="line">=====<span class="number">4</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> Row</span><br><span class="line">l = [(<span class="string">'Alice'</span>, <span class="number">1</span>)]</span><br><span class="line">rdd = sc.parallelize(l)</span><br><span class="line">Person = Row(<span class="string">'name'</span>, <span class="string">'age'</span>)</span><br><span class="line">person = rdd.map(<span class="keyword">lambda</span> r: Person(*r))</span><br><span class="line">spark.createDataFrame(person).collect()</span><br><span class="line">=====<span class="number">5</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> *</span><br><span class="line">schema = StructType([</span><br><span class="line">   StructField(<span class="string">"name"</span>, StringType(), <span class="literal">True</span>),</span><br><span class="line">   StructField(<span class="string">"age"</span>, IntegerType(), <span class="literal">True</span>)])</span><br><span class="line">spark.createDataFrame(rdd, schema).collect()</span><br><span class="line">=====<span class="number">6</span></span><br><span class="line">spark.createDataFrame(df.toPandas()).collect() <span class="comment">#将 pandas的dataframe转换成spark的</span></span><br><span class="line">spark.createDataFrame(pandas.DataFrame([[<span class="number">1</span>, <span class="number">2</span>]])).collect()</span><br><span class="line">=====<span class="number">7</span></span><br><span class="line">spark.createDataFrame(rdd, <span class="string">"a: string, b: int"</span>).collect()</span><br></pre></td></tr></table></figure><p>#####DataFrame操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#按照一列进行排序</span></span><br><span class="line">df.sort(df.age.desc()).show()</span><br><span class="line"><span class="comment">#多列排序</span></span><br><span class="line">df.sort(df.age.desc(), df.name.asc()).show()</span><br><span class="line"><span class="comment">#对列进行重命名</span></span><br><span class="line">df.select(df.name.alias(<span class="string">"username"</span>),df.age).show()</span><br></pre></td></tr></table></figure><h5 id="SparkConf-gt-资源控制-配置spark"><a href="#SparkConf-gt-资源控制-配置spark" class="headerlink" title="SparkConf====&gt;资源控制,配置spark"></a>SparkConf====&gt;资源控制,配置spark</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">sc_conf = SparkConf()</span><br><span class="line">sc_conf.setMaster(<span class="string">'spark://192.168.0.217:7077'</span>)</span><br><span class="line">sc_conf.setAppName(<span class="string">'my-app'</span>)</span><br><span class="line">sc_conf.set(<span class="string">'spark.executor.memory'</span>, <span class="string">'60g'</span>)  <span class="comment">#executor memory是每个节点上占用的内存。每一个节点可使用内存</span></span><br><span class="line">sc_conf.set(<span class="string">"spark.executor.cores"</span>, <span class="string">'4'</span>) <span class="comment">#spark.executor.cores：顾名思义这个参数是用来指定executor的cpu内核个数，分配更多的内核意味着executor并发能力越强，能够同时执行更多的task</span></span><br><span class="line">sc_conf.set(<span class="string">'spark.cores.max'</span>, <span class="number">40</span>)    <span class="comment">#spark.cores.max：为一个application分配的最大cpu核心数，如果没有设置这个值默认为spark.deploy.defaultCores</span></span><br><span class="line">sc_conf.set(<span class="string">'spark.logConf'</span>, <span class="literal">True</span>)    <span class="comment">#当SparkContext启动时，将有效的SparkConf记录为INFO。</span></span><br><span class="line">print(sc_conf.getAll())</span><br><span class="line"></span><br><span class="line">=============================大类下的方法======</span><br><span class="line">sc_conf.contains('spark.executor.memory') ====&gt;返回True和False</span><br><span class="line">sc_conf.getAll()  ====&gt;获取配置信息</span><br><span class="line">sc_conf.set('spark.executor.memory', '2g')  ======&gt;设置spark的配置</span><br><span class="line">sc_conf.setAll([('spark.executor.memory', '2g'),('spark.cores.max', 40)]) ===&gt;一次设置多个配置</span><br><span class="line">sc_conf.setMaster() 设置连接的主URL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">动态资源分配:============还不懂==================&gt;反正很重要</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conf</span><span class="params">(self)</span>:</span></span><br><span class="line">     conf = super(TbtestStatisBase, self).conf</span><br><span class="line">     conf.update(&#123;</span><br><span class="line">            <span class="string">'spark.shuffle.service.enabled'</span>: <span class="string">'true'</span>,</span><br><span class="line">            <span class="string">'spark.dynamicAllocation.enabled'</span>: <span class="string">'false'</span>,</span><br><span class="line">            <span class="string">'spark.dynamicAllocation.initialExecutors'</span>: <span class="number">50</span>,</span><br><span class="line">            <span class="string">'spark.dynamicAllocation.minExecutors'</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">'spark.dynamicAllocation.maxExecutors'</span>: <span class="number">125</span>,</span><br><span class="line">            <span class="string">'spark.sql.parquet.compression.codec'</span>: <span class="string">'snappy'</span>,</span><br><span class="line">            <span class="string">'spark.yarn.executor.memoryOverhead'</span>: <span class="number">4096</span>,</span><br><span class="line">            <span class="string">"spark.speculation"</span>: <span class="string">'true'</span>,</span><br><span class="line">            <span class="string">'spark.kryoserializer.buffer.max'</span>: <span class="string">'512m'</span>,</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure><h5 id="SparkContext"><a href="#SparkContext" class="headerlink" title="SparkContext"></a>SparkContext</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SparkContext每个JVM仅应激活一个。在创建新 的活动目录之前，必须先停止活动目录</span><br><span class="line">getOrCreate:获取或实例化SparkContext并将其注册为单例对象</span><br><span class="line">glom()返回通过将每个分区内的所有元素合并到列表中而创建的RDD</span><br></pre></td></tr></table></figure><p>#####其他方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">parallelize([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="number">3</span>)  分发本地Python集合以形成RDD</span><br><span class="line">pickleFile()  使用saveAsPickleFile()保存的RDD</span><br><span class="line">sc.runJob(sc.parallelize(range(<span class="number">6</span>), <span class="number">3</span>), <span class="keyword">lambda</span> part: [x * x <span class="keyword">for</span> x <span class="keyword">in</span> part], [<span class="number">0</span>, <span class="number">2</span>], <span class="literal">True</span>) 对指定的分区进行指定的操作,未指定分区则在全部分区执行</span><br><span class="line">sc.sparkUser() 获取正在使用spark_context的用户</span><br><span class="line">sc.stop()  关闭sparkcontext</span><br><span class="line">sc.TextFile()  从对于路径读取文件</span><br><span class="line">sc.union([rdd1,rdd2])  建立rdd列表的并集</span><br><span class="line">rdd1.intersection(rdd2) 建立rdd的交集</span><br><span class="line">rdd1.subtract(rdd2) 建立rdd的差集</span><br><span class="line">rdd1.distinct() RDD去重</span><br><span class="line">rdd1.takeOrdered(<span class="number">3</span>,key=<span class="keyword">lambda</span> x:-x) 从大到小排序,从小到大不用<span class="keyword">lambda</span></span><br><span class="line">rdd1.randomsplit([<span class="number">0.4</span>,<span class="number">0.6</span>]) rdd等比例分割</span><br><span class="line">sc.parallelize([<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>], <span class="number">5</span>).aggregate((<span class="number">1</span>, <span class="number">1</span>), seqOp1, combOp1)</span><br><span class="line">rdd1.cache() rdd放到内存中</span><br><span class="line">rdd1.cartesian(rdd2) 计算两个rdd的笛卡尔乘积</span><br><span class="line">rdd.getNumPartitions()  获取分区数量</span><br><span class="line">sc.parallelize([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">3</span>).coalesce(<span class="number">1</span>).glom().collect()  减少rdd的分区</span><br><span class="line">rdd1.collect() 返回rdd的所有元素列表</span><br><span class="line">sorted(sc.parallelize([(<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"b"</span>, <span class="number">4</span>)]).cogroup(sc.parallelize([(<span class="string">"a"</span>, <span class="number">2</span>)])).collect())  返回一个元组,其中包含key的所有值的列表(类似按照键聚合)</span><br><span class="line">sc.parallelize([(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>)]).collectAsMap()  构建字典,数据较小时(放到内存中)</span><br><span class="line">sc.parallelize([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).count()</span><br><span class="line">sc.parallelize([(<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"b"</span>, <span class="number">1</span>), (<span class="string">"a"</span>, <span class="number">1</span>)]).countByKey().items()  <span class="comment">#计算每个键的元素数</span></span><br><span class="line">sc.parallelize([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]).countByValue().items()  <span class="comment">#返回值的计数</span></span><br><span class="line">sorted(sc.parallelize([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).distinct().collect())  <span class="comment">#返回去重后的RDD</span></span><br><span class="line">sc.parallelize([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>).collect() <span class="comment">#筛选符合条件的构建新的rdd</span></span><br><span class="line">sc.parallelize([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).first()  <span class="comment">#返回rdd的第一条数据,空的rdd会报错</span></span><br><span class="line">sorted(sc.parallelize([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).flatMap(<span class="keyword">lambda</span> x: range(<span class="number">1</span>, x)).collect())  <span class="comment">#对rdd的每一个元素处理,然后将结果展平</span></span><br><span class="line">sc.parallelize([]).isEmpty() <span class="comment">#判断RDD是否为空</span></span><br><span class="line">sc.parallelize(range(<span class="number">0</span>,<span class="number">3</span>)).keyBy(<span class="keyword">lambda</span> x: x*x).collect()  创建元组的键[(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">4</span>, <span class="number">2</span>)]</span><br><span class="line">sc.parallelize([(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>)]).keys() 返回rdd的键</span><br><span class="line">rdd1.max() 返回最大值,存在参数key</span><br><span class="line">rdd1.is_cached  判断是否是缓存</span><br><span class="line">sc.broadcast(array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])) 广播变量</span><br><span class="line">sc.parallelize([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]).take(<span class="number">3</span>)  获取前三个元素</span><br><span class="line">sc.parallelize([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]).takeOrdered(<span class="number">3</span>) 排序后取前三个</span><br><span class="line">sc.parallelize([<span class="number">10</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">3</span>]).top(<span class="number">3</span>)  取前<span class="number">3</span>个数据,适用于较小的数据</span><br><span class="line">sc.parallelize([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).variance()  计算rdd的方差</span><br><span class="line">sc.parallelize([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]).sum() 求和</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">================foreach==============</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span> print(x)</span><br><span class="line">sc.parallelize([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).foreach(f)</span><br><span class="line">============flatMapValues================</span><br><span class="line">x = sc.parallelize([(<span class="string">"a"</span>, [<span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"z"</span>]), (<span class="string">"b"</span>, [<span class="string">"p"</span>, <span class="string">"r"</span>])])</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span> <span class="keyword">return</span> x</span><br><span class="line">x.flatMapValues(f).collect()</span><br><span class="line">sc.parallelize([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]).fold(<span class="number">0</span>,<span class="keyword">lambda</span> x,y:x+y)  类似于reduce的聚合,<span class="number">0</span> 表示初始聚合值和聚合类型。</span><br><span class="line">==============join,leftOuterjoin,rightOuterjoin========</span><br><span class="line">kvRDD1 = sc.parallelize([(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">3</span>,<span class="number">6</span>),(<span class="number">5</span>,<span class="number">6</span>),(<span class="number">1</span>,<span class="number">2</span>)])</span><br><span class="line">kvRDD2 = sc.parallelize([(<span class="number">3</span>,<span class="number">8</span>)]) </span><br><span class="line">kvRDD1.join(kvRDD2)   <span class="comment">#按照相同的key值拼接</span></span><br><span class="line">kvRDD1.leftOuterJoin(kvRDD2)  <span class="comment">#左侧认rdd为准,没有的为None==&gt;[(1,(2,None)),(3,(4,8)),(3,(6,8)),(5,(6,None))]</span></span><br><span class="line">kvRDD1.rightOuterJoin(kvRDD2)  右连接</span><br><span class="line">kvRDD1.fullOuterJoin(kvRDD2)   外连接</span><br><span class="line">===========subtractByKey===== 删除相同key值的数据</span><br><span class="line">kvRDD1.subtractByKey(kvRDD2)</span><br><span class="line">===============groupBy==============将RDD中每个键的值分组为单个序列</span><br><span class="line">rdd = sc.parallelize([(<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"b"</span>, <span class="number">1</span>), (<span class="string">"a"</span>, <span class="number">1</span>)])</span><br><span class="line">sorted(rdd.groupByKey().mapValues(len).collect())</span><br><span class="line">sorted(rdd.groupByKey().mapValues(list).collect())</span><br><span class="line">=================mapPartitions==============RDD的每个分区应用函数</span><br><span class="line">rdd = sc.parallelize([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">2</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(iterator)</span>:</span> <span class="keyword">yield</span> sum(iterator)</span><br><span class="line">rdd.mapPartitions(f).collect()</span><br><span class="line">=================mapValues============不更改键,对值操作</span><br><span class="line">x = sc.parallelize([(<span class="string">"a"</span>, [<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"lemon"</span>]), (<span class="string">"b"</span>, [<span class="string">"grapes"</span>])])</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span> <span class="keyword">return</span> len(x)</span><br><span class="line">x.mapValues(f).collect()</span><br><span class="line">===================zip==================</span><br><span class="line">x = sc.parallelize(range(<span class="number">0</span>,<span class="number">5</span>))</span><br><span class="line">y = sc.parallelize(range(<span class="number">1000</span>, <span class="number">1005</span>))</span><br><span class="line">x.zip(y).collect()</span><br></pre></td></tr></table></figure><h5 id="aggregate"><a href="#aggregate" class="headerlink" title="aggregate"></a>aggregate</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、&gt;&gt;&gt;  seqOp  =  ( <span class="keyword">lambda</span>  x, y: (x[ <span class="number">0</span> ]  +  y, x[ <span class="number">1</span> ]  +   <span class="number">1</span> ))</span><br><span class="line"><span class="number">2</span>、&gt;&gt;&gt;  combOp  =  ( <span class="keyword">lambda</span>  x, y: (x[ <span class="number">0</span> ]  +  y[ <span class="number">0</span> ], x[ <span class="number">1</span> ]  +  y[ <span class="number">1</span> ]))</span><br><span class="line"><span class="number">3</span>、&gt;&gt;&gt;  sc . parallelize([ <span class="number">1</span> ,  <span class="number">2</span> ,  <span class="number">3</span> ,  <span class="number">4</span> ]，<span class="number">4</span>) . aggregate(( <span class="number">0</span> ,  <span class="number">0</span> ), seqOp, combOp)</span><br><span class="line">(<span class="number">10</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">4</span>、&gt;&gt;&gt;  sc.parallelize([ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,<span class="number">5</span> ],<span class="number">3</span>).aggregate((<span class="number">1</span>,<span class="number">1</span>),seqOp,combOp)</span><br><span class="line">(<span class="number">19</span>,<span class="number">9</span>）</span><br><span class="line"></span><br><span class="line">依次解释上述函数</span><br><span class="line"><span class="number">1</span>、建立各分区内的聚集函数，又初始值依次与分区内的函数做操作</span><br><span class="line"><span class="number">2</span>、建立各分区间的组合函数</span><br><span class="line"><span class="number">3</span>、使用aggregate 样例<span class="number">1</span></span><br><span class="line"><span class="number">4</span>、使用aggregate 样例<span class="number">2</span></span><br><span class="line"></span><br><span class="line">样例<span class="number">1</span> 解释：</span><br><span class="line">分区数 ： <span class="number">4</span> </span><br><span class="line"><span class="number">0</span> ： <span class="number">1</span></span><br><span class="line"><span class="number">1</span> ： <span class="number">2</span></span><br><span class="line"><span class="number">2</span> ： <span class="number">3</span></span><br><span class="line"><span class="number">3</span> ： <span class="number">4</span></span><br><span class="line"></span><br><span class="line">利用zerovalue （0,0） 和 seqOp 对各分区进行聚集  ： ----&gt;看成x为(0,0) y为分区的</span><br><span class="line"><span class="number">0</span> ： （<span class="number">1</span>，<span class="number">1</span>）</span><br><span class="line"><span class="number">1</span> ： （<span class="number">2</span> , <span class="number">1</span>）</span><br><span class="line"><span class="number">2</span> ： （<span class="number">3</span>，<span class="number">1</span>）</span><br><span class="line"><span class="number">3</span>：  （<span class="number">4</span> , <span class="number">1</span>）</span><br><span class="line"></span><br><span class="line">利用 zerovalue和combOp 进行各分区间的聚合 ：</span><br><span class="line">（<span class="number">0</span>,<span class="number">0</span>） + （<span class="number">1</span>,<span class="number">1</span>）+ （<span class="number">2</span>,<span class="number">1</span>）+ （<span class="number">3</span>,<span class="number">1</span>）+ （<span class="number">4</span>,<span class="number">1</span>） = （<span class="number">10</span>,<span class="number">4</span>）</span><br><span class="line"></span><br><span class="line">样例<span class="number">2</span> 解释：</span><br><span class="line">分区数 ： <span class="number">3</span></span><br><span class="line"><span class="number">0</span> ： <span class="number">1</span></span><br><span class="line"><span class="number">1</span> ： <span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="number">2</span> ： <span class="number">4</span>,<span class="number">5</span></span><br><span class="line"></span><br><span class="line">利用zerovalue （<span class="number">0</span>,<span class="number">0</span>） 和 seqOp 对各分区进行聚集  ： </span><br><span class="line"><span class="number">0</span> ： (<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">1 ： (6,3)===&gt;来源(1,1)+(2,1)=(3,2)===&gt;(3,2)+(3,1)====&gt;(6,3)</span><br><span class="line"><span class="number">2</span> ： (<span class="number">10</span>,<span class="number">3</span>) </span><br><span class="line"></span><br><span class="line">利用 zerovalue和combOp 进行各分区间的聚合 ：</span><br><span class="line">(<span class="number">1</span>,<span class="number">1</span>) + (<span class="number">2</span>,<span class="number">2</span>) + (<span class="number">6</span>,<span class="number">3</span>) + (<span class="number">10</span>,<span class="number">3</span>) = (<span class="number">19</span>,<span class="number">9</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Application来说，资源是Executor。对于Executor来说资源是内存、core</span><br><span class="line"></span><br><span class="line">standalone 集群模式当前只支持一个简单的跨应用程序的 FIFO 调度。然而，为了允许多个并发的用户，您可以控制每个应用程序能用的最大资源数。默认情况下，它将获取集群中的 all cores（核），这只有在某一时刻只允许一个应用程序运行时才有意义, 因为如果此时其他的核被占用, 自然无法获取资源, 运行程序, 此时是有多少核用多少核.</span><br><span class="line"></span><br><span class="line">Spark中的调度模式主要有两种：FIFO和FAIR。</span><br><span class="line">默认情况下Spark的调度模式是FIFO（先进先出），谁先提交谁先执行，后面的任务需要等待前面的任务执行。</span><br><span class="line">而FAIR（公平调度）模式支持在调度池中为任务进行分组，不同的调度池权重不同，任务可以按照权重来决定执行顺序。</span><br></pre></td></tr></table></figure><h5 id="提交代码优化"><a href="#提交代码优化" class="headerlink" title="提交代码优化"></a>提交代码优化</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/hd-zg/p/<span class="number">6089207.</span>html 原文</span><br><span class="line">资源参数设置的不合理，可能会导致没有充分利用集群资源，作业运行会极其缓慢；或者设置的资源过大，队列没有足够的资源来提供，进而导致各种异常。总之，无论是哪种情况，都会导致Spark作业的运行效率低下，甚至根本无法运行。因此我们必须对Spark作业的资源使用原理有一个清晰的认识，并知道在Spark作业运行过程中，有哪些资源参数是可以设置的，以及如何设置合适的参数值。</span><br><span class="line"></span><br><span class="line">启动原理:</span><br><span class="line">我们使用spark-submit提交一个Spark作业之后，这个作业就会启动一个对应的Driver进程。根据你使用的部署模式（deploy-mode）不同，Driver进程可能在本地启动，也可能在集群中某个工作节点上启动。Driver进程本身会根据我们设置的参数，占有一定数量的内存和CPU core。而Driver进程要做的第一件事情，就是向集群管理器申请运行Spark作业需要使用的资源，这里的资源指的就是Executor进程。</span><br><span class="line">在申请到了作业执行所需的资源之后，Driver进程就会开始调度和执行我们编写的作业代码了。Driver进程会将我们编写的Spark作业代码分拆为多个stage，每个stage执行一部分代码片段，并为每个stage创建一批task，然后将这些task分配到各个Executor进程中执行。</span><br><span class="line">task是最小的计算单元，负责执行一模一样的计算逻辑（也就是我们自己编写的某个代码片段），只是每个task处理的数据不同而已。一个stage的所有task都执行完毕之后，会在各个节点本地的磁盘文件中写入计算中间结果，然后Driver就会调度运行下一个stage。下一个stage的task的输入数据就是上一个stage输出的中间结果。如此循环往复，直到将我们自己编写的代码逻辑全部执行完，并且计算完所有的数据，得到我们想要的结果为止。</span><br><span class="line"></span><br><span class="line">　　Spark是根据shuffle类算子来进行stage的划分。如果我们的代码中执行了某个shuffle类算子（比如reduceByKey、join等），那么就会在该算子处，划分出一个stage界限来。可以大致理解为，shuffle算子执行之前的代码会被划分为一个stage，shuffle算子执行以及之后的代码会被划分为下一个stage。因此一个stage刚开始执行的时候，它的每个task可能都会从上一个stage的task所在的节点，去通过网络传输拉取需要自己处理的所有key，然后对拉取到的所有相同的key使用我们自己编写的算子函数执行聚合操作（比如reduceByKey()算子接收的函数）。这个过程就是shuffle。</span><br><span class="line"></span><br><span class="line">--total-executor-cores参数指定用的总core数量。若不指定则会用光所有剩下的cores。</span><br><span class="line">--executor-memory</span><br><span class="line">每个executor分配内存，若超过worker可用剩余内存则不会提交给此worker，若不可提交给任意worker则报错</span><br><span class="line">--driver-memory</span><br><span class="line">--driver-cores</span><br><span class="line">--total-executor-cores</span><br></pre></td></tr></table></figure><h5 id="资源参数调优"><a href="#资源参数调优" class="headerlink" title="资源参数调优"></a>资源参数调优</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/hd-zg/p/<span class="number">6089207.</span>html</span><br><span class="line">☆☆☆☆num-executors:设置spark任务总共需要多少个Executors</span><br><span class="line">建议:一般设置<span class="number">50</span><span class="number">-100</span>个,设置太少,集群资源得不到利用.设置太大,大部分无法给与足够的资源</span><br><span class="line">☆☆☆☆☆executor-memory:每个Executor内存大小</span><br><span class="line">建议:直接决定了spark作业的性能,num-executors*executor-memory不能超过总内存,同时因为要是共享资源,所以通常是总量<span class="number">1</span>/<span class="number">3</span><span class="number">-1</span>/<span class="number">2</span></span><br><span class="line">☆☆☆☆☆executor-cores:每个executor进程的CPU核心数</span><br><span class="line">建议:num-executors * executor-cores不要超过队列总CPU core的<span class="number">1</span>/<span class="number">3</span>~<span class="number">1</span>/<span class="number">2</span></span><br><span class="line">driver-memory:设置Driver进程的内存</span><br><span class="line">建议:通常不设置或者为<span class="number">1</span>G,当报OOM内存溢出错误的时候,可能跟这个参数有关</span><br><span class="line">☆☆☆☆☆spark.default.parallelism:设置每个stage的task数量,直接影响性能</span><br><span class="line">建议:Spark作业的默认task数量为<span class="number">500</span>~<span class="number">1000</span>个较为合适,设置该参数为num-executors * executor-cores的<span class="number">2</span>~<span class="number">3</span>倍较为合适，比如Executor的总CPU core数量为<span class="number">300</span>个，那么设置<span class="number">1000</span>个task是可以的，此时可以充分地利用Spark集群的资源。</span><br><span class="line">☆☆☆spark.storage.memoryFraction:RDD持久化数据在Executor内存中可占的比例,不够时候,会写入磁盘</span><br><span class="line">建议:通常默认为<span class="number">0.6</span>,尽量大点,因为spark作业中会有很多的持久化操作,尽量避免写入磁盘</span><br><span class="line">☆☆☆spark.shuffle.memoryFraction:shuffle过程中一个task拉取到上个stage的task的输出后，进行聚合操作时能够使用的Executor内存的比例，默认是<span class="number">0.2</span></span><br><span class="line">建议:RDD持久化操作较少，shuffle操作较多时,可提高占比.避免溢出写磁盘</span><br></pre></td></tr></table></figure><h5 id="开发调优"><a href="#开发调优" class="headerlink" title="开发调优"></a>开发调优</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/u012102306/article/details/<span class="number">51322209</span></span><br><span class="line"><span class="number">1.</span>避免创建重复的RDD</span><br><span class="line"><span class="number">2.</span>尽可能复用同一个RDD</span><br><span class="line"><span class="number">3.</span>对多次使用的RDD进行持久化</span><br><span class="line">4.尽量避免使用shuffle类算子===&gt;shuffle过程，简单来说，就是将分布在集群中多个节点上的同一个key，拉取到同一个节点上，进行聚合或join等操作.===&gt;很耗时间</span><br><span class="line"><span class="number">5.</span>使用map-side预聚合的shuffle操作</span><br><span class="line"><span class="number">6.</span>使用高性能的算子</span><br><span class="line"><span class="number">7.</span>广播大变量</span><br><span class="line"><span class="number">8.</span>使用Kryo优化序列化性能</span><br><span class="line"><span class="number">9.</span>优化数据结构</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*****************************高性能的算子*******************************</span><br><span class="line">reduceByKey/aggregateByKey替代groupByKey===&gt;这样实现了现在分区按照key聚合,在整体</span><br><span class="line">使用mapPartitions替代普通map</span><br><span class="line">使用foreachPartitions替代foreach</span><br><span class="line">使用filter之后进行coalesce操作</span><br><span class="line">使用repartitionAndSortWithinPartitions替代repartition与sort类操作</span><br><span class="line"></span><br><span class="line">***********************序列化********************</span><br><span class="line">Spark默认使用的是Java的序列化机制</span><br><span class="line">Spark同时支持使用Kryo序列化库，Kryo序列化类库的性能比Java序列化类库的性能要高很多</span><br><span class="line"></span><br><span class="line">*****************************优化数据结构******************************</span><br><span class="line">尽量避免使用耗内存的数据结构如以下三种</span><br><span class="line"><span class="number">1.</span>对象</span><br><span class="line"><span class="number">2.</span>集合,如hashmap和链表等.</span><br><span class="line"><span class="number">3.</span>字符串，每个字符串内部都有一个字符数组以及长度等额外信息</span><br></pre></td></tr></table></figure><h5 id="数据倾斜调优"><a href="#数据倾斜调优" class="headerlink" title="数据倾斜调优"></a>数据倾斜调优</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">整个Spark作业的运行进度是由运行时间最长的那个task决定的。数据倾斜只会发生在shuffle过程中 </span><br><span class="line"></span><br><span class="line">现象:<span class="number">1.</span>绝大多数task执行得都非常快，但个别task执行极慢。</span><br><span class="line"> <span class="number">2.</span>某个正常运行的spark作业,突然出现oom.(内存溢出)</span><br><span class="line"> </span><br><span class="line">原理：在进行shuffle的时候，必须将各个节点上相同的key拉取到某个节点上的一个task来进行处理，比如按照key进行聚合或join等操作。</span><br><span class="line"></span><br><span class="line">会触发shuffle操作的算子：distinct、groupByKey、reduceByKey、aggregateByKey、join、cogroup、repartition等</span><br><span class="line"></span><br><span class="line">解决方案:</span><br><span class="line"></span><br><span class="line">解决方案<span class="number">1</span>:过滤少数导致倾斜的key</span><br><span class="line">将导致数据倾斜的key给过滤掉之后，这些key就不会参与计算了，自然不可能产生数据倾斜。</span><br><span class="line">前提:发现导致倾斜的key就少数几个，而且对计算本身的影响并不大的话，那么很适合使用这种方案</span><br><span class="line">优点：实现简单，而且效果也很好，可以完全规避掉数据倾斜。</span><br><span class="line">缺点：适用场景不多，大多数情况下，导致倾斜的key还是很多的，并不是只有少数几个。</span><br><span class="line"></span><br><span class="line">解决方案<span class="number">2</span>:提高shuffle操作的并行度</span><br><span class="line">建议优先使用这种方案，因为这是处理数据倾斜最简单的一种方案</span><br><span class="line">在对RDD执行shuffle算子时，给shuffle算子传入一个参数，比如reduceByKey(<span class="number">1000</span>)，该参数就设置了这个shuffle算子执行时shuffle read task的数量。对于Spark SQL中的shuffle类语句，比如group by、join等，需要设置一个参数，即spark.sql.shuffle.partitions，该参数代表了shuffle read task的并行度，该值默认是<span class="number">200</span>，对于很多场景来说都有点过小。</span><br><span class="line">原理:更多的task分配更多的key,避免集中.</span><br><span class="line">方案优点：实现起来比较简单，可以有效缓解和减轻数据倾斜的影响。</span><br><span class="line">         方案缺点：只是缓解了数据倾斜而已，没有彻底根除问题，根据实践经验来看，其效果有限。</span><br><span class="line">         </span><br><span class="line">解决方案3:两阶段聚合=====&gt;适用于聚合类shuffle</span><br><span class="line">（局部聚合+全局聚合）</span><br><span class="line">原理:分次聚合,将原本相同的key通过附加随机前缀的方式，变成多个不同的key</span><br><span class="line">方案优点：对于聚合类的shuffle操作导致的数据倾斜，效果是非常不错的。通常都可以解决掉数据倾斜，或者至少是大幅度缓解数据倾斜，将Spark作业的性能提升数倍以上。</span><br><span class="line">      方案缺点：仅仅适用于聚合类的shuffle操作，适用范围相对较窄。如果是join类的shuffle操作，还得用其他的解决方案</span><br><span class="line">案例:比如(hello, <span class="number">1</span>) (hello, <span class="number">1</span>) (hello, <span class="number">1</span>) (hello, <span class="number">1</span>)，就会变成(<span class="number">1</span>_hello, <span class="number">1</span>) (<span class="number">1</span>_hello, <span class="number">1</span>) (<span class="number">2</span>_hello, <span class="number">1</span>) (<span class="number">2</span>_hello, <span class="number">1</span>)。接着对打上随机数后的数据，执行reduceByKey等聚合操作，进行局部聚合，那么局部聚合结果，就会变成了(<span class="number">1</span>_hello, <span class="number">2</span>) (<span class="number">2</span>_hello, <span class="number">2</span>)。</span><br><span class="line"></span><br><span class="line">解决方案4:将reduce join转为map join======&gt;join</span><br><span class="line">join操作中的一个RDD或表的数据量比较小（比如几百M或者一两G）</span><br><span class="line">原理:普通的join是会走shuffle过程的，而一旦shuffle，就相当于会将相同key的数据拉取到一个shuffle read task中再进行join，此时就是reduce join。但是如果一个RDD是比较小的，则可以采用广播小RDD全量数据+map算子来实现与join同样的效果，也就是map join.</span><br><span class="line">方案优点：对join操作导致的数据倾斜，效果非常好，因为根本就不会发生shuffle，也就根本不会发生数据倾斜。</span><br><span class="line">方案缺点：适用场景较少，因为这个方案只适用于一个大表和一个小表的情况。毕竟我们需要将小表进行广播，此时会比较消耗内存资源，driver和每个Executor内存中都会驻留一份小RDD的全量数据。如果我们广播出去的RDD数据比较大，比如<span class="number">10</span>G以上，那么就可能发生内存溢出了。因此并不适合两个都是大表的情况。</span><br><span class="line">    </span><br><span class="line">    解决方案5:采样倾斜key并分拆join操作======&gt;join</span><br><span class="line">一个表的key较均匀,而另外一个表的少数几个key数据量较大</span><br><span class="line">实现思路:对包含少数几个数据量过大的key的那个RDD，通过sample算子采样出一份样本来，然后统计一下每个key的数量，计算出来数据量最大的是哪几个key。</span><br><span class="line">然后将这几个key对应的数据从原来的RDD中拆分出来，形成一个单独的RDD，并给每个key都打上n以内的随机数作为前缀，而不会导致倾斜的大部分key形成另外一个RDD。</span><br><span class="line">接着将需要join的另一个RDD，也过滤出来那几个倾斜key对应的数据并形成一个单独的RDD，将每条数据膨胀成n条数据，这n条数据都按顺序附加一个<span class="number">0</span>~n的前缀，不会导致倾斜的大部分key也形成另外一个RDD。</span><br><span class="line">再将附加了随机前缀的独立RDD与另一个膨胀n倍的独立RDD进行join，此时就可以将原先相同的key打散成n份，分散到多个task中去进行join了。</span><br><span class="line">而另外两个普通的RDD就照常join即可。</span><br><span class="line">最后将两次join的结果使用union算子合并起来即可，就是最终的join结果</span><br><span class="line">方案优点：对于join导致的数据倾斜，如果只是某几个key导致了倾斜，采用该方式可以用最有效的方式打散key进行join。而且只需要针对少数倾斜key对应的数据进行扩容n倍，不需要对全量数据进行扩容。避免了占用过多内存。</span><br><span class="line">      方案缺点：如果导致倾斜的key特别多的话，比如成千上万个key都导致数据倾斜，那么这种方式也不适合。</span><br><span class="line">      </span><br><span class="line">      解决方案6:使用随机前缀和扩容RDD进行join ======&gt;join</span><br><span class="line">        如果在进行join操作时，RDD中有大量的key导致数据倾斜，那么进行分拆key也没什么意义</span><br><span class="line">        实现思路:首先查看RDD/Hive表中的数据分布情况，找到那个造成数据倾斜的RDD/Hive表，比如有多个key都对应了超过<span class="number">1</span>万条数据。</span><br><span class="line">然后将该RDD的每条数据都打上一个n以内的随机前缀。</span><br><span class="line">同时对另外一个正常的RDD进行扩容，将每条数据都扩容成n条数据，扩容出来的每条数据都依次打上一个<span class="number">0</span>~n的前缀。</span><br><span class="line">最后将两个处理后的RDD进行join即可。</span><br><span class="line"> 原理:将原先一样的key通过附加随机前缀变成不一样的key，然后就可以将这些处理后的“不同key”分散到多个task中去处理，而不是让一个task处理大量的相同key。</span><br><span class="line"> 方案优点：对join类型的数据倾斜基本都可以处理，而且效果也相对比较显著，性能提升效果非常不错。</span><br><span class="line">        方案缺点：该方案更多的是缓解数据倾斜，而不是彻底避免数据倾斜。而且需要对整个RDD进行扩容，对内存资源要求很高。</span><br><span class="line">     </span><br><span class="line">     解决方案<span class="number">7</span>:多种方案组合使用</span><br><span class="line">     如果只是处理较为简单的数据倾斜场景，那么使用上述方案中的某一种基本就可以解决。但是如果要处理一个较为复杂的数据倾斜场景，那么可能需要将多种方案组合起来使用</span><br></pre></td></tr></table></figure><h5 id="shuffle调优-gt-相比其他三个较为次要"><a href="#shuffle调优-gt-相比其他三个较为次要" class="headerlink" title="shuffle调优====&gt;相比其他三个较为次要"></a>shuffle调优====&gt;相比其他三个较为次要</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  大多数Spark作业的性能主要就是消耗在了shuffle环节，因为该环节包含了大量的磁盘IO、序列化、网络数据传输等操作。</span><br><span class="line">spark.shuffle.file.buffer</span><br><span class="line">    默认值：<span class="number">32</span>k</span><br><span class="line">    参数说明：该参数用于设置shuffle write task的BufferedOutputStream的buffer缓冲大小。将数据写到磁盘文件之前，会先写入buffer缓冲中，待缓冲写满之后，才会溢写到磁盘。</span><br><span class="line">    调优建议：如果作业可用的内存资源较为充足的话，可以适当增加这个参数的大小（比如<span class="number">64</span>k），从而减少shuffle write过程中溢写磁盘文件的次数，也就可以减少磁盘IO次数，进而提升性能。在实践中发现，合理调节该参数，性能会有<span class="number">1</span>%~<span class="number">5</span>%的提升。</span><br><span class="line">    </span><br><span class="line">spark.reducer.maxSizeInFlight</span><br><span class="line">    默认值：<span class="number">48</span>m</span><br><span class="line">    参数说明：该参数用于设置shuffle read task的buffer缓冲大小，而这个buffer缓冲决定了每次能够拉取多少数据。</span><br><span class="line">    调优建议：如果作业可用的内存资源较为充足的话，可以适当增加这个参数的大小（比如<span class="number">96</span>m），从而减少拉取数据的次数，也就可以减少网络传输的次数，进而提升性能。在实践中发现，合理调节该参数，性能会有<span class="number">1</span>%~<span class="number">5</span>%的提升。   </span><br><span class="line"></span><br><span class="line">spark.shuffle.io.retryWait</span><br><span class="line">    默认值：<span class="number">5</span>s</span><br><span class="line">    参数说明：具体解释同上，该参数代表了每次重试拉取数据的等待间隔，默认是<span class="number">5</span>s。</span><br><span class="line">    调优建议：建议加大间隔时长（比如<span class="number">60</span>s），以增加shuffle操作的稳定性。    </span><br><span class="line">    </span><br><span class="line">spark.shuffle.memoryFraction</span><br><span class="line">    默认值：<span class="number">0.2</span></span><br><span class="line">    参数说明：该参数代表了Executor内存中，分配给shuffle read task进行聚合操作的内存比例，默认是<span class="number">20</span>%。</span><br><span class="line">    调优建议：在资源参数调优中讲解过这个参数。如果内存充足，而且很少使用持久化操作，建议调高这个比例，给shuffle read的聚合操作更多内存，以避免由于内存不足导致聚合过程中频繁读写磁盘。在实践中发现，合理调节该参数可以将性能提升<span class="number">10</span>%左右。</span><br><span class="line">    </span><br><span class="line">spark.shuffle.manager</span><br><span class="line">    默认值：sort</span><br><span class="line">    参数说明：该参数用于设置ShuffleManager的类型。Spark <span class="number">1.5</span>以后，有三个可选项：hash、sort和tungsten-sort。HashShuffleManager是Spark <span class="number">1.2</span>以前的默认选项，但是Spark <span class="number">1.2</span>以及之后的版本默认都是SortShuffleManager了。tungsten-sort与sort类似，但是使用了tungsten计划中的堆外内存管理机制，内存使用效率更高。</span><br><span class="line">    调优建议：由于SortShuffleManager默认会对数据进行排序，因此如果你的业务逻辑中需要该排序机制的话，则使用默认的SortShuffleManager就可以；而如果你的业务逻辑不需要对数据进行排序，那么建议参考后面的几个参数调优，通过bypass机制或优化的HashShuffleManager来避免排序操作，同时提供较好的磁盘读写性能。这里要注意的是，tungsten-sort要慎用，因为之前发现了一些相应的bug。</span><br><span class="line">    </span><br><span class="line">spark.shuffle.sort.bypassMergeThreshold</span><br><span class="line">    默认值：<span class="number">200</span></span><br><span class="line">    参数说明：当ShuffleManager为SortShuffleManager时，如果shuffle read task的数量小于这个阈值（默认是<span class="number">200</span>），则shuffle write过程中不会进行排序操作，而是直接按照未经优化的HashShuffleManager的方式去写数据，但是最后会将每个task产生的所有临时磁盘文件都合并成一个文件，并会创建单独的索引文件。</span><br><span class="line">    调优建议：当你使用SortShuffleManager时，如果的确不需要排序操作，那么建议将这个参数调大一些，大于shuffle read task的数量。那么此时就会自动启用bypass机制，map-side就不会进行排序了，减少了排序的性能开销。但是这种方式下，依然会产生大量的磁盘文件，因此shuffle write性能有待提高。    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spark.shuffle.consolidateFiles</span><br><span class="line">    默认值：false</span><br><span class="line">    参数说明：如果使用HashShuffleManager，该参数有效。如果设置为true，那么就会开启consolidate机制，会大幅度合并shuffle write的输出文件，对于shuffle read task数量特别多的情况下，这种方法可以极大地减少磁盘IO开销，提升性能。</span><br><span class="line">    调优建议：如果的确不需要SortShuffleManager的排序机制，那么除了使用bypass机制，还可以尝试将spark.shffle.manager参数手动指定为hash，使用HashShuffleManager，同时开启consolidate机制。在实践中尝试过，发现其性能比开启了bypass机制的SortShuffleManager要高出<span class="number">10</span>%~<span class="number">30</span>%。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from pyspark.sql.functions import pandas_udf, PandasUDFType</span><br><span class="line">&gt;&gt;&gt; df = spark.createDataFrame(</span><br><span class="line">...     [(1, 1.0), (1, 2.0), (2, 3.0), (2, 5.0), (2, 10.0)],</span><br><span class="line">...     (&quot;id&quot;, &quot;v&quot;))</span><br><span class="line">&gt;&gt;&gt; :pandas_udf(&quot;id long, v double&quot;, PandasUDFType.GROUPED_MAP)  # doctest: +SKIP</span><br><span class="line">... def normalize(pdf):</span><br><span class="line">...     v = pdf.v</span><br><span class="line">...     return pdf.assign(v=(v - v.mean()) / v.std())</span><br><span class="line">&gt;&gt;&gt; df.groupby(&quot;id&quot;).apply(normalize).show()  # doctest: +SKIP</span><br></pre></td></tr></table></figure><h2 id="下面是使用RDD的场景和常见案例："><a href="#下面是使用RDD的场景和常见案例：" class="headerlink" title="下面是使用RDD的场景和常见案例："></a>下面是使用RDD的场景和常见案例：</h2><ul><li>你希望可以对你的数据集进行最基本的转换、处理和控制；</li><li>你的数据是非结构化的，比如流媒体或者字符流；</li><li>你不希望像进行列式处理一样定义一个模式，通过名字或字段来处理或访问数据属性；</li><li>你并不在意通过DataFrame和Dataset进行结构化和半结构化数据处理所能获得的一些优化和性能上的好处；</li></ul><h2 id="该什么时候使用DataFrame或Dataset呢？"><a href="#该什么时候使用DataFrame或Dataset呢？" class="headerlink" title="该什么时候使用DataFrame或Dataset呢？"></a>该什么时候使用DataFrame或Dataset呢？</h2><ul><li><p>如果你需要丰富的语义、高级抽象和特定领域专用的API，那就使用DataFrame或Dataset；</p></li><li><p>如果你的处理需要对半结构化数据进行高级处理，如filter、map、aggregation、average、sum、SQL查询、列式访问或使用lambda函数，那就使用DataFrame或Dataset；</p></li><li><p>如果你想在编译时就有高度的类型安全，想要有类型的JVM对象，用上Catalyst优化，并得益于Tungsten生成的高效代码，那就使用Dataset；</p></li><li><p>如果你想在不同的Spark库之间使用一致和简化的API，那就使用DataFrame或Dataset；</p></li><li><p>如果你是R语言使用者，就用DataFrame；</p></li><li><p>如果你是Python语言使用者，就用DataFrame，在需要更细致的控制时就退回去使用RDD；</p><p>​</p></li></ul><p>DataFrame与RDD相同之处，都是不可变分布式弹性数据集。不同之处在于，DataFrame的数据集都是按指定列存储，即结构化数据。相似于传统数据库中的表。DataFrame的设计是为了让大数据解决起来更容易。</p><p>RDD适合需要low-level函数式编程和操作数据集的情况；DataFrame和Dataset适合结构化数据集，用high-level和特定领域语言(DSL)编程，空间效率高和速度快。</p><h5 id="在正常情况下都不推荐使用-RDD-算子"><a href="#在正常情况下都不推荐使用-RDD-算子" class="headerlink" title="在正常情况下都不推荐使用 RDD 算子"></a>在正常情况下都不推荐使用 RDD 算子</h5><ul><li>在某种抽象层面来说，使用 RDD 算子编程相当于直接使用最底层的 Java API 进行编程</li><li>RDD 算子与 SQL、DataFrame API 和 DataSet API 相比，<strong>更偏向于如何做，而非做什么</strong>，这样优化的空间很少</li><li>RDD 语言不如 SQL 语言友好</li></ul><h5 id="仅在一些特殊情况下可以使用-RDD"><a href="#仅在一些特殊情况下可以使用-RDD" class="headerlink" title="仅在一些特殊情况下可以使用 RDD"></a>仅在一些特殊情况下可以使用 RDD</h5><ul><li>你希望可以对你的数据集进行最基本的转换、处理和控制；</li><li>你的数据是非结构化的，比如流媒体或者字符流；</li><li>你想通过函数式编程而不是特定领域内的表达来处理你的数据；</li><li>你不希望像进行列式处理一样定义一个模式，通过名字或字段来处理或访问数据属性（更高层次抽象）；</li><li>你并不在意通过 DataFrame 和 Dataset 进行结构化和半结构化数据处理所能获得的一些优化和性能上的好处；</li></ul><h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h3><p>与 RDD 相似，DataFrame 也是数据的一个不可变分布式集合。但与 RDD 不同的是，数据都被组织到有名字的列中，就像关系型数据库中的表一样。设计 DataFrame 的目的就是要让对大型数据集的处理变得更简单，它让开发者可以为分布式的数据集指定一个模式，进行更高层次的抽象。它提供了特定领域内专用的 API 来处理你的分布式数据，并让更多的人可以更方便地使用 Spark，而不仅限于专业的数据工程师。</p><p>Spark 2.0 中，DataFrame 和 Dataset 的 API 融合到一起，完成跨函数库的数据处理能力的整合。在整合完成之后，开发者们就不必再去学习或者记忆那么多的概念了，可以通过一套名为 Dataset 的高级并且类型安全的 API 完成工作。</p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">driver主要负责向excetuor分发task和代码,负责计算的调度,cluster manager负责资源的调度(可以是standalone,yarn,mesos),driver会向cluster申请资源</span><br><span class="line"></span><br><span class="line">executor负责代码的执行,内部包含很多个executor进程,每个stage计算完成后会将结果写入磁盘进行存储,输入下一个stage,stage的划分是按照shuffle算子</span><br><span class="line"></span><br><span class="line">driver:主要功能是创建sparkcontext,是一切程序的入口,同时负责和clustermanager进行通信,进行资源的申请和任务的分配,当所有任务完成后会将sparkcontext关闭</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xgboost算法</title>
      <link href="/2020/12/30/Xgboost%E7%AE%97%E6%B3%95/"/>
      <url>/2020/12/30/Xgboost%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>Xgboost本质上还是GBDT(梯度提升树),Xgboost算法是对GBDT算法的改进</span><br><span class="line"><span class="number">2.</span>Xgboost是Boosting算法的其中一种，Boosting算法的思想是将许多弱分类器集成在一起，形成一个强分类器。因为Xgboost是一种提升树模型，所以它是将许多树模型集成在一起，形成一个很强的分类器。而所用到的树模型则是CART回归树模型</span><br><span class="line"><span class="number">3.</span>xgboost中的基学习器除了可以是CART也可以是线性分类器</span><br><span class="line"><span class="number">4.</span>做二分类的时候输出的是模型预测的所有概率中最大的那个值(连续值中取概率最大的)</span><br><span class="line">xgboost即可以做回归也可以做分类,但是通常都是做回归</span><br><span class="line">5.用到了加法模型和前项分布算法(每次只学习一个基函数及系数，逐步逼近最优解),--&gt;将同时求所有树的参数问题转换成求每个树</span><br><span class="line"><span class="number">6.</span>用二阶导数会收敛的更快,从一维向量到二维矩阵,再往后不成熟(张量),算起来慢点</span><br><span class="line">单一的回归树不够--&gt;boosting框架--&gt;回归树改良,GBDT--&gt;进一步提升,Xgboost</span><br></pre></td></tr></table></figure><h3 id="机器学习常用名词解释"><a href="#机器学习常用名词解释" class="headerlink" title="机器学习常用名词解释"></a>机器学习常用名词解释</h3><p>正则化: 向你的模型加入某些规则，加入先验，缩小解空间，减小求出错误解的可能性,有效防止过拟合</p><p>超参数: 是人为设置值的参数，而不是通过训练得到的参数数据，如学习率</p><p>稀疏数据: 数据框中绝大多数数值缺失或者为零的数据,类推稀疏矩阵</p><p>离散数据(变量):指其数值只能用自然数或整数单位计算.例如,企业个数,职工人数,设备台数等,只能按计量单位数计数</p><p>连续数据(变量):指在一定区间内可以任意取值，相邻的两个数值可作无限分割(即可取无限个值)。比如身高，身高可以是183，也可以是183.1，也可以是183.111……1</p><p>离散特征：其数值只能用自然数来表示，只能用计量单位统计，如个数，人数等</p><p>连续特征：是按测量或者计量方法得到。连续特征是指在一段长度内可以任意获得的特征，其数值是不间断。比如[0,1]之间的数，可以取n个数。</p><p>总之，记住，离散只能用自然数表示，是统计得到的。连续是按测量或者计量到得到数，比如各种传感器采集得到的数。</p><p>核外计算: (内存外计算),大数据的数据规模下，一次性把训练数据导到内存里面计算是不实际的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">三个计算级别：（速度越来越慢，数据量越来越大）</span><br><span class="line">内存里（核内）</span><br><span class="line">内存外（核外）</span><br></pre></td></tr></table></figure><p>分布式 spark，Hadoop方面<br>其他:待补充</p><h3 id="Cart分类树和回归树实现原理"><a href="#Cart分类树和回归树实现原理" class="headerlink" title="Cart分类树和回归树实现原理"></a>Cart分类树和回归树实现原理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">决策树三种方式:ID3(信息增益)   C4<span class="number">.5</span>(信息增益率)  Cart(基尼指数)</span><br><span class="line">二叉</span><br><span class="line">Cart分类树</span><br><span class="line">离散特征:(CART的处理思想与C4<span class="number">.5</span>是相同的，即将连续特征值离散化）</span><br><span class="line"><span class="number">1.</span>训练数据集为D,计算现有特征对训练数据集的基尼指数，此时对于每一个特征A,对其可能取得每一个值a，根据此值将训练样本切分为D1和D2两部分，然后根据上式计算A=a基尼指数</span><br><span class="line"><span class="number">2.</span>在所有可能的特征以及所有可能的值里面选择基尼指数最小的特征及其切分点作为最优的特征及切分点，从结点生成两个子结点，将训练数据集分配到子结点中去</span><br><span class="line"><span class="number">3.</span>递归的调用<span class="number">1</span> <span class="number">2</span> 直到满足停止的条件</span><br><span class="line"><span class="number">4.</span>生成分类决策树</span><br><span class="line">Cart回归树</span><br><span class="line">连续特征:</span><br><span class="line"><span class="number">1.</span>训练数据集为D,依次遍历每个特征，以及该特征的每个取值，计算每个切分点的损失函数(平方损失)，选择损失函数最小的切分点,y为每个数值,y^为划分的左右两边各自的均值</span><br><span class="line"><span class="number">2.</span>递归的调用<span class="number">1</span>直到满足停止的条件</span><br><span class="line">树停止条件:</span><br><span class="line"><span class="number">1.</span>只有一个元素,或者元素全部相同时</span><br><span class="line"><span class="number">2.</span>达到设置的最大深度</span><br><span class="line"><span class="number">3.</span>特征已经划分完</span><br><span class="line"><span class="number">4.</span>样本个数小于预定阀值</span><br><span class="line">二者区别:</span><br><span class="line"><span class="number">1.</span>分类树与回归树的区别在样本的输出，如果样本输出是离散值，这是分类树；样本输出是连续值，这是回归树。分类树的输出是样本的类别，回归树的输出是一个实数。</span><br><span class="line"><span class="number">2.</span>连续值的处理方法不同。</span><br><span class="line"><span class="number">3.</span>决策树建立后做预测的方式不同。</span><br><span class="line">分类模型：采用基尼系数的大小度量特征各个划分点的优劣。</span><br><span class="line">回归模型：平方误差最小准则</span><br><span class="line">对于决策树建立后做预测的方式，CART分类树采用叶子节点里概率最大的类别作为当前节点的预测类别。回归树输出不是类别，采用叶子节点的均值或者中位数来预测输出结果。</span><br><span class="line">剪枝策略:(解决过拟合)</span><br><span class="line">预剪枝:在节点划分前来确定是否继续增长,是否继续划分----&gt;降低过拟合,减少训练时间,存在欠拟风险</span><br><span class="line">方法:<span class="number">1.</span>节点内数据样本低于某一阈值</span><br><span class="line"><span class="number">2.</span>所有节点特征都已分裂</span><br><span class="line"><span class="number">3.</span>节点划分前准确率比节点划分后准确率高</span><br><span class="line">后剪枝:创建完整的决策树，然后再尝试消除多余的节点，也就是采用减枝的方法</span><br><span class="line">区别:</span><br><span class="line">预剪枝:运算量小,但是不一定精准,欠拟合风险大</span><br><span class="line">后剪枝:运算量大,比较精准,欠拟合风险小</span><br></pre></td></tr></table></figure><h2 id="2-Xgboost的优点"><a href="#2-Xgboost的优点" class="headerlink" title="2.Xgboost的优点"></a>2.Xgboost的优点</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>正则化项防止过拟合</span><br><span class="line"><span class="number">2.</span>xgboost不仅使用到了一阶导数，还使用二阶导数，损失更精确</span><br><span class="line"><span class="number">3.</span>XGBoost的并行优化，XGBoost的并行是在特征粒度上的</span><br><span class="line"><span class="number">4.</span>考虑了训练数据为稀疏值的情况，可以为缺失值或者指定的值指定分支的默认方向，这能大大提升算法的效率</span><br><span class="line"><span class="number">5.</span>列抽样。xgboost借鉴了随机森林的做法，支持列抽样，不仅能降低过拟合，还能减少计算，这也是xgboost异于传统gbdt的一个特性。</span><br><span class="line"><span class="number">6.</span>一种新颖的用于处理稀疏数据的树学习算法</span><br><span class="line"><span class="number">7.</span>XGBoost利用了核外计算</span><br></pre></td></tr></table></figure><h4 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h4><p>内容:包含L1正则化、L2正则化</p><p>以线性回归为例</p><p><img src="/2020/12/30/Xgboost算法/rfPdE6XjKkJbtrML__thumbnail.png" alt="img">L1正则化</p><p><img src="/2020/12/30/Xgboost算法/ws67LEPoFTyvj9vp__thumbnail.png" alt="图片">L2正则化</p><p>L1正则化最大的特点是能生成稀疏矩阵(主要用于特征选择,0和非0)</p><p>L2正则能够有效的防止模型过拟合</p><p>作用:解决过拟合,降低模型复杂度,防止参数过大(限制模型的参数)</p><p>正则化能实现过拟合原因:</p><p>1.作为惩罚项,惩罚特征权重w,当λ越大w越小,权重影响越小</p><p>2.直观的理解，如果我们的正则化系数λ无穷大，则权重w就会趋近于0。权重变小，非线性程度自然就降低了</p><p>## </p><h2 id="3-Xgboost与GBDT的区别"><a href="#3-Xgboost与GBDT的区别" class="headerlink" title="3.Xgboost与GBDT的区别"></a>3.Xgboost与GBDT的区别</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GBDT:梯度提升算法利用损失函数的负梯度作为残差拟合的方式，如果其中的基函数采用决策树的话，就得到了梯度提升决策树</span><br><span class="line"><span class="number">1.</span>XGBoost对损失函数做了二阶泰勒展开,GBDT只用了一阶导数信息.并且在损失函数一阶,二阶可导的条件下XGBoost可以自定义损失函数。</span><br><span class="line"><span class="number">2.</span>XGBoost的目标函数加了正则项，相当于预剪枝，使得学习出来的模型更加不容易过拟合。</span><br><span class="line"><span class="number">3.</span>XGBoost支持列抽样，与随机森林类似，用于防止过拟合</span><br><span class="line">对树中的每个非叶子节点，XGBoost可以自动学习出它的默认分裂方向。如果某个样本该特征值确缺失，会将其划入默认分支。</span><br><span class="line"><span class="number">4.</span>XGBoost支持特征维度的并行</span><br></pre></td></tr></table></figure><h4 id="拟合残差-最后结果相加就是预测的"><a href="#拟合残差-最后结果相加就是预测的" class="headerlink" title="拟合残差:最后结果相加就是预测的"></a>拟合残差:最后结果相加就是预测的</h4><p><img src="/2020/12/30/Xgboost算法/8gE0ZOi1q2goy1Aj__thumbnail.png" alt="图片"></p><h2 id="4-算法的实现过程"><a href="#4-算法的实现过程" class="headerlink" title="4.算法的实现过程"></a>4.算法的实现过程</h2><p><img src="/2020/12/30/Xgboost算法/hEObUuFtGB7eReAB__thumbnail.png" alt="图片"></p><p>分别代表训练损失和树的复杂度</p><p><img src="/2020/12/30/Xgboost算法/6q821lMeAb4x1j8u__thumbnail.png" alt="图片"></p><p><img src="https://uploader.shimo.im/f/lV1W4JNWoVACOJkz.png!thumbnail" alt="图片"></p><p>前t-1颗树的结构已经确定,认定为常数</p><p><img src="/2020/12/30/Xgboost算法/1MMcolaV0NYJyU8l__thumbnail.png" alt="图片"></p><p><img src="/2020/12/30/Xgboost算法/SCywmucLREpDjbsl__thumbnail.png" alt="图片">表示损失函数,如平方损失<img src="/2020/12/30/Xgboost算法/ZARlOwoammWYFWlB__thumbnail.png" alt="图片"></p><p><img src="/2020/12/30/Xgboost算法/UN8xNIJsdrizNrRk__thumbnail.png" alt="图片">表示正则化项,考虑树的复杂度,防止过拟合</p><p><img src="/2020/12/30/Xgboost算法/jfItMoUlzSDD5Gfb__thumbnail.png" alt="图片"></p><p><img src="/2020/12/30/Xgboost算法/WCtd8UsozGyp85rH__thumbnail.png" alt="图片">表示常数项</p><p>损失函数使用平方损失</p><p>平方损失函数有许多友好的地方，它具有一阶项（通常称为残差）和二次项。对于其他形式的损失函数，并不容易获得这么好的形式</p><p><img src="/2020/12/30/Xgboost算法/O8LU9a7dWJ9y7gwB__thumbnail.png" alt="图片"></p><p>损失函数不是平方损失</p><p>泰勒二阶展开</p><p><img src="/2020/12/30/Xgboost算法/FGnIHMvJHKG6kQyG__thumbnail.png" alt="图片"></p><p><img src="/2020/12/30/Xgboost算法/1FuD6CCv2dYBa6ik__thumbnail.png" alt="图片"></p><p><img src="/2020/12/30/Xgboost算法/lkXFvALpsItdsp4B__thumbnail.png" alt="图片"></p><p><img src="/2020/12/30/Xgboost算法/WzlgYR0TZQVCwbJp__thumbnail.png" alt="图片"></p><p>代入原公式:</p><p><img src="/2020/12/30/Xgboost算法/83NixqoNNEei4Pq8__thumbnail.png" alt="图片"></p><p>化简树结构</p><p>定义一棵树q(x)为输入x然后输出叶子结点索引,w为叶子结点向量</p><p><img src="/2020/12/30/Xgboost算法/VsfD8pLvsEW0u1ut__thumbnail.png" alt="图片"></p><p><img src="/2020/12/30/Xgboost算法/dFzv0FKNbK5PjhQw__thumbnail.png" alt="图片"></p><p>树的复杂度</p><p><img src="/2020/12/30/Xgboost算法/hm3Pz6ZBBtbq2sJK__thumbnail.png" alt="图片"></p><p><img src="/2020/12/30/Xgboost算法/GOvYXKYNO3HeMHBm__thumbnail.png" alt="图片"></p><p><img src="/2020/12/30/Xgboost算法/xmQKq1cD2GPjJanC__thumbnail.png" alt="图片"></p><p><img src="/2020/12/30/Xgboost算法/dgUvH4IiDkPEqYun__thumbnail.png" alt="图片"></p><p>这样就将样本累加操作转换为叶子节点的操作</p><p>Gj 表示映射为叶子节点 j 的所有输入样本的一阶导之和</p><p>G和H都是常数，那么这个问题就变成了一个二次问题了，求解最小值</p><p><img src="/2020/12/30/Xgboost算法/PuCNXc1brXYjEuXq__thumbnail.png" alt="图片"></p><p>#### </p><h2 id="5-Xgboost的实现-案例-回归预测房价"><a href="#5-Xgboost的实现-案例-回归预测房价" class="headerlink" title="5.Xgboost的实现(案例:回归预测房价)"></a>5.Xgboost的实现(案例:回归预测房价)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">train=pd.read_csv(<span class="string">r'C:\Users\Administrator\Desktop\train.csv'</span>, header=<span class="number">0</span>)</span><br><span class="line">test=pd.read_csv(<span class="string">r'C:\Users\Administrator\Desktop/test.csv'</span>, header=<span class="number">0</span>)</span><br><span class="line">c_test  = test.copy()</span><br><span class="line">c_train  = train.copy()</span><br><span class="line">c_train[<span class="string">'train'</span>]  = <span class="number">1</span></span><br><span class="line">c_test[<span class="string">'train'</span>]  = <span class="number">0</span></span><br><span class="line">df = pd.concat([c_train, c_test], axis=<span class="number">0</span>,sort=<span class="literal">False</span>)</span><br><span class="line">NAN = [(c, df[c].isna().m                                                                 ean()*<span class="number">100</span>) <span class="keyword">for</span> c <span class="keyword">in</span> df]</span><br><span class="line">NAN = pd.DataFrame(NAN, columns=[<span class="string">"column_name"</span>, <span class="string">"percentage"</span>])</span><br><span class="line">NAN = NAN[NAN.percentage &gt; <span class="number">50</span>]</span><br><span class="line">NAN.sort_values(<span class="string">"percentage"</span>, ascending=<span class="literal">False</span>)<span class="comment">#得到缺失率超过50%的字段</span></span><br><span class="line">df = df.drop([<span class="string">'Alley'</span>,<span class="string">'PoolQC'</span>,<span class="string">'Fence'</span>,<span class="string">'MiscFeature'</span>],axis=<span class="number">1</span>)</span><br><span class="line">object_columns_df = df.select_dtypes(include=[<span class="string">'object'</span>])</span><br><span class="line">numerical_columns_df =df.select_dtypes(exclude=[<span class="string">'object'</span>])</span><br><span class="line">null_counts = object_columns_df.isnull().sum() <span class="comment">#object数据中每个特征空值的数量</span></span><br><span class="line">columns_None = [<span class="string">'BsmtQual'</span>,<span class="string">'BsmtCond'</span>,<span class="string">'BsmtExposure'</span>,<span class="string">'BsmtFinType1'</span>,<span class="string">'BsmtFinType2'</span>,<span class="string">'GarageType'</span>,<span class="string">'GarageFinish'</span>,<span class="string">'GarageQual'</span>,<span class="string">'FireplaceQu'</span>,<span class="string">'GarageCond'</span>]</span><br><span class="line">object_columns_df[columns_None]= object_columns_df[columns_None].fillna(<span class="string">'None'</span>)</span><br><span class="line">columns_with_lowNA = [<span class="string">'MSZoning'</span>,<span class="string">'Utilities'</span>,<span class="string">'Exterior1st'</span>,<span class="string">'Exterior2nd'</span>,<span class="string">'MasVnrType'</span>,<span class="string">'Electrical'</span>,<span class="string">'KitchenQual'</span>,<span class="string">'Functional'</span>,<span class="string">'SaleType'</span>]</span><br><span class="line">object_columns_df[columns_with_lowNA] = object_columns_df[columns_with_lowNA].fillna(object_columns_df.mode().iloc[<span class="number">0</span>]) <span class="comment">#object_columns_df.mode()返回频数最高的</span></span><br><span class="line">null_counts = numerical_columns_df.isnull().sum()</span><br><span class="line"><span class="comment">#YearBuilt无空值</span></span><br><span class="line">print((numerical_columns_df[<span class="string">'YrSold'</span>]-numerical_columns_df[<span class="string">'YearBuilt'</span>]).median()) <span class="comment">#35</span></span><br><span class="line">print(numerical_columns_df[<span class="string">"LotFrontage"</span>].median()) <span class="comment">#68</span></span><br><span class="line">numerical_columns_df[<span class="string">'GarageYrBlt'</span>] = numerical_columns_df[<span class="string">'GarageYrBlt'</span>].fillna(numerical_columns_df[<span class="string">'YrSold'</span>]<span class="number">-35</span>)</span><br><span class="line">numerical_columns_df[<span class="string">'LotFrontage'</span>] = numerical_columns_df[<span class="string">'LotFrontage'</span>].fillna(<span class="number">68</span>)</span><br><span class="line">numerical_columns_df= numerical_columns_df.fillna(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#作图找出方差小的特征,将他们删除(方差小,离散程度低,特征无明显区分左右,故删除)</span></span><br><span class="line">object_columns_df[<span class="string">'Utilities'</span>].value_counts().plot(kind=<span class="string">'bar'</span>,figsize=[<span class="number">10</span>,<span class="number">3</span>])</span><br><span class="line">object_columns_df[<span class="string">'Utilities'</span>].value_counts() </span><br><span class="line">object_columns_df[<span class="string">'Street'</span>].value_counts().plot(kind=<span class="string">'bar'</span>,figsize=[<span class="number">10</span>,<span class="number">3</span>])</span><br><span class="line">object_columns_df[<span class="string">'Street'</span>].value_counts() </span><br><span class="line">object_columns_df[<span class="string">'Condition2'</span>].value_counts().plot(kind=<span class="string">'bar'</span>,figsize=[<span class="number">10</span>,<span class="number">3</span>])</span><br><span class="line">object_columns_df[<span class="string">'Condition2'</span>].value_counts() </span><br><span class="line">object_columns_df[<span class="string">'RoofMatl'</span>].value_counts().plot(kind=<span class="string">'bar'</span>,figsize=[<span class="number">10</span>,<span class="number">3</span>])</span><br><span class="line">object_columns_df[<span class="string">'RoofMatl'</span>].value_counts()</span><br><span class="line">object_columns_df[<span class="string">'Heating'</span>].value_counts().plot(kind=<span class="string">'bar'</span>,figsize=[<span class="number">10</span>,<span class="number">3</span>])</span><br><span class="line">object_columns_df[<span class="string">'Heating'</span>].value_counts() <span class="comment">#======&gt; Drop feature one Type</span></span><br><span class="line">object_columns_df = object_columns_df.drop([<span class="string">'Heating'</span>,<span class="string">'RoofMatl'</span>,<span class="string">'Condition2'</span>,<span class="string">'Street'</span>,<span class="string">'Utilities'</span>],axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#创造特征</span></span><br><span class="line">numerical_columns_df[<span class="string">'Age_House'</span>]= (numerical_columns_df[<span class="string">'YrSold'</span>]-numerical_columns_df[<span class="string">'YearBuilt'</span>])</span><br><span class="line">numerical_columns_df[<span class="string">'Age_House'</span>].describe() <span class="comment">#对特征分析</span></span><br><span class="line">Negatif = numerical_columns_df[numerical_columns_df[<span class="string">'Age_House'</span>] &lt; <span class="number">0</span>]</span><br><span class="line">numerical_columns_df.loc[numerical_columns_df[<span class="string">'YrSold'</span>] &lt; numerical_columns_df[<span class="string">'YearBuilt'</span>],<span class="string">'YrSold'</span> ] = <span class="number">2009</span></span><br><span class="line">numerical_columns_df[<span class="string">'Age_House'</span>]= (numerical_columns_df[<span class="string">'YrSold'</span>]-numerical_columns_df[<span class="string">'YearBuilt'</span>])</span><br><span class="line">numerical_columns_df[<span class="string">'Age_House'</span>].describe()</span><br><span class="line">numerical_columns_df[<span class="string">'TotalBsmtBath'</span>] = numerical_columns_df[<span class="string">'BsmtFullBath'</span>] + numerical_columns_df[<span class="string">'BsmtFullBath'</span>]*<span class="number">0.5</span></span><br><span class="line">numerical_columns_df[<span class="string">'TotalBath'</span>] = numerical_columns_df[<span class="string">'FullBath'</span>] + numerical_columns_df[<span class="string">'HalfBath'</span>]*<span class="number">0.5</span> </span><br><span class="line">numerical_columns_df[<span class="string">'TotalSA'</span>]=numerical_columns_df[<span class="string">'TotalBsmtSF'</span>] + numerical_columns_df[<span class="string">'1stFlrSF'</span>] + numerical_columns_df[<span class="string">'2ndFlrSF'</span>]</span><br><span class="line">bin_map  = &#123;<span class="string">'TA'</span>:<span class="number">2</span>,<span class="string">'Gd'</span>:<span class="number">3</span>, <span class="string">'Fa'</span>:<span class="number">1</span>,<span class="string">'Ex'</span>:<span class="number">4</span>,<span class="string">'Po'</span>:<span class="number">1</span>,<span class="string">'None'</span>:<span class="number">0</span>,<span class="string">'Y'</span>:<span class="number">1</span>,<span class="string">'N'</span>:<span class="number">0</span>,<span class="string">'Reg'</span>:<span class="number">3</span>,<span class="string">'IR1'</span>:<span class="number">2</span>,<span class="string">'IR2'</span>:<span class="number">1</span>,<span class="string">'IR3'</span>:<span class="number">0</span>,<span class="string">"None"</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="string">"No"</span> : <span class="number">2</span>, <span class="string">"Mn"</span> : <span class="number">2</span>, <span class="string">"Av"</span>: <span class="number">3</span>,<span class="string">"Gd"</span> : <span class="number">4</span>,<span class="string">"Unf"</span> : <span class="number">1</span>, <span class="string">"LwQ"</span>: <span class="number">2</span>, <span class="string">"Rec"</span> : <span class="number">3</span>,<span class="string">"BLQ"</span> : <span class="number">4</span>, <span class="string">"ALQ"</span> : <span class="number">5</span>, <span class="string">"GLQ"</span> : <span class="number">6</span></span><br><span class="line">            &#125;</span><br><span class="line">object_columns_df[<span class="string">'ExterQual'</span>] = object_columns_df[<span class="string">'ExterQual'</span>].map(bin_map)</span><br><span class="line">object_columns_df[<span class="string">'ExterCond'</span>] = object_columns_df[<span class="string">'ExterCond'</span>].map(bin_map)</span><br><span class="line">object_columns_df[<span class="string">'BsmtCond'</span>] = object_columns_df[<span class="string">'BsmtCond'</span>].map(bin_map)</span><br><span class="line">object_columns_df[<span class="string">'BsmtQual'</span>] = object_columns_df[<span class="string">'BsmtQual'</span>].map(bin_map)</span><br><span class="line">object_columns_df[<span class="string">'HeatingQC'</span>] = object_columns_df[<span class="string">'HeatingQC'</span>].map(bin_map)</span><br><span class="line">object_columns_df[<span class="string">'KitchenQual'</span>] = object_columns_df[<span class="string">'KitchenQual'</span>].map(bin_map)</span><br><span class="line">object_columns_df[<span class="string">'FireplaceQu'</span>] = object_columns_df[<span class="string">'FireplaceQu'</span>].map(bin_map)</span><br><span class="line">object_columns_df[<span class="string">'GarageQual'</span>] = object_columns_df[<span class="string">'GarageQual'</span>].map(bin_map)</span><br><span class="line">object_columns_df[<span class="string">'GarageCond'</span>] = object_columns_df[<span class="string">'GarageCond'</span>].map(bin_map)</span><br><span class="line">object_columns_df[<span class="string">'CentralAir'</span>] = object_columns_df[<span class="string">'CentralAir'</span>].map(bin_map)</span><br><span class="line">object_columns_df[<span class="string">'LotShape'</span>] = object_columns_df[<span class="string">'LotShape'</span>].map(bin_map)</span><br><span class="line">object_columns_df[<span class="string">'BsmtExposure'</span>] = object_columns_df[<span class="string">'BsmtExposure'</span>].map(bin_map)</span><br><span class="line">object_columns_df[<span class="string">'BsmtFinType1'</span>] = object_columns_df[<span class="string">'BsmtFinType1'</span>].map(bin_map)</span><br><span class="line">object_columns_df[<span class="string">'BsmtFinType2'</span>] = object_columns_df[<span class="string">'BsmtFinType2'</span>].map(bin_map)</span><br><span class="line">PavedDrive =   &#123;<span class="string">"N"</span> : <span class="number">0</span>, <span class="string">"P"</span> : <span class="number">1</span>, <span class="string">"Y"</span> : <span class="number">2</span>&#125;</span><br><span class="line">object_columns_df[<span class="string">'PavedDrive'</span>] = object_columns_df[<span class="string">'PavedDrive'</span>].map(PavedDrive)</span><br><span class="line">rest_object_columns = object_columns_df.select_dtypes(include=[<span class="string">'object'</span>])</span><br><span class="line"><span class="comment">#独热编码</span></span><br><span class="line">object_columns_df = pd.get_dummies(object_columns_df, columns=rest_object_columns.columns) </span><br><span class="line">df_final = pd.concat([object_columns_df, numerical_columns_df], axis=<span class="number">1</span>,sort=<span class="literal">False</span>)</span><br><span class="line">df_final = df_final.drop([<span class="string">'Id'</span>,],axis=<span class="number">1</span>)</span><br><span class="line">df_train = df_final[df_final[<span class="string">'train'</span>] == <span class="number">1</span>]</span><br><span class="line">df_train = df_train.drop([<span class="string">'train'</span>,],axis=<span class="number">1</span>)</span><br><span class="line">df_test = df_final[df_final[<span class="string">'train'</span>] == <span class="number">0</span>]</span><br><span class="line">df_test = df_test.drop([<span class="string">'SalePrice'</span>],axis=<span class="number">1</span>)</span><br><span class="line">df_test = df_test.drop([<span class="string">'train'</span>,],axis=<span class="number">1</span>)</span><br><span class="line">target= df_train[<span class="string">'SalePrice'</span>]</span><br><span class="line">df_train = df_train.drop([<span class="string">'SalePrice'</span>],axis=<span class="number">1</span>)</span><br><span class="line">x_train,x_test,y_train,y_test = train_test_split(df_train,target,test_size=<span class="number">0.33</span>,random_state=<span class="number">0</span>)</span><br><span class="line"><span class="comment">#前面全是创建特征工程,数据预处理</span></span><br><span class="line">xgb =XGBRegressor( booster=<span class="string">'gbtree'</span>, colsample_bylevel=<span class="number">1</span>,</span><br><span class="line">             colsample_bynode=<span class="number">1</span>, colsample_bytree=<span class="number">0.6</span>, gamma=<span class="number">0</span>,</span><br><span class="line">             importance_type=<span class="string">'gain'</span>, learning_rate=<span class="number">0.01</span>,                  max_delta_step=<span class="number">0</span>,</span><br><span class="line">             max_depth=<span class="number">4</span>, min_child_weight=<span class="number">1.5</span>, n_estimators=<span class="number">2400</span>,</span><br><span class="line">             n_jobs=<span class="number">1</span>, nthread=<span class="literal">None</span>, objective=<span class="string">'reg:linear'</span>,</span><br><span class="line">             reg_alpha=<span class="number">0.6</span>, reg_lambda=<span class="number">0.6</span>, scale_pos_weight=<span class="number">1</span>, </span><br><span class="line">             silent=<span class="literal">None</span>, subsample=<span class="number">0.8</span>, verbosity=<span class="number">1</span>)</span><br><span class="line">xgb.fit(x_train, y_train)</span><br><span class="line">predict1 = xgb.predict(x_test)</span><br><span class="line">xgb.fit(df_train, target)</span><br><span class="line">predicty = xgb.predict(df_test)</span><br><span class="line">predicty</span><br></pre></td></tr></table></figure><h2 id="6-Xgboost的参数详解以及使用"><a href="#6-Xgboost的参数详解以及使用" class="headerlink" title="6.Xgboost的参数详解以及使用"></a>6.Xgboost的参数详解以及使用</h2><h4 id="一般参数-控制总体的功能"><a href="#一般参数-控制总体的功能" class="headerlink" title="一般参数:控制总体的功能"></a>一般参数:控制总体的功能</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>booster[default=gbtree]选择基分类器 gbtree、gblinear 树或线性分类器</span><br><span class="line"><span class="number">2.</span>nthread [default to maximum number of threads available <span class="keyword">if</span> <span class="keyword">not</span> set]线程数默认最大</span><br></pre></td></tr></table></figure><h4 id="Tree-Booster参数：控制单个学习器的属性"><a href="#Tree-Booster参数：控制单个学习器的属性" class="headerlink" title="Tree Booster参数：控制单个学习器的属性"></a>Tree Booster参数：控制单个学习器的属性</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> learning_rate[default=<span class="number">0.3</span>]:学习率learning rate,步长.一般常用的数值: <span class="number">0.01</span><span class="number">-0.2</span></span><br><span class="line"><span class="number">2.</span> min_child_weight [default=<span class="number">1</span>]:这个参数用来控制过拟合,如果数值太大可能会导致欠拟合</span><br><span class="line"><span class="number">3.</span> max_depth [default=<span class="number">6</span>]: 每颗树的最大深度，树高越深，越容易过拟合。</span><br><span class="line"><span class="number">4.</span> gamma [default=<span class="number">0</span>]：如果分裂能够使loss函数减小的值大于gamma，则这个节点才分裂。gamma设置了这个减小的最低阈值。如果gamma设置为<span class="number">0</span>，表示只要使得loss函数减少，就分裂,通常设置为<span class="number">0</span></span><br><span class="line"><span class="number">6.</span> subsample [default=<span class="number">1</span>]：对原数据集进行随机采样来构建单个树。这个参数代表了在构建树时候 对原数据集采样的百分比。eg：如果设为<span class="number">0.8</span>表示随机抽取样本中<span class="number">80</span>%的个体来构建树。</span><br><span class="line"><span class="number">7.</span> colsample_bytree [default=<span class="number">1</span>]：创建树的时候，从所有的列中选取的比例。e.g：如果设为<span class="number">0.8</span>表示随机抽取<span class="number">80</span>%的列 用来创建树.一般设置为： <span class="number">0.5</span><span class="number">-1</span></span><br><span class="line"><span class="number">8.</span> <span class="keyword">lambda</span> [default=<span class="number">1</span>]：控制模型复杂度的权重值的L2正则化项参数，参数越大，模型越不容易过拟合。</span><br><span class="line"><span class="number">9.</span> alpha [default=<span class="number">0</span>]:控制模型复杂程度的权重值的 L1 正则项参数，参数值越大，模型越不容易过拟合。</span><br><span class="line"><span class="number">10.</span> scale_pos_weight [default=<span class="number">1</span>]在各类别样本十分不平衡时，把这个参数设定为一个正值，可以使算法更快收敛。通常可以将其设置为负样本的数目与正样本数目的比值。</span><br></pre></td></tr></table></figure><h4 id="学习任务参数：控制调优的步骤"><a href="#学习任务参数：控制调优的步骤" class="headerlink" title="学习任务参数：控制调优的步骤"></a>学习任务参数：控制调优的步骤</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>objective [缺省值=reg:linear]</span><br><span class="line">    reg:linear– 线性回归</span><br><span class="line">    reg:logistic – 逻辑回归</span><br><span class="line">    binary:logistic – 二分类逻辑回归，输出为概率</span><br><span class="line">    binary:logitraw – 二分类逻辑回归，输出的结果为wTx</span><br><span class="line">    count:poisson – 计数问题的poisson回归，输出结果为poisson分布。在poisson回归中，max_delta_step的缺省值为<span class="number">0.7</span> (used to safeguard optimization)</span><br><span class="line">    multi:softmax – 设置 XGBoost 使用softmax目标函数做多分类，需要设置参数num_class（类别个数）</span><br><span class="line">    multi:softprob – 如同softmax，但是输出结果为ndata*nclass的向量，其中的值是每个数据分为每个类的概率</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>seed [ default=<span class="number">0</span> ]随机种子,为了产生能够重现的结果。因为如果不设置这个种子，每次产生的结果都会不同。</span><br><span class="line"><span class="number">3.</span>eval_metric [缺省值=通过目标函数选择]</span><br><span class="line">    rmse: 均方根误差</span><br><span class="line">    mae: 平均绝对值误差</span><br><span class="line">    logloss: negative log-likelihood</span><br><span class="line">    error: 二分类错误率。</span><br><span class="line">    merror: 多分类错误率，计算公式为(wrong cases)/(all cases)</span><br><span class="line">    mlogloss: 多分类log损失</span><br><span class="line">    auc: 曲线下的面积</span><br><span class="line">    ndcg: Normalized Discounted Cumulative Gain</span><br><span class="line">    map: 平均正确率</span><br></pre></td></tr></table></figure><h4 id="调参方法"><a href="#调参方法" class="headerlink" title="调参方法"></a>调参方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">需要借助一个模块sklearn.model_selection.GridSearchCV(模型调参利器,网格搜索)</span><br><span class="line"> 参数:</span><br><span class="line">   <span class="number">1.</span>estimator,优化器,即你建立的模型,这里选xgboost</span><br><span class="line">   <span class="number">2.</span>param_grid 一般用字典(通常,也可列表),输入优化的参数</span><br><span class="line">   <span class="number">3.</span>scoring 模型评价标准,如roc,auc等</span><br><span class="line">调参顺序:</span><br><span class="line">  <span class="number">1.</span>n_estimators 迭代次数,就是生成树的个数 如,cv_params = &#123;<span class="string">'n_estimators'</span>: [<span class="number">550</span>, <span class="number">575</span>, <span class="number">600</span>, <span class="number">650</span>, <span class="number">675</span>]&#125;</span><br><span class="line">  <span class="number">2.</span>min_child_weight和max_depth 这两个参数是控制树生成的，树的结构对于最终的结果影响还是很大</span><br><span class="line">  <span class="number">3.</span>gamma控制节点分裂标准 cv_params = &#123;<span class="string">'gamma'</span>: [<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.4</span>, <span class="number">0.5</span>, <span class="number">0.6</span>]&#125;</span><br><span class="line">  <span class="number">4.</span>subsample和colsample_bytree  采样比例,cv_params = &#123;<span class="string">'subsample'</span>: [<span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>, <span class="number">0.9</span>], <span class="string">'colsample_bytree'</span>: [<span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>, <span class="number">0.9</span>]&#125;</span><br><span class="line">  <span class="number">5.</span> alpha和<span class="keyword">lambda</span>, 正则化的参数 cv_params = &#123;<span class="string">'alpha'</span>: [<span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">'lambda'</span>: [<span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</span><br><span class="line">  <span class="number">6.l</span>earning_rate  学习率,从较小的开始 cv_params = &#123;<span class="string">'learning_rate'</span>: [<span class="number">0.01</span>, <span class="number">0.05</span>, <span class="number">0.07</span>, <span class="number">0.1</span>, <span class="number">0.2</span>]&#125;</span><br><span class="line">  <span class="number">7.</span>调参可以提高模型性能，但是更重要的还是特征选择，数据清洗，特征融合</span><br><span class="line">  </span><br><span class="line">控制过拟合</span><br><span class="line">  当您观察到较高的训练准确率，但测试精度较低时，很可能遇到了过拟合问题。</span><br><span class="line">  通常可以通过两种方式来控制xgboost中的过拟合</span><br><span class="line">  第一种方式是直接控制模型的复杂性</span><br><span class="line">      这包括max_depth，min_child_weight 和 gamma</span><br><span class="line">  第二种方法是增加随机性，使训练对噪声更加鲁棒</span><br><span class="line">      这包括subsample，colsample_bytree,eta</span><br><span class="line">      </span><br><span class="line">样本不均衡问题</span><br><span class="line">   <span class="number">1</span>) 设置scale_pos_weight,有时会遇到样本不均衡的问题，比如正例占<span class="number">99</span>%，反例占<span class="number">1</span>%，那么如果预测为全正例或者随机抽机，正确率也占<span class="number">99</span>%。此时可使用scale_pos_weight提高反例权重，默认为<span class="number">1</span>，不增加权重。</span><br><span class="line">   <span class="number">2</span>)使用xgb自带的调用接口 (非sklearn接口)，需要把数据转成DMatrix格式，如果想给不同实例分配不同权重，可以转换时使用weight参数，它传入与实例个数等长的数组，数组中每个数对应一个实例的权重，在xgb每次迭代后调整权重时也会将它计算在内。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line">​</span><br><span class="line">cancer = load_breast_cancer()</span><br><span class="line">x = cancer.data[:<span class="number">50</span>]</span><br><span class="line">y = cancer.target[:<span class="number">50</span>]</span><br><span class="line">train_x, valid_x, train_y, valid_y = train_test_split(x, y, test_size=<span class="number">0.333</span>, random_state=<span class="number">0</span>)</span><br><span class="line">parameters = &#123;</span><br><span class="line">    <span class="string">'max_depth'</span>: [<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>],</span><br><span class="line">    <span class="string">'learning_rate'</span>: [<span class="number">0.01</span>, <span class="number">0.02</span>, <span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">0.15</span>],</span><br><span class="line">    <span class="string">'n_estimators'</span>: [<span class="number">50</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">500</span>],</span><br><span class="line">    <span class="string">'min_child_weight'</span>: [<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>],</span><br><span class="line">    <span class="string">'max_delta_step'</span>: [<span class="number">0</span>, <span class="number">0.2</span>, <span class="number">0.6</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">    <span class="string">'subsample'</span>: [<span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>, <span class="number">0.85</span>, <span class="number">0.95</span>],</span><br><span class="line">    <span class="string">'colsample_bytree'</span>: [<span class="number">0.5</span>, <span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>, <span class="number">0.9</span>],</span><br><span class="line">    <span class="string">'reg_alpha'</span>: [<span class="number">0</span>, <span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>, <span class="number">1</span>],</span><br><span class="line">    <span class="string">'reg_lambda'</span>: [<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>, <span class="number">0.8</span>, <span class="number">1</span>],</span><br><span class="line">    <span class="string">'scale_pos_weight'</span>: [<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>, <span class="number">0.8</span>, <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">xlf = xgb.XGBClassifier(max_depth=<span class="number">10</span>,</span><br><span class="line">                        learning_rate=<span class="number">0.01</span>,</span><br><span class="line">                        n_estimators=<span class="number">2000</span>,</span><br><span class="line">                        silent=<span class="literal">True</span>,</span><br><span class="line">                        objective=<span class="string">'binary:logistic'</span>,</span><br><span class="line">                        nthread=<span class="number">-1</span>,</span><br><span class="line">                        gamma=<span class="number">0</span>,</span><br><span class="line">                        min_child_weight=<span class="number">1</span>,</span><br><span class="line">                        max_delta_step=<span class="number">0</span>,</span><br><span class="line">                        subsample=<span class="number">0.85</span>,</span><br><span class="line">                        colsample_bytree=<span class="number">0.7</span>,</span><br><span class="line">                        colsample_bylevel=<span class="number">1</span>,</span><br><span class="line">                        reg_alpha=<span class="number">0</span>,</span><br><span class="line">                        reg_lambda=<span class="number">1</span>,</span><br><span class="line">                        scale_pos_weight=<span class="number">1</span>,</span><br><span class="line">                        seed=<span class="number">1440</span>,</span><br><span class="line">                        missing=<span class="literal">None</span>)</span><br><span class="line">​</span><br><span class="line"><span class="comment"># 有了gridsearch我们便不需要fit函数</span></span><br><span class="line">gsearch = GridSearchCV(xlf, param_grid=parameters, scoring=<span class="string">'accuracy'</span>, cv=<span class="number">3</span>)</span><br><span class="line">gsearch.fit(train_x, train_y)</span><br><span class="line">print(<span class="string">"Best score: %0.3f"</span> % gsearch.best_score_)</span><br><span class="line">print(<span class="string">"Best parameters set:"</span>)</span><br><span class="line">best_parameters = gsearch.best_estimator_.get_params()</span><br><span class="line"><span class="keyword">for</span> param_name <span class="keyword">in</span> sorted(parameters.keys()):</span><br><span class="line">    print(<span class="string">"\t%s: %r"</span> % (param_name, best_parameters[param_name]))</span><br><span class="line"><span class="comment">#比较耗费时间,穷举法</span></span><br></pre></td></tr></table></figure><h4 id="案例2-https-www-jianshu-com-p-7aab084b7f47"><a href="#案例2-https-www-jianshu-com-p-7aab084b7f47" class="headerlink" title="案例2:https://www.jianshu.com/p/7aab084b7f47"></a>案例2:<a href="https://www.jianshu.com/p/7aab084b7f47" target="_blank" rel="noopener">https://www.jianshu.com/p/7aab084b7f47</a></h4><p><a href="https://blog.csdn.net/weixin_30838921/article/details/94989933?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param" target="_blank" rel="noopener">https://blog.csdn.net/weixin_30838921/article/details/94989933?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param</a></p><h2 id="7-Xgboost的注意事项"><a href="#7-Xgboost的注意事项" class="headerlink" title="7.Xgboost的注意事项"></a>7.Xgboost的注意事项</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>windows安装推荐方式，直接pip会各种报错</span><br><span class="line">https://blog.csdn.net/qq_20412595/article/details/79771490?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</span><br><span class="line"><span class="number">2.</span>在Xgb中需要将离散特征one-hot编码，和连续特征一起输入训练</span><br><span class="line"><span class="number">3.</span>Xgb中支持稀疏矩阵训练模型，导致数据稀疏的原因如下</span><br><span class="line">  缺省值</span><br><span class="line">  稠密数据中零元素</span><br><span class="line">  离散特征one-hot编码后产生的<span class="number">0</span>值</span><br><span class="line"><span class="number">4.</span>win和mac平台运行相同的xgboost代码，效果如果可能不同,将参数colsample_bytree设置为<span class="number">1</span></span><br><span class="line"><span class="number">5.</span>xgboost提供两种调用方式，一种是自身接口，一种是类似sklearn的接口，建议使用自身接口，因为很多重要功能，如存取模型，评估功能都无法通过sklearn接口调用。</span><br><span class="line"><span class="number">6.</span>Xgboost可以处理二分类，多分类，回归问题。处理不同问题，主要的区别在于指定不同的误差函数，xgboost会根据不同误差函数计算的结果调整权重进行下一次迭代。通过参数objective可设置xgb自带的误差函数：回归一般用reg:xxx（如reg:linear），二分类用binary:xxx（如binary:logistic），多分类用multi:xxx（如multi:softmax）</span><br></pre></td></tr></table></figure><h2 id="Xgboost原生接口和Sklearn接口的区别"><a href="#Xgboost原生接口和Sklearn接口的区别" class="headerlink" title="Xgboost原生接口和Sklearn接口的区别"></a>Xgboost原生接口和Sklearn接口的区别</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>xgboost原生接口，数据需要经过标签标准化(LabelEncoder().fit_transform)、输入数据标准化(xgboost.DMatrix)和输出结果反标签标准化(LabelEncoder().inverse_transform)，训练调用train预测调用predict.</span><br><span class="line"><span class="number">2.</span>xgboost的sklearn接口，可以不经过标签标准化(即将标签编码为<span class="number">0</span>~n_class<span class="number">-1</span>)，直接喂给分类器特征向量和标签向量，使用fit训练后调用predict就能得到预测向量的预测标签，它会在内部调用sklearn.preprocessing.LabelEncoder()将标签在分类器使用时transform，在输出结果时inverse_transform。</span><br></pre></td></tr></table></figure><p><img src="/2020/12/30/Xgboost算法/HOLO6wBr3CEco4RE__thumbnail.png" alt="图片"></p><p>xgb在选择最佳分裂点，进行枚举的时候并行！</p><p><strong>xgboost的并行是在特征粒度上的</strong>。我们知道，决策树的学习最耗时的一个步骤就是对特征的值进行排序（因为要确定最佳分割点），在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行</p><p>拟合残差只是考虑到损失函数为平方损失的特殊情况，负梯度是更加广义上的拟合项，更具普适性。</p><p>无论损失函数是什么形式，每个决策树拟合的都是负梯度。准确的说，不是用负梯度代替残差，而是当损失函数是均方损失时，负梯度刚好是残差，残差只是特例。</p><p>为啥要去用梯度拟合不用残差？代价函数除了loss还有正则项，正则中有参数和变量，很多情况下只拟合残差loss变小但是正则变大，代价函数不一定就小，这时候就要用梯度啦，梯度的本质也是一种方向导数，综合了各个方向（参数）的变化，选择了一个总是最优（下降最快）的方向；</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spark入门</title>
      <link href="/2020/12/24/spark%E5%85%A5%E9%97%A8/"/>
      <url>/2020/12/24/spark%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h5 id="Apache重要的三个基金会项目-hadoop-spark-storm"><a href="#Apache重要的三个基金会项目-hadoop-spark-storm" class="headerlink" title="Apache重要的三个基金会项目(hadoop,spark,storm)"></a>Apache重要的三个基金会项目(hadoop,spark,storm)</h5><p>Spark提供了内存计算，减少了迭代计算时的IO开销；虽然，Hadoop已成为大数据的事实标准，但其MapReduce分布式计算模型仍存在诸多缺陷，而Spark不仅具备Hadoop MapReduce所具有的优点，且解决了Hadoop MapReduce的缺陷。</p><p>Spark:可以作为一个更加快速、高效的大数据计算平台。基于内存的大数据并行计算框架.将计算分解成多个任务在不同的机器上运行.</p><p>别人的学习总结:<a href="https://blog.csdn.net/qq_33247435/article/details/83653584#8Spark_71" target="_blank" rel="noopener">https://blog.csdn.net/qq_33247435/article/details/83653584#8Spark_71</a></p><h5 id="spark的概念"><a href="#spark的概念" class="headerlink" title="spark的概念"></a>spark的概念</h5><p>​    1.$RDD$(resilient distribute dataset 弹性分布式训练集).是分布式内存里的一个抽象概念,表示的是高度受限的共享内存模型</p><p>​    2.$DAG$(directed acyclic gragh),有向无环图,表明了RDD之间的依赖关系</p><p>​    3.$EXECUTOR:$运行在工作节点上的一个进程,负责运行任务,以及应用程序存储数据</p><p>​    4.$程序:$编写的spark程序</p><p>​    5.$任务:$运行在executor上的工作单元</p><p>​    6.$作业:$包含多个RDD及对应RDD上的操作</p><p>​    7.$阶段:$作业的基本调度单位,一个作业会分成多组任务,每组任务称为阶段</p><p>​    8.$shuffle过程:$简单认为就是将不同节点上的相同key拉到同一个节点上计算</p><p>​    9.$SparkSession:$代表了spark集群中的一个连接,在应用程序实例化的时候启动</p><p>====&gt;spark的入口,2.0之前spark core是sparkcontext,spark sql是sqlcontext,sparkstreaming应用使用streamingContext.2.0之后,sparksession对象把所有的对象组合到一起.称为所有程序统一的入口</p><h5 id="RDD详解-待补充"><a href="#RDD详解-待补充" class="headerlink" title="RDD详解(待补充)"></a>RDD详解(待补充)</h5><h3 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h3><h5 id="spark运行架构"><a href="#spark运行架构" class="headerlink" title="spark运行架构"></a>spark运行架构</h5><p><img src="/2020/12/24/spark入门/1609144230200.png" alt="1609144230200"></p><p>​    $driver:$每个应用的任务控制节点</p><p>​    $cluster  manager:$集群资源管理器</p><p>​    $node:$运行作业任务的工作节点</p><p>​    $Executor$:每个工作节点上负责具体任务的执行进程</p><p>​    $\textcolor{red}{关系:}$</p><p>​        一个应用由一个一个控制节点(driver)和若干个作业构成,一个作业由若干个阶段构成,一个阶段由多个任务构成.当执行一个应用时,任务控制节点会向集群管理器申请资源,启动executor,并向executor发送应用程序和代码和文件.然后在executor上执行任务,运行结束后,执行结果会返回给任务控制节点,或者写到数据库中.</p><p>​    $\textcolor{red}{Executor优点:}$</p><p>​        1.采用的是多线程(map reduce 使用的是进程模型),减少了开销</p><p>​        2.executor中有一个blockmanager存储模块,会将内存和磁盘作为存储模块,当需要多轮迭代计算的时候,可以将数据存储到这个模块.有效减少了IO开销；或者在交互式查询场景下，预先将表缓存到该存储系统上，从而可以提高读写IO性能。</p><h5 id="spark运行基本流程"><a href="#spark运行基本流程" class="headerlink" title="spark运行基本流程"></a>spark运行基本流程</h5><pre><code>1.当一个spark应用被提交时,需要为这个应用提供基本的运行环境,即有任务控制节点(driver)创建一个sparkcontext,负责和资源管理器的通信以及资源的申请和任务的分配和监控等.sparkcontext会向资源管理器注册并申请运行Executor的资源.</code></pre><p>​    2.资源管理器为Executor分配资源,并启动Executor进程,Executor运行情况将随着心跳发送到资源管理器上</p><p>​    3.任务在Executor上运行,并将结果返回给任务调度器,然后反馈给DAG调度器,运行完毕,写入资源并释放所有资源.</p><p>​    $\textcolor{orange}{详解}$</p><p>​    1.构建spark applicantion的运行环境,启动SparkContext</p><p>​    2.sparkcontext向资源管理器申请运行Executor</p><p>​    3.Executor向Sparkcontext申请Task</p><p>​    4.SparkContext将应用程序分发给Executor</p><p>​    5.sparkcontext构建DAG图,将DAG图分解成Stage,将tasket发送给Task Scheduler,最后由Task Scheduler将Task发送给Executor运行</p><p>​    6.Task在Executor上运行,运行完释放所有资源</p><p>​    $\textcolor{red}{SparkContext原理:}$</p><p>​        依据RDD的依赖关系构建DAG图,然后将DAG图提交给DAG调度器进行解析,将DAG图分解成多个阶段,并计算出各个阶段的依存关系,然后把一个个任务集提交给底层的调度器进行处理.Executor向sparkcontext申请人无,任务调度器将任务发送给Executor并将应用程序代码发送给Executor</p><p><img src="/2020/12/24/spark入门/a5c6525ad8f559b0511319b4e1ec76e.png" alt="1609221852735"></p><h5 id="spark-on-standalone流程"><a href="#spark-on-standalone流程" class="headerlink" title="spark on standalone流程"></a>spark on standalone流程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1、我们提交一个任务，任务就叫Application</span><br><span class="line">2、初始化程序的入口SparkContext，</span><br><span class="line">　　2.1 初始化DAG Scheduler</span><br><span class="line">　　2.2 初始化Task Scheduler</span><br><span class="line">3、Task Scheduler向master去进行注册并申请资源（CPU Core和Memory）</span><br><span class="line">4、Master根据SparkContext的资源申请要求和Worker心跳周期内报告的信息决定在哪个Worker上分配资源，然后在该Worker上获取资源，然后启动StandaloneExecutorBackend；顺便初</span><br><span class="line">始化好了一个线程池</span><br><span class="line">5、StandaloneExecutorBackend向Driver(SparkContext)注册,这样Driver就知道哪些Executor为他进行服务了。</span><br><span class="line">　  到这个时候其实我们的初始化过程基本完成了，我们开始执行transformation的代码，但是代码并不会真正的运行，直到我们遇到一个action操作。生产一个job任务，进行stage的划分</span><br><span class="line">6、SparkContext将Applicaiton代码发送给StandaloneExecutorBackend；并且SparkContext解析Applicaiton代码，构建DAG图，并提交给DAG Scheduler分解成Stage（当碰到Action操作   时，就会催生Job；每个Job中含有1个或多个Stage，Stage一般在获取外部数据和shuffle之前产生）。</span><br><span class="line">7、将Stage（或者称为TaskSet）提交给Task Scheduler。Task Scheduler负责将Task分配到相应的Worker，最后提交给StandaloneExecutorBackend执行；</span><br><span class="line">8、对task进行序列化，并根据task的分配算法，分配task</span><br><span class="line">9、对接收过来的task进行反序列化，把task封装成一个线程</span><br><span class="line">10、开始执行Task，并向SparkContext报告，直至Task完成。</span><br><span class="line">11、资源注销</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">心跳是分布式技术的基础，我们知道在Spark中，是有一个Master和众多的Worker，那么Master怎么知道每个Worker的情况呢，这就需要借助心跳机制了。心跳除了传输信息，另一个主要的作用就是Worker告诉Master它还活着，当心跳停止时，方便Master进行一些容错操作，比如数据转移备份等等。</span><br></pre></td></tr></table></figure><h5 id="spark部署"><a href="#spark部署" class="headerlink" title="spark部署"></a>spark部署</h5><p>​    $\textcolor{red}{三种部署方式:}$1.standalone 2.spark on Mesos  3.spark on YARN</p><p>​    $\textcolor{green}{standalone:}$</p><p>​        分布式集群服务，自带的完整服务，Spark自己进行资源管理和任务监控,一定程度上来说,此模式是其他两个模式的基础</p><p>​    $\textcolor{green}{Sapark on Mesos:}$</p><p>​        官方推荐(都是apache的),spark设计之初就考虑支持mesos,spark在mesos上比在YARN上更灵活</p><p>​        $Mesos$是一种资源调度管理框架</p><p>​        $两种调度模式:$</p><p>​        1.粗粒度模式</p><p>​            每个应用程序的运行环境由一个driver和若干个executor组成.其中,每个executor占用若干资源,内部可运行多个Task,应用程序在开始之前需要将运行环境的资源全部申请好,且运行过程中要一直占用这些资源,即使不用.当程序结束时,会进行回收.</p><p>​        2.细粒度模式</p><p>​            粗粒度会造成很大的资源浪费,动态分配</p><p>​    $\textcolor{red}{Spark on Yarn}$</p><p>​    是一种最有前景的部署模式。但限于YARN自身的发展，目前仅支持粗粒度模式    </p><p>​    Spark可运行于YARN之上，与Hadoop进行统一部署</p><p>​    分布式部署集群，这是由于YARN(资源管理器)上的Container资源是不可以动态伸缩的，一旦Container启动之后，可使用的资源不能再发生变化.</p><h5 id="spark相对hadoop的优势"><a href="#spark相对hadoop的优势" class="headerlink" title="spark相对hadoop的优势"></a>spark相对hadoop的优势</h5><p>​    hadoop的mapreduce计算模型延迟过高,无法胜任$\textcolor{red}{实时}$和$\textcolor{red}{快速}$计算,只适用离线批处理</p><p>​    $hadoop的缺点$:</p><p>​        1.表达能力有限.分为map阶段和reduce阶段.难以描述复杂数据处理过程.</p><p>​         2.磁盘io开销大.每次执行都需要从磁盘读取数据,且存的时候需要将中间数据存到磁盘中.</p><p>​         3.延迟高,一次计算可能需要分解成一系列按顺序执行的MapReduce任务,任务之间的衔接涉及到IO开销,会产生较高的延迟.</p><p>​    $Spark的优点$:</p><p>​        1.计算模式也属于MapReduce,但不局限于map和reduce操作,提供多种数据类型操作,比MapReduce更灵活</p><p>​        2.spark提供了内存计算,中间结果直接放到内存中</p><p>​        3.spark使用的是DAG进行任务调度,比MapReduce的迭代执行机制强</p><p>​    $整体:$</p><p>​        spark最大的优点就是将计算结果,中间数据存储到内存中,大大减少了IO开销.因为spark更适合迭代运算多的数据挖掘和机器学习运算</p><p>​    $总:$尽管整体上spark比hadoop要好,但是无法完全替代hadoop,通常是用来替代hadoop的MapReduce部分</p><h5 id="spark生态"><a href="#spark生态" class="headerlink" title="spark生态"></a>spark生态</h5><p><img src="/2020/12/24/spark入门/spark生态.png" alt="spark生态"></p><p>​    spark生态主要包含$\textcolor{red}{Spark Core}$ ,$\textcolor{red}{Spark Sql}$,$\textcolor{red}{Spark Screaming}$,$\textcolor{red}{MLlib}$,$\textcolor{red}{Graphx}$</p><p>​    $\textcolor{red}{Spark Core:}$Spark Core包含Spark的基本功能，如内存计算、任务调度、部署模式、故障恢复、存储管理等。通常所说的Apache Spark，就是指Spark Core</p><p>​    $\textcolor{red}{Spark Sql:}$Spark SQL允许直接处理RDD，同时也可查询Hive、HBase等外部数据源。Spark SQL的一个重要特点是其能够统一处理关系表和RDD，使得开发人员可以轻松地使用SQL命令进行查询，并进行更复杂的数据分析；</p><p>​    $\textcolor{red}{Spark Screaming:}$    Spark Streaming支持高吞吐量、可容错处理的实时流数据处理，其核心思路是将流式计算分解成一系列短小的批处理作业。</p><p>​    $\textcolor{red}{Graphx:}$GraphX是Spark中用于图计算的API</p><p>​    $\textcolor{red}{MLlib:}$MLlib提供了常用机器学习算法的实现，包括聚类、分类、回归、协同过滤等</p><h5 id="在pyspark中执行词频统计"><a href="#在pyspark中执行词频统计" class="headerlink" title="在pyspark中执行词频统计"></a>在pyspark中执行词频统计</h5><p>​    $案例1.词频统计$</p><p>​        ①首先创建一个worldcount目录(shell 命令下)</p><p>​        ②然后创建一个txt文件,里面随便写一些文字.作为统计的原材料</p><p>​        ③词频统计需要启动pyspark.cd /usr/local/spark   然后  ./bin/pyspark</p><p>​        ④加载文件—&gt;确定是在本地还是在分布式的hdfs上</p><p>​        $本地$:</p><p>​            textFile = sc.textFile(‘file:///usr/local/spark/mycode/wordcount/word.txt’)(要加载本地文件，必须采用“file:///”开头的这种格式)–&gt;惰性的,需要first()这种才能打印出数据</p><p>​            textFile.first()(打印第一行数据,文件不存在会显示拒绝连接)</p><p>​        $HDFS$:</p><p>​            需要首先启动Hadoop中的HDFS组件</p><p>​            1.  cd /usr/local/hadoop</p><p>​            2.  ./sbin/start-dfs.sh</p><p>​            $\textcolor{red}{上传文件到hdfs上}$./bin/hdfs dfs -put /usr/local/spark/mycode/wordcount/word.txt .</p><p>​            3.加载文件textFile = sc.textFile(“hdfs://localhost:9000/user/hadoop/word.txt”)–&gt;惰性的</p><p>​        ⑤写代码,在pyspark窗口(类似于ipython那种&gt;&gt;&gt;),代码如下</p><p>​            textFile = sc.textFile(“file:///usr/local/spark/mycode/wordcount/word.txt”)</p><p>​            wordCount = textFile.flatMap(lambda line: line.split(“ “)).map(lambda word: (word,1)).reduceByKey(lambda a, b : a + b)</p><p>​             wordCount.collect()</p><p>​            $\textcolor{red}{代码解释:}$</p><p>​                 1.第一行即从本地加载文件数据</p><p>​                 2.第二行textFile.flatMap(lambda line: line.split(“ “))表示按行处理,每行按照空白符分割.这样每行得到一个单词集合.textFile.flatMap()操作就把这多个单词集合“拍扁”得到一个大的单词集合.map(lambda word: (word,1))会遍历单词集合中的每一个单词,并执行Lamda表达式word : (word, 1).</p><p>​                程序执行到这里，已经得到一个RDD，这个RDD的每个元素是(key,value)形式的tuple。最后，针对这个RDD，执行reduceByKey(labmda a, b : a + b)操作，这个操作会把所有RDD元素按照key进行分组，然后使用给定的函数（这里就是Lamda表达式：a, b : a + b）</p><p>​                如:(“hadoop”,1)和(“hadoop”,1)—–&gt;(“hadoop”,2)</p><h5 id="编写独立应用程序执行词频统计"><a href="#编写独立应用程序执行词频统计" class="headerlink" title="编写独立应用程序执行词频统计"></a>编写独立应用程序执行词频统计</h5><p>​    1.创建test.py文件内容如下</p><p>​        from pyspark import SparkContext</p><p>​        sc = SparkContext( ‘local’, ‘test’)</p><p>​        textFile = sc.textFile(“file:///usr/local/spark/mycode/wordcount/word.txt”)</p><p>​        wordCount = textFile.flatMap(lambda line: line.split(“ “)).map(lambda word: (word,1)).reduceByKey(lambda a, b : a + b)</p><p>​        wordCount.foreach(print)</p><h5 id="在集群上运行spark"><a href="#在集群上运行spark" class="headerlink" title="在集群上运行spark"></a>在集群上运行spark</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.启动hadoop集群</span><br><span class="line">①cd /usr/local/hadoop/</span><br><span class="line">②sbin/start-all.sh</span><br><span class="line">2.启动spark的master节点和索引slaves节点</span><br><span class="line">①cd /usr/local/spark/</span><br><span class="line">②sbin/start-master.sh</span><br><span class="line">③sbin/start-slaves.sh</span><br><span class="line">3.介绍两种资源管理方式standalone 和 spark on yarn</span><br><span class="line">独立资源管理器:</span><br><span class="line">1&gt;安装jar包</span><br><span class="line">向独立集群管理器提交应用,需要把spark://master:7077作为主节点参数传递给spark-submit.</span><br><span class="line">eg:bin/spark-submit --class org.apache.spark.examples.SparkPi --master spark://master:7077 examples/jars/spark-examples_2.11-2.0.2.jar 100 2&gt;&amp;1 | grep &quot;Pi is roughly&quot;</span><br><span class="line">2&gt;在集群中运行pyspark</span><br><span class="line">①在shell中输入命令进入pyspark中</span><br><span class="line">cd /usr/local/spark/</span><br><span class="line">bin/pyspark --master spark://master:7077</span><br><span class="line">spark on yarn:</span><br><span class="line">1&gt;安装应用程序jar包</span><br><span class="line">需要把yarn-cluster作为主节点参数传递给spark-submit</span><br><span class="line">2&gt;在集群中运行pyspark</span><br><span class="line">①bin/pyspark --master yarn</span><br></pre></td></tr></table></figure><p>$\textcolor{red}{spark-submit}$ 可以提交任务到 spark 集群执行，也可以提交到 hadoop 的 yarn 集群执行。</p><p>bin/spark-submit –class org.apache.spark.examples.SparkPi –master表示以集群模式启动spark</p><h5 id="Jupyter-Notebook调试PySpark"><a href="#Jupyter-Notebook调试PySpark" class="headerlink" title="Jupyter Notebook调试PySpark"></a>Jupyter Notebook调试PySpark</h5><h5 id="RDD的弹性"><a href="#RDD的弹性" class="headerlink" title="RDD的弹性"></a>RDD的弹性</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.自动的进行内存和磁盘的存储切换</span><br><span class="line">2.Task如果失败，会自动进行特定次数的重试</span><br><span class="line">3.数据分片的高度弹性（coalesce）,优先内存,内存不够才放磁盘</span><br></pre></td></tr></table></figure><p>主从架构 和 P2P架构</p><p>宽依赖 债依赖<br>shuffle操作</p><p>fork和join </p><h5 id="RDD运行原理"><a href="#RDD运行原理" class="headerlink" title="RDD运行原理"></a>RDD运行原理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.RDD无法直接更改数据,每次操作都会生成一个新的RDD</span><br><span class="line">2.每个RDD都会分成很多个分区,每个分区都是部分数据集片段,一个RDD的不同分区可以保存到不同集群的不同节点上,从而可以实现在不同节点的并行计算</span><br><span class="line">3.执行过程:读入外部的数据源（或者内存中的集合）进行 RDD 创建；</span><br><span class="line">RDD 经过一系列的 “转换” 操作，每一次都会产生不同的 RDD，供给下一个转换使用；</span><br><span class="line">最后一个 RDD 经过 “行动” 操作进行处理，并输出指定的数据类型和值。</span><br><span class="line">RDD 采用了惰性调用，即在 RDD 的执行过程中，所有的转换操作都不会执行真正的操作，只会记录依赖关系，而只有遇到了行动操作，才会触发真正的计算，并根据之前的依赖关系得到最终的结果。</span><br><span class="line">4.RDD发生行为操作并生成输出数据时，Spark 才会根据 RDD 的依赖关系生成有向无环图（DAG），并从起点开始执行真正的计算。正是 RDD 的这种惰性调用机制，使得转换操作得到的中间结果不需要保存，而是直接管道式的流入到下一个操作进行处理</span><br></pre></td></tr></table></figure><h5 id="RDD可以实现高效计算的原因"><a href="#RDD可以实现高效计算的原因" class="headerlink" title="RDD可以实现高效计算的原因"></a>RDD可以实现高效计算的原因</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.高效的容错性。可以直接利用 RDD 之间的依赖关系来重新计算得到丢失的分区。</span><br><span class="line">2.中间结果持久化到内存。不需要存储到磁盘,降低了IO.</span><br><span class="line">3.存放的数据可以是 Java 对象，避免了不必要的对象序列化和反序列化开销。</span><br><span class="line">序列化:将数据转换为字节存储的过程(存储数据到磁盘)</span><br><span class="line">反序列化:将二进制字节码转换成java对象(从磁盘读数据)</span><br></pre></td></tr></table></figure><h5 id="RDD之间的依赖关系"><a href="#RDD之间的依赖关系" class="headerlink" title="RDD之间的依赖关系"></a>RDD之间的依赖关系</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">宽依赖:父 RDD 与子 RDD 之间的一对多关系，即一个父 RDD 转换成多个子 RDD</span><br><span class="line"></span><br><span class="line">窄依赖:父 RDD 和子 RDD 之间的一对一关系或者多对一关系,主要包括的操作有 map、filter、union 等</span><br><span class="line"></span><br><span class="line">宽依赖的RDD通常伴随着Shuffle操作(非常复杂且昂贵的操作,包含在executors和machines上的数据复制)</span><br><span class="line">首先需要计算好所有父分区数据，然后在节点之间进行 Shuffle.在进行数据恢复时，窄依赖只需要根据父 RDD 分区重新计算丢失的分区即可，而且可以并行地在不同节点进行重新计算。而对于宽依赖而言，单个节点失效通常意味着重新计算过程会涉及多个父 RDD 分区，开销较大。</span><br></pre></td></tr></table></figure><p><img src="/2020/12/24/spark入门/360截图17290508434977.png" alt="360截图17290508434977"></p><h5 id="RDD编程"><a href="#RDD编程" class="headerlink" title="RDD编程"></a>RDD编程</h5><p>######1.通过加载数据创建RDD</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pyspark import SparkContext</span><br><span class="line">sc = SparkContext( &apos;local&apos;, &apos;test&apos;)</span><br><span class="line">lines = sc.textFile(&quot;hdfs://localhost:9000/user/hadoop/word.txt&quot;)  #hdfs,HBase、Cassandra、Amazon S3等外部数据源中加载数据集等文件系统加载</span><br><span class="line">textFile = sc.textFile(&apos;file:///usr/local/spark/mycode/wordcount/word.txt&apos;) #本地节点加载</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">1.如果使用了本地文件系统的路径,必须保证在所有的worker节点上,也可以采用相同的路径访问到改文件</span><br><span class="line">(既可以复制到每个worker节点上,也可以使用网络挂载共享文件系统)</span><br><span class="line">2.textFile输入的参数可以是文件名,可以说目录,也可以说压缩文件等.</span><br></pre></td></tr></table></figure><h6 id="2-通过并行集合-数组-创建RDD"><a href="#2-通过并行集合-数组-创建RDD" class="headerlink" title="2.通过并行集合(数组)创建RDD"></a>2.通过并行集合(数组)创建RDD</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用sparkcontext的parallelize方法,在Driver中一个已存在的集合(数组)上创建</span><br><span class="line">nums = [1,2,3,4]</span><br><span class="line">rdd = sc.parallelize(nums)</span><br></pre></td></tr></table></figure><h5 id="RDD操作"><a href="#RDD操作" class="headerlink" title="RDD操作"></a>RDD操作</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.转换:基于现有的数据集创建一个新的数据集</span><br><span class="line">2.行动:在数据集上进行运算,返回计算值</span><br></pre></td></tr></table></figure><h6 id="1-转换操作"><a href="#1-转换操作" class="headerlink" title="1.转换操作"></a>1.转换操作</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对于RDD而言，每一次转换操作都会产生不同的RDD，供给下一个“转换”使用。转换得到的RDD是惰性求值的，也就是说，整个转换过程只是记录了转换的轨迹，并不会发生真正的计算，只有遇到行动操作时，才会发生真正的计算，开始从血缘关系源头开始，进行物理的转换操作。</span><br><span class="line"></span><br><span class="line">下面列出一些常见的转换操作（Transformation API）：</span><br><span class="line">* filter(func)：筛选出满足函数func的元素，并返回一个新的数据集</span><br><span class="line">* map(func)：将每个元素传递到函数func中，并将结果返回为一个新的数据集</span><br><span class="line">* flatMap(func)：与map()相似，但每个输入元素都可以映射到0或多个输出结果</span><br><span class="line">* groupByKey()：应用于(K,V)键值对的数据集时，返回一个新的(K, Iterable)形式的数据集</span><br><span class="line">* reduceByKey(func)：应用于(K,V)键值对的数据集时，返回一个新的(K, V)形式的数据集，其中的每个值是将每个key传递到函数func中进行聚合</span><br></pre></td></tr></table></figure><h6 id="2-行动操作"><a href="#2-行动操作" class="headerlink" title="2.行动操作"></a>2.行动操作</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">行动操作是真正触发计算的地方。Spark程序执行到行动操作时，才会执行真正的计算，从文件中加载数据，完成一次又一次转换操作，最终，完成行动操作得到结果。</span><br><span class="line">下面列出一些常见的行动操作（Action API）：</span><br><span class="line">* count() 返回数据集中的元素个数</span><br><span class="line">* collect() 以数组的形式返回数据集中的所有元素</span><br><span class="line">* first() 返回数据集中的第一个元素</span><br><span class="line">* take(n) 以数组的形式返回数据集中的前n个元素</span><br><span class="line">* reduce(func) 通过函数func（输入两个参数并返回一个值）聚合数据集中的元素</span><br><span class="line">* foreach(func) 将数据集中的每个元素传递到函数func中运行*</span><br></pre></td></tr></table></figure><p>######3.惰性机制解释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lines = sc.textFile(&quot;data.txt&quot;)</span><br><span class="line">lineLengths = lines.map(lambda s : len(s))</span><br><span class="line">totalLength = lineLengths.reduce( lambda a, b : a + b)</span><br><span class="line"></span><br><span class="line">1.第一行textFile读取文件构建一个RDD,textFile()只是一个转换操作,并不会直接将数据读到内存中,这时的lines只是一个指向这个文件的指针.</span><br><span class="line">2.map是一个转换操作,并不会立即计算每行的长度</span><br><span class="line">3.reduce是一个动作,这时就会触发真正的计算.spark会把计算分解和产能很多个小任务在不同的机器上运行,每台机器运行位于属于它的map和reduce.最后把结果返回给Driver.</span><br></pre></td></tr></table></figure><h6 id="4-持久化"><a href="#4-持久化" class="headerlink" title="4.持久化"></a>4.持久化</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">由于RDD采用的是惰性求值的方法,每次遇到行动操作都会从头开始计算,当程序有多个行动时,这样的代价就会很大.</span><br><span class="line"></span><br><span class="line">为了解决这个问题,通过持久化(缓存)机制避免重复计算的开销.通过persisit()方法对RDD标记为持久化(当触发第一个行动操作后,会将计算结果持久化,持久化的后的RDD将会保留在计算节点的内存中被后面的行动操作重复使用</span><br><span class="line"></span><br><span class="line">unpersist()方法手动地把持久化的RDD从缓存中移除。</span><br><span class="line"></span><br><span class="line">list = [<span class="string">"Hadoop"</span>,<span class="string">"Spark"</span>,<span class="string">"Hive"</span>]</span><br><span class="line">rdd = sc.parallelize(list)</span><br><span class="line">rdd.cache()  //会调用persist(MEMORY_ONLY)，但是，语句执行到这里，并不会缓存rdd，这是rdd还没有被计算生成</span><br><span class="line">print(rdd.count()) //第一次行动操作，触发一次真正从头到尾的计算，这时才会执行上面的rdd.cache()，把这个rdd放到缓存中</span><br><span class="line">print(<span class="string">','</span>.join(rdd.collect())) //第二次行动操作，不需要触发从头到尾的计算，只需要重复使用上面缓存中的rdd</span><br></pre></td></tr></table></figure><p>$rdd.foreach(print)或者rdd.map(print)打印输出$</p><p>$rdd.collect().foreach(print):将所有节点的数据打印,容易爆内存$</p><p>$rdd.take(100).foreach(print):打印RDD部分数据$</p><h6 id="5-键值对RDD"><a href="#5-键值对RDD" class="headerlink" title="5,键值对RDD"></a>5,键值对RDD</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#首先创建键值对RDD---两种方法</span></span><br><span class="line"><span class="comment">##方法1.读文件</span></span><br><span class="line">lines = sc.textFile(<span class="string">"file:///usr/local/spark/mycode/pairrdd/word.txt"</span>)</span><br><span class="line">pairRDD = lines.flatMap(<span class="keyword">lambda</span> line : line.split(<span class="string">" "</span>)).map(<span class="keyword">lambda</span> word : (word,<span class="number">1</span>))</span><br><span class="line">pairRDD.foreach(<span class="keyword">print</span>)</span><br><span class="line"><span class="comment">##方法2.通过列表</span></span><br><span class="line">list = [<span class="string">"Hadoop"</span>,<span class="string">"Spark"</span>,<span class="string">"Hive"</span>,<span class="string">"Spark"</span>]</span><br><span class="line">rdd = sc.parallelize(list)</span><br><span class="line">pairRDD = rdd.map(<span class="keyword">lambda</span> word : (word,<span class="number">1</span>))</span><br><span class="line">pairRDD.foreach(<span class="keyword">print</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">(Hadoop,1)</span></span><br><span class="line"><span class="string">(Spark,1)</span></span><br><span class="line"><span class="string">(Hive,1)</span></span><br><span class="line"><span class="string">(Spark,1)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#-----------------------------常用的键值对转换操作------------------------------</span></span><br><span class="line"><span class="comment">#reduceByKey()、groupByKey()、sortByKey()、join()、cogroup()等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#==============================reduceByKey()==================================</span></span><br><span class="line"><span class="comment">#用func函数合并具有相同键的值</span></span><br><span class="line">pairRDD.reduceByKey(<span class="keyword">lambda</span> a,b : a+b).foreach(<span class="keyword">print</span>) <span class="comment">#a,b都表示键对应的value,表示按照键合并,将值相加</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">输出</span></span><br><span class="line"><span class="string">(Spark,2)</span></span><br><span class="line"><span class="string">(Hive,1)</span></span><br><span class="line"><span class="string">(Hadoop,1)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#==============================groupByKey()==================================</span></span><br><span class="line"><span class="comment">#按照键进行分组</span></span><br><span class="line">pairRDD.groupByKey().foreach(<span class="keyword">print</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">输出</span></span><br><span class="line"><span class="string">(Spark,(1,1))</span></span><br><span class="line"><span class="string">(Hive,(1,))</span></span><br><span class="line"><span class="string">(Hadoop,(1,))</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#==============================keys()==================================</span></span><br><span class="line">pairRDD.keys().foreach(<span class="keyword">print</span>) <span class="comment">#&#123;“spark”,”spark”,”hadoop”,”hadoop”&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">输出</span></span><br><span class="line"><span class="string">hadoop</span></span><br><span class="line"><span class="string">spark</span></span><br><span class="line"><span class="string">hive</span></span><br><span class="line"><span class="string">spark</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#==============================values()==================================</span></span><br><span class="line">pairRDD.values().foreach(<span class="keyword">print</span>)<span class="comment">#&#123;1,2,3,5&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">输出</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#==============================sortByKey()==================================</span></span><br><span class="line">pairRDD.sortByKey()  <span class="comment">#返回根据键排序的RDD</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">输出</span></span><br><span class="line"><span class="string">(Hadoop,1)</span></span><br><span class="line"><span class="string">(Hive,1)</span></span><br><span class="line"><span class="string">(Spark,1)</span></span><br><span class="line"><span class="string">(Spark,1)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#==============================mapValues()==================================</span></span><br><span class="line">pairRDD.mapValues(<span class="keyword">lambda</span> x : x+<span class="number">1</span>)  <span class="comment">#对RDD键值对的所有value做相同的处理</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">输出</span></span><br><span class="line"><span class="string">(Hadoop,2)</span></span><br><span class="line"><span class="string">(Spark,2)</span></span><br><span class="line"><span class="string">(Hive,2)</span></span><br><span class="line"><span class="string">(Spark,2)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#==============================join()==================================</span></span><br><span class="line">pairRDD1 = sc.parallelize([(<span class="string">'spark'</span>,<span class="number">1</span>),(<span class="string">'spark'</span>,<span class="number">2</span>),(<span class="string">'hadoop'</span>,<span class="number">3</span>),(<span class="string">'hadoop'</span>,<span class="number">5</span>)])</span><br><span class="line">pairRDD2 = sc.parallelize([(<span class="string">'spark'</span>,<span class="string">'fast'</span>)])</span><br><span class="line">pairRDD1.join(pairRDD2).foreach(<span class="keyword">print</span>)   <span class="comment">#join默认内连接,相同的键才会返回</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">输出</span></span><br><span class="line"><span class="string">('spark',1,'fast')</span></span><br><span class="line"><span class="string">('spark',2,'fast')</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#===================================实例===================================</span></span><br><span class="line"><span class="comment">#计算每个键对应的平均值</span></span><br><span class="line">rdd = sc.parallelize([(<span class="string">"spark"</span>,<span class="number">2</span>),(<span class="string">"hadoop"</span>,<span class="number">6</span>),(<span class="string">"hadoop"</span>,<span class="number">4</span>),(<span class="string">"spark"</span>,<span class="number">6</span>)])</span><br><span class="line">rdd.mapValues(<span class="keyword">lambda</span> x : (x,<span class="number">1</span>)).reduceByKey(<span class="keyword">lambda</span> x,y : (x[<span class="number">0</span>]+y[<span class="number">0</span>],x[<span class="number">1</span>] + y[<span class="number">1</span>])).mapValues(<span class="keyword">lambda</span> x : (x[<span class="number">0</span>] / x[<span class="number">1</span>])).collect()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">输出:</span></span><br><span class="line"><span class="string">[('hadoop', 5.0), ('spark', 4.0)]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">collect()是一个行动操作，功能是以数组的形式返回数据集中的所有元素，当我们要实时查看一个RDD中的元素内容时，就可以调用collect()函数。</span><br></pre></td></tr></table></figure><p>#####共享变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">目的:要在多个任务之间共享变量，或者在任务（Task）和任务控制节点（Driver Program）之间共享变量</span><br><span class="line">Spark提供了两种类型的变量：广播变量（broadcast variables）和累加器（accumulators）</span><br><span class="line">广播变量:用来把变量在所有节点的内存之间进行共享。</span><br><span class="line">累加器:则支持在所有不同节点之间进行累加计算（比如计数或者求和）。</span><br></pre></td></tr></table></figure><h6 id="1-广播变量"><a href="#1-广播变量" class="headerlink" title="1.广播变量"></a>1.广播变量</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">通过广播方式进行传播的变量，会经过序列化，然后在被任务使用时再进行反序列化。</span><br><span class="line"></span><br><span class="line">broadcastVar = sc.broadcast([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">broadcastVar.value</span><br><span class="line"></span><br><span class="line">一旦广播变量创建后，普通变量v的值就不能再发生修改，从而确保所有节点都获得这个广播变量的相同的值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">用途:经常需要把两个数据集组合起来获取结果数据集</span><br><span class="line">    方法1:可以直接以rdd形式连接两个数据集====&gt;但是可能会导致数据混洗(shuffle),代价很大</span><br><span class="line">    方法<span class="number">2</span>:将小的数据集初始化为广播变量,原理是将将变量复制到所有节点上</span><br><span class="line"></span><br><span class="line">目的:进程间共享数据</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">要点:</span><br><span class="line">    <span class="number">1.</span>使用广播变量避免了数据混洗</span><br><span class="line">    <span class="number">2.</span>每个节点复制一份数据而非每个任务复制一次</span><br><span class="line">    <span class="number">3.</span>广播变量可以被多个任务多次使用(广播变量的好处，不需要每个task带上一份变量副本，而是变成每个节点的executor才一份副本)</span><br></pre></td></tr></table></figure><h6 id="2-累加器"><a href="#2-累加器" class="headerlink" title="2.累加器"></a>2.累加器</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">通常可以被用来实现计数器（counter）和求和（sum）</span><br><span class="line">accum = sc.accumulator(<span class="number">0</span>)</span><br><span class="line">sc.parallelize([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).foreach(<span class="keyword">lambda</span> x : accum.add(x))</span><br><span class="line">accum.value</span><br></pre></td></tr></table></figure><h5 id="RDD打印数据"><a href="#RDD打印数据" class="headerlink" title="RDD打印数据"></a>RDD打印数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.rdd.foreach(print)</span><br><span class="line">2.rdd.collect()  ==可能导致内存溢出</span><br><span class="line">3.rdd.take(100)</span><br></pre></td></tr></table></figure><p>##### </p><p>RDD运行原理—-阶段的划分和RDD的运行过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">宽依赖窄依赖</span><br><span class="line">宽依赖：父RDD的分区被子RDD的多个分区使用(一对一,多对一)</span><br><span class="line">窄依赖：父RDD的每个分区都只被子RDD的一个分区使用 (一对多)</span><br><span class="line">shuffle操作:洗牌</span><br></pre></td></tr></table></figure><p>fork and join机制</p><p>####standalone环境配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">Spark standalone部署配置</span><br><span class="line">1.在home路径下创建文件夹spark,然后cd spark-----&gt;这个文件夹需要所有用户都可以使用</span><br><span class="line">1.配置JAVA环境</span><br><span class="line">(1)在spark文件夹下,创建java文件夹,然后cd java</span><br><span class="line">(2)将压缩包jdk-15.0.1_linux-x64_bin.tar.gz 上传到java目录下</span><br><span class="line">(3)解压缩jdk包.使用命令tar -xvf jdk-15.0.1_linux-x64_bin.tar.gz 会出现一个文件夹jdk-15.0.1</span><br><span class="line">(4)cd jdk-15.0.1 进入文件夹下,使用pwd命令查看当前路径,并记住路径,下面要用</span><br><span class="line">(5)打开配置文件 vim /etc/profile(非管理 ~/.bashrc),加入下面配置,JAVA_HOME为(4)输出的路径</span><br><span class="line">JAVA_HOME=/home/spark/java/jdk-15.0.1</span><br><span class="line">CLASSPATH=$JAVA_HOME/lib:$JAVA_HOME/jre/lib</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin</span><br><span class="line"></span><br><span class="line">(export JAVA_HOME=/home/spark/java/jdk-15.0.1</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar   上面那个如果没成功试试这个)</span><br><span class="line">(6)source /etc/profile 保存修改</span><br><span class="line">(7)输入javac,未报错即成功配置java环境</span><br><span class="line">(8)执行两次cd .. 进入spark目录下</span><br><span class="line"></span><br><span class="line">2.配置spark环境</span><br><span class="line">(1)在spark目录下创建pyspark文件夹,mkdir pyspark</span><br><span class="line">(2)cd pyspark,然后将压缩包spark-3.0.1-bin-hadoop3.2.tgz 上传到pyspark目录下</span><br><span class="line">(3)解压缩tar -xvf spark-3.0.1-bin-hadoop3.2.tgz</span><br><span class="line">(4)cd spark-3.0.1-bin-hadoop3.2/conf ,进入文件夹,可看到以下文件</span><br><span class="line"></span><br><span class="line">(5)cp spark-env.sh.template spark-env.sh ,复制一个spark-env.sh文件</span><br><span class="line">(6)然后vim spark-env.sh,在末尾加入配置</span><br><span class="line">export PYSPARK_PYTHON=/usr/bin/python3</span><br><span class="line">(7)source spark-env.sh</span><br><span class="line"></span><br><span class="line">(8)打开配置文件 vim /etc/profile(非管理vim ~/.bashrc   vi ~/.bash_profile),加入下面配置,SPARK_HOME为spark的安装路径</span><br><span class="line">SPARK_HOME=/home/spark/pyspark/spark-3.0.1-bin-hadoop3.2</span><br><span class="line">export PATH=$PATH:$SPARK_HOME/bin</span><br><span class="line">export PYSPARK_PYTHON=python3</span><br><span class="line">(9)source /etc/profile</span><br><span class="line">(10)pip3 install pyspark -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">(11)输入pyspark,进入下面的页面即成功</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">1.需要在227,231和217分别进行相同的配置</span><br><span class="line">2.创建的文件夹spark,需要所有用户均可操作(用以启动服务,跑代码)</span><br><span class="line"></span><br><span class="line">当三台全部配置好的时候:</span><br><span class="line">进入217:</span><br><span class="line">1.cd  /home/spark/pyspark/spark-3.0.1-bin-hadoop3.2/sbin</span><br><span class="line">2.执行 ./start-master.sh</span><br><span class="line">   进入231:</span><br><span class="line">1. cd  /home/spark/pyspark/spark-3.0.1-bin-hadoop3.2/sbin</span><br><span class="line">2. 执行 ./start-slave.sh spark://192.168.0.217:7077</span><br><span class="line">进入227:</span><br><span class="line">1. cd  /home/spark/pyspark/spark-3.0.1-bin-hadoop3.2/sbin</span><br><span class="line">2. 执行 ./start-slave.sh spark://192.168.0.217:7077</span><br><span class="line"></span><br><span class="line">export JAVA_HOME=/home/kuailiang/2020/java/jdk1.8.0_281</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.Spark在计算的过程中，是不是特别消耗内存？</span><br><span class="line">  不是。Spark是在管道中计算的，而管道中不是特别耗内存。即使有很多管道同时进行，也不是特别耗内存。</span><br><span class="line">2.什么样的场景最耗内存？</span><br><span class="line">  使用控制类算子的时候耗内存，特别是使用cache时最耗内存。</span><br><span class="line">3.如果管道中有cache逻辑，他是如何缓存数据的？</span><br><span class="line">有cache时，会在一个task运行成功时（遇到action类算子时），将这个task的运行结果缓存到内存中</span><br><span class="line">4.RDD（弹性分布式数据集），为什么他不存储数据还叫数据集？</span><br><span class="line">    虽然RDD不具备存储数据的能力，但是他具备操作数据的能力。</span><br><span class="line">5.如果有1T数据，单机运行需要30分钟，但是使用Saprk计算需要两个小时（4node），为什么？</span><br><span class="line">1）、发生了计算倾斜。大量数据给少量的task计算。少量数据却分配了大量的task。</span><br><span class="line">2）、开启了推测执行机制</span><br><span class="line">6.</span><br></pre></td></tr></table></figure><h5 id="运行spark程序"><a href="#运行spark程序" class="headerlink" title="运行spark程序"></a>运行spark程序</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sc.master可以查看当前的运行模式</span><br><span class="line">1.本地运行pyspark程序</span><br><span class="line">pyspark --master local[4]  ====&gt;local[4]表示在本地运行,使用四个线程,local[*]表示尽可能多的使用核心</span><br><span class="line"></span><br><span class="line">   pyspark --master spark://192.168.0.217:7077   暂时有问题不知道是不是231ip问题,后面重启后在尝试一下</span><br></pre></td></tr></table></figure><h5 id="pandas的DF和spark的DF对比"><a href="#pandas的DF和spark的DF对比" class="headerlink" title="pandas的DF和spark的DF对比"></a>pandas的DF和spark的DF对比</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">两者的异同：</span><br><span class="line"></span><br><span class="line">Pyspark DataFrame是在分布式节点上运行一些数据操作，而pandas是不可能的；</span><br><span class="line">Pyspark DataFrame的数据反映比较缓慢，没有Pandas那么及时反映；</span><br><span class="line">Pyspark DataFrame的数据框是不可变的，不能任意添加列，只能通过合并进行；</span><br><span class="line">pandas比Pyspark DataFrame有更多方便的操作以及很强大</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">有效专利:针对一件专利,从申请日期开始,一直到失效日期都是有效的,若专利没有失效日期,需要结合当前状态去判断,如果当前状态为授权状态/再审状态,按照最大年限去认定失效日期,发明为20年,新型为10年.如果当前状态为失效,则判断不了具体失效时间,不做统计(总共只有一条).</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">,没有失效日期的按照最大年限去考虑,如发明专利,从申请日期开始往后20年都是有效的</span><br></pre></td></tr></table></figure><h5 id="spark-sql架构"><a href="#spark-sql架构" class="headerlink" title="spark sql架构"></a>spark sql架构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.列式存储</span><br><span class="line"></span><br><span class="line">2.dataframe api</span><br><span class="line"></span><br><span class="line">3.DAG部分执行(pde),让我们在执行时根据处理过程中发现的一些数据动态修改和优化DAG.</span><br></pre></td></tr></table></figure><h4 id="jupyter-notebook连接spark"><a href="#jupyter-notebook连接spark" class="headerlink" title="jupyter notebook连接spark"></a>jupyter notebook连接spark</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">spark_name = <span class="string">'/home/spark/pyspark/spark-3.0.1-bin-hadoop3.2'</span></span><br><span class="line">sys.path.insert(<span class="number">0</span>,os.path.join(spark_name,<span class="string">'python'</span>))</span><br><span class="line">sys.path.insert(<span class="number">0</span>,os.path.join(spark_name,<span class="string">'python/lib/py4j-0.10.9-src.zip'</span>))</span><br><span class="line">exec(open(os.path.join(spark_name,<span class="string">'python/pyspark/shell.py'</span>)).read())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>距离和相似度</title>
      <link href="/2020/12/04/%E8%B7%9D%E7%A6%BB%E5%92%8C%E7%9B%B8%E4%BC%BC%E5%BA%A6/"/>
      <url>/2020/12/04/%E8%B7%9D%E7%A6%BB%E5%92%8C%E7%9B%B8%E4%BC%BC%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h4 id="综合"><a href="#综合" class="headerlink" title="综合:"></a>综合:</h4><p>​    距离和相似度是用来判断相似性两种不同的方法</p><h4 id="距离-物体在空间中的距离-距离越远越不相似"><a href="#距离-物体在空间中的距离-距离越远越不相似" class="headerlink" title="距离(物体在空间中的距离,距离越远越不相似)"></a>距离(物体在空间中的距离,距离越远越不相似)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.欧式距离:计算的是空间位置的绝对路径,要求是指标维度的度量要一致,如kg和cm会出问题</span><br><span class="line">1.1欧氏距离标准化 -- &gt;对各个维度数据进行标准化,使之在同一度量上</span><br><span class="line"></span><br><span class="line">2.曼哈顿距离:</span><br><span class="line"></span><br><span class="line">2.明式距离</span><br><span class="line">p = 1 曼哈顿</span><br><span class="line">p = 2 欧式</span><br><span class="line">p -&gt; 无穷 契比雪夫</span><br><span class="line"></span><br><span class="line">3.切比雪夫距离</span><br><span class="line">国际象棋中国王的走路,每次只能在八个格变化</span><br><span class="line">明式距离P趋近无穷时</span><br><span class="line"></span><br><span class="line">4.马氏距离</span><br><span class="line">欧式距离,指标维度不同是,需要进行归一化,归一化后即是马氏距离</span><br><span class="line"></span><br><span class="line">5.海明距离</span><br><span class="line">两个等长字符串,相同位置字符不同的个数----&gt;引入,物体压缩成字符串,进行比较</span><br></pre></td></tr></table></figure><h6 id="相似度-相似程度-越大越好"><a href="#相似度-相似程度-越大越好" class="headerlink" title="相似度(相似程度,越大越好)"></a>相似度(相似程度,越大越好)</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>余弦相似度:</span><br><span class="line">注重两个向量在方向上的差异，而非距离或长度上,如,在指定夹角里,两点距离可无限远,忽略大距离的影响</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>调整余弦相似度:</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>皮尔逊系数:</span><br><span class="line">自身向量标准化后计算空间向量的余弦夹角</span><br><span class="line"></span><br><span class="line"><span class="number">4.j</span>accard 系数:</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>广义Jaccard系数:</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>互信息/信息增益，相对熵/KL散度</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>TF-IDF等:</span><br></pre></td></tr></table></figure><h6 id="距离和相似度的区别"><a href="#距离和相似度的区别" class="headerlink" title="距离和相似度的区别"></a>距离和相似度的区别</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">距离衡量的是空间中的距离,与坐标位置直接相关,而相似度体现的是体现方向上的差异</span><br><span class="line">距离:维度的数值大小中体现差异的分析</span><br><span class="line">相似度:对绝对的数值不敏感</span><br></pre></td></tr></table></figure><h5 id="欧式和余弦的区别"><a href="#欧式和余弦的区别" class="headerlink" title="欧式和余弦的区别:"></a>欧式和余弦的区别:</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">一致性:衡量个体间差异的大小</span><br><span class="line"></span><br><span class="line">定义:</span><br><span class="line">欧氏距离:向量在空间中的距离</span><br><span class="line">余弦相似:相似度夹角</span><br><span class="line">        </span><br><span class="line">差别:</span><br><span class="line">欧氏距离:对数值敏感</span><br><span class="line">余弦相似:对偏向敏感</span><br><span class="line"></span><br><span class="line">余弦夹角可以有效规避个体相同认知中不同程度的差异表现，更注重维度之间的差异，而不注重数值上的差异</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总结:一个更侧重于偏向,如x轴,y轴.(余弦)  宁一个更侧重数值差异性,值的相似程度</span><br></pre></td></tr></table></figure><h5 id="核心节点专利图"><a href="#核心节点专利图" class="headerlink" title="核心节点专利图:"></a>核心节点专利图:</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#涉及到距离的部分总共涉及两个</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>计算专利和专利的相似度</span><br><span class="line"><span class="number">1</span>)上期计算是通过h5文件直接读取专利与专利之间的相似度</span><br><span class="line">    <span class="number">2</span>)本期改版,通过专利的词向量来计算,使用余弦相似度</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql实战45讲</title>
      <link href="/2020/11/18/mysql%E5%AE%9E%E6%88%9845%E8%AE%B2/"/>
      <url>/2020/11/18/mysql%E5%AE%9E%E6%88%9845%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h4 id="第一讲-Mysql查询执行流程-笔记来自极客时间"><a href="#第一讲-Mysql查询执行流程-笔记来自极客时间" class="headerlink" title="第一讲 Mysql查询执行流程(笔记来自极客时间)"></a>第一讲 Mysql查询执行流程(笔记来自极客时间)</h4><h5 id="1-mysql架构"><a href="#1-mysql架构" class="headerlink" title="1.mysql架构"></a>1.mysql架构</h5><p><img src="/2020/11/18/mysql实战45讲/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="img"></p><h5 id="2-架构解释"><a href="#2-架构解释" class="headerlink" title="2.架构解释"></a>2.架构解释</h5><p>​        ①mysql架构由两部分组成,server端和存储引擎</p><p>​                ②    连接器:建立连接,验证权限,维持和管理连接</p><p>​                        分析器:首先分析每个词代表的含义,然后分析整个sql语句的语法</p><p>​                        查询缓存:键值对形式,sql语句对应数据缓存,命中sql,则直接返回数据。</p><p>​                        优化器:join时优先表的选择,及多索引优先索引选择</p><p>​                        执行器:表权限验证,操作引擎获取数据</p><p>​        ③ 其他补充:</p><p>​            1)查询缓存在8.0版本取消,查询缓存并没有想象中那么好用,命中率很低,而且表变化后缓存就会清空,适合静态表,很久才更新的那种</p><p>​                         2)如果查询缓存命中的时候,会在返回数据的时候做权限验证,验证是否有这张表的权限</p><p>​                         3)执行器,在执行sql前先判断是否对表有执行查询的权限,有则从引擎取数据</p><h4 id="第二讲-Mysql更新记录操作流程"><a href="#第二讲-Mysql更新记录操作流程" class="headerlink" title="第二讲  Mysql更新记录操作流程"></a>第二讲  Mysql更新记录操作流程</h4><h5 id="总体-1-查询的执行过程同查询过程一致"><a href="#总体-1-查询的执行过程同查询过程一致" class="headerlink" title="总体:1.查询的执行过程同查询过程一致"></a>总体:1.查询的执行过程同查询过程一致</h5><h5 id="2-一个表的数据更新的时候-跟这个表相关的所有缓存都会消失"><a href="#2-一个表的数据更新的时候-跟这个表相关的所有缓存都会消失" class="headerlink" title="2.一个表的数据更新的时候,跟这个表相关的所有缓存都会消失"></a>2.一个表的数据更新的时候,跟这个表相关的所有缓存都会消失</h5><h5 id="3-不同于查询-更新涉及到两个日志模块。redo-log和binlog"><a href="#3-不同于查询-更新涉及到两个日志模块。redo-log和binlog" class="headerlink" title="3.不同于查询,更新涉及到两个日志模块。redo log和binlog"></a>3.不同于查询,更新涉及到两个日志模块。redo log和binlog</h5><h5 id="redo-log-保证数据不会丢失-—-gt-innodb特有"><a href="#redo-log-保证数据不会丢失-—-gt-innodb特有" class="headerlink" title="redo log:(保证数据不会丢失)—-&gt;innodb特有"></a>redo log:(保证数据不会丢失)—-&gt;innodb特有</h5><p>​    1.目的:每次更新都需要写到磁盘,然后磁盘也要找到那条记录然后更新数据,这样导致整个IO成本和查找成本都很高.同时redo log</p><p>​    2.日志和磁盘和结合,即所说的WAL技术(write ahead logging),即先写日志,再写磁盘(不忙的时候),日志写满则开始写入磁盘</p><p>​        补充:日志存储在磁盘里,写日志用的是顺序IO,更新操作用的是随机IO,而顺序IO比随机IO 快很多(随机IO要寻址)</p><p>​    3.crash safe能力:数据库异常重启时,不会丢失数据</p><h5 id="binlog-server层特有-—-gt-所有引擎共用"><a href="#binlog-server层特有-—-gt-所有引擎共用" class="headerlink" title="binlog:(server层特有)—-&gt;所有引擎共用"></a>binlog:(server层特有)—-&gt;所有引擎共用</h5><p>​    1.没有crash_safe能力</p><p>​    2.为什么会有两个日志?因为本来mysql 并没有innodb引擎,所以只有binlog日志,后来innodb作为插件引入到mysql,由于binlog没有crash-safe能力,所以引入了新的日志系统redo-log.binlog用于归档</p><h5 id="redolog和binlog的区别"><a href="#redolog和binlog的区别" class="headerlink" title="redolog和binlog的区别"></a>redolog和binlog的区别</h5><p>​    1.redo是innodb引擎特有的,而binlog是所有引擎共有的</p><p>​    2.redo是物理日志,记录在某个&lt;数据页&gt;做了什么修改,binlog是逻辑日志.记录了sql</p><p>​        Binlog有两种模式，statement 格式的话是记sql语句， row格式(常用)会记录行的内容，记两条，更新前和更新后都有。</p><p>​    3.redo log是循环写,空间有限制,写完了就写入磁盘然后重新写.而binlog是追加写,一个文件达到一定大小后,开始下一个</p><h5 id="update流程"><a href="#update流程" class="headerlink" title="update流程"></a>update流程</h5><p><img src="/2020/11/18/mysql实战45讲/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" alt="img"></p><p>1.获取id=2这行判断是否在缓存里.若果是则直接获取,不是则从磁盘读取.</p><p>2.将这行数据的c+1</p><p>3.写入新行</p><p>4.引擎将这行数据更新到内存中,同时记录在redo log中,次数redo log处于prepare阶段,随时可提交事务</p><p>5.执行器生成这个操作的binlog,并将binlog写入磁盘</p><p>6.执行器调用引擎执行事务的接口,redo log处于commit阶段—&gt;两阶段提交为了让binlog和redo log的逻辑一致</p><h5 id="binlog数据恢复过程"><a href="#binlog数据恢复过程" class="headerlink" title="binlog数据恢复过程"></a>binlog数据恢复过程</h5><p>1.假如无删除操作,恢复数据需要最近一次的全量备份数据和现在的binlog,但是需要将binlog里无删除操作去掉,然后将binlog放到旧数据的指定位置.这样就恢复了</p><h5 id="为什么要分两段提交以及提交的顺序-这里不使用分段提交"><a href="#为什么要分两段提交以及提交的顺序-这里不使用分段提交" class="headerlink" title="为什么要分两段提交以及提交的顺序(这里不使用分段提交)"></a>为什么要分两段提交以及提交的顺序(这里不使用分段提交)</h5><p>​    1.先写redo log 后写bin log</p><p>​        假设redo log 写完后,系统重启,这时候binlog还没写,redo log 写过,这样当使用binlog恢复数据时,就会出现数据库少了一次更新</p><p>​    2.先写bin log 后写 redo log</p><p>​        假设在写完binlog时候crash,由于redo log没有提交,则重启后事务无效,但是binlog已经更改,这样,当恢复数据的时候就会出现多了一次事务</p><h4 id="第三讲-事务隔离"><a href="#第三讲-事务隔离" class="headerlink" title="第三讲 事务隔离"></a>第三讲 事务隔离</h4><h6 id="事务-保证对数据库操作的一致性-一组操作全部成功或者全部失败"><a href="#事务-保证对数据库操作的一致性-一组操作全部成功或者全部失败" class="headerlink" title="事务:保证对数据库操作的一致性,一组操作全部成功或者全部失败"></a>事务:保证对数据库操作的一致性,一组操作全部成功或者全部失败</h6><h5 id="1-Innodb支持事务而Mysiam不支持"><a href="#1-Innodb支持事务而Mysiam不支持" class="headerlink" title="1.Innodb支持事务而Mysiam不支持"></a>1.Innodb支持事务而Mysiam不支持</h5><h5 id="2-事务的隔离性和隔离级别"><a href="#2-事务的隔离性和隔离级别" class="headerlink" title="2.事务的隔离性和隔离级别"></a>2.事务的隔离性和隔离级别</h5><p>​    ①事务的特性:ACID,原子性,一致性,隔离性,持久性</p><p>​    ②多事务可能出现的问题:脏读,幻读,不可重复读</p><p>​        脏读:读到其他事务未提交的数据</p><p>​        幻读:前后读取的记录数量不一致</p><p>​        不可重复读:读取前后的数据不一致</p><p>​    ③事务的隔离级别(为了解决上面的多事务问题):读未提交,读已提交,可重复读,序列化(串行化)</p><p>​        读未提交(RU):一个事务没提交,但是变更可被其他事务看到</p><p>​        读已提交(RC):一个事务提交后,变更才能被其他事务看到</p><p>​        可重复读(RR):事务在执行过程中读到的数据和事务启动时的数据一致</p><p>​        串行化(Serial):指的是会给同一行加锁.读锁和写锁.当读写冲突时,后面的事务需要等前一个事务结束后才行</p><p>​        $\textcolor{red}{总结:}$</p><p>​            1.在实现上,主要是通过MVCC视图(数据库会创建),但是针对RU是没有是没有视图概念的,直接返回记录上的最新值</p><p>​            2.针对RC,是在每一个SQL语句开始执行的时候创建的视图</p><p>​            3.RR是在事务启动时候创建的视图</p><p>​            4.Serial直接用加锁的方式避免并行,无视图概念</p><p>​            $视图的概念:$视图是一种虚拟存在的表，是一个逻辑表，本身并不包含数据。是基于 SQL 语句的结果集的可视化的表，可以包含表的全部或者部分记录，也可以由一个表或者多个表来创建.实际上是在数据库里执行了SELECT语句，SELECT语句包含了字段名称、函数、运算符，来给用户$\textcolor{red}{显示数据}$。</p><h5 id="2-事务隔离的实现"><a href="#2-事务隔离的实现" class="headerlink" title="2.事务隔离的实现"></a>2.事务隔离的实现</h5><p>​    在数据更新的时候mysql的redo log会做一个变更记录，同时与变更相反的回滚操作记录会记录在undo log上</p><p>​    例:回滚日志记录</p><p><img src="/2020/11/18/mysql实战45讲/d9c313809e5ac148fc39feff532f0fee.png" alt="d9c313809e5ac148fc39feff532f0fee"></p><p>​    原操作是从1到2再到3再到4.当前值为4,但是不同时刻启动的事务会有不同的视图.同一条记录在系统中可以存在多个版本,这就是数据库的多版本并发控制(mvcc).</p><p>​    回滚日志并非一直并非一直存在,当系统中没有比日志更早的视图的时候,回滚日志就会被删除</p><p>​    所以尽量避免长事务.长事务导致undo log一直存在不会被删除.且会占用大量的空间</p><h4 id="第四讲深入浅出索引-一种数据结构"><a href="#第四讲深入浅出索引-一种数据结构" class="headerlink" title="第四讲深入浅出索引(一种数据结构)"></a>第四讲深入浅出索引(一种数据结构)</h4><h5 id="1-常见的索引模型"><a href="#1-常见的索引模型" class="headerlink" title="1.常见的索引模型"></a>1.常见的索引模型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.哈希表:一种以键值存储数据的结构,原理是当传入一个键的时候,会通过哈希函数返回一个位置,直接将位置的value取出即可.但是存在不同的键经过哈希函数以后返回相同的value.处理这种情况是拉开一个链表。</span><br><span class="line"></span><br><span class="line">Mysql的hash索引是把索引字段经过hash函数计算得出hash码存放到key里面，value里面存放的是对应记录的位置，遇到相同的值或者计算出相同的hash码，就会在那个hash码上使用链表方式解决相同hash码的问题。</span><br><span class="line"></span><br><span class="line">----------------适合做等值查询，范围查询效率低-------------------</span><br><span class="line"></span><br><span class="line">2.有序数组:用二分法操作的，对于等值查询和范围查询性能都很优秀，但是更新数据非常麻烦，中间插入数据，后面所有的记录都得往后挪动，成本高</span><br><span class="line"></span><br><span class="line">3.搜索树:</span><br><span class="line">二叉搜索树：父节点左子树所有节点的值小于右节点，但是大多数的数据库很少用二叉树，因为索引不仅存在内存中还要写到磁盘上。（高度不可控，IO特别大）</span><br><span class="line">多叉搜索树(B+树)：相对于二叉是为了减少IO。由于在读写上的性能优点，以及适配磁盘的访问模式，被广泛应用在</span><br></pre></td></tr></table></figure><p>$\textcolor{red}{总结:}$数据库的底层核心就是这些数据模型,碰到一个新的数据库需要关心它的数据类型,这样才能在理论上分析数据库的适用场景</p><h5 id="2-Innodb的索引模型"><a href="#2-Innodb的索引模型" class="headerlink" title="2.Innodb的索引模型"></a>2.Innodb的索引模型</h5><p>在 InnoDB 中，每一张表其实就是多个 B+ 树，即一个主键索引树和多个非主键索引树</p><p>$\textcolor{red}{使用B+树的原因}$B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。</p><p><img src="/2020/11/18/mysql实战45讲/360截图17290508656955.png" alt="360截图17290508656955"></p><p>主键索引： key:主键的值，value:整行数据。 普通列索引： key：索引列的值， value:主键的值。</p><p>$\textcolor{red}{回表}$</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ID为主键索引,k为普通索引</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> <span class="keyword">ID</span>=<span class="number">500</span>，即主键查询方式,则只需要搜索 <span class="keyword">ID</span> 这棵 B+ 树</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> k=<span class="number">5</span>，即普通索引查询方式,则需要先搜索 k 索引树，得到 <span class="keyword">ID</span> 的值为 <span class="number">500</span>，再到 <span class="keyword">ID</span> 索引树搜索一次。这个过程称为回表</span><br><span class="line">也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</span><br></pre></td></tr></table></figure><h5 id="3-索引维护"><a href="#3-索引维护" class="headerlink" title="3.索引维护"></a>3.索引维护</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B+Tree为了维护索引的有序性,在插入新值的时候需要做必要的维护.(上图,比如数据现id为700,添加新的行的id为700,则只需要在r5后面记录插入的新纪录,如果插入的值为400,则需要挪动后面的数据,空出位置.假如R5的数据页已经满了,则需要在申请一个新的数据页,然后挪动数据过去---&gt;页分裂.---&gt;影响数据页的利用率,原本一个页的数据放到了)</span><br></pre></td></tr></table></figure><h4 id="第六讲-全局锁和表锁"><a href="#第六讲-全局锁和表锁" class="headerlink" title="第六讲:全局锁和表锁"></a>第六讲:全局锁和表锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">锁涉及的初衷:处理并发问题</span><br><span class="line"></span><br><span class="line">分类:根据加锁范围分为全局锁,表级锁,行锁</span><br></pre></td></tr></table></figure><h5 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">说明:给整个数据库实例加锁</span><br><span class="line">状态:如全局读锁,整个数据库只允许读,不允许改和删等</span><br><span class="line">使用场景:全库逻辑备份</span><br><span class="line">风险：</span><br><span class="line">1.如果在主库备份，在备份期间不能更新，业务停摆</span><br><span class="line">2.如果在从库备份，备份期间不能执行主库同步的binlog，导致主从延迟</span><br></pre></td></tr></table></figure><h5 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">分类:表锁,元数据锁(MDL)</span><br><span class="line">对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大</span><br><span class="line">在对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</span><br><span class="line">读锁之间不互斥。读写锁之间，写锁之间是互斥的，用来保证变更表结构操作的安全性。</span><br></pre></td></tr></table></figure><h5 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">行锁是各个引擎自己实现的,并不是所有的引擎都支持行锁,不支持的只能使用表锁</span><br><span class="line">Innodb支持行锁,Mysiam不支持行锁.使用的是表锁,任何时候只能有一个更新在执行,影响了并发度.适合读多写少的操作</span><br></pre></td></tr></table></figure><p>linux 装mysql5.7</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">https://www.suibibk.com/topic/721421244804628480</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pypy</title>
      <link href="/2020/09/24/pypy/"/>
      <url>/2020/09/24/pypy/</url>
      
        <content type="html"><![CDATA[<h4 id="pypy-install"><a href="#pypy-install" class="headerlink" title="pypy install"></a>pypy install</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line">export PATH=/home/kuailiang/pypy3.6-v7.3.1-linux64/bin:$PATH</span><br><span class="line">source ~/.bashrc</span><br><span class="line"></span><br><span class="line">pypy3 -m ensurepip  </span><br><span class="line">curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py</span><br><span class="line">安装模块:</span><br><span class="line">pypy3 -m pip install requests</span><br></pre></td></tr></table></figure><p>pip3出现问题时候 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash -r</span><br><span class="line">清除缓存后即可。</span><br></pre></td></tr></table></figure><h3 id="查看代码耗时"><a href="#查看代码耗时" class="headerlink" title="查看代码耗时"></a>查看代码耗时</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%timeit results_data[&apos;five_part_divide&apos;] = results_data.sm.apply(lambda x:five_part_divide(x))</span><br><span class="line"></span><br><span class="line">%prun -l 4 results_data[&apos;five_part_divide&apos;] = results_data.sm.apply(lambda x:five_part_divide(x))  #展示最耗时的四个操作,内置魔法方法</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习</title>
      <link href="/2020/09/08/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/09/08/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="1-helloworld代码"><a href="#1-helloworld代码" class="headerlink" title="1.helloworld代码"></a>1.helloworld代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  /*头文件,C语言的一个文件,主要用于关键词输入和显示输出的功能,这里的作用是键入stdio的所有内容*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  <span class="comment">/*int 表示返回的类型为整形,main为函数名,void表示不传任何参数*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  num = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"helloworld%d次"</span>,num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>######helloworld注解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>注释用法<span class="comment">/**/</span> 或者<span class="comment">//</span></span><br><span class="line"><span class="number">2.</span>main函数是c程序的基础,所有c程序都是从main函数开始的</span><br><span class="line"><span class="number">3.</span>花括号&#123;&#125;表示函数的主体</span><br><span class="line"><span class="number">4.</span><span class="keyword">void</span>可写在括号里,也可以卸载main前面,推荐使用前者,后者有些编译器支持,有些不支持</span><br><span class="line"><span class="number">5.</span>所有变量使用前必须先定义</span><br></pre></td></tr></table></figure><h6 id="C程序的构成"><a href="#C程序的构成" class="headerlink" title="C程序的构成"></a>C程序的构成</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">程序是由一个或者多个函数组成,其中必须有一个main函数,函数由函数头和函数体构成,函数头包括预处理(指的是导入的文件)和函数名,函数体位于花括号中并由一系列语句组成,每个语句由分号结束,最后main函数由<span class="keyword">return</span>结束.</span><br><span class="line"><span class="number">2.</span>算子:指参与运算的值 如 <span class="number">2</span>+<span class="number">3</span>,<span class="number">2</span>和<span class="number">3</span>就是算子</span><br></pre></td></tr></table></figure><h5 id="2-多个函数"><a href="#2-多个函数" class="headerlink" title="2.多个函数"></a>2.多个函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">/*通知编译器要用到该函数,第一个void表函数没有返回值,第二个void表示函数没有参数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"我进来了"</span>);</span><br><span class="line">fun();    <span class="comment">/*调用该函数*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"结束了"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">void</span>)</span>   <span class="comment">/*声明函数*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"我是66啊"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-c语言关键字"><a href="#3-c语言关键字" class="headerlink" title="3.c语言关键字"></a>3.c语言关键字</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> </span><br><span class="line"><span class="keyword">case</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">char</span></span><br><span class="line"><span class="keyword">const</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">default</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">double</span></span><br><span class="line"><span class="keyword">while</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">exterm</span><br><span class="line"><span class="keyword">float</span></span><br><span class="line"><span class="keyword">for</span></span><br><span class="line"><span class="keyword">goto</span></span><br><span class="line"><span class="keyword">if</span></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line"><span class="keyword">long</span></span><br><span class="line"><span class="keyword">register</span></span><br><span class="line"><span class="keyword">restrict</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">short</span></span><br><span class="line"><span class="keyword">signed</span></span><br><span class="line"><span class="keyword">sizeof</span></span><br><span class="line"><span class="keyword">static</span></span><br><span class="line">struct</span><br><span class="line"><span class="keyword">switch</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">unsigned</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line"><span class="keyword">volatile</span></span><br><span class="line">_bool</span><br><span class="line">_complex</span><br><span class="line">_imaginary</span><br></pre></td></tr></table></figure><p>#####3.体重</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> weight;</span><br><span class="line">    <span class="keyword">float</span> value;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入你的体重"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;weight);</span><br><span class="line">    value = <span class="number">770</span> * weight * <span class="number">14.5833</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果scanf报错需要将属性中的常规里的c++/c中的sdl检查改成否*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>()函数提供键盘输入功能,%f表示输入的是浮点数,&amp;weight表示将输入的值赋值给weight</span><br></pre></td></tr></table></figure><h6 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">整数:整数以二进制存储</span><br><span class="line">浮点数:存储方式是将整数部分和小数部分分开存储</span><br><span class="line"><span class="keyword">int</span>有三个修饰符,<span class="keyword">long</span> <span class="keyword">short</span> <span class="keyword">unsigned</span></span><br><span class="line">  <span class="keyword">short</span> <span class="keyword">int</span> :占用可能比<span class="keyword">int</span>更少的空间,适用于小数值存储(不同机器,<span class="keyword">short</span>可能和<span class="keyword">int</span>占用一样,如<span class="number">16</span>位)</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> : 可能占用比<span class="keyword">int</span>更多的内存,适用于大数值的场合</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>:比<span class="keyword">long</span> <span class="keyword">int</span>更大的的内存和存储空间</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> :无符号整形,正数,范围<span class="number">0</span><span class="number">-65535</span>,<span class="keyword">int</span> 为有符号,范围<span class="number">-32768</span>到<span class="number">32767</span></span><br><span class="line">  现在一般情况:</span><br><span class="line">  longlong <span class="number">64</span>位,<span class="keyword">long</span> <span class="number">32</span>位,<span class="keyword">short</span> <span class="number">16</span>位,<span class="keyword">int</span> <span class="number">16</span>或者<span class="number">32</span>位</span><br><span class="line">当数值超过类型的表示范围时,即溢出,会从头开始有符号从负的开始,无符号从<span class="number">0</span>开始</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>:(%c)</span><br><span class="line"><span class="keyword">char</span> grad = <span class="string">'a'</span>; 将a转换成相应的编码值</span><br><span class="line"><span class="keyword">char</span> grad = <span class="string">"a"</span>; 将a当成字符串</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span>/<span class="keyword">double</span>:</span><br><span class="line">精度不同<span class="keyword">float</span>至少<span class="number">6</span>位,<span class="keyword">double</span>至少<span class="number">10</span>位</span><br></pre></td></tr></table></figure><h6 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c内置运算符,以字节为单位打印类型的大小</span><br><span class="line">在c中<span class="keyword">char</span>就占一个字节,因为c把<span class="keyword">char</span>类型的长度定义为一个字节</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> num = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"num占用%u"</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#####4.年纪</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据年纪算出过了多少秒</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">double</span> total;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入你的年龄\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;age);</span><br><span class="line">total = age * <span class="number">3.156e7</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"共经过%f秒"</span>, total);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-字符串-交流"><a href="#5-字符串-交流" class="headerlink" title="5.字符串 交流"></a>5.字符串 交流</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  //提供strlen的原型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DENSITY 62.4  <span class="comment">//定义符号常量DENSITY</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">float</span> weight,value;</span><br><span class="line"><span class="keyword">int</span> size,letters;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">40</span>];   <span class="comment">//数组存放40个字节,每个字节一个字符串</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入你的姓名\n"</span>,&amp;name);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入你的体重\n"</span>,weight);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%f"</span>, &amp;weight);</span><br><span class="line">size = <span class="keyword">sizeof</span>(name);</span><br><span class="line">letters = <span class="built_in">strlen</span>(name);  <span class="comment">//获取字符串的长度</span></span><br><span class="line">value = weight / DENSITY;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"名字占%u字节"</span>, size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"名字长度为%d"</span>, letters);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"人的质量%f"</span>, value);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sizeof给出数据的大小,strlen给出字符串的长度,因为一个字符占一个字节可以看成相同的结果</span></span><br></pre></td></tr></table></figure><h5 id="6-字符串简介"><a href="#6-字符串简介" class="headerlink" title="6.字符串简介"></a>6.字符串简介</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>双引号不是字符串的一部分,而是通知编译器其中包含一个字符串,单引号代表的是一个字符</span><br><span class="line"><span class="number">2.</span>c没有字符串定义专门的变量类型,而是把它存在<span class="keyword">char</span>数组中</span><br><span class="line"><span class="number">3.</span>%s告诉<span class="built_in">printf</span>()要打印一个字符串</span><br><span class="line"><span class="number">4.</span><span class="built_in">scanf</span>会在遇到的第一个空白字符串处停止</span><br><span class="line"><span class="number">5.</span>字符串常量x和字符常量x不同.字符串常量x属于基本类型<span class="keyword">char</span>,而字符串常量x属于派生类(<span class="keyword">char</span>数组)</span><br><span class="line"><span class="number">6.</span><span class="keyword">char</span>字符,因为<span class="keyword">char</span>字符对应ascii码,而八位最够对应所有的ascii码,所以一位足够</span><br><span class="line"><span class="number">7.</span><span class="built_in">string</span>.h文件里包含许多与字符串相关的函数的原型</span><br><span class="line"><span class="number">8.</span>c中的<span class="keyword">char</span>表示一个字符,要表示一个字符序列,c使用字符串,字符串的一种形式是字符常量,用双引号括起来,也可以在字符数组中存储一个个字符,相邻的字符构成字符串.</span><br><span class="line"><span class="number">9.</span>程序中最好使用字符常量使用<span class="meta">#<span class="meta-keyword">define</span>或者const表示,使得程序可读性更强,更利于修改维护</span></span><br></pre></td></tr></table></figure><h5 id="7-常量"><a href="#7-常量" class="headerlink" title="7.常量"></a>7.常量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>第一种定义常量,<span class="meta">#<span class="meta-keyword">define</span> pi 3.1415 ,当程序编译时,会将所有出现pi的地方替换成pi的值3.1415</span></span><br><span class="line">    (注意:这里没有等号,且通常使用大写)</span><br><span class="line"><span class="number">2.</span><span class="meta">#<span class="meta-keyword">define</span>也可以支持定于字符和字符串变量,前者单引号,后者双引号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEE <span class="meta-string">'T'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPS <span class="meta-string">"now you have done it"</span></span></span><br><span class="line"><span class="number">3.</span>第二种定义常量,<span class="keyword">const</span>(比define灵活)</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MONTHS = <span class="number">12</span>;</span><br><span class="line"><span class="number">4.</span>第三种,枚举(<span class="keyword">enum</span>)</span><br><span class="line"></span><br><span class="line">第一种代码:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="keyword">float</span> size;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入圆的半径\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;r);</span><br><span class="line">size = PI * r * r;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"圆的面积为%.2f"</span>, size);  <span class="comment">//保留两位小数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第二种代码:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> PI = <span class="number">3.14</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="keyword">float</span> size;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入圆的半径\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;r);</span><br><span class="line">size = PI * r * r;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"圆的面积为%.2f"</span>, size);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-查看整形和浮点型的大小限制"><a href="#8-查看整形和浮点型的大小限制" class="headerlink" title="8.查看整形和浮点型的大小限制"></a>8.查看整形和浮点型的大小限制</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用到了两个头文件,limits.h---&gt;查看整形和float.h---&gt;查看浮点型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;float.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"整形最大值%d和最小值%d"</span>,INT_MAX,INT_MIN);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"浮点型正数最大值%f和最小值%f"</span>,FLT_MAX,FLT_MIN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="printf-scanf-转换说明符"><a href="#printf-scanf-转换说明符" class="headerlink" title="printf(),scanf()转换说明符"></a>printf(),scanf()转换说明符</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">%d:有符号十进制整数</span><br><span class="line">%s:字符串</span><br><span class="line">%u:无符号十进制整数</span><br><span class="line">%c:字符</span><br><span class="line">%f:有符号十进制浮点数</span><br><span class="line">%%:一个%</span><br><span class="line">%p:指针</span><br><span class="line">其他...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> value = <span class="number">120</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*%d*\n"</span>,value);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*%2d*\n"</span>,value);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*%10d*\n"</span>,value); <span class="comment">//不够10位,左补到10位,空格</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*%-10d*"</span>,value);  <span class="comment">//不够10位,右补到10位,空格</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*%010d*\n"</span>,value); <span class="comment">//不够10位左边不够的补0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//printf参数传递解释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">printf("%1d %1d %1d %1d\n",n1,n2,n3,n4);</span></span><br><span class="line"><span class="comment">原理:该调用告诉计算机.n1,n2,n3,n4被调用,然后计算机将他们放入到堆栈中,计算机根据变量的类型而非转换说明符将这些值放到堆栈中,每个数占据一定的字节,然后printf函数将数据一个一个读出来</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">prinft作为函数也有返回值,很少被用到,作为打印输出的附带功能</span></span><br><span class="line"><span class="comment">前面的转换说明和后面的变量类型要一致,否则会产生奇怪的结果</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*计算多个鞋对应的英寸尺度 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> SCALE = <span class="number">0.325</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> ADJUST = <span class="number">7.64</span>;</span><br><span class="line"><span class="keyword">double</span> shoe, foot;</span><br><span class="line">shoe = <span class="number">3.0</span>;</span><br><span class="line"><span class="keyword">while</span>(shoe &lt; <span class="number">19.5</span>)</span><br><span class="line">&#123;</span><br><span class="line">foot = SCALE* shoe + ADJUST;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"鞋的尺码为%.2f,英寸为%.2f\n"</span>, shoe, foot);</span><br><span class="line">shoe +=  <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>+-*/ 四则运算符</span><br><span class="line"><span class="number">2.</span>= 赋值运算符</span><br><span class="line"><span class="number">3.</span><span class="keyword">sizeof</span> 所占字节大小</span><br><span class="line"><span class="number">4.</span>++ 两种形式a++ 和 ++a</span><br><span class="line"><span class="number">5.</span>--</span><br><span class="line"><span class="number">6.</span>%取余</span><br></pre></td></tr></table></figure><h5 id="和–"><a href="#和–" class="headerlink" title="++和–"></a>++和–</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*a++和++a的区别,a++是用过a的值之后加1,而++a是用a前先给他加一,区别见第二个案例*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>, y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (x &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">x++;</span><br><span class="line">++y;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"x = %d,y = %d\n"</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (a++ &lt; <span class="number">19</span>) <span class="comment">//当这里使用a++时,是先与19比较后才加1,结果就是a++会多打印一个19</span></span><br><span class="line">        <span class="comment">//而++a是在与19去比较前先优化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a的值为%d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">while</span> (num &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入一个num\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">fun(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"num是%d\n"</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="if条件"><a href="#if条件" class="headerlink" title="if条件"></a>if条件</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (++num &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"当前num值为%d\n"</span>, num);</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"66大顺啊!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d不怎么样,你觉得呢?\n"</span>,num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">for</span> (num = <span class="number">10</span>;num &lt;= <span class="number">20</span>;num++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"num是%d\n"</span>, num);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dask</title>
      <link href="/2020/08/10/dask/"/>
      <url>/2020/08/10/dask/</url>
      
        <content type="html"><![CDATA[<h6 id="Dask"><a href="#Dask" class="headerlink" title="Dask"></a>Dask</h6><p>Dask是一款用于分析计算的灵活并行计算库。</p><p>Dask是一个并行计算库，能在集群中进行分布式计算，能以一种更方便简洁的方式处理大数据量，与Spark这些大数据处理框架相比较，Dask更轻。Dask更侧重与其他框架，如：Numpy，Pandas，Scikit-learning相结合，从而使其能更加方便进行分布式并行计算</p><p>入门Dask DataFrame很容易，但是要很好的使用它需要一些经验。</p><p>Dask DataFrame是由许多较小的Pandas DataFrame组成的大型并行DataFrame</p><p>当内存无法容纳数据时，可以使用数据分块的方法：以数据块的形式分批加载到内存进行处理。这样就可以通过加载数据集的子集，来逐步处理整个数据集。</p><p>Dask存在三种最基本的数据结构，分别是：Arrays、Dataframes以及Bags</p><p>安装:pip install dask</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> dask.dataframe <span class="keyword">as</span> dd</span><br><span class="line">tmp = pd.DataFrame(&#123;<span class="string">'name'</span>: range(<span class="number">10</span>), <span class="string">'content'</span>: [range(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]&#125;)</span><br><span class="line">ddf = dd.from_pandas(tmp, npartitions=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>dask.array</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dask中的Arrays（位于包dask.arrays下），其实就是对Numpy中的ndarray的部分接口进行了改进，从而方便处理大数据量。对于大数据集，特别是其大小大于内存时，如果我们要对其计算，按照传统的方式，，我们会将其全部塞进内存里，那么这就会报Out-Of-Memory错误，当然，我们也可以一次读取一部分数据，那么我们是否可以提前将大数据集进行分块处理了，我们只需要控制每块数据集不超过内存，从而满足In-Memory计算了？Dask就是这样做的</span><br></pre></td></tr></table></figure><p>dask.dataframe(调用Pandas API)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Dask Dataframe对象则 在处理远大于当前主机内存的表格数据有用。与传统pandas Dataframe在加载完成所有数据后继续数据类型推断不同Dask Datadrame支持部分加载数据时，对表格数据类型进行推断。Dask Dataframe实现了分块并行Dataframe, 对Dask Dataframe的操作将被映射到按索引列划分的子Dataframe上</span><br><span class="line">在Pandas上运行缓慢的操作（例如逐行迭代）在Dask DataFrame上仍然运行缓慢</span><br><span class="line">处理大型数据集，即使这些数据集不适合存储在内存中</span><br><span class="line">通过使用多个内核来加速长计算</span><br><span class="line">使用标准的Pandas操作（例如groupby，join和时间序列计算）在大型数据集上进行分布式计算</span><br></pre></td></tr></table></figure><p>dask.bag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于Bags，其最主要的是用于半结构化的大数据集，比如日志或者博客等等，我们从其read_text（dask.bag.text.py）中来解析如何创建一个Dask Bag对象</span><br><span class="line">Dataframe是基于Pandas Dataframe改进的一个可以并行处理大数据量的数据结构，即使对大于内存的数据也是能够处理的</span><br></pre></td></tr></table></figure><p>四、Dask分布式</p><h4 id="dask-delayed-和-dask-bag"><a href="#dask-delayed-和-dask-bag" class="headerlink" title="dask.delayed 和 dask.bag"></a>dask.delayed 和 dask.bag</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delayed :延迟计算,并不是立即计算,而是将关系绘制成一个图,可以使用visualize查看并行的可能性,然后使用compute立刻开始计算</span><br><span class="line"></span><br><span class="line">bag:相当于spark中的rdd操作,</span><br><span class="line">bg.from_sequence([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], npartitions=<span class="number">5</span>).map(<span class="keyword">lambda</span> x:x**<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h5 id="Dask创建和存储数据框"><a href="#Dask创建和存储数据框" class="headerlink" title="Dask创建和存储数据框"></a>Dask创建和存储数据框</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">读:</span><br><span class="line">    read_csv  将CSV文件读取到Dask.DataFrame中</span><br><span class="line">    read_json  从一组JSON文件创建数据框</span><br><span class="line">    read_sql_table  从SQL表创建数据框。</span><br><span class="line">    from_pandas  从Pandas DataFrame构造Dask DataFrame</span><br><span class="line">    dask不能读excel</span><br><span class="line">存:</span><br><span class="line">    to_csv  将Dask DataFrame存储到CSV文件</span><br><span class="line">    to_sql 将Dask数据框存储到SQL表</span><br><span class="line">    to_json  将数据框写入JSON文本文件</span><br><span class="line">其他见:https://docs.dask.org/en/latest/dataframe-api.html</span><br></pre></td></tr></table></figure><p>#####Dask的Sql</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>Dask不支持任意文本查询,仅支持整个表和sqlalchemy</span><br><span class="line"><span class="keyword">import</span> dask.dataframe <span class="keyword">as</span> dd</span><br><span class="line">en = <span class="string">'mysql+pymysql://user_rw:1a2s3d4f@192.168.0.251:3306/pre_formal_2?charset=UTF8mb4'</span></span><br><span class="line">dd.read_sql_table(<span class="string">"A61_single_us"</span>, en, index_col=<span class="string">'id'</span>,npartitions=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><img src="/2020/08/10/dask/C:/Users\ADMINI~1\AppData\Local\Temp\1597109748639.png" alt="1597109748639"></p><p>默认情况下，Dask DataFrame使用多线程调度程序。</p><p>Dask是为处理大于内存的数据集而设计的</p><p><img src="/2020/08/10/dask/1633751522366.png" alt="1633751522366"></p><h3 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h3><h5 id="dask分布式"><a href="#dask分布式" class="headerlink" title="dask分布式"></a>dask分布式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.python -m pip install dask distributed --upgrade</span><br><span class="line"></span><br><span class="line">2.在某个节点启用调度节点,dask-scheduler</span><br><span class="line"></span><br><span class="line">3.dask-worker 192.168.0.227:8786 --nprocs 20 --nthreads 2 创建工人,并指向调度节点</span><br><span class="line">--memory-limit 2e10 设置内存</span><br><span class="line">若启动失败:pip3 install click==7.1.2</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>#####同时使用某函数——&gt;等价分布式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#==================================1=================================</span></span><br><span class="line"><span class="keyword">from</span> dask.distributed <span class="keyword">import</span> Client</span><br><span class="line">client = Client(<span class="string">'192.168.0.227:8786'</span>)  <span class="comment">#使用分布式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(x)</span>:</span></span><br><span class="line">ls = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(x):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(x):</span><br><span class="line">ls.append(i+j)</span><br><span class="line">    print(sum(ls))</span><br><span class="line"><span class="keyword">return</span> sum(ls)</span><br><span class="line"></span><br><span class="line">a = client.map(test, [<span class="number">10000</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">100</span>,<span class="number">50</span>])</span><br><span class="line">client.gather(a)</span><br><span class="line">client.restart() <span class="comment">#重启</span></span><br><span class="line">client.close() <span class="comment">#关闭</span></span><br><span class="line"><span class="comment">#==================================2=================================</span></span><br><span class="line"><span class="keyword">from</span> dask.distributed <span class="keyword">import</span> Client</span><br><span class="line">client = Client() <span class="comment">#使用当前节点多进程</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(num)</span>:</span></span><br><span class="line">t1 = datetime.now()</span><br><span class="line">ls = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(num):</span><br><span class="line">ls.append(i+j)</span><br><span class="line">print(num,datetime.now()-t1,os.getpid())</span><br><span class="line"><span class="keyword">return</span> pd.DataFrame(range(num)).sum().values[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">a = client.map(func,range(<span class="number">2000</span>,<span class="number">3000</span>,<span class="number">10</span>))</span><br><span class="line">client.gather(a)</span><br><span class="line"><span class="comment">#====================================3================================</span></span><br><span class="line"><span class="keyword">from</span> dask.distributed <span class="keyword">import</span> Client, progress</span><br><span class="line">cl(n_workers=<span class="number">20</span>,threads_per_worker=<span class="number">3</span>) <span class="comment">#单机设置</span></span><br><span class="line">                </span><br><span class="line"><span class="comment">#传参</span></span><br><span class="line">[dask_cl.submit(func_patent_expect_life,dic,i) <span class="keyword">for</span> i <span class="keyword">in</span> group_name_list]</span><br><span class="line">[future] = dask_cl.scatter([df_data.values],broadcast=<span class="literal">True</span>) <span class="comment">#广播变量,将数据放到调度器中          </span></span><br><span class="line"><span class="comment">#replicate复制数据到节点</span></span><br><span class="line">client_dask.replicate([group_name_num])</span><br></pre></td></tr></table></figure><h4 id="分布式传参案例"><a href="#分布式传参案例" class="headerlink" title="分布式传参案例"></a>分布式传参案例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># author = 'kl'</span></span><br><span class="line"><span class="comment"># create_date: 2021/10/14</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line"><span class="keyword">from</span> clickhouse_driver <span class="keyword">import</span> Client</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">"ignore"</span>)</span><br><span class="line"><span class="keyword">from</span> dask.distributed <span class="keyword">import</span> Client <span class="keyword">as</span> cl</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_bfpm_history</span><span class="params">(company_list_short, group_name_num, jiqun_company, year,dic_com)</span>:</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">group_name_num = pd.DataFrame(group_name_num,columns=[<span class="string">'applicant_name'</span>,<span class="string">'group_names'</span>,<span class="string">'group_num'</span>])</span><br><span class="line">jiqun_company = pd.DataFrame(jiqun_company,columns=[<span class="string">'group_name'</span>,<span class="string">'applicants'</span>])</span><br><span class="line">storage_table = <span class="string">'history_jsbj'</span> + <span class="string">'_20211008'</span></span><br><span class="line">data_all = []</span><br><span class="line">company_list_short_ = [company_list_short[i:i+<span class="number">50</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(company_list_short),<span class="number">50</span>)]</span><br><span class="line"><span class="keyword">for</span> companys <span class="keyword">in</span> company_list_short_:</span><br><span class="line">df_100 = group_name_num[group_name_num.applicant_name.isin(companys)]</span><br><span class="line">df_100[<span class="string">'applicants'</span>] = df_100.group_names.apply(<span class="keyword">lambda</span> x: list(set(chain(*jiqun_company.loc[jiqun_company[<span class="string">'group_name'</span>].isin(x)].applicants.tolist()))))</span><br><span class="line">df_100_split = df_100.explode(<span class="string">'applicants'</span>)</span><br><span class="line">df_100_split[<span class="string">'num_com'</span>] = df_100_split[<span class="string">'applicants'</span>].apply(<span class="keyword">lambda</span> x: dic_com[x] <span class="keyword">if</span> x <span class="keyword">in</span> dic_com <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">df_res = df_100_split.groupby(<span class="string">'applicant_name'</span>).apply(<span class="keyword">lambda</span> x: round(len(x[x.num_com &gt;= x.group_num.values[<span class="number">0</span>]]) / x.shape[<span class="number">0</span>],<span class="number">4</span>)).reset_index()</span><br><span class="line">df_res.columns = [<span class="string">'applicant_name'</span>,<span class="string">'bf_pm'</span>]</span><br><span class="line">df_res[<span class="string">'year'</span>] = year</span><br><span class="line">df_final = df_res.merge(df_100[[<span class="string">'applicant_name'</span>,<span class="string">'group_names'</span>,<span class="string">'group_num'</span>]],on=[<span class="string">'applicant_name'</span>],how=<span class="string">'left'</span>)</span><br><span class="line">df_final.loc[df_final.bf_pm == <span class="number">1</span>,<span class="string">'bf_pm'</span>] = <span class="number">0.9999</span></span><br><span class="line">df_final.loc[df_final.bf_pm == <span class="number">0</span>, <span class="string">'bf_pm'</span>] = <span class="number">0.0001</span></span><br><span class="line">data_all.append(df_final)</span><br><span class="line">data_final = pd.concat(data_all)</span><br><span class="line">data_final.rename(columns = &#123;<span class="string">'group_names'</span>:<span class="string">'groups'</span>&#125;,inplace=<span class="literal">True</span>)</span><br><span class="line">data_final_tuple = [tuple(i) <span class="keyword">for</span> i <span class="keyword">in</span> data_final.values]</span><br><span class="line">client = Client(host=<span class="string">'192.168.0.170'</span>, port=<span class="string">'9000'</span>, user=<span class="string">'algorithm'</span>, password=<span class="string">'1a2s3d4f'</span>, database=<span class="string">'algorithm_dis'</span>)</span><br><span class="line">sql = <span class="string">"insert into algorithm_dis.&#123;&#125; (`applicant_name`,`bf_pm`,`year`,`groups`,`group_num`) VALUES"</span>.format(storage_table)</span><br><span class="line">client.execute(sql, data_final_tuple)</span><br><span class="line">client.disconnect()</span><br><span class="line">print(<span class="string">'存完l'</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">print(e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">n = <span class="number">10000</span>  <span class="comment"># 10000 开一个进程</span></span><br><span class="line">table_tail = <span class="string">'_20210908'</span>  <span class="comment"># 版本表后缀(开始计算的时间或者)</span></span><br><span class="line">company_formername = <span class="string">'company_formername_20210908'</span>  <span class="comment"># 企业最新名跟曾用名的唯一对应  这个后期会有变化，每次都记得调整</span></span><br><span class="line">similer_company = <span class="string">'similer_company'</span>  <span class="comment"># 企业名称别名</span></span><br><span class="line">es_time = <span class="string">'20210901'</span>  <span class="comment"># es更新截至的时间 用于计算多个时间相关的数据</span></span><br><span class="line">country_code = <span class="string">'country_code'</span>  <span class="comment"># 国家缩写表</span></span><br><span class="line">ipc_split_10000_c_list_v = <span class="string">'ipc_split_10000_c_list_v3'</span>  <span class="comment"># 集群内ipc表</span></span><br><span class="line">history_group_patent_num = <span class="string">'history_group_patent_num'</span> + table_tail</span><br><span class="line">zl_zu_L = <span class="string">'zl_zu_L'</span> + table_tail</span><br><span class="line">t1 = datetime.now()</span><br><span class="line"><span class="keyword">for</span> year <span class="keyword">in</span> range(<span class="number">1985</span>, int(es_time[:<span class="number">4</span>]) + <span class="number">1</span>):</span><br><span class="line">t0 = datetime.now()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment">## 获取每个年份内企业的集群数</span></span><br><span class="line">client = Client(host=<span class="string">'192.168.0.170'</span>, port=<span class="string">'9000'</span>, user=<span class="string">'algorithm'</span>, password=<span class="string">'1a2s3d4f'</span>, database=<span class="string">'algorithm_dis'</span>)</span><br><span class="line">sql = <span class="string">'''</span></span><br><span class="line"><span class="string">SELECT</span></span><br><span class="line"><span class="string">applicant_name,</span></span><br><span class="line"><span class="string">arrayDistinct(arrayFlatten(groupArray(group_name))) AS `group_names`,</span></span><br><span class="line"><span class="string">length(group_names) AS group_num</span></span><br><span class="line"><span class="string">FROM </span></span><br><span class="line"><span class="string">(</span></span><br><span class="line"><span class="string">SELECT</span></span><br><span class="line"><span class="string">arrayJoin(applicants) AS applicant_name,</span></span><br><span class="line"><span class="string">group_name</span></span><br><span class="line"><span class="string">FROM &#123;&#125;</span></span><br><span class="line"><span class="string">WHERE (applicant_name GLOBAL IN </span></span><br><span class="line"><span class="string">(</span></span><br><span class="line"><span class="string">SELECT arrayJoin(arrayDistinct(arrayFlatten(groupArray(applicants))))</span></span><br><span class="line"><span class="string">FROM &#123;&#125;</span></span><br><span class="line"><span class="string">WHERE year = &#123;&#125;</span></span><br><span class="line"><span class="string">GROUP BY year</span></span><br><span class="line"><span class="string">)) AND (toYear(app_date) &lt;= &#123;&#125;)</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">GROUP BY applicant_name</span></span><br><span class="line"><span class="string">'''</span>.format(zl_zu_L, history_group_patent_num, year, year)</span><br><span class="line">group_name_num = client.execute(sql, columnar=<span class="literal">False</span>, with_column_types=<span class="literal">True</span>)</span><br><span class="line">group_name_num = pd.DataFrame(group_name_num[<span class="number">0</span>], columns=[i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> group_name_num[<span class="number">1</span>]])</span><br><span class="line">dic_com = dict(zip(group_name_num.applicant_name, group_name_num.group_num))</span><br><span class="line">sql = <span class="string">"select group_name,applicants from &#123;&#125; where `year` = &#123;&#125;"</span>.format(history_group_patent_num, year)</span><br><span class="line">jiqun_company = pd.DataFrame(client.execute(sql, columnar=<span class="literal">False</span>), columns=[<span class="string">'group_name'</span>, <span class="string">'applicants'</span>])</span><br><span class="line">client.disconnect()</span><br><span class="line">company_list = group_name_num[<span class="string">'applicant_name'</span>].unique().tolist()</span><br><span class="line">company_list_short = [company_list[i:i+<span class="number">1000</span>] <span class="keyword">for</span> i <span class="keyword">in</span>  range(<span class="number">0</span>,len(company_list),<span class="number">1000</span>)]</span><br><span class="line">client_dask = cl(<span class="string">'192.168.0.227:8786'</span>)</span><br><span class="line">[future] = client_dask.scatter([group_name_num.values], broadcast=<span class="literal">True</span>)</span><br><span class="line">[future2] = client_dask.scatter([jiqun_company.values], broadcast=<span class="literal">True</span>)</span><br><span class="line">[future3] = client_dask.scatter([dic_com], broadcast=<span class="literal">True</span>)</span><br><span class="line">a = client_dask.map(func_bfpm_history,company_list_short, [future]*len(company_list_short), [future2]*len(company_list_short), [year]*len(company_list_short), [future3]*len(company_list_short))</span><br><span class="line">client_dask.gather(a)</span><br><span class="line">client_dask.close()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">print(e)</span><br><span class="line">print(year,<span class="string">'完成,耗时:'</span>,datetime.now() - t0)</span><br><span class="line">print(<span class="string">'总耗时:'</span>,datetime.now() - t1)</span><br></pre></td></tr></table></figure><p>`</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client.persist(df) <span class="comment">#持久化dataframe,主要针对大的数据集</span></span><br><span class="line">client.compute() <span class="comment">#处理较小的结果集</span></span><br><span class="line"></span><br><span class="line">要点:pandas基于内存的计算和分布式dask混合使用</span><br></pre></td></tr></table></figure><p>#####pandas groupby 优化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>multiprocessing</span><br><span class="line"><span class="number">2.j</span>oblib</span><br><span class="line"><span class="number">3.</span>parallel_apply</span><br><span class="line">=======================delayed===================================</span><br><span class="line"><span class="keyword">from</span> joblib <span class="keyword">import</span> Parallel, delayed</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line">t1 = datetime.now()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">beta_cal_mult</span><span class="params">(one_fund_df)</span>:</span></span><br><span class="line"><span class="keyword">return</span> pd.DataFrame([[one_fund_df.app_text.values[<span class="number">0</span>],one_fund_df[<span class="string">'dict'</span>].tolist()]],columns=[<span class="string">'app_text'</span>,<span class="string">'dict_new'</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">applyParallel</span><span class="params">(dfGrouped, func)</span>:</span></span><br><span class="line">retLst = Parallel(n_jobs=multiprocessing.cpu_count())(delayed(func)(group) <span class="keyword">for</span> name, group <span class="keyword">in</span> dfGrouped)</span><br><span class="line"><span class="keyword">return</span> pd.concat(retLst)</span><br><span class="line"></span><br><span class="line">app_text_list_json = applyParallel(app_text_list.groupby(<span class="string">'app_text'</span>), beta_cal_mult)</span><br><span class="line">print(datetime.now()-t1)</span><br><span class="line"></span><br><span class="line">==========================parallel_apply=============================</span><br><span class="line">app_text_list.groupby(by=<span class="string">'app_text'</span>).parallel_apply(<span class="keyword">lambda</span> x: list(x.dict)).rename(<span class="string">'dict_new'</span>).reset_index()</span><br><span class="line">不能写成</span><br><span class="line">app_text_list.groupby(by=<span class="string">'app_text'</span>)[<span class="string">'dict'</span>].parallel_apply(<span class="keyword">lambda</span> x: list(x)).rename(<span class="string">'dict_new'</span>).reset_index()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">===================================swifter===============</span><br><span class="line">cython</span><br><span class="line"></span><br><span class="line">numba</span><br><span class="line">parallel_apply的速度有时候并不一定比单个apply快,注意使用时机,针对多进程能够明显提升,</span><br></pre></td></tr></table></figure><h4 id="注意-parallel-apply应用的函数不应该是lambda函数-gt-尽量"><a href="#注意-parallel-apply应用的函数不应该是lambda函数-gt-尽量" class="headerlink" title="注意:parallel_apply应用的函数不应该是lambda函数===&gt;尽量"></a>注意:parallel_apply应用的函数不应该是lambda函数===&gt;尽量</h4><h5 id="np-vectorize-矢量化函数-矢量化操作-可用来优化apply"><a href="#np-vectorize-矢量化函数-矢量化操作-可用来优化apply" class="headerlink" title="np.vectorize,矢量化函数,矢量化操作,可用来优化apply"></a>np.vectorize,矢量化函数,矢量化操作,可用来优化apply</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def func(a,b):</span><br><span class="line">if a== b:</span><br><span class="line">return 1</span><br><span class="line">else:</span><br><span class="line">return 0</span><br><span class="line">fun = np.vectorize(func)</span><br><span class="line">fun([1,2,3,4],[4,5,3,4])</span><br><span class="line">array([0, 0, 1, 1])</span><br></pre></td></tr></table></figure><p>#####可视化失败时候</p><p><img src="/2020/08/10/dask/1633751522366.png" alt="1633751522366"></p>]]></content>
      
      
      <categories>
          
          <category> 优化方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>skin</title>
      <link href="/2020/08/10/skin/"/>
      <url>/2020/08/10/skin/</url>
      
        <content type="html"><![CDATA[<h5 id="shed-skin"><a href="#shed-skin" class="headerlink" title="shed skin"></a>shed skin</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原理:将代码转换成c++,旨在加快计算密集型Python程序的执行速度</span><br></pre></td></tr></table></figure><p>不支持的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.eval,getattr,hasattr,isinstance</span><br><span class="line">2.魔术方法__iter__,__call__,__del__</span><br><span class="line">3.函数参数 *args,**args</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>modin</title>
      <link href="/2020/08/07/modin/"/>
      <url>/2020/08/07/modin/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 优化方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> modin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numba</title>
      <link href="/2020/07/21/Numba/"/>
      <url>/2020/07/21/Numba/</url>
      
        <content type="html"><![CDATA[<h6 id="Numba介绍"><a href="#Numba介绍" class="headerlink" title="Numba介绍"></a>Numba介绍</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   Cython毕竟不是原生的 Python 代码，使用起来还是有诸多不便的。为此，numba 就成了一个功能强大又容易上手的替代选择,是一个用于编译python数组和数值计算函数的编译器,在使用NumPy数组和循环的代码上效果最佳</span><br><span class="line">使用方法:添加装饰器</span><br><span class="line">   Jit(just-<span class="keyword">in</span>-time compiler)即时编译器，在运行时将某些函数编译成二进制代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">☆☆☆☆☆:numba内不能有第三方包</span><br></pre></td></tr></table></figure><h6 id="适用情景"><a href="#适用情景" class="headerlink" title="适用情景"></a>适用情景</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用numpy数组做大量科学计算时</span><br><span class="line">使用<span class="keyword">for</span>循环时</span><br></pre></td></tr></table></figure><h6 id="Numba的装饰器"><a href="#Numba的装饰器" class="headerlink" title="Numba的装饰器"></a>Numba的装饰器</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@jit 对于函数中能够编译的部分转换成机器码,剩余的代码使用Python解释器 Numba 提供的最灵活的装饰器</span></span><br><span class="line"><span class="meta">@njit 与 @jit(nopython=True)  二者等价,将全部代码转换成机器码,无法实现时会报错</span></span><br><span class="line"><span class="meta">@generated_jit   有时需要根据输入变量的类型来决定函数的实现功能</span></span><br><span class="line"><span class="meta">@vectorize    矢量化</span></span><br><span class="line"><span class="meta">@guvectorize  矢量化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">装饰器可选参数</span><br><span class="line">parallel = <span class="literal">True</span>  @jit的自动并行化仅在<span class="number">64</span>位平台上可用。注意需要和nopython=true一起使用,numba的多线程的数量通过全局变量来设置 </span><br><span class="line"><span class="keyword">import</span> numba  </span><br><span class="line">numba.config.NUMBA_NUM_THREADS=<span class="number">8</span>   全局变量设置多线程数目</span><br><span class="line">cache=<span class="literal">True</span>  为了避免每次调用 Python 程序时的编译时间，可以指示 Numba 将函数编译的结果写入基于文件的缓存中,将函数编译完成的结果保存在一个file文件中。</span><br><span class="line">nogil = <span class="literal">True</span> 一旦编译完成，就会释放GIL,这样的情况下就可以充分利用多核系统，但是需要注意多线程编程中需要注意的同步、一致性、竞争等情况</span><br></pre></td></tr></table></figure><p>#####jit<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#斐波那契数列</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> jit</span><br><span class="line"><span class="meta">@jit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;=<span class="number">2</span> :</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>);</span><br><span class="line">start = time.time()</span><br><span class="line">fib(<span class="number">40</span>)</span><br><span class="line">end = time.time()</span><br><span class="line">print(<span class="string">"python3+numba cost_seconds:"</span>, end-start)</span><br></pre></td></tr></table></figure></p><p><img src="/2020/07/21/Numba/C:/Users\ADMINI~1\AppData\Local\Temp\1595401428838.png" alt="1595401428838"></p><p>#####generated_jit</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> generated_jit,types</span><br><span class="line"><span class="meta">@generated_jit(nopython=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_missing</span><span class="params">(x)</span>:</span></span><br><span class="line">    print(type(x))</span><br><span class="line">    print(numba.typeof(x))</span><br><span class="line">    <span class="keyword">if</span> isinstance(x, types.Float):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> x:x+<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(x, types.Integer):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> x:x+<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(x, types.List):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> x:x</span><br><span class="line">    <span class="keyword">if</span> isinstance(x, types.Array):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> x:list(x)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> x:x</span><br><span class="line">is_missing(np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br><span class="line">numba.typeof(x) types,只能在generated_jit中用,</span><br><span class="line">generated_jit会将数据转换成Numba中的数据类型</span><br><span class="line">上面的代码完成的是根据输入去判断缺省值的事情。</span><br><span class="line">注意下面问题：</span><br><span class="line"><span class="number">1</span>、在调用的时候，传入的参数，使用变量的numba类型，而不是值；</span><br><span class="line"><span class="number">2</span>、这个修饰函数返回的结果不是一个计算结果；</span><br></pre></td></tr></table></figure><p><img src="/2020/07/21/Numba/C:/Users\ADMINI~1\AppData\Local\Temp\1595584369339.png" alt="1595584369339"></p><p><img src="/2020/07/21/Numba/C:/Users\ADMINI~1\AppData\Local\Temp\1595585033204.png" alt="1595585033204"></p><p>#####vectorize和guvectorize(矢量化计算)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vectorize和guvectorize，Numba可以将纯Python函数编译为一个ufunc </span><br><span class="line">(ufunc,通用函数是numpy的特点之一,会将函数作用于array对象的每一个元素上,常见的如add,subtract,multiply,divide...)</span><br><span class="line">vectorize 是一个一个元素处理的,而guvectorize是一组一组数据处理的</span><br><span class="line">eg:[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line">vectorize每次传入一个数据,去计算.而guvectorize是将[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]这样一组(行)传进去</span><br><span class="line">guvectorize() 函数不返回其结果值：它们将其结果作为数组参数传进去。</span><br><span class="line">guvectorize格式:</span><br><span class="line"><span class="meta">@guvectorize([(int64[:], int64, int64[:])], '(n),()-&gt;(n)')</span></span><br><span class="line"><span class="string">'(n),()-&gt;(n)'</span>是输入和输出布局的声明,告诉 NumPy 该函数采用 n 元素的一维数组，一个标量（用符号表示为空元组()）并返回 n 元素的一维数组;</span><br><span class="line">[:] 表示一维数组,[::]表示二维数组.int64表示数组内的数据类型</span><br><span class="line"></span><br><span class="line">vectorize() 和 guvectorize() 都支持传递nopython=<span class="literal">True</span> ，如同@jit 装饰器。使用它来确保生成的代码不会回退到对象模式。</span><br></pre></td></tr></table></figure><p>######直接传矩阵会报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trig</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> math.sin(a**<span class="number">2</span>) * math.exp(b)</span><br><span class="line">a = numpy.ones((<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">b = numpy.ones((<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">trig(a, b)</span><br></pre></td></tr></table></figure><p><img src="/2020/07/21/Numba/C:/Users\ADMINI~1\AppData\Local\Temp\1596165994666.png" alt="1596165994666"></p><h6 id="jit也无法使用"><a href="#jit也无法使用" class="headerlink" title="jit也无法使用"></a>jit也无法使用</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">@jit(nopython=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trig</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> math.sin(a**<span class="number">2</span>) * math.exp(b)</span><br><span class="line">a = numpy.ones((<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">b = numpy.ones((<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">trig(a, b)</span><br></pre></td></tr></table></figure><p>######使用vectorize后会使函数转换成numpy中的unfunc,作用于每一个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">@vectorize(nopython=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trig</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> math.sin(a**<span class="number">2</span>) * math.exp(b)</span><br><span class="line">a = numpy.ones((<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">b = numpy.ones((<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">trig(a, b)</span><br><span class="line"><span class="comment">#下面案列同样可使用</span></span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> vectorize,int32</span><br><span class="line"><span class="meta">@vectorize([int32(int32, int32)])  #@vectorize(["int32(int32, int32)"])这样不用从numba导入,且列表里面允许多种类型,传的参数符合一个即可,否则报错</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trig</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> math.sin(a**<span class="number">2</span>) * math.exp(b)</span><br><span class="line">a = numpy.ones((<span class="number">5</span>,<span class="number">5</span>),dtype=numpy.int32)</span><br><span class="line">b = numpy.ones((<span class="number">5</span>,<span class="number">5</span>),dtype=numpy.int32)</span><br><span class="line">trig(a, b)</span><br></pre></td></tr></table></figure><p><img src="/2020/07/21/Numba/C:/Users\ADMINI~1\AppData\Local\Temp\1596166115954.png" alt="1596166115954"></p><p>######guvectorize<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> jit, guvectorize</span><br><span class="line"></span><br><span class="line"><span class="meta">@guvectorize(["float64[:], float64[:]"], "(n) -&gt; ()", target="parallel", nopython=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">row_sum_gu</span><span class="params">(input, output)</span> :</span></span><br><span class="line">    output[<span class="number">0</span>] = np.sum(input)</span><br><span class="line"></span><br><span class="line"><span class="meta">@jit(nopython=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">row_sum_jit</span><span class="params">(input_array, output_array)</span> :</span></span><br><span class="line">    m, n = input_array.shape</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m) :</span><br><span class="line">        output_array[i] = np.sum(input_array[i,:])</span><br><span class="line"></span><br><span class="line">rows = int(<span class="number">64</span>)</span><br><span class="line">columns = int(<span class="number">1e6</span>)</span><br><span class="line">input_array = np.ones((rows, columns))</span><br><span class="line">output_array = np.zeros((rows))</span><br><span class="line">output_array2 = np.zeros((rows))</span><br><span class="line"></span><br><span class="line"><span class="comment">#the first run includes the compile time</span></span><br><span class="line">row_sum_jit(input_array, output_array)</span><br><span class="line">row_sum_gu(input_array, output_array2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#run each function 100 times and record the time</span></span><br><span class="line">print(<span class="string">"jit time:"</span>, timeit.timeit(<span class="string">"row_sum_jit(input_array, output_array)"</span>, <span class="string">"from __main__ import row_sum_jit, input_array, output_array"</span>, number=<span class="number">100</span>))</span><br><span class="line">print(<span class="string">"guvectorize time:"</span>, timeit.timeit(<span class="string">"row_sum_gu(input_array, output_array2)"</span>, <span class="string">"from __main__ import row_sum_gu, input_array, output_array2"</span>, number=<span class="number">100</span>))</span><br></pre></td></tr></table></figure></p><p><img src="/2020/07/21/Numba/C:/Users\ADMINI~1\AppData\Local\Temp\1596177562619.png" alt="1596177562619"></p><p>###### </p><p>#####Numba中的数据类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">整形 Integer</span><br><span class="line">浮点型 Float</span><br><span class="line">负数 Complex</span><br><span class="line">列表 List</span><br><span class="line">字符串 UnicodeType</span><br><span class="line">集合  Set</span><br><span class="line">元组 UniTuple</span><br><span class="line">数组 Array</span><br><span class="line">其他..</span><br></pre></td></tr></table></figure><p>Numba的两种模式Nopython和Object模式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Numba @jit装饰器从根本上以两种编译模式运行，nopython模式和object模式。</span><br><span class="line">nopython编译模式，可以完全运行而无需Python解释器的参与。这是使用Numba jit装饰器的推荐和最佳实践方式，因为它可以带来最佳性能。</span><br><span class="line"></span><br><span class="line">如果编译nopython模式失败（例如出现了字符串处理等numba无法编译的数据），Numba可以使用object模式 。在这种模式下，Numba将识别它可以编译的循环，并将它们编译成在机器代码中运行的函数，并且它将运行解释器中的其余代码。为获得最佳性能，请避免使用此模式。</span><br></pre></td></tr></table></figure><p><img src="/2020/07/21/Numba/C:/Users\ADMINI~1\AppData\Local\Temp\1595412696382.png" alt="1595412696382"></p><p>案例1:斐波那契数列</p><p>Numba无法理解Pandas，因此Numba只需通过解释器运行此代码，但会增加Numba内部开销</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#下面代码运行良好</span></span><br><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> jit</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.arange(<span class="number">100</span>).reshape(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"><span class="meta">@jit(nopython=True) # Set "nopython" mode for best performance, equivalent to @njit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">go_fast</span><span class="params">(a)</span>:</span> <span class="comment"># Function is compiled to machine code when called the first time</span></span><br><span class="line">    trace = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(a.shape[<span class="number">0</span>]):   <span class="comment"># Numba likes loops</span></span><br><span class="line">        trace += np.tanh(a[i, i]) <span class="comment"># Numba likes NumPy functions</span></span><br><span class="line">    <span class="keyword">return</span> a + trace              <span class="comment"># Numba likes NumPy broadcasting</span></span><br><span class="line">print(go_fast(x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面代码运行较差</span></span><br><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> jit</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">x = &#123;<span class="string">'a'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">'b'</span>: [<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]&#125;</span><br><span class="line"><span class="meta">@jit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_pandas</span><span class="params">(a)</span>:</span> <span class="comment"># Function will not benefit from Numba jit</span></span><br><span class="line">    df = pd.DataFrame.from_dict(a) <span class="comment"># Numba doesn't know about pd.DataFrame</span></span><br><span class="line">    df += <span class="number">1</span>                        <span class="comment"># Numba doesn't understand what this is</span></span><br><span class="line">    <span class="keyword">return</span> df.cov()                <span class="comment"># or this!</span></span><br><span class="line">print(use_pandas(x))</span><br></pre></td></tr></table></figure><p><img src="/2020/07/21/Numba/C:/Users\ADMINI~1\AppData\Local\Temp\1595900106564.png" alt="1595900106564"></p><h4 id="故障排除和技巧"><a href="#故障排除和技巧" class="headerlink" title="故障排除和技巧"></a>故障排除和技巧</h4><p><a href="http://numba.pydata.org/numba-doc/latest/user/troubleshoot.html#numba-troubleshooting" target="_blank" rel="noopener">http://numba.pydata.org/numba-doc/latest/user/troubleshoot.html#numba-troubleshooting</a></p><h5 id="弃用警告"><a href="#弃用警告" class="headerlink" title="弃用警告"></a>弃用警告</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Numba弃用了列表和集合</span><br><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> njit</span><br><span class="line"><span class="meta">@njit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>:</span></span><br><span class="line">    x.append(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">foo(a)</span><br><span class="line">NumbaDeprecationWarning或 NumbaPendingDeprecationWarning代表Numba弃用</span><br><span class="line">弃用原因(官方解释)</span><br><span class="line">首先回想一下，为了使Numba能够在nopython 模式下编译函数，所有变量必须具有通过类型推断确定的具体类型。在简单的情况下，很明显如何反映内部容器的更改nopython模式返回到原始的Python容器。但是，无法快速有效地将具有嵌套容器类型（例如，整数列表的列表）的复杂数据结构反映出来。经过多年的处理此问题的经验后，很明显，提供此行为既困难又常常导致代码性能不佳（所有反映的数据都必须通过特殊的API才能将数据转换为本地数据格式，然后在返回时返回CPython格式）</span><br><span class="line">禁止弃用警告:</span><br><span class="line"><span class="keyword">from</span> numba.errors <span class="keyword">import</span> NumbaDeprecationWarning, NumbaPendingDeprecationWarning</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.simplefilter(<span class="string">'ignore'</span>, category=NumbaDeprecationWarning)</span><br><span class="line">warnings.simplefilter(<span class="string">'ignore'</span>, category=NumbaPendingDeprecationWarning)</span><br></pre></td></tr></table></figure><p><img src="/2020/07/21/Numba/C:/Users\ADMINI~1\AppData\Local\Temp\1595901667054.png" alt="1595901667054"></p><p><img src="/2020/07/21/Numba/C:/Users\ADMINI~1\AppData\Local\Temp\1595902092742.png" alt="1595902092742"></p><p><img src="/2020/07/21/Numba/C:/Users\ADMINI~1\AppData\Local\Temp\1595902995756.png" alt="1595902995756"></p><h6 id="Numba无法编译原因"><a href="#Numba无法编译原因" class="headerlink" title="Numba无法编译原因"></a>Numba无法编译原因</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.普遍的原因是依赖了不受支持的Python功能</span><br><span class="line">2.无法确定函数的返回类型,类型统一失败,if--else中返回的类型不同</span><br><span class="line">3.列表中类型无法推断(列表中的类型要一致)</span><br></pre></td></tr></table></figure><h5 id="Numba编译太慢的原因"><a href="#Numba编译太慢的原因" class="headerlink" title="Numba编译太慢的原因"></a>Numba编译太慢的原因</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编译JIT函数缓慢的最常见原因是，在nopython模式下编译失败，并且Numba编译器已退回到对象模式。 与常规的Python解释相比，对象模式目前几乎没有提供任何加速，其主要点是允许进行称为循环提升的内部优化 ：无论哪种代码包围这些内部循环，此优化都将允许以nopython模式编译内部循环</span><br><span class="line">要确定函数是否成功进行类型推断，可以使用inspect_types()  f.inspect_types()</span><br></pre></td></tr></table></figure><h6 id="Numba中的cuda-大规模并行运算-———-gt-了解有这个用法"><a href="#Numba中的cuda-大规模并行运算-———-gt-了解有这个用法" class="headerlink" title="Numba中的cuda(大规模并行运算)———&gt;了解有这个用法"></a>Numba中的cuda(大规模并行运算)———&gt;了解有这个用法</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CUDA:    一种通用并行计算架构,架构使GPU能够解决复杂的计算问题.(CPU与GPU<span class="string">"协同处理"</span>)</span><br><span class="line">CUDA发展历程:      GPU越来越强大，GPU为显示图像做了优化之外，在计算上已经超越了通用的CPU。如此强大的芯片如果只是作为显卡就太浪费了，因此NVidia推出CUDA，让显卡可以用于图像计算以外的目的，也就是超于游戏，使得GPU能够发挥其强大的运算能力。</span><br><span class="line">CUDA作用:    CUDA具有不同于用于CPU编程的传统顺序模型的执行模型。在CUDA中，您编写的代码将同时由多个线程（通常成百上千个）执行</span><br><span class="line">CUDA环境配置:  失败========</span><br></pre></td></tr></table></figure><h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意:numba装饰的函数在第一次调用的时候会进行编译,会消耗一些时间,再次调用就不会了</span><br><span class="line">如果函数无法在nopython模式下编译，则会发出警告\报错，并说明编译失败的原因</span><br></pre></td></tr></table></figure><p>swifter  =========&gt;优化apply,df.swifter.apply</p>]]></content>
      
      
      <categories>
          
          <category> 优化方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pp模块</title>
      <link href="/2020/07/21/pp%E6%A8%A1%E5%9D%97/"/>
      <url>/2020/07/21/pp%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 大家一起完善</span></span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> pp</span><br><span class="line"><span class="comment"># 本机ip</span></span><br><span class="line">local_ip = [x.split(<span class="string">' '</span>)[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> os.popen(<span class="string">'hostname -I'</span>)][<span class="number">0</span>]</span><br><span class="line">host_tuple = (&#123;<span class="string">'ip'</span>: <span class="string">'192.168.0.231'</span>, <span class="string">'port'</span>: <span class="number">22</span>, <span class="string">'username'</span>: <span class="string">'root'</span>, <span class="string">'password'</span>: <span class="string">'e6772fc39c25'</span>&#125;,</span><br><span class="line">             &#123;<span class="string">'ip'</span>: <span class="string">'192.168.0.227'</span>, <span class="string">'port'</span>: <span class="number">22</span>, <span class="string">'username'</span>: <span class="string">'root'</span>, <span class="string">'password'</span>: <span class="string">'fa2cadd1cc81'</span>&#125;)</span><br><span class="line">ssh = paramiko.SSHClient()</span><br><span class="line">ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line"><span class="comment"># 根据内存使用判断进程数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ppserve_1</span><span class="params">(host_tuple)</span>:</span></span><br><span class="line">    remote_cpu_nums=[]</span><br><span class="line">    ports = []</span><br><span class="line">    <span class="keyword">for</span> host <span class="keyword">in</span> host_tuple:</span><br><span class="line">        <span class="comment"># 内存使用情况</span></span><br><span class="line">        ssh.connect(hostname=host[<span class="string">'ip'</span>], port=host[<span class="string">'port'</span>], username=host[<span class="string">'username'</span>], password=host[<span class="string">'password'</span>])</span><br><span class="line">        print(host[<span class="string">'ip'</span>])</span><br><span class="line">        stdin, stdout, stderr = ssh.exec_command(<span class="string">'cat /proc/meminfo'</span>)</span><br><span class="line">        str_out = stdout.read().decode()</span><br><span class="line">        str_err = stderr.read().decode()</span><br><span class="line">        <span class="keyword">if</span> str_err != <span class="string">""</span>:</span><br><span class="line">            print(str_err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        str_total = re.search(<span class="string">'MemTotal:.*?\n'</span>, str_out).group()</span><br><span class="line">        <span class="comment"># print(str_total)</span></span><br><span class="line">        totalmem = re.search(<span class="string">'\d+'</span>, str_total).group()</span><br><span class="line">        str_free = re.search(<span class="string">'MemFree:.*?\n'</span>, str_out).group()</span><br><span class="line">        <span class="comment"># print(str_free)</span></span><br><span class="line">        freemem = re.search(<span class="string">'\d+'</span>, str_free).group()</span><br><span class="line">        mem_free = round(float(freemem) / float(totalmem), <span class="number">2</span>)</span><br><span class="line">        print(<span class="string">'当前内存空闲率为：'</span> + str(mem_free))</span><br><span class="line">        <span class="comment"># 本地可以不走分布式，但分布式 debug 模式可以监测在干什么，但增加了数据传输量；减少传输量，传参数过去后再读取或生成比较快。</span></span><br><span class="line">        <span class="comment"># if host['ip'] == local_ip:</span></span><br><span class="line">        <span class="comment">#     local_cpu_num = int((mem_free-0.1)/0.0125)</span></span><br><span class="line">        <span class="comment">#     if local_cpu_num&lt;0:</span></span><br><span class="line">        <span class="comment">#         local_cpu_num=0</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">        <span class="comment"># 根据内存使用判断进程数：假设保留 10% 内存，剩余内存按 80 个进程平均分配，不适合所有计算</span></span><br><span class="line">        remote_cpu_num = int((mem_free<span class="number">-0.1</span>) / <span class="number">0.0125</span>)</span><br><span class="line">        <span class="keyword">if</span> remote_cpu_num &lt; <span class="number">0</span>:</span><br><span class="line">            remote_cpu_num = <span class="number">0</span></span><br><span class="line">        print(<span class="string">'新开进程数为：'</span> + str(remote_cpu_num))</span><br><span class="line">        remote_cpu_nums.append(remote_cpu_num)</span><br><span class="line">        <span class="comment"># 随机生成端口号</span></span><br><span class="line">        port = int(random.random()*(<span class="number">65535</span><span class="number">-1024</span>)+<span class="number">1024</span>)</span><br><span class="line">        ports.append(port)</span><br><span class="line">        <span class="comment"># nohup 启动不了，不知道 why</span></span><br><span class="line">        <span class="comment"># cmd = 'cd /usr/bin;nohup python3 ppserver.py -p '+str(port)+' -d -w '+str(remote_cpu_num)+'  -P ppserver.pid -t 3600 -k 3600 &gt; ppserver.out 2&gt;&amp;1 &amp;'</span></span><br><span class="line">        <span class="comment"># 启动命令，进入 ppserver.py 所在文件夹，用 Python3 启动，可以调用 python3 下的包， -p 指定端口，-d debug模式，-w 知道进程数， -P 指定一个文件保留进程号，后面 kill 时候用到</span></span><br><span class="line">        cmd = <span class="string">'cd /usr/bin;python3 ppserver.py -p '</span>+str(port)+<span class="string">' -d -w '</span>+str(remote_cpu_num)+<span class="string">'  -P ppserver.pid -t 3600 -k 3600'</span></span><br><span class="line">        <span class="comment"># 若在这里执行则后面 ssh.close() 注销掉，否则 close 了就停止（如何 close，在这里分布式，然后分别close？）；而且看不到 debug 模式，</span></span><br><span class="line">        <span class="comment"># stdin, stdout, stderr = ssh.exec_command(cmd, get_pty=True)</span></span><br><span class="line">        print(cmd)    </span><br><span class="line">        ssh.close()</span><br><span class="line">    <span class="keyword">return</span> remote_cpu_nums,ports</span><br><span class="line">remote_cpu_nums,ports = ppserve_1(host_tuple)</span><br><span class="line"><span class="comment"># 等待 ppserver 生成完成</span></span><br><span class="line">time.sleep(<span class="number">30</span>)</span><br><span class="line">ppservers = tuple([x[<span class="string">'ip'</span>]+<span class="string">':'</span>+str(port) <span class="keyword">for</span> x,port <span class="keyword">in</span> zip(host_tuple,ports)] )</span><br><span class="line"><span class="comment"># ppservers = tuple([x['ip']+':'+str(port) for x in host_list if x['ip'] != local_ip])</span></span><br><span class="line"><span class="comment"># 本地进程数设为0</span></span><br><span class="line">job_server = pp.Server(<span class="number">0</span> ,ppservers=ppservers,socket_timeout=<span class="number">3600</span>)</span><br><span class="line"><span class="comment"># 问题：worker数、进程数、cpu数的关系？</span></span><br><span class="line">job_server.get_active_nodes()</span><br><span class="line"><span class="comment"># job_server.submit() 指令</span></span><br><span class="line">job_server.print_stats()</span><br><span class="line"><span class="comment"># 关闭 client（python）端</span></span><br><span class="line">job_server.destroy()</span><br><span class="line"><span class="comment"># kill server（服务器）端 ppserver.py 进程</span></span><br><span class="line"><span class="keyword">for</span> host <span class="keyword">in</span> host_tuple:</span><br><span class="line">    ssh.connect(hostname=host[<span class="string">'ip'</span>], port=host[<span class="string">'port'</span>], username=host[<span class="string">'username'</span>], password=host[<span class="string">'password'</span>])</span><br><span class="line">    ssh.exec_command(<span class="string">'cd /usr/bin;kill `cat ppserver.pid`'</span>)</span><br><span class="line">    ssh.close()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pp</span><br><span class="line"><span class="keyword">import</span> pandas</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> sqlalchemy</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">db_251_pre2 = &#123;</span><br><span class="line">   <span class="string">'host'</span>: <span class="string">'192.168.0.251'</span>,</span><br><span class="line">   <span class="string">'port'</span>: <span class="number">3306</span>,</span><br><span class="line">   <span class="string">'user'</span>: <span class="string">'user_rw'</span>,</span><br><span class="line">   <span class="string">'password'</span>: <span class="string">'1a2s3d4f'</span>,</span><br><span class="line">   <span class="string">'db'</span>: <span class="string">'pre_formal_2'</span>,</span><br><span class="line">   <span class="string">'charset'</span>: <span class="string">'utf8mb4'</span>&#125;</span><br><span class="line">db_222_pre2 = &#123;</span><br><span class="line">   <span class="string">'host'</span>: <span class="string">'192.168.0.222'</span>,</span><br><span class="line">   <span class="string">'port'</span>: <span class="number">3306</span>,</span><br><span class="line">   <span class="string">'user'</span>: <span class="string">'user_rw'</span>,</span><br><span class="line">   <span class="string">'password'</span>: <span class="string">'1a2s3d4f'</span>,</span><br><span class="line">   <span class="string">'db'</span>: <span class="string">'pre_formal_2'</span>,</span><br><span class="line">   <span class="string">'charset'</span>: <span class="string">'utf8mb4'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">df2_mysql</span><span class="params">(df_data, table_name, **kwargs)</span>:</span></span><br><span class="line">   <span class="string">"""</span></span><br><span class="line"><span class="string">    To wrap a function that insert DataFrame to Mysql</span></span><br><span class="line"><span class="string">    :param df_data: DataFrame data</span></span><br><span class="line"><span class="string">    :param table_name: The name of mysql table, type is string</span></span><br><span class="line"><span class="string">    :param kwargs: The connection of database, type is dict</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">   engine = sqlalchemy.create_engine(</span><br><span class="line">      <span class="string">'mysql+pymysql://&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;/&#123;&#125;?charset=&#123;&#125;'</span>.format(kwargs[<span class="string">'user'</span>], kwargs[<span class="string">'password'</span>], kwargs[<span class="string">'host'</span>],</span><br><span class="line">                                                         kwargs[<span class="string">'port'</span>], kwargs[<span class="string">'db'</span>], kwargs[<span class="string">'charset'</span>]))</span><br><span class="line">   pandas.io.sql.to_sql(df_data, table_name, engine, index=<span class="literal">False</span>, if_exists=<span class="string">'append'</span>,</span><br><span class="line">          chunksize=<span class="number">10000</span>)  <span class="comment"># if_exists: 'replace', 'append'</span></span><br><span class="line">   engine.dispose()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main_func</span><span class="params">(industry_id, db_251_pre2, db_222_pre2, result_tb)</span>:</span></span><br><span class="line">   print(industry_id, <span class="string">'开始'</span>, <span class="string">'********************'</span>)</span><br><span class="line">   <span class="comment"># 其他指标</span></span><br><span class="line">   print(<span class="string">f'industry[<span class="subst">&#123;industry_id&#125;</span>] reading...'</span>)</span><br><span class="line">   sql1 = <span class="string">f'select * from patent_layout_20200722 where industry_id="<span class="subst">&#123;industry_id&#125;</span>"'</span></span><br><span class="line">   conn = pymysql.connect(**db_251_pre2)</span><br><span class="line">   df_data = pandas.read_sql(sql1, conn)</span><br><span class="line">   conn.close()</span><br><span class="line">   df_columns = df_data.columns</span><br><span class="line">   <span class="keyword">if</span> <span class="string">'id'</span> <span class="keyword">in</span> df_columns:  <span class="comment"># 若有id，就删除id</span></span><br><span class="line">      df_data = df_data.drop(<span class="string">'id'</span>, axis=<span class="number">1</span>)</span><br><span class="line">   print(<span class="string">f'industry[<span class="subst">&#123;industry_id&#125;</span>] insert into mysql...'</span>)</span><br><span class="line">   batch_num = <span class="number">250</span></span><br><span class="line">   <span class="keyword">for</span> batch_i <span class="keyword">in</span> range(<span class="number">0</span>, len(df_data), batch_num):</span><br><span class="line">      df2_mysql(df_data[batch_i: batch_i + batch_num], result_tb, **db_222_pre2)</span><br><span class="line">   print(<span class="string">f'industry[<span class="subst">&#123;industry_id&#125;</span>] is done! \n'</span>, <span class="string">'='</span> * <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">   start_time = time.time()</span><br><span class="line">   <span class="keyword">with</span> open(<span class="string">'industries_idname.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">      industries = json.load(f)</span><br><span class="line">   result_tb = <span class="string">'patent_layout_pptest200727'</span></span><br><span class="line">   <span class="comment"># 先选择一个服务器作为客户端，</span></span><br><span class="line">   <span class="comment"># 再找到ppserver.py文件</span></span><br><span class="line">   <span class="comment"># 然后，启动文件：python ppserver.py - p 3505 - w 5 - i 192.168.0.231 - s "123456"</span></span><br><span class="line">   <span class="comment"># 然后在本机中，运行主函数代码</span></span><br><span class="line">   <span class="comment"># 注意：主函数代码中，导入模块不能使用import...as，也不能用from ... import，只能用import</span></span><br><span class="line">   <span class="comment"># 在服务器上，用ps -ef | grep python | grep pp  | grep deng 查询pp进程</span></span><br><span class="line">   ppservers = (<span class="string">'192.168.0.231:3505'</span>,)  <span class="comment"># 远程服务端ip和端口号，为空就是本机</span></span><br><span class="line">   job_server = pp.Server(ncpus=<span class="number">5</span>, ppservers=ppservers, secret=<span class="string">'123456'</span>)  <span class="comment"># ncpus：本机进程数量</span></span><br><span class="line">   jobs = [job_server.submit(main_func, </span><br><span class="line">                            (industry_id, db_251_pre2, db_222_pre2, result_tb),</span><br><span class="line">                             depfuncs=(df2_mysql,),</span><br><span class="line">                             modules=(<span class="string">"pymysql"</span>, <span class="string">"time"</span>, <span class="string">"sqlalchemy"</span>, <span class="string">"pandas"</span>))</span><br><span class="line">           <span class="keyword">for</span> industry_id <span class="keyword">in</span> industries]</span><br><span class="line">   <span class="keyword">for</span> job <span class="keyword">in</span> jobs:</span><br><span class="line">      job()</span><br><span class="line">   job_server.destroy()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cython模块</title>
      <link href="/2020/07/17/Cython%E6%A8%A1%E5%9D%97/"/>
      <url>/2020/07/17/Cython%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h5 id="Cython入门"><a href="#Cython入门" class="headerlink" title="Cython入门"></a>Cython入门</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1. 理解Cpython和Cython的区别</span><br><span class="line">Cpython:C语言实现的Python解释器,类似Jpython,IronPython,代表标识&gt;&gt;&gt;</span><br><span class="line">Cython:用于编写Python的C扩展的语言,用C高效实现某些程序，再给python调用.简单的认为就是给Python加上了静态类型后的语法。</span><br><span class="line">2. 使用Cython的优点</span><br><span class="line">综合了Python的优势语言简短,写起来方便,和C的速度,编译性语言,将代码编译成机器码形式运行.Python最大的缺点就是运行慢(解释性语言).</span><br><span class="line">3. Cython用户指南</span><br><span class="line">http://docs.cython.org/en/latest/src/userguide/language_basics.html#cython-file-types</span><br><span class="line">4.Cython使用(pycharm\vs等IDE)</span><br><span class="line">    1&gt;.创建名为.pyx后缀的文件,文件内写符合C格式的代码(较难)</span><br><span class="line">    2&gt;.创建setup.py文件</span><br><span class="line">    3&gt;.python setup.py install 生成.c文件</span><br><span class="line">    4&gt;.进入cpython,import 模块</span><br><span class="line">使用案例:Helloworld</span><br><span class="line">     1.创建名为Helloworld.pyx的文件</span><br><span class="line">     2.不需要创建setup.py文件,直接在函数里导入</span><br><span class="line">        import pyximport </span><br><span class="line">        pyximport.install()</span><br><span class="line">        import 模块名</span><br><span class="line">        导入函数:模块名.函数名(参数) </span><br><span class="line">    编译说明:</span><br><span class="line">        .pyx文件将要被cython编译成.c文件</span><br><span class="line">        .c文件然后被C编译器编译成.pyd文件(可被Python直接调用)</span><br><span class="line">5.要点</span><br><span class="line">    1&gt;.在 Cython 中，类型标注对于提升速度是至关重要的</span><br><span class="line">    2&gt;.C语言在定义函数的时候,参数是要设定类型的,变量使用前需要定义类型</span><br><span class="line">    3&gt;.难点在代码转换,如何将Python形式的代码转换成C语言形式</span><br><span class="line">    4&gt;在进行整形计算的时候注意可能会溢出,c的int类型由大小限制</span><br><span class="line">6.特点</span><br><span class="line">是支持作为语言一部分的可选静态类型声明。将源代码转换为优化的C / C ++代码，并编译为Python扩展模块。</span><br></pre></td></tr></table></figure><p>#####Jupyter 中使用Cython<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.首先加载cython,%load_ext Cython</span><br><span class="line">2.在写函数的时候需要加上%%cython即可对其进行编译</span><br></pre></td></tr></table></figure></p><p><img src="/2020/07/17/Cython模块/C:/Users\ADMINI~1\AppData\Local\Temp\1595214211432.png" alt="1595214211432"><img src="/2020/07/17/Cython模块/C:/Users\ADMINI~1\AppData\Local\Temp\1595214448387.png" alt="1595214448387"></p><h5 id="Cython语句和表达式"><a href="#Cython语句和表达式" class="headerlink" title="Cython语句和表达式"></a>Cython语句和表达式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">缺点:需要会C语言相关知识,能够将Python代码通过Python+C实现(重计算的部分\频繁调用)</span><br><span class="line">总体速度:纯C&gt;C+Python&gt;纯Python</span><br><span class="line">1.Cython的语句和表达式遵循Python的语法</span><br><span class="line">2.Cython里没有-&gt;操作符,用·替代;Cython里没有指针的取值操作符,用P[0]替代*p;Cython里取变量的地址操作符&amp;;在Cython里空指针用Null表示,而且Null是保留关键字,不能用0表示</span><br><span class="line">3.Cython里用&lt;&gt;进行强制转换,而非()  eg: a = &lt;int&gt;b</span><br><span class="line">4.Cython的for循环:</span><br><span class="line">①同样支持Python的for in range</span><br><span class="line">②处于性能考虑,Cython对for循环进行了优化,在循环前先定义变量</span><br><span class="line">eg: cdef int i</span><br><span class="line">for i in  range(10)</span><br></pre></td></tr></table></figure><h5 id="Cython语法"><a href="#Cython语法" class="headerlink" title="Cython语法"></a>Cython语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1. 定义一个C变量</span><br><span class="line">    cdef int n  = 123  声明整形</span><br><span class="line">    cdef float score 声明浮点型（单精度）</span><br><span class="line">    cdef int an[20] 声明一维数组,长度为20,以0填充</span><br><span class="line">    cdef int an[10][10] 声明二维数组</span><br><span class="line">    cdef list particles 声明列表</span><br><span class="line">    cdef dict events  声明字典</span><br><span class="line">    cdef set unique_names  声明集合</span><br><span class="line">    cdef (double, int, float) d = (1.0, 2, 3.0)</span><br><span class="line">    cdef bint a = True 或者 cdef bint a = 1 声明bool类型</span><br><span class="line">    cdef str mystring = &apos;foo&apos; 声明字符串</span><br><span class="line">    cdef char* data = &quot;snfxjh&quot;  声明字符串,当字符串中含有中文时候不适用</span><br><span class="line">2. 强制类型转换 &lt;&gt;  eg: a = &lt;int&gt;b</span><br><span class="line">3. cdef/def/cpdef/ctypedef</span><br><span class="line">    def在python和cython中均可以调用,cdef在c系列可以调用,cpdef在两者都可以调用,但要知道返回的类型,且丧失了cython的类型安全,不推荐这么做.也就是说我们想要在Python中调用的函数使用def定义,不需要调用的函数使用cdef定义.</span><br><span class="line">    ctypedef用它来为类型取一个新的名字</span><br><span class="line">python程序中看不到cdef函数，python只能直接调用def的函数，cdef的函数只能通过Python调用def的函数来调用</span><br><span class="line">4.import 和 cimport</span><br><span class="line">cimport可以访问导入模块下的C函数或属性，而import可以访问Python函数或属性</span><br><span class="line">    import numpy as np</span><br><span class="line">cimport numpy as np   #并没有真正导入,只是允许访问模块下的C函数或属性</span><br><span class="line">5.cython中创建矩阵</span><br><span class="line">cdef int carr[3][3][3]  #创建一个三维矩阵,类型为int</span><br><span class="line">    cdef np.ndarray h = np.zeros([xmax, ymax], dtype=int) </span><br><span class="line">6.调用C函数</span><br><span class="line">可以在cython包里的cython/includes中找到可以导入哪些包</span><br><span class="line">7.边界检查(比如列表的索引)</span><br><span class="line">在函数前添加装饰器</span><br><span class="line">    cimport cython</span><br><span class="line">@cython.boundscheck(False)</span><br><span class="line">@cython.wraparound(False)</span><br><span class="line">    去掉边界检查可以提升速度,每次都进行边界检查非常耗时，而且有些代码是不可能产生越界的问题的，所以这个操作并不总是需要被执行,但是如果不进行边界检查，如果碰巧超出了边界，则在最佳情况下将使程序崩溃，在最坏的情况下将破坏数据.</span><br><span class="line">8.数组(array)</span><br><span class="line">from cpython cimport array</span><br><span class="line">    import array</span><br><span class="line">    cdef array.array a = array.array(&apos;i&apos;, [1, 2, 3])</span><br><span class="line">    cdef int[:] ca = a</span><br></pre></td></tr></table></figure><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml11996\wps7.jpg" alt="img"></p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml11996\wps8.jpg" alt="img"></p><p><img src="/2020/07/17/Cython模块/D:/Blog\source\_posts\Cython模块\1595234872493.png" alt="1595234872493"></p><p>#####Cython代码样例</p><p>######1.样例一号(求质数)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">首先,创建.pyx文件,创建prime.pyx,写代码,C特性变量使用前必须先声明</span><br><span class="line">def primes(int nb_primes):</span><br><span class="line">    cdef int n, i, len_p</span><br><span class="line">    cdef int p[1000]</span><br><span class="line">    if nb_primes &gt; 1000:</span><br><span class="line">        nb_primes = 1000</span><br><span class="line">    len_p = 0 </span><br><span class="line">    n = 2</span><br><span class="line">    while len_p &lt; nb_primes:</span><br><span class="line">        for i in p[:len_p]:</span><br><span class="line">            if n % i == 0:</span><br><span class="line">                break </span><br><span class="line">        else:</span><br><span class="line">            p[len_p] = n</span><br><span class="line">            len_p += 1</span><br><span class="line">        n += 1</span><br><span class="line">    result_as_list  = [prime for prime in p[:len_p]]</span><br><span class="line">    return result_as_list</span><br><span class="line">然后,在代码里导入模块名</span><br><span class="line">import pyximport</span><br><span class="line">pyximport.install()</span><br><span class="line">import prime</span><br><span class="line">print(prime.primes(100))</span><br></pre></td></tr></table></figure><h6 id="2-样例二号-比较C程度不同的代码速度"><a href="#2-样例二号-比较C程度不同的代码速度" class="headerlink" title="2.样例二号(比较C程度不同的代码速度"></a>2.样例二号(比较C程度不同的代码速度</h6><blockquote><p><a href="https://www.jianshu.com/p/9410db8fbf50" target="_blank" rel="noopener">https://www.jianshu.com/p/9410db8fbf50</a> 计算沿地球表面两点之间的距离</p></blockquote><p>​                                 <img src="/2020/07/17/Cython模块/D:/Blog\source\_posts\Cython模块\wps4.jpg" alt=" wps4">  </p><p>​                               <img src="/2020/07/17/Cython模块/D:/Blog\source\_posts\Cython模块\1594973454534.png" alt="1594973454534"></p><p>​                                <img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml11996\wps6.jpg" alt="img"> </p><p>​                                <img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml11996\wps5.jpg" alt="img"></p><blockquote><p>速度对比综合:大多数情况下，Python的性能是足够好的，一旦循环、数字运算和Python函数调用上去了，性能就会相应地下降，在这种情况下，建议使用Cython进行优化</p></blockquote><h6 id="3-样例三号-传矩阵参数"><a href="#3-样例三号-传矩阵参数" class="headerlink" title="3.样例三号(传矩阵参数)"></a>3.样例三号(传矩阵参数)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">一.</span><br><span class="line">cdef int sum3d(int[:, :, :] arr) nogil:</span><br><span class="line">    cdef size_t i, j, k, I, J, K</span><br><span class="line">    cdef int total = 0</span><br><span class="line">    I = arr.shape[0]</span><br><span class="line">    J = arr.shape[1]</span><br><span class="line">    K = arr.shape[2]</span><br><span class="line">    for i in range(I):</span><br><span class="line">        for j in range(J):</span><br><span class="line">            for k in range(K):</span><br><span class="line">                total += arr[i, j, k]</span><br><span class="line">    return total</span><br><span class="line">说明:传的arr为三维矩阵,且矩阵内数据为int类型</span><br><span class="line">    </span><br><span class="line">二.</span><br><span class="line">import numpy as np</span><br><span class="line">cimport numpy as np</span><br><span class="line">DTYPE = np.int</span><br><span class="line">ctypedef np.int_t DTYPE_t</span><br><span class="line">def naive_convolve(np.ndarray f, np.ndarray g):</span><br><span class="line">    if g.shape[0] % 2 != 1 or g.shape[1] % 2 != 1:</span><br><span class="line">        raise ValueError(&quot;Only odd dimensions on filter supported&quot;)</span><br><span class="line">    assert f.dtype == DTYPE and g.dtype == DTYPE</span><br><span class="line">    cdef int vmax = f.shape[0]</span><br><span class="line">    cdef int wmax = f.shape[1]</span><br><span class="line">    cdef int smax = g.shape[0]</span><br><span class="line">    cdef int tmax = g.shape[1]</span><br><span class="line">    cdef int smid = smax // 2</span><br><span class="line">    cdef int tmid = tmax // 2</span><br><span class="line">    cdef int xmax = vmax + 2 * smid</span><br><span class="line">    cdef int ymax = wmax + 2 * tmid</span><br><span class="line">    cdef np.ndarray h = np.zeros([xmax, ymax], dtype=DTYPE)</span><br><span class="line">    cdef int x, y, s, t, v, w</span><br><span class="line">    cdef int s_from, s_to, t_from, t_to</span><br><span class="line">    cdef DTYPE_t value</span><br><span class="line">    for x in range(xmax):</span><br><span class="line">        for y in range(ymax):</span><br><span class="line">            s_from = max(smid - x, -smid)</span><br><span class="line">            s_to = min((xmax - x) - smid, smid + 1)</span><br><span class="line">            t_from = max(tmid - y, -tmid)</span><br><span class="line">            t_to = min((ymax - y) - tmid, tmid + 1)</span><br><span class="line">            value = 0</span><br><span class="line">            for s in range(s_from, s_to):</span><br><span class="line">                for t in range(t_from, t_to):</span><br><span class="line">                    v = x - smid + s</span><br><span class="line">                    w = y - tmid + t</span><br><span class="line">                    value += g[smid - s, tmid - t] * f[v, w]</span><br><span class="line">            h[x, y] = value</span><br><span class="line">    return h</span><br><span class="line">或者使用 def naive_convolve(object[DTYPE_t, ndim=2] f,object[DTYPE_t, ndim=2] g)也可以,速度稍微慢点</span><br><span class="line">或者使用 def naive_convolve(np.ndarray[DTYPE_t, ndim=2] f,np.ndarray[DTYPE_t, ndim=2] g):</span><br></pre></td></tr></table></figure><h6 id="分析Cython程序的好坏"><a href="#分析Cython程序的好坏" class="headerlink" title="分析Cython程序的好坏"></a>分析Cython程序的好坏</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.cython -a yfxl.pyx (yfxl.pyx为cython文件名,会生成的.html文件</span><br><span class="line">2.在jupyter中使用 %%cython --annotate</span><br><span class="line">3.通过生成的报告可以看出来转换的程度,白色线条转换为纯C，黄色的为与Python有交互</span><br></pre></td></tr></table></figure><p>######优化(由简单到复杂)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 将数据类型由动态转换成静态(变量使用前先cdef定义一下)-----&gt;这一步就对速度有显著提升</span><br><span class="line">2. Python加C混合使用,尽可能多的使用C(如import仍使用Python)</span><br><span class="line">3. 完全使用C,比如import math 转换成使用C的标准库实现</span><br></pre></td></tr></table></figure><p>######总结</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 数据类型必须使用前定义,但不是全部,Cython根据其分配推导局部变量的类型，这也可以减少在任何地方显式指定类型的需要(如循环的i),添加类型过多会使代码的可读性降低，因此请适度使用它们</span><br><span class="line">2. 循环和重计算的代码尽量使用Cython代码实现</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心学院nlp</title>
      <link href="/2020/07/07/%E8%B4%AA%E5%BF%83%E5%AD%A6%E9%99%A2nlp/"/>
      <url>/2020/07/07/%E8%B4%AA%E5%BF%83%E5%AD%A6%E9%99%A2nlp/</url>
      
        <content type="html"><![CDATA[<h4 id="NLP项目流程"><a href="#NLP项目流程" class="headerlink" title="NLP项目流程"></a>NLP项目流程</h4><p>原始文本—-&gt;分词—–&gt;清洗—–&gt;标准化—–&gt;特征提取——&gt;建模</p><p><img src="/2020/07/07/贪心学院nlp/nlp流程.jpg" alt></p><h4 id="分词方法"><a href="#分词方法" class="headerlink" title="分词方法"></a>分词方法</h4><p>1.$\textcolor{red}{分词工具}$</p><p>​    1.jieba分词</p><p>​    2.SnowNLP</p><p>​    3.LTP</p><p>​    4.HanNLP</p><p>2.$\textcolor{red}{分词方法}$</p><p>​    1.最大匹配算法</p><p>​        ①前向最大匹配算法</p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python优化方法</title>
      <link href="/2020/06/17/python%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"/>
      <url>/2020/06/17/python%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="Python的缺点就是运行特别慢-比其他语言慢2-10倍"><a href="#Python的缺点就是运行特别慢-比其他语言慢2-10倍" class="headerlink" title="Python的缺点就是运行特别慢,比其他语言慢2-10倍"></a>Python的缺点就是运行特别慢,比其他语言慢2-10倍</h3><p>原因:它是GIL(Global interpreter lock 全局解释器锁)===cpython,其他语言实现的Python可以没有如jpython,为解释型语言,为动态型语言</p><p>$\textcolor{red}{静态语言:}$数据类型需要先声明</p><p>$\textcolor{red}{动态语言:}$即语言无需声明数据类型直接可以使用的语言</p><p>Python写起来方便,简短的代价为执行速度</p><p>GIL:使得在同一进程内任何时刻仅有一个线程在执行(Cpython)</p><p>Python的解析器 ——<br>含有GIL的有：CPython、PyPy、Psyco；<br>没有GIL的有：JPython，IronPython。</p><p>multiprocessing库的出现很大程度上是为了弥补thread库因为GIL而低效的缺陷</p><p>方便将来$\textcolor{orange}{量化}$或者别的应用场景中的一些$\textcolor{green}{重计算的部分}$单独取出来，然后用Cython改写，独立成模块来提高运算速度</p><p>$\textcolor{red}{cpu密集型}$:也叫计算密集型,，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作大部分的状况是CPU Loading 100%，CPU要读/写I/O(硬盘/内存)，I/O在很短的时间就可以完成，而CPU还有许多运算要处理，CPU Loading很高。<br>$\textcolor{red}{io密集型}$:IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作，此时CPU Loading并不高。<br>$\textcolor{red}{Cpython}$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>cpython和ipython的区别:</span><br><span class="line">CPython是用C语言编写的实现,CPython是使用字节码的解释器，CPython将您的Python代码编译为字节码</span><br><span class="line">cpython就是我们下载完Python后通过命令行Python进入的解释器</span><br><span class="line">CPython用&gt;&gt;&gt;作为提示符，而IPython用In [序号]:作为提示符。</span><br><span class="line"></span><br><span class="line">使用:</span><br><span class="line"><span class="number">1.</span>创建名为.pyx后缀的文件,文件内写符合C格式的代码(较难)</span><br><span class="line"><span class="number">2.</span>创建setup.py文件</span><br><span class="line"><span class="number">3.</span>python setup.py install 生成.c文件</span><br><span class="line"><span class="number">4.</span>进入cpython,<span class="keyword">import</span> 模块</span><br><span class="line">案例:Helloworld</span><br><span class="line">      <span class="number">1.</span>创建一个文件helloworld.pyx,内容如下:</span><br><span class="line">        print(<span class="string">'hello world!'</span>)</span><br><span class="line">      <span class="number">2.</span>创建setup.py文件,内容如下</span><br><span class="line">    <span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup</span><br><span class="line">        <span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span><br><span class="line">        setup(</span><br><span class="line">        ext_modules = cythonize(<span class="string">"helloworld.pyx))</span></span><br><span class="line"><span class="string">       3.命令行进入到当前的位置,python setup.py install,生成文件</span></span><br><span class="line"><span class="string">       4.命令行使用Python进入cpython,import helloworld会自动输入helloworld</span></span><br><span class="line"><span class="string">          (通常为import fib fib.fib(10)的形式调用函数)</span></span><br><span class="line"><span class="string">2.实现:Cython</span></span><br><span class="line"><span class="string">   一.注意:</span></span><br><span class="line"><span class="string">     1.Cython的扩展名为.pyx</span></span><br><span class="line"><span class="string">     2.引入模块cimport 模块名</span></span><br><span class="line"><span class="string">     3.@cython.boundscheck(False) 和 @cython.wraparound(False) 两个修饰符用来关闭 Cython 的边界检查  </span></span><br><span class="line"><span class="string"> 4.Cython的函数使用cdef定义</span></span><br><span class="line"><span class="string">   二.实现方法1</span></span><br><span class="line"><span class="string">     同上面的helloworld案例</span></span><br><span class="line"><span class="string">   三.实现方法2</span></span><br><span class="line"><span class="string">     1.创建名为.pyx的文件</span></span><br><span class="line"><span class="string">     2.不需要创建setup.py文件,直接在函数里导入</span></span><br><span class="line"><span class="string">        import pyximport </span></span><br><span class="line"><span class="string">        pyximport.install()</span></span><br><span class="line"><span class="string">        import 模块名</span></span><br><span class="line"><span class="string">        导入函数:模块名.函数名(参数)</span></span><br></pre></td></tr></table></figure><p>$\textcolor{red}{Cython}$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.在 Cython 中，类型标注对于提升速度是至关重要的</span><br><span class="line">2.C语言在定义函数的时候,参数是要设定类型的,变量使用前需要定义类型</span><br><span class="line">3.难点在代码转换,如何将Python形式的代码转换成C语言形式</span><br></pre></td></tr></table></figure><p>$\textcolor{red}{速度快慢}$:纯Python版本&lt;Python+c混合&lt;C实现Python调用&lt;纯c(C实现C调用)</p><p><a href="https://www.jianshu.com/p/9410db8fbf50" target="_blank" rel="noopener">https://www.jianshu.com/p/9410db8fbf50</a></p><p>$\textcolor{red}{Cython语句和表达式}$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.Cython的语句和表达式遵循Python的语法</span><br><span class="line">2.Cython里没有-&gt;操作符,用·替代;Cython里没有指针的取值操作符,用P[0]替代*p;Cython里取变量的地址操作符&amp;;在Cython里空指针用Null表示,而且Null是保留关键字,不能用0表示</span><br><span class="line">3.Cython里用&lt;&gt;进行强制转换,而非()  eg: a = &lt;int&gt;b</span><br><span class="line">4.Cython的for循环:</span><br><span class="line">①同样支持Python的for in range</span><br><span class="line">②处于性能考虑,Cython对for循环进行了优化,在循环前先定义变量</span><br><span class="line">eg: cdef int i</span><br><span class="line">for i in  range(10)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络算法</title>
      <link href="/2020/06/01/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95/"/>
      <url>/2020/06/01/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h5 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">神经网络的结构:输入层--&gt;隐藏层--&gt;输出层</span><br><span class="line">卷积神经网络:</span><br><span class="line">卷积神经网络和普通神经网络的关系:</span><br><span class="line">    卷积神经网络依旧是层级网络,只是层的功能和形式发生了变化</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>社交网络算法</title>
      <link href="/2020/05/28/%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95/"/>
      <url>/2020/05/28/%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h6 id="社交网络算法"><a href="#社交网络算法" class="headerlink" title="社交网络算法"></a>社交网络算法</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">使用的包为igraph</span><br><span class="line">衡量指标:</span><br><span class="line">    <span class="number">1.</span>点度中心性:在网络中共有N个结点,每个节点由k个直接连接的节点,则该点的自由度为deg(x) = k,该点的点度中心性为deg(x)/(N<span class="number">-1</span>),N<span class="number">-1</span>为排除自身总共的节点</span><br><span class="line">    <span class="number">2.</span>紧密度中间性:距离d为该点到其余各点带权的最短路径和,各个节点的紧密度中间性为d/(N<span class="number">-1</span>)的结果的倒数.结果越大表示越<span class="string">'紧密'</span></span><br><span class="line">    <span class="number">3.</span>介数中间性(公式见下图):</span><br><span class="line">        设节点x 和节点 y之间的最短路径数为σ(x,y)，最短路径中通过节点 v 的路径数为σ(x,y|v)</span><br><span class="line">        eg:A-B-C-D-E(无向图)</span><br><span class="line">         对于A而言经过该节点的路线没有故介数中间性为<span class="number">0</span></span><br><span class="line">        对于B,经过该节点的为A-B-C,A-B-C-D,A-B-C-D-E,每一种情况的σ均为<span class="number">1</span>,所以,B点的介数中心性为<span class="number">3</span>/(<span class="number">4</span>*<span class="number">3</span>/<span class="number">2</span>)</span><br><span class="line">    <span class="number">4.</span>特征值中心性</span><br><span class="line">    N个节点的无向网络,可以转换成N*N的矩阵,不相连为<span class="number">0</span>,相连则为<span class="number">1</span></span><br><span class="line">      使用特征方程Ix = λx===&gt;(I-λE)x = 0可求解出特征值和特征向量,特征值作为向心度大小,特征向量作为向心度在各个连接的得分值</span><br><span class="line">总:紧密度中间性可以降低远距离点的干扰,介数中间性可以找到大佬(公认).</span><br></pre></td></tr></table></figure><p><img src="/2020/05/28/社交网络算法/介数中间性.png" alt="介数中间性"></p><h5 id="igragh包安装"><a href="#igragh包安装" class="headerlink" title="igragh包安装"></a>igragh包安装</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>https://www.lfd.uci.edu/~gohlke/pythonlibs/ 下载对应python版本的igragh包</span><br><span class="line"><span class="number">2.</span>https://www.lfd.uci.edu/~gohlke/pythonlibs/  下载对应Python版本的pycairo</span><br><span class="line"><span class="number">3.</span>pip instal 两个文件的路径</span><br><span class="line"><span class="number">4.</span>完成,无法使用的话卸载anaconda重新安装</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g = igraph.Graph([(<span class="number">0</span>,<span class="number">2</span>),(<span class="number">0</span>,<span class="number">3</span>),(<span class="number">3</span>,<span class="number">1</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">3</span>,<span class="number">5</span>),(<span class="number">1</span>,<span class="number">4</span>)])<span class="comment">#创建图</span></span><br><span class="line">igraph.plot(g)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span>  igraph</span><br><span class="line">config1 = &#123;</span><br><span class="line">        <span class="string">'host'</span>: <span class="string">'192.168.0.250'</span>,</span><br><span class="line">        <span class="string">'port'</span>: <span class="number">3306</span>,  <span class="comment"># MySQL默认端口</span></span><br><span class="line">        <span class="string">'user'</span>: <span class="string">'user_rw'</span>,  <span class="comment"># mysql默认用户名</span></span><br><span class="line">        <span class="string">'password'</span>: <span class="string">'1a2s3d4f'</span>,</span><br><span class="line">        <span class="string">'db'</span>: <span class="string">'pre_formal_1'</span>,  <span class="comment"># 数据库</span></span><br><span class="line">        <span class="string">'charset'</span>: <span class="string">'utf8'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">conn1 = pymysql.connect(**config1)</span><br><span class="line">sql = <span class="string">"select app_text,inventors from zl_zu_20200526_L where applicant_other = '新疆恒泰艾普能源服务有限公司'"</span></span><br><span class="line">df = pd.read_sql(sql,conn1)</span><br><span class="line">ls = []</span><br><span class="line">ls1 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> df.inventors:</span><br><span class="line">    i = i.split(<span class="string">','</span>)</span><br><span class="line">    i = list(set(i))</span><br><span class="line">    ls.extend(i)</span><br><span class="line">    <span class="keyword">if</span> len(i)&gt;<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> range(len(i)):</span><br><span class="line">            k = m+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> k&lt;len(i):</span><br><span class="line">                ls1.append((i[m],i[k]))</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ls1.append((i[<span class="number">0</span>],i[<span class="number">0</span>]))</span><br><span class="line">inv_ls = list(set(ls))</span><br><span class="line">g = igraph.Graph()</span><br><span class="line">vertex = inv_ls</span><br><span class="line">g.add_vertices(vertex)</span><br><span class="line">g.vs[<span class="string">'label'</span>] = g.vs[<span class="string">'name'</span>]</span><br><span class="line">edges = ls1</span><br><span class="line">g.add_edges(edges)</span><br><span class="line">igraph.plot(g)</span><br><span class="line">dict1 = dict(zip(inv_ls,g.degree()))</span><br><span class="line">sorted(dict1.items(),key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络基础知识</title>
      <link href="/2020/05/25/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/05/25/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/05/25/网络基础知识/1590378268619.png" alt="1590378268619"></p><h6 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.osi7层模型</span><br><span class="line">2.TCP/IP四层和五层模型</span><br><span class="line">3.简单介绍一下osi各个层及作用</span><br><span class="line">4.简单介绍一下tcp/ip协议的三次握手和四次挥手</span><br><span class="line">5.为什么连接时候是三次握手而关闭时候是四次</span><br><span class="line">6.为什么不能用两次握手建立连接</span><br><span class="line">7.TCP和UDP协议的区别</span><br><span class="line">8.HTTP和HTTPS的区别</span><br><span class="line">9.get请求和post请求的区别</span><br><span class="line">10.session和cookie的区别</span><br></pre></td></tr></table></figure><p>#####OSI参考模型(开放式系统互联)</p><p>定义了网络互联的七层框架,物理层,数据链路层,网络层,传输层,会话层,表示层和应用层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">osi七层模型 &lt;-----TCP/IP五层模型 &lt;-------TCP/IP四层模型</span><br><span class="line">物理层          物理层网络接口层</span><br><span class="line">数据链路层   数据链路层 网络接口层</span><br><span class="line">网络层网络层网络层</span><br><span class="line">传输层传输层传输层</span><br><span class="line">会话层应用层应用层</span><br><span class="line">表示层应用层应用层</span><br><span class="line">应用层应用层应用层</span><br></pre></td></tr></table></figure><h6 id="简单介绍osi七层模型中的各层"><a href="#简单介绍osi七层模型中的各层" class="headerlink" title="简单介绍osi七层模型中的各层"></a>简单介绍osi七层模型中的各层</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">物理层:重要设备为中继器(放大信号)和集线器(放大信号),扩大网络的传输距离. 作用:确保原始数据可在网络媒体上传输</span><br><span class="line">数据链路层:重要设备为网桥(连接网段)和交换机(更多连接接口). 作用:为网络层提供可靠的数据传输,数据成帧,流量控制,数据检错,重发.   协议:网络接口协议</span><br><span class="line">网络层:重要设备为路由器(连接不同网络,信息传输). 作用:对子网间的数据进行路由选择,拥塞控制,网际互连.  协议:IP/ICMP/ARP/RARP协议</span><br><span class="line">传输层:重要设备为网关(网络互连,跟门原理差不多).  作用:将上层数据分段,并提供端到端的,可靠的或不可靠的传输以及端到端的差错控制和流量控制问题   协议:TCP/UDP协议</span><br><span class="line">会话层:管理主机间的会话进程</span><br><span class="line">表示层:对数据进行变换以保证一个主机应用层信息可以被宁一个主机的应用程序理解</span><br><span class="line">应用层:为操作系统或网络应用程序提供访问网络服务的接口</span><br><span class="line">会话层、表示层、应用层的协议：FTP(文件传送协议)/Telnet(远程登录协议)/DNS(域名解析协议)/SMTP(邮件传送协议)/POP3</span><br></pre></td></tr></table></figure><h6 id="TCP-IP的三次握手和四次挥手♻"><a href="#TCP-IP的三次握手和四次挥手♻" class="headerlink" title="TCP/IP的三次握手和四次挥手♻"></a>TCP/IP的三次握手和四次挥手♻</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1.三次握手（建立连接阶段）：</span><br><span class="line">①客户端发送初始序号x和syn=1请求标志</span><br><span class="line">②服务器发送请求标志syn，发送确认标志ACK，发送自己的序号seq=y，发送客户端的确认序号ack=x+1</span><br><span class="line">③客户端发送ACK确认号，发送自己的序号seq=x+1，发送对方的确认号ack=y+1</span><br><span class="line"></span><br><span class="line">第一次：客户端发送请求到服务器，服务器知道客户端发送，自己接收正常。SYN=1,seq=x</span><br><span class="line">第二次：服务器发给客户端，客户端知道自己发送、接收正常，服务器接收、发送正常。ACK=1,ack=x+1,SYN=1,seq=y</span><br><span class="line">第三次：客户端发给服务器：服务器知道客户端发送，接收正常，自己接收，发送也正常.seq=x+1,ACK=1,ack=y+1</span><br><span class="line"></span><br><span class="line">2.四次挥手（连接释放阶段）：</span><br><span class="line">①客户端发出释放FIN=1，自己序列号seq=u，进入FIN-WAIT-1状态</span><br><span class="line">②服务器收到客户端的后，发出ACK=1确认标志和客户端的确认号ack=u+1，自己的序列号seq=v，进入CLOSE-WAIT状态</span><br><span class="line">    ③客户端收到服务器确认结果后，进入FIN-WAIT-2状态。此时服务器发送释放FIN=1信号，确认标志ACK=1，确认序号ack=u+1，自己序号seq=w，服务器进入LAST-ACK（最后确认态）</span><br><span class="line">    ④第四次挥手：客户端收到回复后，发送确认ACK=1，ack=w+1，自己的seq=u+1，客户端进入TIME-WAIT（时间等待）。客户端经过2个最长报文段寿命后，客户端CLOSE；服务器收到确认后，立刻进入CLOSE状态。</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    第一次：客户端请求断开FIN,seq=u</span><br><span class="line">    第二次：服务器确认客户端的断开请求ACK,ack=u+1,seq=v</span><br><span class="line">    第三次：服务器请求断开FIN,seq=w,ACK,ack=u+1</span><br><span class="line">    第四次：客户端确认服务器的断开ACK,ack=w+1,seq=u+1</span><br><span class="line">    </span><br><span class="line">ack:确认序号的标志,ack=1表示序列号有效,ack=0表示报文不含确认序列号信息</span><br><span class="line">syn:连接请求序号标志,用于建立连接,syn = 1表示请求连接</span><br><span class="line">fin:结束标志,用于释放连接,1表示关闭本方数据流</span><br></pre></td></tr></table></figure><h6 id="为什么三次握手和四次挥手"><a href="#为什么三次握手和四次挥手" class="headerlink" title="为什么三次握手和四次挥手"></a>为什么三次握手和四次挥手</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">三次握手时,服务器同时把ack和syn放在一起发送到客户端那里</span><br><span class="line">四次挥手时,当收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方 ACK 和 FIN 一般都会分开发送。</span><br></pre></td></tr></table></figure><p>######能否两次握手建立连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3次握手完成两个重要的功能,既要双方做好发送数据的准备工作,也要允许双方就初始序列号进行协商,这个序列号在握手过程中被发送和确认</span><br></pre></td></tr></table></figure><h6 id="使用tcp的协议"><a href="#使用tcp的协议" class="headerlink" title="使用tcp的协议"></a>使用tcp的协议</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">FTP(文件传输协议)  Telnet(远程登录协议)  SMTP(简单邮件传输协议) POP3(与SMTP对应用于接收邮件) HTTP协议等</span><br></pre></td></tr></table></figure><p>######TCP和UDP协议的区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.TCP是面向连接的,可靠的字节流服务,UDP是面向无连接的,不可靠的数据流服务</span><br><span class="line"></span><br><span class="line">2.TCP安全,稳定,但比较慢,对系统资源要求多,且效率较低</span><br></pre></td></tr></table></figure><h6 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http是以明文方式发送内容</span><br><span class="line">https是在http的基础上使用了SSL/TSL加密</span><br></pre></td></tr></table></figure><p>######Get和Post请求的区别</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、url可见性：</span><br><span class="line">get:参数url可见         post:参数url不可见</span><br><span class="line"><span class="number">2</span>、数据传输上：</span><br><span class="line">get:通过拼接url进行传递参数          post:通过body体传输参数</span><br><span class="line"><span class="number">3</span>、缓存性：</span><br><span class="line">get请求是可以缓存的             post请求不可以缓存</span><br><span class="line"><span class="number">4</span>、后退页面的反应:</span><br><span class="line">get请求页面后退时，不产生影响                 post请求页面后退时，会重新提交请求</span><br><span class="line"><span class="number">5</span>、传输数据的大小</span><br><span class="line">get一般传输数据大小不超过<span class="number">2</span>k<span class="number">-4</span>k（根据浏览器不同，限制不一样，但相差不大）</span><br><span class="line">post请求传输数据的大小根据配置文件设定，也可以无限大。</span><br><span class="line"><span class="number">6.</span>参数的数据类型</span><br><span class="line">get只接受ASCII字符          而POST没有限制</span><br><span class="line"></span><br><span class="line">核心:</span><br><span class="line">    首先GET和POST是什么？</span><br><span class="line">    他们是HTTP协议中两种发送请求的方式。HTTP是基于TCP与IP的关于数据在万维网中如何通信的协议。HTTP的底层是TCP/IP，也就是说GET与POST都是TCP链接。GET与POST做的事是一样的，都可以传输数据。因此GET与POST在本质上没有区别，而真正的区别在于TPC链接的不同</span><br><span class="line">    原理</span><br><span class="line">    POST方式会产生两个TCP数据包。详细的说，对于GET请求，浏览器会把http header和data一并发送出去，服务器响应<span class="number">200</span>ms后返回数据。而POST请求，浏览器会先发送http header服务器响应<span class="number">100</span>-<span class="keyword">continue</span>(协议)，浏览器再发送data，服务器响应<span class="number">200</span>ms后再返回数据。</span><br></pre></td></tr></table></figure><h6 id="session和cookie"><a href="#session和cookie" class="headerlink" title="session和cookie"></a>session和cookie</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP协议中,客户端请求服务器端是一种无状态的连接,每次请求都是独立的请求</span><br><span class="line">(1)cookie以文本文件格式存储在浏览器中,而session存储在服务器端</span><br><span class="line">(2)cookie的存储限制了数据量,只允许4kb,而session是无限量的</span><br><span class="line">(3)我们可以轻松访问cookie值但是我们无法轻松访问会话值,因此更安全</span><br><span class="line">(4)可以考虑将登录信息等重要信息存放为session,不重要的信息,可以放在cookie中</span><br><span class="line">联系:</span><br><span class="line">(1)都是用来记录用户的信息以便让服务器分辨不同的用户</span><br><span class="line">(2)可以搭配使用 ,都有自己的使用局限,要考虑到安全和性能问题</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习思路与方向</title>
      <link href="/2020/05/22/%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%B7%AF%E4%B8%8E%E6%96%B9%E5%90%91/"/>
      <url>/2020/05/22/%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%B7%AF%E4%B8%8E%E6%96%B9%E5%90%91/</url>
      
        <content type="html"><![CDATA[<p>#多动脑子  勤动手</p><h4 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">计算机组成原理---&gt;C语言基础---&gt;看懂项目(开源社区)</span><br><span class="line">入门：</span><br><span class="line">C语言的基本语法知识：</span><br><span class="line">·环境</span><br><span class="line">·简单的程序</span><br><span class="line">·算法概念，简单六成结构，流程图等</span><br><span class="line">·基本数据类型</span><br><span class="line">·运算符与表达式</span><br><span class="line">·简单输入输出函数</span><br><span class="line">·选择循环分支结构</span><br><span class="line">·数组</span><br><span class="line">·函数编程基础</span><br><span class="line">·指针</span><br><span class="line">提高：</span><br><span class="line">C语言基本知识框架</span><br><span class="line">·指针的深刻理解和使用</span><br><span class="line">·位运算</span><br><span class="line">·存储管理</span><br><span class="line">·预处理</span><br><span class="line">·字符串处理</span><br><span class="line">·文件的读写操作</span><br><span class="line">·函数熟练使用</span><br><span class="line">·常用的数据结构</span><br><span class="line">·图形图像的简单处理</span><br><span class="line">应用：</span><br><span class="line">综合性运用软件的开发能力</span><br><span class="line">·软件工程基本知识</span><br><span class="line">·数据库知识</span><br><span class="line">·数据结构知识</span><br><span class="line">·程序运维能力</span><br><span class="line">·工程化思维</span><br></pre></td></tr></table></figure><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python语言基础---&gt;Python语言高级---&gt;全栈前端---&gt;全栈后端---&gt;后端高级---&gt;linux基础</span><br><span class="line">---&gt;linux运维自动化开发---&gt;数据分析---&gt;大数据---&gt;机器学习</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql底层知识</title>
      <link href="/2020/05/13/mysql%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/05/13/mysql%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>##基础知识</p><p>文章来源:<a href="https://www.jianshu.com/p/47664afa249e" target="_blank" rel="noopener">https://www.jianshu.com/p/47664afa249e</a></p><h4 id="Mysql的常用引擎"><a href="#Mysql的常用引擎" class="headerlink" title="Mysql的常用引擎"></a>Mysql的常用引擎</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.Innodb(更适合高并发场景)</span><br><span class="line">Innodb的存储文件有两个,后缀名分别为.frm和.idb,其中.frm是表的定义文件,而.idb是数据文件</span><br><span class="line">Innodb中存在表锁和行锁,不过行锁是在命中索引的情况下才会起作用</span><br><span class="line">Innodb支持事务,且支持四种隔离级别(读未提交,读已提交,可重复读,序列化),默认为可重读读;而在oracle数据库中,只支持序列化和读已提交这两种级别,默认为读已提交</span><br><span class="line">2.Myisam</span><br><span class="line">Myisam的存储文件有三个,后缀名分别为.frm,.MYD,.MYI.其中.frm是表的定义文件,MYD是表的数据文件,MYI是索引文件.</span><br><span class="line">Myisam只支持表锁,且不支持事务.Mysiam由于有单独的索引文件,在读取数据方面性能更高</span><br><span class="line">3.存储结构</span><br><span class="line">Innodb和Myisam都是用B+Tree来存储数据的</span><br></pre></td></tr></table></figure><h5 id="Mysql的数据、索引存储结构"><a href="#Mysql的数据、索引存储结构" class="headerlink" title="Mysql的数据、索引存储结构"></a>Mysql的数据、索引存储结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.数据存储的原理(硬盘)</span><br><span class="line">信息存储在硬盘里,硬盘是有很多的盘片组成,通过盘片表面的磁性物质来存储数据.盘片表面是凹凸不平的,凸起的地方磁化,代表数字1,凹的地方被磁化,代表数字0,因此硬盘是通过二进制来存储数字,文字等信息的</span><br><span class="line">2.数据读写的原理</span><br><span class="line">硬盘在逻辑上被分为磁道,柱面以及扇区.</span><br><span class="line">磁头靠近主轴接触的表面,即线速度最小的地方,是一个特殊的区域,它不存放任何数据,称为启停区或者着陆区,启停区外就是数据区</span><br><span class="line">在最外圈,离主轴最远的地方就是0磁道,硬盘数据的存放就是从最外圈开始的</span><br><span class="line">在硬盘中还有一个叫0磁道检测器的构件,用来完成磁盘的初始定位</span><br><span class="line">3.磁盘的读写原理</span><br><span class="line">系统将文件存储到磁盘上时,按柱面、磁头和扇区的方式进行，即最先是第一磁道的第一磁头下的所有扇区，然后是同一柱面的下一个磁头</span><br><span class="line">一个柱面存储满后就推进到下一个柱面，直到把文件内容全部写入磁盘</span><br><span class="line">系统也以相同的顺序读出数据，读出数据时通过告诉磁盘控制器要读出所在扇区所在柱面、磁头号和扇区号进行</span><br><span class="line">4.减少i/o的预读原理</span><br><span class="line">由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动消耗的时间。磁盘的存取速度往往是主存的几百分之一，因此为了提高效率尽量减少磁盘的io。</span><br><span class="line">磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。</span><br><span class="line">5.mysql的索引</span><br><span class="line">索引是一种用来实现Mysql高效获取数据的数据结构</span><br><span class="line">我们通常所说的在某个字段上建索引，意思就是让mysql对该字段以索引这种数据结构来存储，然后查找时有对应的查找算法。</span><br><span class="line">建立索引的目的是为了查找的优化，一般的查找算法有顺序查找，折半查找，快速查找。每种查找算法都用于特定的数据结构。如顺序查找以来于顺序结构，折半查找通过二叉查找树黑着红黑树实现二分搜索。因此在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这种数据结构以某种方式引用数据，这样就可以在这些数据结果上实现高级查找算法，这种数据结构就是索引。</span><br></pre></td></tr></table></figure><h5 id="Mysql中的B-Tree"><a href="#Mysql中的B-Tree" class="headerlink" title="Mysql中的B+Tree"></a>Mysql中的B+Tree</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">目前大多数的数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构</span><br><span class="line">B+树索引是B+树在数据库中的一种实现，是最常见也是数据库中使用最为频繁的一种索引，B表示平衡而非二叉。</span><br><span class="line">B+Tree是由平衡二叉树演变而来,B+Tree是由二叉查找树(左子树的键值小于根节点键值,右子树的键值大于根的键值),平衡二叉树(在二叉查找树的条件下,还满足任何节点的两个子树高度最大差为<span class="number">1</span>),平衡多路查找树(为磁盘外存储设备设计的一种平衡查找树)逐步优化过来的</span><br><span class="line">系统从磁盘读取数据到内存时是以磁盘块为基本单位的,位于同一磁盘块中的数据会被一次性取出来,而不是按需读取</span><br><span class="line">Innodb使用页作为数据读取单位,页是其磁盘管理的最小单位,默认page大小是<span class="number">16</span>k</span><br><span class="line">系统中一个磁盘的大小往往没有那么大,因此Innodb每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小<span class="number">16</span>kb</span><br><span class="line">Innodb在把磁盘数据读入到磁盘时会以页作为基本单位,在查询数据时如果一个页中的每条数据都能助于定位数据记录的位置,这将会减少磁盘I/O的次数,提高查询效率</span><br><span class="line">B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块</span><br><span class="line">为了描述B-Tree,首先定义一条数据记录为一个二元组[key,data],key为记录的键值,对于不同数据记录,可以是互不相同的,data为数据记录除key外的数据</span><br><span class="line">B-Tree的每个节点根据实际情况可以包含大量的关键字信息和分支</span><br><span class="line">每个节点占用一个盘块的磁盘空间,一个节点上有两个升序排序的关键字个三个只想子树根节点的指针,指针存储的是子节点所在磁盘块的地址.</span><br><span class="line">两个关键词划分成的三个范围域对应三个指针只想的子树的数据的范围域</span><br><span class="line">以根节点为例,关键字为<span class="number">17</span>和<span class="number">35</span>,p1指针指向的子树的数据范围为小于<span class="number">17</span>,p2指针指向的子树的数据范围为<span class="number">17</span><span class="number">-35</span>,p3指针指向的为大于<span class="number">35</span></span><br></pre></td></tr></table></figure><p>####B-Tree</p><p><img src="/2020/05/13/mysql底层知识/360截图184307107476110.png" alt="360截图184307107476110"></p><p>查找关键字29的过程:</p><p>​    1.根据根节点找到磁盘1,读入内存(磁盘i/o操作一次)</p><p>​    2.根据关键字29在区间(17,35),找到磁盘块1的指针p2</p><p>​    3.根据p2指针找到磁盘块3,读入内存,磁盘i/o操作第二次</p><p>​    4.比较关键字29在区间(26,30),找到磁盘块3的指针p2</p><p>​    5.根据p2指针找到磁盘块8,读入内存,磁盘i/o操作第三次</p><p>​    6.在磁盘块8的关键字列表中找到关键字29</p><p>Mysql的Innodb存储引擎在设计时是将根节点常驻内存的,因此力求达到树的深度不超过3,也就是I/O不需要超过3次</p><p>根据上面的过程可以发现需要3次磁盘I/O操作,和3次内存查找工作.由于内存中的关键字是一个有序表结构,可以利用二分法查找提高效率,因而3次磁盘的I/O操作是影响整个B-tree查找效率的决定性因素</p><p>B-Tree 相对于平衡二叉树缩减了节点个数,使每次I/O取到内存的数据都发挥了作用,从而提高了查询效率</p><p>B+Tree是在B-Tree的基础上的一种优化,使其更适合实现外存储索引结构,Innodb存储引擎就是用B+Tree实现其索引结构</p><p>在B-Tree中,每个节点中有key,也有data,而每一个页的存储空间有限,如果data数据较大时会导致每个节点(即一个页)能存储的的key数量很小</p><p>在B+Tree中,所有数据记录节点都是按照键值大小顺序存放在同一层的叶子结点上,</p><p>而非叶子结点上只存储key值信息,这样可以大大加大每个节点存储的key值数量,降低B+Tree的高度</p><p>B+Tree和B-Tree的区别</p><p>​    1.数据是存在叶子节点上中的</p><p>​    2.数据节点间是有指针指向的</p><p><img src="/2020/05/13/mysql底层知识/微信截图_20200513155027.png" alt="微信截图_20200513155027"></p><h5 id="Myisam中的B-Tree"><a href="#Myisam中的B-Tree" class="headerlink" title="Myisam中的B+Tree"></a>Myisam中的B+Tree</h5><p>Myisam引擎也是采用的B+Tree结构作为索引结构</p><p>由于Myisam中的索引和数据存放在不同的文件,所以在索引树中的叶子结点中存的数据是该索引对应的数据记录的地址,由于数据和索引不在一起,所以Myisam是非聚簇索引</p><p>(叶子结点存放对应数据的物理地址)</p><p>#####Innoodb中的B+Tree</p><p>Innodb是以ID为索引的数据存储</p><p>采用Innodb引擎的数据存储文件有两个,一个定义文件,一个数据文件</p><p>Innodb通过B+Tree结构对ID建索引,然后通过叶子结点中存储记录</p><p>若建索引的字段不是主键ID,则对该字段建索引,然后在叶子节点中存存的是该记录的主键,然后通过主键索引找到对应记录</p><p>#####Mysql的相关优化</p><h6 id="1-Mysql性能优化-组成-表的设计"><a href="#1-Mysql性能优化-组成-表的设计" class="headerlink" title="1.Mysql性能优化:组成,表的设计"></a>1.Mysql性能优化:组成,表的设计</h6><p>​    ①开启查询缓存.避免某些sql函数直接在sql语句中使用,从而导致Mysql缓存失效</p><p>​    ②目的是什么就取什么,能查一条判断的就不要全取</p><p>​    ③建合适的索引,所以要建在合适的地方,合适的对象上,经常操作/比较/判断的字段应该建索引</p><p>​    ④字段大小要适宜.字段的取值是有限而且固定的,这种情况下可以使用enum,ip字段介意用unsigned int来存储</p><p>​    ⑤表的设计.垂直分割表,使得固定表与边长表分割,从而降低表的复杂度和字段的数目</p><h6 id="2-SQL语句优化-避免全表扫描"><a href="#2-SQL语句优化-避免全表扫描" class="headerlink" title="2.SQL语句优化:避免全表扫描"></a>2.SQL语句优化:避免全表扫描</h6><p>​    1.建索引  一般在where及order by中涉及到的列上建索引,尽量不要对可以重复的字段建索引.</p><p>​    2.尽量避免在where中使用!或or也不要进行null值判断</p><p>​    3.尽量避免在where中对字段进行函数操作、表达式操作</p><p>​    4.尽量避免使用llike %，在这种情况下可以进行全文检索</p><h5 id="Mysql基准测试"><a href="#Mysql基准测试" class="headerlink" title="Mysql基准测试"></a>Mysql基准测试</h5><p>原因:基准测试可以观察系统在不同压力下的行为,评估系统的容量,掌握哪些是重要的变化,或者观察系统如何处理不同的数据</p><p>######基准测试的策略:</p><p>​    针对整个系统的测试(集成式full-stack)</p><p>​    单独测试Mysql(单组件式single-component)</p><h6 id="测试的指标"><a href="#测试的指标" class="headerlink" title="测试的指标"></a>测试的指标</h6><p>​    1.吞吐量,指单位时间内的事务处理数,常用的测试单位是每秒事务级(TPS),或每分钟事务数(TPM)</p><p>​    2.响应时间或者延迟,用于测试任务所需的整体时间,根据具体的应用,测试的时间单位可能是微秒毫秒秒或者分钟.通常使用百分比响应时间来代替最大响应时间</p><p>​    3.并发性,需要关注的是正在工作中的并发操作,或者是同时工作中的线程数或者连接数.在测试期间记录Mysql数据库的Threads_running状态值</p><p>​    4.可扩展性,给系统增加一倍的工作,在理想状态下就能获得两倍的效果(即吞吐量增加一倍),对于容量规范非常有用,可以提供其他测试无法提供的信息</p><h6 id="基准测试方法"><a href="#基准测试方法" class="headerlink" title="基准测试方法"></a>基准测试方法</h6><p>1.需要避免的一些常见错误:</p><p>​    使用真实数据的子集而不是全集</p><p>​    使用错误的数据分布</p><p>​    使用不真实的分布参数</p><p>​    在多用户的场景中,只做单用户测试</p><p>​    在单服务器上测试分布式应用</p><p>​    与真实用户行为不匹配</p><p>​    反复执行同一个查询</p><p>​    没有检查错误</p><p>​    忽略了系统预热(warm up)过程</p><p>​    使用默认的服务器配置</p><p>​    测试时间太短</p><p>2,应该建立将参数和结果文档化的规范,每一轮测试都必须进行详细记录</p><p>3.基准测试应该运行足够长的时间,需要在稳定状态下测试并观察</p><p>4.在执行基准测试时.需要尽可能多地收集被测试系统的信息</p><p>5.自动化基准测试可以防止测试人员偶尔遗漏某些步骤,或者误操作,宁外也有助于归档整个测试过程</p><h6 id="剖析mysql查询"><a href="#剖析mysql查询" class="headerlink" title="剖析mysql查询"></a>剖析mysql查询</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.剖析服务器负载</span><br><span class="line">·慢查询日志  long_query_time为0可以捕获所有的查询,查询的响应时间单位可以做到微秒级</span><br><span class="line">·生成剖析报告  pt-query-digest</span><br><span class="line">2.剖析单条查询</span><br><span class="line">show profiles</span><br><span class="line">show global status</span><br></pre></td></tr></table></figure><h6 id="诊断间歇性问题"><a href="#诊断间歇性问题" class="headerlink" title="诊断间歇性问题"></a>诊断间歇性问题</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.尽量不要用试错的方式来解决问题,如果一时无法定位,可能是测量的方式不准确,或者测量的点选择有误,或者使用的工具不合适</span><br><span class="line">2.确定单条查询问题还是服务器问题</span><br><span class="line">show global  status</span><br><span class="line">show processlist</span><br><span class="line">使用查询日志</span><br><span class="line">理解发现的问题,使用gnuplot或R,或其他绘图工具将结果绘制成图形</span><br><span class="line">3.捕获诊断数据</span><br><span class="line">诊断触发器:在问题出现时能够捕获数据的基础,有两个常见问题可能导致无法达到预期的结果:误报或者漏检</span><br><span class="line">收集数据:尽可能收集所有能收集的数据,但只在需要的时间段内收集,oprofile,strace,tcpdump,pt-collect,pt-stalk</span><br><span class="line">解释结果数据:pt-mysql-summary输出结果打包....</span><br></pre></td></tr></table></figure><p>Schema与数据类型优化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">schema就是数据库对象的集合，所谓的数据库对象也就是常说的表，索引，视图，存储过程等。</span><br><span class="line">在schema之上的，就是数据库的实例，也就是通常create databases获得的东西</span><br><span class="line">选择优化的数据类型</span><br><span class="line">1.数据类型的选择原则</span><br><span class="line">更小的通常更好</span><br><span class="line">简单就好</span><br><span class="line">尽量避免null</span><br><span class="line">2.应该尽量只在对小数进行精确计算时才使用decimal,使用int类型通过程序控制单位效果更好</span><br><span class="line">3.使用varchar合适的情况,字符串列的最大长度比平均长度大很多;列的更新很少</span><br><span class="line">4.char适合存储很短的字符串,或者所有值都接近同一个长度,不容易产生碎片,在存储空间上更有效率</span><br><span class="line">5.通常应该尽量使用timestamp,它比datetime空间效率更高</span><br></pre></td></tr></table></figure><h6 id="加快alter-table操作的速度"><a href="#加快alter-table操作的速度" class="headerlink" title="加快alter table操作的速度"></a>加快alter table操作的速度</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.在一台不提供服务的机器上执行alter  table操作,然后和提供服务的主库进行切换</span><br><span class="line">2.通过影子拷贝,创建一张新表,然后通过重命名和删表操作交换两张表及里面的数据</span><br></pre></td></tr></table></figure><p>快速创建Myisam索引,先禁用索引,导入数据,然后重新启用索引</p><h6 id="创建高性能的索引"><a href="#创建高性能的索引" class="headerlink" title="创建高性能的索引"></a>创建高性能的索引</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">一.索引基础</span><br><span class="line">1.索引可以包含一个或多个列的值,如果索引包含多个列,那么列的顺序也十分重要,因为mysql只能高效地使用索引的最左前缀列</span><br><span class="line">2.orm工具能够产生符合逻辑,合法的查询,除非只是生成非常基本的语句,否则很难生成适合索引的查询</span><br><span class="line">3.在mysql中,索引是在存储引擎层而不是服务器层实现的,所以,并没有统一的索引标准;不同存储引擎的索引的工作方式并不一样,也不是所有的存储引擎都支持所有类型的索引</span><br><span class="line">4.B-Tree意味着所有的值都是按顺序存储的,并且每一个叶子页到根的距离相同,能够加快访问数据的速度,从索引的根节点开始搜索,适用于全键值\键值范围或键前缀查找</span><br><span class="line">5.B-Tree索引的限制:</span><br><span class="line">如果不是按照索引的最左列开始查找,则无法使用索引</span><br><span class="line">不能跳过索引中的列</span><br><span class="line">如果查询中有某个列的范围查询,则其右边所有列都无法使用索引优化查找</span><br><span class="line">6.哈希索引基于哈希表实现,只有精确匹配索引所有列的查询才会有效,只有memory引擎支持哈希索引</span><br><span class="line">7.哈希索引的限制:</span><br><span class="line">哈希索引只包含哈希值和行指针,而不存储字段值,所以不能使用索引中的值来避免读取行</span><br><span class="line">哈希索引数据并不是按照索引值顺序存储的,所以也就无法用于排序</span><br><span class="line">哈希索引也不支持部分索引列匹配查找,因为哈希索引始终是使用索引列的全部内容来计算哈希值的</span><br><span class="line">只支持等值比较查询,不支持任何范围查询</span><br><span class="line">访问哈希索引的数据非常快,除非有很多哈希冲突</span><br><span class="line">如果哈希冲突很多的话,一般索引维护的代价也会很高</span><br><span class="line">8.空间数据索引(r-Tree),myisam支持空间索引,可以使用地理数据存储</span><br><span class="line">9.全文索引,试用与Match against操作,而不是普通的where条件操作</span><br><span class="line">二.索引的优点</span><br><span class="line">1.三个优点</span><br><span class="line">①索引大大减少了服务器需要扫描的数据量</span><br><span class="line">②索引可以帮助服务器避免排序和临时表</span><br><span class="line">③索引可以将随机I/O变成顺序I/O</span><br><span class="line">2.索引三星系统:</span><br><span class="line">①索引将相关的记录放到一起则获得一星</span><br><span class="line">②如果索引中的数据顺序和查找中的排序一致则获得二星</span><br><span class="line">③如果索引中的列包含了查询中需要的全部列则获得三星</span><br><span class="line">三.高性能的索引策略</span><br><span class="line">1.独立的列:如果查询中的列不是独立的,则MYSQL不会使用索引.独立的列是指索引列,不能是表达式的一部分,也不能是函数的参数</span><br><span class="line">2前缀索引和索引选择性</span><br><span class="line">①通常可以索引开始的部分字符,可以大大节约索引空间,但也会降低索引的选择性</span><br><span class="line">②索引的选择性是指,不重复的索引值和数据表的记录总数的比值.选择性越高则查询效率越高,因为选择性高的索引可以让mysql在查找到时候过滤掉很多的行</span><br><span class="line">③mysql无法使用最左前缀索引做order by 和group by,也无法做覆盖扫描</span><br><span class="line">3.选择合适的索引列顺序</span><br><span class="line">①正确的索引列顺序依赖于使用该索引的查询,并且同时需要考虑如何更好地满足排序和分组的需要</span><br><span class="line">②在一个多列B-Tree索引中,索引列的顺序意味着索引首先按照最左列进行排序,其次是第二列</span><br><span class="line">③将选择性最高的列放到索引最前列</span><br><span class="line">4.聚簇索引:并不是一种单独的索引类型,而是一种数据存储方式</span><br><span class="line">(最好避免随机的聚簇索引,特别是对于I/O密集型的应用)</span><br><span class="line">5.覆盖索引:如果一个索引包含所有要查询的字段的值,称为覆盖索引</span><br><span class="line">覆盖索引必须要存储索引列的值</span><br><span class="line">6.压缩(前缀)索引,默认值压缩字符串,减少索引的大小,对于cpu密集型应用没因为扫描需要随机查找,压缩索引在myisam上要慢好几倍</span><br><span class="line">7.重复索引是指在相同的列上按照相同的熟悉顺序创建的相同类型的索引,应该尽量避免这样重复的创建索引</span><br><span class="line">8.索引可以让查询锁定更少的行</span><br><span class="line">四.维护索引和表</span><br><span class="line">1.check table 表名 检查表是否损坏</span><br><span class="line">2.altet table 表名 engine = Innodb  修复表</span><br><span class="line">3.show index from 表名  查看索引的基数</span><br><span class="line">4.b-tree可能会碎片化,降低查询的效率</span><br></pre></td></tr></table></figure><h6 id="五-查询性能优化"><a href="#五-查询性能优化" class="headerlink" title="五.查询性能优化"></a>五.查询性能优化</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">1.为什么查询速度会变慢</span><br><span class="line">①如果要优化查询,实际上要优化其子任务,要么消除其中一些子任务,要么减少子任务的执行次数,要么让子任务运行的更快</span><br><span class="line">    ②查询的生命周期大致可以按照顺序来看:从客户端,到服务器,然后在服务器上进行解析,生成执行计划,执行,并将结果返回给客户端</span><br><span class="line">2.慢查询基础:优化数据访问</span><br><span class="line">1.两个分析步骤:</span><br><span class="line">    ①确认应用程序是否检索大量超过需要的数据</span><br><span class="line">②确认Mysql服务器层是否在分析大量超过需要的数据行</span><br><span class="line">2.是否向数据库请求了不需要的数据</span><br><span class="line">①查询了不需要的数据</span><br><span class="line">②多表关联并返回全部列</span><br><span class="line">③总是取出全部列</span><br><span class="line">④重复查询相同的数据</span><br><span class="line">3.mysql是否在扫描额外的记录</span><br><span class="line">1.查询开销三个指标:响应时间,扫描行数,返回的行数</span><br><span class="line">             ②响应时间:服务时间和排队时间之和</span><br><span class="line">             ③扫描的行数:较短的行的访问速度更快,内存中的行也比磁盘中的行的访问速度要快的多</span><br><span class="line">             ④访问的类型:explain中的type列反应了访问类型,通过增加合适的索引.</span><br><span class="line">2.三种方式应用where条件,在索引中使用where条件来过滤不匹配的记录;使用索引覆盖扫描来返回记录,直接从索引中过滤不需要的记录并返回命中结果;从数据表中返回数据,然后过滤不满足条件的记录</span><br><span class="line">3.需要扫描大量数据但只返回少数行的优化技巧:使用索引覆盖扫描,改变库表结构,重写复杂的查询</span><br><span class="line">3.重构查询的方式</span><br><span class="line">①Mysql从设计上让连接和断开连接都很轻量级,再返回一个小的查询结果方面很高效</span><br><span class="line">②切分查询,将大查询切分成小查询.每个查询功能完全一样,只完成一小部分,每次只返回一小部分查询结果,可以避免锁住很多数据,占满事务日志,耗尽系统资源,阻塞很多小的但重要的查询</span><br><span class="line">③分解关联查询优势:</span><br><span class="line">1.让缓存的效率更高</span><br><span class="line">2.将查询分解后,执行单个查询可以减小锁的竞争</span><br><span class="line">3.在应用层做关联,可以更容易对数据库进行拆分,更容易做到高性能和可扩展</span><br><span class="line">4.查询效率本身效率也可能会有所提升</span><br><span class="line">5.可以减少冗余记录的查询</span><br><span class="line">6.相当于在应用中实现了哈希关联,而不是使用Mysql的嵌套循环关联</span><br><span class="line">④分解关联查询的场景</span><br><span class="line">1.当应用能够方便的缓存单个查询的结果的时候</span><br><span class="line">2.当可以将数据分布到不同的MYSQL服务器上的时候</span><br><span class="line">3.当能够使用IN()的方式代替关联查询的时候</span><br><span class="line">4.当查询中使用同一个数据表的时候</span><br><span class="line">4.查询执行的基础</span><br><span class="line">①查询执行的路径</span><br><span class="line">客户端发送一条查询给服务器</span><br><span class="line">服务器先检查查询缓存,如果命中则立刻返回,否则进入下一阶段</span><br><span class="line">服务器端进行sql解析,预处理,再由优化器生成对应的执行计划</span><br><span class="line">mysql根据优化器生成的执行计划,调用存储引擎的api来执行查询</span><br><span class="line">将结果返回给客户端</span><br><span class="line">②Mysql客户端和服务器之间的通信协议是半双工的,无法将一个消息切成小块独立来发送,没法进行流量控制,一旦一端开始发生消息,宁一端要接受完整个消息才能响应它</span><br><span class="line">③mysql通常需要等所有的数据都已经发送给客户端才能释放这条查询所占用的资源,所以接收全部结果并缓存通常可以减少服务器的压力</span><br><span class="line">④语法解析器和预处理,通过关键字将sql语句进行解析,并生成一颗对应解析树,解析器将使用MYSQL语法规则验证和解析查询,预处理器则根据一些mysql规则进一步检查树是否合法</span><br><span class="line">⑤查询优化器,找到最好的执行计划,使用基本成本的优化器,将尝试预测一个查询使用某种执行计划时的成本,并选择其中成本最小的一个,使用show status like &apos;last_query_cost&apos;;查看需要多少个数据页的随机查找</span><br><span class="line">⑥导致查询优化器选择错误的原因</span><br><span class="line">1.统计信息不准确,Innodb不能维护一个数据表的行数的精准统计信息</span><br><span class="line">2.执行计划中的成本估算不等同于实际执行的成本</span><br><span class="line">3.Mysql的最优跟你想的最优可能不太一样</span><br><span class="line">4.mysql从不考虑其他并发执行的语句</span><br><span class="line">5.MYSQL也并不任何时候都是基于成本的优化</span><br><span class="line">6.Mysql不会考虑不受控制的操作的成本</span><br><span class="line">7.优化器有时候无法去估算所有可能的执行计划</span><br><span class="line">⑦mysql能处理的优化类型</span><br><span class="line">1.重新定义关联表的顺序</span><br><span class="line">2.将外链接转换为内链接</span><br><span class="line">3.使用等价变换规则</span><br><span class="line">4.优化count(),min(),max(),在explain可以看到&apos;select tables optimized away&apos;</span><br><span class="line">5.预估并转化为常数表达式,当检测到一个表达式可以转换为常数的时候,就会一直把该表达式作为常数进行优化处理</span><br><span class="line">6.覆盖索引操作,当索引中的列包含所有查询中需要使用的列的时候,就可以使用索引返回需要的数据,而无需查询对应的数据行</span><br><span class="line">7.子查询优化</span><br><span class="line">8.提前终止查询,在发现已经满足查询需求的时候,在发现已经满足查询需求的时候,Mysql总是能够立刻终止查询</span><br><span class="line">9.等值传播,如果两个列的值通过等式关联,那么mysql能够把其中一个列的where条件传递到宁一个列上</span><br><span class="line">10.列表in()的比较,mysql将in()列表中的数据先进行排序,然后通过二分查找的方式来确定列表中的值是否满足条件</span><br><span class="line">⑧对于union查询,mysql先将一系列的单个查询结果放到一个临时表中,然后再重新读出临时表数据来完成union查询</span><br><span class="line">⑨无论如何排序都是一个成本很高的操作,所以从性能角度考虑,应尽可能避免排序或者尽可能避免对大量数据进行排序</span><br><span class="line">⑩当不能使用索引生成排序结果的时候,MYSQL需要自己进行排序,如果数据量小则在内存中进行,如果数据量大则需要使用磁盘,Mysql将这个过程称为文件排序,及时完全是内部排序不需要任何磁盘文件也是如此.</span><br></pre></td></tr></table></figure><h6 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">一.Mysql查询优化器的局限性</span><br><span class="line"><span class="number">1.</span>关联子查询:Mysql的子查询实现起来非常糟糕,最糟糕的一类查询是where条件中包含<span class="keyword">in</span>()的子查询语句.使用group_concat()在<span class="keyword">in</span>()中构造一个由逗号分隔的列表,或者使用exists()来改写</span><br><span class="line">     <span class="number">2.</span>union的限制,有时,Mysql无法将限制条件从外层下推到内层,这使得原本能够限制部分返回结果的条件无法应用到内层查询的优化上</span><br><span class="line">    <span class="number">3.</span>Mysql不支持哈希关联,mariadb已经实现了哈希关联</span><br><span class="line">    <span class="number">4.</span>MYSQl无法利用多核来进行并行查询</span><br><span class="line">    <span class="number">5.</span>Mysql不支持松散索引扫描,<span class="number">5.0</span>后的版本在分组查询中需要找到分组的最大值和最小值时可以使用松散索引扫描</span><br><span class="line">    <span class="number">6.</span>对于min和max.mysql优化的并不好</span><br><span class="line">二.优化特定类型的查询</span><br><span class="line"><span class="number">1.</span>优化count()查询</span><br><span class="line">    ·count()是一个特殊的函数,有两种非常不同的作用:可以统计某个列值的数量,也可以统计行数,在统计列值时要求列值是非空的(不统计null)</span><br><span class="line">   ·count(*)并不是会像我们猜想的那样扩展成所有的列,实际上,它会忽略所有的列而直接统计所有的行数,当mysql确认括号内的表达式不可能为空时,实际上就是在统计行数</span><br><span class="line">    Myisam的count函数只有没有任何where条件下的count(*)才非常快</span><br><span class="line">    使用近似值,如explain出来的优化器估算行数</span><br><span class="line">    使用索引覆盖</span><br><span class="line">    使用汇总表</span><br><span class="line">    使用外部缓存系统</span><br><span class="line"><span class="number">2.</span>优化关联查询</span><br><span class="line">确保on或者using子句的列上有索引</span><br><span class="line">    确保任何的groupby和order by中的表达式只涉及到一个表中的实例</span><br><span class="line">    当升级mysql的时候需要注意:关联语法,运算符优先级等其他可能会发生变化的地方</span><br><span class="line">    <span class="number">3.</span>优化子查询,尽可能使用关联查询代替</span><br><span class="line"><span class="number">4.</span>优化GROUP BY和DISTINCT</span><br><span class="line">使用索引优化</span><br><span class="line">当无法使用索引时，GROUP BY使用两种策略来完成：使用临时表或者文件排序来做分组</span><br><span class="line">尽可能的将WITH ROLLUP（超级聚合）功能移动应用程序中处理</span><br><span class="line"><span class="number">5.</span>优化LIMIT分页</span><br><span class="line">最简单的办法是尽可能地使用索引覆盖扫描，而不是查询所有的列，然后根据需要做一次关联操作再返回所需的列，select id,name,…… <span class="keyword">from</span> table innert join (select id <span class="keyword">from</span> table order by xxx limit <span class="number">5000</span>,<span class="number">5</span>) <span class="keyword">as</span> table1 USING(id);</span><br><span class="line">offset会导致MySQL扫描大量不需要的行然后再抛弃掉，如果可以记录上次取数据的位置，下次就可以直接从该记录的位置开始扫描，可以避免使用offset</span><br><span class="line">使用预先计算的汇总表，或者关联到一个冗余表</span><br><span class="line"><span class="number">6.</span>优化UNION查询</span><br><span class="line">    通过创建并填充临时表的方式来执行UNION查询，因此很多优化策略在UNION查询中都没法很好地使用，经常需要手工地将WHERE、LIMIT、ORDER BY等子句下推到UNION的各个子查询中</span><br><span class="line">    除非确实需要服务器消除重复的行，否则就一定要使用UNION ALL</span><br></pre></td></tr></table></figure><p>######Mysql高级特性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">一.分区表</span><br><span class="line">1.对用户来说分区表是一个独立的逻辑表,但是底层由多个物理子表组成,实际上是对一组底层表的句柄对象的的封装</span><br><span class="line">2.使用场景:</span><br><span class="line">·表非常大以至于无法全部都放在内存中,或者只在表的最后部分有热点数据,其他均是历史数据</span><br><span class="line">·分区表的数据更容易维护</span><br><span class="line">·分区表的数据可以分布在不同的物理设备上,从而高效的利用多个硬件设备</span><br><span class="line">·可以使用分区表来避免某些特殊的瓶颈</span><br><span class="line">·如果需要,还可以备份和恢复独立的区</span><br><span class="line">3.使用限制</span><br><span class="line">·一个表最多只能有1024个区</span><br><span class="line">·在Mysql5.1中,分区表达式必须是整数,或者返回证书的表达式.在mysql5.5中,某些场景中可以直接使用列来进行分区</span><br><span class="line">·如果分区字段中有主键或者唯一索引的列,那么所有主键列和唯一索引列都必须包含进来</span><br><span class="line">·分区表无法使用外键约束</span><br><span class="line">4.使用分区表</span><br><span class="line">当数据量超大的时候,B-Tree索引就无法起作用了,除非是覆盖索引查询,否则数据库服务器需要根据索引扫描返回的结果,查询所有符合条件的记录,如果数据量巨大,将产生大量随机I/O</span><br><span class="line">5.保证大数据量的可扩展性的策略</span><br><span class="line">·命题扫描数据,无需使用任何索引</span><br><span class="line">·索引数据并分离热点</span><br><span class="line">6.分区策略的问题</span><br><span class="line">·NULL值会使分区过滤无效</span><br><span class="line">·分区列和索引列不匹配</span><br><span class="line">·选择分区的成本可能会很高</span><br><span class="line">·打开并锁住所有底层表的成本可能很高</span><br><span class="line">·维护分区的成本可能很高</span><br><span class="line">·所有分区都必须使用相同的引擎存储</span><br><span class="line">·分区函数中可以使用的函数和表达式也有一些限制</span><br><span class="line">·某些引擎不支持分区</span><br><span class="line">·对于Myisam的分区表,不能再使用load  index  into cache操作</span><br><span class="line">·对于Myisam表,使用分区表时需要打开更多的文件描述符</span><br><span class="line">7.查询优化</span><br><span class="line">很重要的一点是要在where条件中带入分区列</span><br><span class="line">只能在使用分区函数的列本身进行比较时才考虑分区,而不能根据表达式的值去过滤分区,及时这个表达式是分区函数也不行</span><br><span class="line"></span><br><span class="line">二.视图</span><br><span class="line">1.视图本身是一个虚拟表,不存放任何数据,返回的数据是从mysql从其他表生成的</span><br><span class="line">2.Mysql使用两种算法:合并算法和临时表算法,会尽可能的使用合并算法</span><br><span class="line">3.如果视图中包含groupby\distinct\任何聚合函数\union\子查询等.只要无法在原表记录和试图记录中建立一一映射的场景中,Mysql都将使用临时表算法来实现视图</span><br><span class="line">4.可更新视图是指可以任何通过更新这个视图来更新视图涉及的相关表,check option表示任何通过视图更新的行,都必须符合视图本身的where条件定义</span><br><span class="line">5.在重构schema的时候可以使用视图,使得在修改底层表结构的时候,应用代码还可能继续不报错的运行</span><br><span class="line">6.mysql中不支持物化视图(指将视图结果数据存放在一个可以查看的表中,并定期从原始表中刷新到这个表中)</span><br><span class="line">7.不会保存视图定义的原始SQL语句</span><br><span class="line"></span><br><span class="line">三.外键约束</span><br><span class="line">1.使用外键是有成本的,通常要求每次在修改数据时都要在宁外一张表中多执行一次查找操作</span><br><span class="line">2.如果想确保两个关键表始终有一致的数据,那么使用外键比在应用程序中检查一致性的性能要高得多,在相关数据的删除和更新上,比在应用中维护更高效</span><br><span class="line">3.外键会带来很大的额外消耗</span><br><span class="line"></span><br><span class="line">四.在Mysql内部存储代码</span><br><span class="line">1.mysql允许通过触发器,存储过程,函数的形式来存储代码,从5.1开始还可以在定时任务中存放代码,这个定时任务称为时间.存储过程和存储函数都被统称为存储程序</span><br><span class="line">2.存储代码的优点:</span><br><span class="line">·他在服务器内部执行,离数据最近,宁外在服务器上执行还可以节省带宽和网络延迟</span><br><span class="line">·它是一种代码复用,可以方便统一业务规则,保证某些行为总是一致的,所以也可以为应用提供一定的安全性</span><br><span class="line">·它可以简化代码的维护和版本更新</span><br><span class="line">·可以帮助提升安全,比如提供细粒度的权限控制</span><br><span class="line">·服务器端可以缓存存储过程的执行计划,这对于需要反复调用的过程,会大大降低消耗</span><br><span class="line">·因为是在服务器端部署的,所以可以备份,维护都可以在服务器端完成</span><br><span class="line">·可以在应用开发和数据库开发人员之间更好地分工</span><br><span class="line">3.存储代码的缺点</span><br><span class="line">·Mysql本身没有提供好用的开发和调试工具</span><br><span class="line">·较之应用程序的代码,存储代码效率稍微差点</span><br><span class="line">·存储代码可能会给应用程序代码的部署带来额外的复杂性</span><br><span class="line">因为存储程序都部署在服务器内,所以可能有安全隐患</span><br><span class="line">存储过程会给数据库服务器增加额外的压力,而数据库服务器的扩展性相比应用服务器要差很多</span><br><span class="line">mysql并没有选项可以控制存储程序的资源消耗,所以在存储过程的一个小错误,可能会直接把服务器拖死</span><br><span class="line">存储代码在mysql中的实现也有很多的限制--执行计划缓存是连接级别的,游标的物化和临时表相同,异常处理也非常困难</span><br><span class="line">调试mysql的存储过程是一件非常困难的事情</span><br><span class="line">他和基于语句的二进投影日志复制合作的并不好</span><br><span class="line">4.存储过程好而寒暑限制</span><br><span class="line">·优化器无法使用关键字DETERMINISTIC来优化单个查询中多次调用存储函数的情况</span><br><span class="line">·优化器无法评估存储函数的执行成本</span><br><span class="line">·每个连接都有独立的存储过程的执行计划缓存</span><br><span class="line">·存储过程和复制是一种诡异的组合</span><br><span class="line">5.触发器:可以让你在执行insert\update\delete的时候,执行一些特定的操作,可以在mysql中指定是在授权率语句执行前触发还是执行后触发,可以使用触发器实现一些强制限制,或者某些业务逻辑,否则就需要在应用程序中实现逻辑</span><br><span class="line">6.触发器的注意和限制:</span><br><span class="line">·对于每一个表的每一个事件,最多只能定义一个触发器</span><br><span class="line">·只支持基于行的触发,也就是说,触发器是针对一条记录的,而不是针对整个授权率语句的,如果变更的数据集非常大,效率会很低</span><br><span class="line">·触发器可以掩盖服务器背后的工作</span><br><span class="line">·触发器可以掩盖服务器背后的工作,一个简单的sql语句背后可能包含了许多看不见的工作</span><br><span class="line">·触发器的问题很难排查,如果某个性能问题和触发器相关,会很难分析和定位</span><br><span class="line">·触发器可能会导致死锁和锁等待</span><br><span class="line">·触发器并不能保证更新的原子性</span><br><span class="line">7.触发器的用处:</span><br><span class="line">·实现一些约束,系统的维护任务,以及更新反范式化数据的时候</span><br><span class="line">·记录数据变更日志</span><br><span class="line">8.事件:类似于linux的定时任务,指定mysql在某个时候执行一段sql代码,或者每隔一个时间间隔执行一段sql代码</span><br><span class="line"></span><br><span class="line">五.全文索引</span><br><span class="line">1.myisam的全文索引作用对象是一个全文集合,这可能是某个数据列的一列,也肯能是多个列</span><br><span class="line">2.可以根据where子句中的match against来区分查询是否使用全文索引</span><br><span class="line">3.在使用全文索引进行排序的时候,Mysql无法在使用索引排序,如果不想使用文件排序的话,就不要在查询中使用order by子句</span><br><span class="line">4.在布尔搜索中,用户可以在查询中自定义某个被搜索的词语的相关性,可以通过一些前缀修饰符来定制搜索</span><br><span class="line">5.全文索引在insert \update\delete 中的操作代价很大</span><br><span class="line">6.全文索引会影响索引选择\where 子句\order by 等</span><br><span class="line"></span><br><span class="line">六.查询缓存</span><br><span class="line">1.MYSQL查询缓存保存查询返回的完整结果,当查询命中该缓存,mysql会立即返回结果,跳过了解析\优化和执行阶段</span><br><span class="line">2.MYSQL判断缓存命中的方法很简单,缓存放在一个引用表中,通过一个哈希值引用,这个哈希值包括了如下因素,即查询本身,当前要查询的数据库,客户端协议的版本等一些其他可能会影响返回结果的信息</span><br><span class="line">3.当判断缓存是否命中时,mysql不会解析\正规化\或者参数化查询语句,而是直接使用sql语句和客户端发送过来的其他原始信息,任何字符上的不同,例如空格,注释--都会导致缓存的不命中</span><br><span class="line">4.当查询语句中有一些不确定的数据时,则不会被缓存,如包含函数now()等</span><br><span class="line">5.打开查询缓存对读和写都会带来额外的消耗</span><br><span class="line">·读查询在开始之前必须检查是否命中缓存</span><br><span class="line">·如果这个读查询可以被缓存,那么当执行完后,MYSQL若发现查询缓存中没有这个查询,会将其结果存入查询缓存,会带来额外的系统消耗</span><br><span class="line">·当想某个表写入数据的时候,mysql必须将对应表的所有缓存都设置失效,如果查询缓存非常大,或者碎片非常多,这个操作就会带来很大系统消耗</span><br><span class="line">6.对于需要消耗大量资源的查询通常是非常适合缓存的</span><br><span class="line">7.缓存未命中</span><br><span class="line">·查询语句无法被缓存</span><br><span class="line">·MYSQL从未处理这个查询</span><br><span class="line">·查询缓存的内存用完了</span><br><span class="line">·查询缓存还没有完成预热</span><br><span class="line">·查询语句之前从未执行过</span><br><span class="line">·缓存失效操作太多了</span><br><span class="line">8.缓存参数配置</span><br><span class="line">query_cache_type,是否打开查询缓存</span><br><span class="line">query_cache_size  查询缓存使用的总内存空间</span><br><span class="line">query_cache_min_res_unit  在查询缓存中分配内存块时的最小单位,可以帮助减少由碎片导致的内存空间浪费</span><br><span class="line">query_cache_limit  mysql能够缓存的最大查询结果</span><br><span class="line">query_cache_wlock_invalidate 如果某个数据表被其他的连接锁住,是否仍然从查询缓存中返回结果</span><br></pre></td></tr></table></figure><h6 id="优化服务器设置"><a href="#优化服务器设置" class="headerlink" title="优化服务器设置"></a>优化服务器设置</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">一.mysql配置的工作原理</span><br><span class="line">1.任何打算长期使用的设置都应该写到全局配置文件,而不是在命令行特别指定</span><br><span class="line">2.常用变量和动态修改它们的效果:</span><br><span class="line">key_buffer_size:可以一次性为键缓冲区分配所指定的空间</span><br><span class="line">table_cache_size:不会立即生效--将在下次有线程打开表才有效果,如果值大于缓存中表的数量,线程可以把最新打开的表放入缓存,如果比缓存中的表小,京葱缓存中删除不长使用的表</span><br><span class="line">thread_cache_size,不会立即生效,将在下次有连接被关闭时产生效果,检查缓存中是否还有空间在缓存线程,如果有空间,则缓存该线程以备下次连接征用,如果没空间,将销毁该线程而非缓存</span><br><span class="line">query_cache_size:一次性分配并初始化这块内存</span><br><span class="line">read_buffer_size:只有在查询需要使用时才会为该缓存分配内存</span><br><span class="line">read_rnd_buffer_size:只有在查询需要使用到时,才会为该查询分配内存,并且只分配需要的内存大小而不是全部指定的大小</span><br><span class="line">sort_buffer_size:只会在也有查询需要排序的时候才会为该缓存分配内存</span><br><span class="line">3.对应连接级别的设置,不要轻易的在全局级别增加他们的值,除非确认这样做是对的</span><br><span class="line">4.设置变量时请小心,并不是值越大越好,而且如果设置的值太高,可能更容易导致问题:可能会由于内存不足导致服务器内存交换,或者超过地址空间</span><br><span class="line">二.什么不该做</span><br><span class="line">1.不要根据比率来调优,例如缓存命中率跟缓存是否过大或者过小无关</span><br><span class="line">2.不要使用调优脚本</span><br><span class="line">3.不要相信很流行的内存消耗公式</span><br><span class="line">三.创建mysql配置文件</span><br><span class="line">1.mysql编译的默认设置并不都是靠谱的,其中大部分比较合适</span><br><span class="line">2.从一个比默认值大一点但不是大的很离谱的安全值开始是比较好的,MYSQL的内存利用率并不总是可以预测的,他可能依赖很多的因素,例如查询的复杂性和并发性</span><br><span class="line">3.配置服务器的首选途径,了解它内部做了什么,以及参数之间如何相互影响,然后再决定</span><br><span class="line">4.open_files_limit 在linux上尽可能设置的大一点,如果参数不够大,可能会报错,打开的文件太多</span><br><span class="line">5.每隔60s查看状态变量的增量变化:mysqladmin extended-status  ri60</span><br><span class="line">四.配置内存使用</span><br><span class="line">1.配置mysql正确使用内存量对高性能至关重要,内存小号分为两类,可以控制的内存和不可以控制的内存</span><br><span class="line">2.配置内存</span><br><span class="line">确定可以使用的内存上限</span><br><span class="line">确定每隔mysql连接需要使用的内存</span><br><span class="line">确定操作系统需要多少内存才够用</span><br><span class="line">吧剩下的内存全部给mysql的缓存</span><br><span class="line">3.mysql保持一个连接只需要少量的内存,他还需要一个基本量的内存来执行任何给定的查询,需要为高峰时期执行的大量查询预留好足够的内存,否则,查询执行可能因为缺乏内存而导致执行效率不佳或执行失败</span><br><span class="line">4.跟查询一样,操作系统也需要保留足够的内存给他工作,如果没有虚拟内存正在交换到磁盘,就是表名操作系统内存足够的最佳迹象</span><br><span class="line">5.如果服务器只运行mysql.所有不需要为操作系统以及查询管理保留的内存都可以用作mysql缓存</span><br><span class="line">6.大部分情况下最重要的缓存:</span><br><span class="line">innodb缓冲池</span><br><span class="line">innodb日志文件和myisam数据的操作系统缓存</span><br><span class="line">myisam键缓存</span><br><span class="line">查询缓存</span><br><span class="line">无法手工配置的缓存,例如二进制日志和表定义文件的操作系统缓存</span><br><span class="line">7.innodb缓冲池并不仅仅缓存索引,他还会缓存行的数据,自适应哈希索引,插入缓冲,锁,以及其他内部数据结构,还使用缓冲池来帮助延迟写入,innodb严重依赖缓冲池</span><br><span class="line">8.如果事先知道什么时候需要关闭innodb,可以在运行时修改innodb_max_dirty_pages_pct变量,将值改小,等待刷新纯种清理缓冲池,然后在脏页数量较小时关闭,可以监控the innodb_buffer_pool_pages_dirty状态变量或者使用innotop来监控show innodb status来观察脏页的刷新量</span><br><span class="line">9.Myisam的键缓存也被称为键缓冲,默认只有一个键缓存,但也可以创建多个,MYISAM自身之缓存索引,不换存数据.最重要的配置项是key_buffer_size,不要超过索引的总大小,或者不超过操作系统的缓存保留总内存的25%-50%,以更小的为准</span><br><span class="line">10.了解MyISAM索引实际上占用多少磁盘空间，查询INFORMATION_SCHEMA表的INDEX_LENGTH字段，把它们的值相加，就可以得到索引存储占用空间</span><br><span class="line">11.thread_cache_size变量指定了MySQL可以保持在缓存中的线程数，一般不需要配置这个值，除非服务器会有很多连接请求</span><br><span class="line">12.可以关闭InnoDB的innodb_stats_on_metadata选项来避免耗时的表统计信息刷新</span><br><span class="line">13.如果可以，最好把innodb_open_files的值设置得足够大以使服务器可以保持所有的.ibd文件同时打开</span><br><span class="line">五.配置mysql并发</span><br><span class="line">1.InnoDB并发配置</span><br><span class="line">     InnoDB有自己的“线程调度器”控制线程怎么进入内核访问数据，以及它们在内核中一次可以做哪些事，最基本的限制并发的方式是使用innodb_thread_concurrency变量，它会限制一次性可以有多少线程进入内核,并发值 = CPU数量 * 磁盘数量 * 2，在实践中使用更小的值会更好一点</span><br><span class="line">2.MyISAM并发配置</span><br><span class="line">尽管MyISAM是表级锁，它依然可以一边读取，一边并发追加新行，这种情况下只能读取到查询开始时的所有数据，新插入的数据是不可见的，这样可以避免不一致读</span><br><span class="line">通过设置concurrent_insert这个变量，可以配置MyISAM打开并发插入</span><br><span class="line">让INSERT、REPLACE、DELETE、UPDATE语句的优先级比SELECT语句更低，设置low_priority_updates选项就可以</span><br><span class="line"></span><br><span class="line">六.基于工作负载的配置</span><br><span class="line">1.当服务器满载情况下运行时，请尝试记录所有的查询语句，因为这是最好的方式来查看哪种类型的查询语句占用资源最多，同时创建processlist快照，通过state或者command字段来聚合它们</span><br><span class="line">2.优化BLOB和TEXT场景</span><br><span class="line">BLOB有几个限制使得服务器对它的处理跟其他类型不一样，不能在内存临时表中存储BLOB值，效率很低</span><br><span class="line">·通过SUBSTRING()函数把值转换为VARCHAR</span><br><span class="line">·让临时表更快一些：放在基于内存的文件系统</span><br><span class="line">·如果使用的是InnoDB，也可以调大InnoDB日志缓冲大小</span><br><span class="line">·大字段在InnoDB里可能浪费大量空间</span><br><span class="line">·扩展存储禁用了自适应哈希，因为需要完整地比较列的整个长度，才能发现是不是正确的数据</span><br><span class="line">·太长的值可能使得查询中作为WHERE条件不能使用索引</span><br><span class="line">·如果一张表里有很多大字段，最好是把它们组合起来单独存到一个列里面</span><br><span class="line">·有时候可以把大字段用COMPRESS()压缩后再存为BLOB，或者发送到MySQL前在应用程序中进行压缩</span><br><span class="line">3.优化排序（Filesorts）：当MySQL必须排序BLOG或TEXT字段时，它只会使用前缀，然后忽略剩下部分的值</span><br><span class="line"></span><br><span class="line">七.完成基本配置</span><br><span class="line">1.tmp_table_size和max_heap_table_size，这两个设置控制使得Memory引擎的内存临时表能使用多大的内存</span><br><span class="line">2.max_connections，这个设置的作用就像一个紧急刹车，以保证服务器不会因应用程序激增的连接而不堪重负，设置得以容纳正常可能达到的负载，并且要足够安全，能保证允许你登录和管理服务器</span><br><span class="line">3.thread_cache_size，可以通过观察服务器一段时间的活动，来计算一个有理有据的值，250的上限是一个不错的估算值</span><br><span class="line">4.table_cache_size，应该被设置得足够大，以避免总是需要重新打开和重新解析表的定义，可能通过观察Open_tables的值及其在一段时间的变化来检查该变量</span><br><span class="line">八.安全和稳定的设置</span><br><span class="line">1.expire_logs_days，如果启用了二进制日志，应该打开这个选项，可以让服务器在指定的天数之后清理旧的二进制日志</span><br><span class="line">2.max_allowed_packet，防止服务器发送太大的包，也会控制多大的包可以被接收</span><br><span class="line">3.max_connect_errors，如果知道服务器可以充分抵御蛮力攻击，可以把这个值设得非常大，以有效地禁用主机黑名单</span><br><span class="line">4.skip_name_resolve，禁用了另一个网络相关和鉴权谁相关的陷阱：DNS查找</span><br><span class="line">5.sql_mode，不建议修改</span><br><span class="line">6.sysdate_is_now，可能导致与应用预期向后不兼容的选项</span><br><span class="line">7.read_only，禁止没有特权的用户在备库做变更，只接受从主库传输过来的变更，不接受从应用来的变更，可以把备库设置为只读模式</span><br><span class="line">8.skip_slave_start，阻止MySQL试图自动启动复制</span><br><span class="line">9.slave_net_timeout，控制备库发现跟主库的连接已经失败并且需要重连之前等待的时间，设置为一分钟或更短</span><br><span class="line">10.sync_master_info、sync_relay_log、sync_relay_log_info，5.5以后版本可用，解决了复制中备库长期存在的问题：不把它们的状态文件同步到磁盘，所以服务器崩溃后可能需要人来猜测复制的位置实际上在主库是哪个位置，并且可能在中继日志（Relay Log）里有损坏</span><br><span class="line"></span><br><span class="line">八.高级InnoDB设置</span><br><span class="line">1.innodb，如果设置为FORCE，只有在InnoDB可以启动时，服务器才会启动</span><br><span class="line">2.innodb_autoinc_lock_mode，控制InnoDB如何生成自增主键值</span><br><span class="line">3.innodb_buffer_pool_instances，在5.5以后，可以把缓冲池切分为多段，在高负载的多核机器上提升MySQL可扩展性的一个重要方式</span><br><span class="line">4.innodb_io_capacity，有时需要把这个设置得相当高，才能稳定地刷新脏页</span><br><span class="line">5.innodb_read_io_threads和innodb_write_io_threads，控制有多少后台线程可以被I/O操作使用</span><br><span class="line">6.innodb_strict_mode，让MySQL在某些条件下把警告改成抛错，尤其是无效的或者可能有风险的CREATE TABLE选项</span><br><span class="line">7.innodb_old_blocks_time，指定一个页面从LRU链表的“年轻”部分转移到“年老”部分之前必须经过的毫秒数，默认为0，设置为1000毫秒（1秒）非常有效</span><br><span class="line"></span><br><span class="line">九、操作系统和硬件优化</span><br><span class="line">A.什么限制了MySQL的性能</span><br><span class="line">1.当数据可以放在内存中或者可以从磁盘中以足够快的速度读取时，CPU可能出现瓶颈，把大量的数据集完全放到大容量的内存中，以现在的硬件条件完全是可行的</span><br><span class="line">2.I/O瓶颈，一般发生在工作所需的数据远远超过有效内存容量的时候，如果应用程序是分布在网络上的，或者如果有大量的查询和低延迟的要求，瓶颈可能转移到网络上</span><br><span class="line">B.如何为MySQL选择CPU</span><br><span class="line">1.可以通过检查CPU利用率来判断是否是CPU密集型的工作负载，还需要看看CPU使用率和大多数重要的查询的I/O之间的平衡，并注意CPU负载是否分配均匀</span><br><span class="line">2.当遇到CPU密集型的工作时，MySQL通常可以从更快的CPU中获益，但还依赖于负载情况和CPU数量</span><br><span class="line">3.MySQL复制也能在高速CPU下工作得非常好，而多CPU对复制的帮助却不大</span><br><span class="line">4.多CPU在联机事务处理（OLTP）系统的场景中非常有用，在这样的环境中，并发可能成为瓶颈</span><br><span class="line">C.平衡内存和磁盘资源</span><br><span class="line">1.配置大量内存最终目的是避免磁盘I/O，最关键的是平衡磁盘的大小、速度、成本和其他因素，以便为工作负载提供高性能的表现</span><br><span class="line">2.设计良好的数据库缓存（如InnoDB缓冲池），其效率通常超过操作系统的缓存，因为操作系统缓存是为通用任务设计的</span><br><span class="line">3.数据库服务器同时使用顺序和随机I/O，随机I/O从缓存从受益最多</span><br><span class="line">4.每个应用程序都有一个数据的“工作集”——就是这个工作确实需要用到的数据</span><br><span class="line">5.工作集包括数据和索引，所以应该采用缓存单位来计数，一个缓存单位是存储引擎工作的数据最小单位</span><br><span class="line">6.找到一个良好的内存/磁盘比例最好的方式是通过试验和基准测试</span><br><span class="line">7.硬盘选择考虑因素：存储容量、传输速度、访问时间、主轴转速、物理尺寸</span><br><span class="line">8.MySQL如何扩展到多个磁盘上取决于存储引擎和工作负载，InnoDB能很好地扩展到多个硬盘驱动器，然而，MyISAM的表锁限制其写的可扩展性，因此写繁重的工作加在MyISAM上，可能无法从多个驱动器中收益</span><br><span class="line">D.固态存储</span><br><span class="line">1.高质量闪存设备具备：</span><br><span class="line">相比硬盘有更好的随机读写性能</span><br><span class="line">相比硬盘有更好的顺序读写性能</span><br><span class="line">相比硬盘能更好地支持并发</span><br><span class="line">提升随机I/O和并发性</span><br><span class="line">2.闪存的最重要特征是可以迅速完成多次小单位读取，但是写入更有挑战性。闪存不能在没有做擦除操作前改写一个单元（Cell），并且一次必须擦除一个大块。擦除周期是缓慢的，并且最终会磨损整个块</span><br><span class="line">3.垃圾收集对理解闪存很重要。为了保持一些块是干净的并且可以被写入，设备需要回收脏块。这需要设备上有一些空闲空间</span><br><span class="line">4.许多设备被填满后会开始变慢，速度下降是由于没有空闲块时必须等待擦写完成所造成的</span><br><span class="line">5.固态存储最适合使用在任何有着大量随机I/O工作负载的场景下，随机I/O通常是由于数据大于服务器的内存导致的，闪存设备可能大大缓解这种问题</span><br><span class="line">6.单线程工作负载也是另一个闪存的潜在应用场景</span><br><span class="line">7.闪存也可以为服务器整合提供巨大的帮助</span><br><span class="line">8.Flashcache，磁盘和内存技术的结合，适合以读为主的I/O密集型负载，并且工作集太大，用内存优化并不经济的情况</span><br><span class="line">9.优化固态存储上的MySQL</span><br><span class="line">增加InnoDB的I/O容量</span><br><span class="line">让InnoDB日志文件更大</span><br><span class="line">把一些文件从闪存转移到RAID</span><br><span class="line">禁用预读</span><br><span class="line">配置InnoDB刷新算法</span><br><span class="line">禁用双写缓冲的可能</span><br><span class="line">限制插入缓冲大小，插入缓冲设计来用于减少当更新行时不在内存中的非唯一索引引起的随机I/O</span><br><span class="line">InnoDB的页大小</span><br><span class="line">优化InnoDB页面校验（Checksum）的替代算法</span><br><span class="line">E.为备库选择硬件</span><br><span class="line">1.通常需要跟主库差不多的配置</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jieba中文分词</title>
      <link href="/2020/05/12/jieba%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/"/>
      <url>/2020/05/12/jieba%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<p>jieba是目前最好的中文分词组件,主要有三个特性:</p><p>1.支持三种分词模式:精确模式,全模式,搜索引擎模式</p><p>2.支持频繁分词</p><p>3.支持自定义词典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jieba.cut()  <span class="comment">#返回生成器</span></span><br><span class="line">jieba.lcut()  <span class="comment">#返回列表</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">cut_all:是否使用全模式,默认为False(精准模式:他/来自/安徽省)</span></span><br><span class="line"><span class="string">HMM:是否使用隐马尔可夫模型,默认为True</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">jieba.cut_for_search()   </span><br><span class="line">jieba.lcut_for_search()</span><br><span class="line"><span class="string">'''搜索引擎模式</span></span><br><span class="line"><span class="string">HMM:默认为True</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>HMM模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HMM模型,即隐马尔可夫模型,是一种基于概率的统计分析模型,用来描述一个系统隐性状态的转移和隐形状态的表现概率.在jieba中,对于未登录到词库的词,使用了基于汉字成词能力的HMM模型和Viterbi算法.</span><br><span class="line">原理:</span><br><span class="line">    采用四个隐含状态,分别表示为单字成词,词组的开头,词组的中间,词组的结尾.通过标注好的分词训练集,可以得到HMM的各个参数,然后使用Viterbi算法来解释测试集,得到分词结果</span><br></pre></td></tr></table></figure><p>添加自定义词典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">词语  词频(可省略)  词性(可省略)</span><br><span class="line">云计算  <span class="number">3</span>  </span><br><span class="line">创新办 <span class="number">3</span>  i</span><br><span class="line">凯特琳 nz</span><br><span class="line"><span class="comment">#jieba本身自带新词识别能力,但自行添加新词可以保证更高的准确率</span></span><br><span class="line"><span class="comment">#载入词典,通常为txt格式文件</span></span><br><span class="line">jieba.load_userdict(file_name)</span><br><span class="line"><span class="comment">#调整词典</span></span><br><span class="line">jieba.add_word(<span class="string">'石墨烯'</span>)</span><br><span class="line">jieba.add_word(<span class="string">'凯特琳'</span>,freq=<span class="number">42</span>,tag=<span class="string">'nz'</span>) <span class="comment"># 设置词频和词性</span></span><br><span class="line">jieba.del_word(<span class="string">'ada'</span>) <span class="comment">#删除自定义词语</span></span><br></pre></td></tr></table></figure><p>关键词提取(IF-IDF和TextRank)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">IF-IDF是一种统计方法,用以评估一个词语对于一个文件集或一个语料库中的一份文件的重要程度.</span><br><span class="line">原理:</span><br><span class="line">    一个词语在一篇文章中出现的次数越多,同时在所有文档中出现的次数越少,越能代表该文章</span><br><span class="line">公式:TF*IDF</span><br><span class="line">TF(term Frequency):词频,某一个给定的词语在改文件中出现的次数</span><br><span class="line">    tf = 在某一类中词条w出现的次数/该类中所有的词条数目</span><br><span class="line">IDF(inverse document frequency,IDF)逆文件频率,如果包含词条的文件越少,则说明词条具有很好的类别区分能力</span><br><span class="line">idf = log(语料库中的文档总数/(包含词条w的文档数+<span class="number">1</span>))</span><br><span class="line">jieba.analyse.extract_tags    (基于TF-IDF)</span><br><span class="line"><span class="string">'''参数</span></span><br><span class="line"><span class="string">sentense:为待提取的文本</span></span><br><span class="line"><span class="string">topK:为返回几个TF/IDF权重最大的关键词</span></span><br><span class="line"><span class="string">withWeight:是否一并返回关键词权重,默认值为False</span></span><br><span class="line"><span class="string">allowPOS:仅包括指定词性的词,默认值为空</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">TextRank(基于pagerank)</span><br><span class="line">jieba.analyse.textrank   参数和extract_tags一致</span><br></pre></td></tr></table></figure><p>自定义语料库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关键词提取所使用的逆向文件频率(IDF)文本语料库和停用词(stop words)文本语料库可以切换成自定义语料库的路径</span><br><span class="line">jieba.analyse.set_stop_words(<span class="string">'stop_words.txt'</span>)</span><br><span class="line">jieba.analyse.set_idf_path(<span class="string">'idf.txt.big'</span>)</span><br></pre></td></tr></table></figure><p>词性标注</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jieba.posseg.cut(text)</span><br></pre></td></tr></table></figure><p>返回词语在原文中的起止位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jieba.tokenize()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自然语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLTK</title>
      <link href="/2020/04/29/NLTK/"/>
      <url>/2020/04/29/NLTK/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语料库认知:</span><br><span class="line">语料库中存放的是在语言的实际使用中真实出现过的语言材料；语料库是以电子计算机为载体承载语言知识的基础资源；真实语料需要经过加工（分析和处理），才能成为有用的资源。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> nltk.book <span class="keyword">import</span> *</span><br><span class="line">text1.concordance(<span class="string">'monstrous'</span>)   <span class="comment">#concordance 一致</span></span><br><span class="line">text1.similar(<span class="string">'monstrous'</span>)  <span class="comment">#与monstrous相似上下文的词</span></span><br><span class="line">text1.common_contexts([<span class="string">'monstrous'</span>,<span class="string">'very'</span>])  <span class="comment">#研究多个词共同的上下文</span></span><br><span class="line">text1.count(<span class="string">'for'</span>)  <span class="comment">#统计某个词出现的次数</span></span><br><span class="line">bigrams([<span class="string">'more'</span>, <span class="string">'is'</span>, <span class="string">'said'</span>, <span class="string">'than'</span>, <span class="string">'done'</span>]) <span class="comment">#双连词搭配</span></span><br><span class="line">nltk.corpus.gutenberg.fileids()   返回古腾堡项目项目的所有文本信息</span><br><span class="line">nltk.corpus.gutenberg.words(<span class="string">'austen-emma.txt'</span>)  <span class="comment">#获取古腾堡项目艾玛文本的所有单词</span></span><br><span class="line"><span class="keyword">from</span> nltk.corpus <span class="keyword">import</span> brown <span class="comment">#布朗语料库:包含500个不同来源的文本</span></span><br><span class="line">brown.categories()  <span class="comment">#查看布朗语料库所有的类别</span></span><br><span class="line"><span class="comment">#查看布朗语料库中类别为新闻的文本中的单词</span></span><br><span class="line">brown.words(categories=<span class="string">'news'</span>)  </span><br><span class="line">brown.words(fileids = [<span class="string">'news'</span>])</span><br><span class="line">brows.sents(categories=[<span class="string">'news'</span>,<span class="string">'editorial'</span>,<span class="string">'fiction'</span>])  <span class="comment">#多个文本</span></span><br><span class="line"><span class="comment">#载入自己的语料库</span></span><br><span class="line"><span class="keyword">from</span> nltk.corpus <span class="keyword">import</span> PlaintextCorpusReader</span><br><span class="line"><span class="comment">#处理html  === &gt; 对文本进行分词</span></span><br><span class="line">raw = nltk.clean_html(html)</span><br><span class="line">tokes = nltk.word_tokensize(raw)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>nltk.corpus  语料库和词典的标准化接口(获取和处理语料库)</span><br><span class="line"><span class="number">2.</span>nltk.tokenize,nltk.stem  分词,句子分解提取主干(字符串处理)</span><br><span class="line"><span class="number">3.</span>nltk.collocations  t-检验,卡方</span><br><span class="line"><span class="number">4.</span>nltk.tag  词性标识符</span><br><span class="line"><span class="number">5.</span>nltk.classify,nltk.cluster  决策树,最大熵,贝叶斯,EM等(分类)</span><br><span class="line"><span class="number">6.</span>nltk.chunk   正则表达式(分块)</span><br><span class="line"><span class="number">7.</span>nltk.parse   图表,基于特征,一致性,概率(解析)</span><br><span class="line"><span class="number">8.</span>nltk.metrics 精度,召回率等(指标评测)</span><br><span class="line"><span class="number">9.</span>nltk.probability  概率分布,平滑概率分布</span><br><span class="line"><span class="number">10.</span>nltk.app  nltk.chat   图形化的关键词排序,聊天机器人(应用)</span><br></pre></td></tr></table></figure><p>nltk自带的语料库(corpus)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gutenberg 古典小说语料库</span><br><span class="line">webtext 网络广告</span><br><span class="line">nps_chat  聊天消息语料库</span><br><span class="line">browm  一个百万词级的英语语料库</span><br><span class="line">reuters  路透社语料库,新闻文档</span><br><span class="line">inaugural  演讲语料库</span><br></pre></td></tr></table></figure><p>NLTK词频统计</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">freq = nltk.FreqDist(数据)</span><br><span class="line">B()  返回词典的长度</span><br><span class="line">plot(title,cumulative=<span class="literal">False</span>)  <span class="comment">#绘制词频分布图,若cumu为True,则是累计频率分布图  </span></span><br><span class="line">tabulate()  生成频率分布的表格形式</span><br><span class="line">most_common() 返回出现次数最频繁的词和频度</span><br><span class="line">hapaxes() 返回只出现过一次的词</span><br><span class="line"></span><br><span class="line">freq.most_common(<span class="number">5</span>)  返回出现频率最高的五个词</span><br></pre></td></tr></table></figure><p>NLTK去除停用词(stopwords)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">在自然语言处理中,无用词(数据)称为停用词</span><br><span class="line"><span class="keyword">from</span> nltk.corpus <span class="keyword">import</span> stopwords</span><br><span class="line">stopwords.words(<span class="string">'english'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#例题:从文本中删除停用词</span></span><br><span class="line"><span class="keyword">from</span> nltk.corpus <span class="keyword">import</span> stopwords</span><br><span class="line"><span class="keyword">from</span> nltk.tokensize  <span class="keyword">import</span> word_tokenize</span><br><span class="line">example_sent = <span class="string">'this is a sample sentence,showing off the stop  words filtration'</span></span><br><span class="line">stop_words =  set(stopwords.words(<span class="string">'english'</span>))</span><br><span class="line">word_tokens = word_tokenize(example_sent)</span><br><span class="line">filtered_sentence = [w <span class="keyword">for</span> w <span class="keyword">in</span> word_tokens <span class="keyword">if</span> <span class="keyword">not</span> w <span class="keyword">in</span> stops_words]</span><br></pre></td></tr></table></figure><p>nltk的分词(tokensize)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span>  nltk.tokenize <span class="keyword">import</span>  sent_tokenize</span><br><span class="line"><span class="keyword">from</span> nltk.tokenize  <span class="keyword">import</span> word_tokenize</span><br><span class="line"><span class="comment">#分句</span></span><br><span class="line">sent_tokenize(mytext)</span><br><span class="line">sent_tokenize(mytext,<span class="string">'french'</span>)  <span class="comment">#标记非英语语言文本</span></span><br><span class="line"><span class="comment">#分词</span></span><br><span class="line">word_tokenize(mytext)</span><br></pre></td></tr></table></figure><p>nltk词干提取==可能创造不存在的词汇</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">***************************<span class="number">1</span>********************************</span><br><span class="line"><span class="keyword">from</span> nltk.stem <span class="keyword">import</span> PorterStemmer</span><br><span class="line">porter_stemmer = PorterStemmer()</span><br><span class="line">porter_stemmer.stem('working')----------&gt;work</span><br><span class="line">****************************<span class="number">2</span>*******************************</span><br><span class="line">fromnltk.stem <span class="keyword">import</span> SnowballStemmer</span><br><span class="line">lancaster_stemmer = LancasterStemmet()</span><br><span class="line">lancaster_stemmer.stem('working') ---------&gt;work</span><br></pre></td></tr></table></figure><p>nltk词形还原 == 解决词干提取会出现不存在词汇的问题</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> nltk.stem <span class="keyword">import</span> WordNetLemmatizer</span><br><span class="line">lemmatizer = WordNetLemmatizer()</span><br><span class="line">lemmatizer.lemmatize('increases') ----&gt;increase</span><br><span class="line">lemmatizer.lemmatize('palying',post='v')-----&gt;默认还原结果为名词,post还原为动词</span><br></pre></td></tr></table></figure><p>nltk词性标注(pos tag)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nltk</span><br><span class="line">text = nltk.word_tokenize(<span class="string">'what does the fox say'</span>)</span><br><span class="line">nltk.post_tag(text)</span><br><span class="line"><span class="comment">#返回</span></span><br><span class="line">[(<span class="string">'what'</span>, <span class="string">'WDT'</span>), (<span class="string">'does'</span>, <span class="string">'VBZ'</span>), (<span class="string">'the'</span>, <span class="string">'DT'</span>), (<span class="string">'fox'</span>, <span class="string">'NNS'</span>), (<span class="string">'say'</span>, <span class="string">'VBP'</span>)]</span><br></pre></td></tr></table></figure><p>NLTK中的wordnet</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取给定词的定义和例句</span></span><br><span class="line"><span class="keyword">from</span> nltk.corpus <span class="keyword">import</span> wordnet</span><br><span class="line">syn = wordnet.synsets(<span class="string">'pain'</span>) <span class="comment">#获取'pain'同义词集</span></span><br><span class="line">syn[<span class="number">0</span>].definition()  <span class="comment">#pain的解释</span></span><br><span class="line">syn[<span class="number">0</span>].examples()  <span class="comment">#pain的例句</span></span><br><span class="line"><span class="comment">#获取同义词</span></span><br><span class="line"><span class="keyword">for</span> syn <span class="keyword">in</span> wordnet.synsets(<span class="string">'pain'</span>):</span><br><span class="line">    <span class="keyword">for</span> lemma <span class="keyword">in</span> syn.lemmas():</span><br><span class="line">        synonyms.append(lemma.name())</span><br><span class="line"><span class="comment">#获取反义词</span></span><br><span class="line">antonyms = []</span><br><span class="line"><span class="keyword">for</span> syn <span class="keyword">in</span> wordnet.synsets(<span class="string">"small"</span>):</span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> syn.lemmas:</span><br><span class="line">        <span class="keyword">if</span> l.antonyms():</span><br><span class="line">            antonyms.append(l.antonyms()[<span class="number">0</span>].name())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习周志华</title>
      <link href="/2020/04/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%91%A8%E5%BF%97%E5%8D%8E/"/>
      <url>/2020/04/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%91%A8%E5%BF%97%E5%8D%8E/</url>
      
        <content type="html"><![CDATA[<p>基本概念:属性\特征\样本\示例\属性值\属性空间\样本空间\输入空间\数据集\标签\特征向量(一个示例都可以在坐标上表示出来)\训练集\测试集\训练样本\输出空间\标记空间\泛化\过拟合\欠拟合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">错误率:分类错误的数据占总样本的比例</span><br><span class="line">精度: 1 - 错误率</span><br><span class="line">查准率(准确率):TP/(TP+FP)</span><br><span class="line">查全率(召回率):TP/(TP+FN)</span><br><span class="line">训练误差/经验误差:学习器的实际预测输出与真实输出的差异称为误差,在训练集上的误差称为~</span><br><span class="line">泛化误差:新样本上的误差</span><br><span class="line">roc/auc/pr曲线/pr图</span><br><span class="line">平衡点(BEP):查准点=查全率  y=x与曲线的交点</span><br></pre></td></tr></table></figure><p>训练集和测试集产生的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.留出法:3,7分,2,8分,将训练集分成互斥的两个集合</span><br><span class="line">2.交叉验证法:又叫k折交叉验证,先将数据集划分为k个大小相似的互斥子集,每次用k-1个子集作为训练集,余下的作为测试集.这样就可以得到k组训练集\测试集,从而可以进行k次训练和测试,最终返回的是这k个测试结果的均值.通常进行p次k折交叉验证</span><br><span class="line"></span><br><span class="line">缺点:留出法和交叉验证法,由于保留了一部分样本用于测试,因此实际评估的模型所使用的的训练集比D小,这必然会引入一些因训练样本规模不同而导致的估计偏差</span><br><span class="line">3.自助法 以自助采样法为基础.给定包含m个样本的数据集D,我们对它采样产生数据集D1,每次随机从D中挑选一个样本,将其拷贝到D1,然后再将该样本放回初始数据D中,使得该样本在下次采样时仍有可能被采到.这个过程重复执行m次,我们就得到了包含m个样本的数据集D1.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫代码</title>
      <link href="/2020/04/07/%E7%88%AC%E8%99%AB%E4%BB%A3%E7%A0%81/"/>
      <url>/2020/04/07/%E7%88%AC%E8%99%AB%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>####urllib</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line">****************************************基本********************************************</span><br><span class="line"><span class="comment">#确定url地址</span></span><br><span class="line">base_url = <span class="string">'http://www.baidu.com/'</span></span><br><span class="line"><span class="comment">#发送请求</span></span><br><span class="line">response = request.urlopen(base_url)</span><br><span class="line"><span class="comment">#获取相应内容</span></span><br><span class="line">html = response.read()</span><br><span class="line">print(html.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="comment">#存储</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'2.html'</span>,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> k:</span><br><span class="line">    k.write(html.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">***************************************添加headers********************************************</span><br><span class="line">base_url = <span class="string">'http://www.baidu.com/'</span></span><br><span class="line">headers = &#123;<span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36'</span>&#125;</span><br><span class="line">req = request.Request(url = base_url,headers=headers)</span><br><span class="line">response = request.urlopen(req)</span><br><span class="line">html = response.read()</span><br><span class="line">print(html.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">****************************************未登录跳过登录爬取人人网********************************</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request,parse</span><br><span class="line"><span class="keyword">from</span> http <span class="keyword">import</span> cookiejar</span><br><span class="line"><span class="comment">#实例化cookie管理器</span></span><br><span class="line">cookie = cookiejar.CookieJar()</span><br><span class="line">cook_handle = request.HTTPCookieProcessor(cookie)</span><br><span class="line"><span class="comment">#创建opener</span></span><br><span class="line">opener = request.build_opener(cook_handle)</span><br><span class="line">base_url = <span class="string">'http://www.renren.com/PLogin.do'</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'email'</span>:<span class="string">'17333119189'</span>,</span><br><span class="line">    <span class="string">'password'</span>:<span class="string">'19960102kuai'</span></span><br><span class="line">&#125;</span><br><span class="line">res = parse.urlencode(data)</span><br><span class="line">re = request.Request(base_url,data=res.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">responsd = opener.open(re)</span><br><span class="line">******************************************添加代理****************************************</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line">base_url = <span class="string">'http://www.66ip.cn/'</span></span><br><span class="line">proxy = &#123;</span><br><span class="line">    <span class="string">'http'</span>:<span class="string">'alice:123456@120.78.166.84:6666'</span>,</span><br><span class="line">    <span class="string">'https'</span>:<span class="string">'alice:123456@120.78.166.84:6666'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#创建管理器</span></span><br><span class="line">proxy_handler = request.ProxyHandler(proxy)</span><br><span class="line"><span class="comment">#创建opener</span></span><br><span class="line">opener = request.build_opener(proxy_handler)</span><br><span class="line">headers = &#123;</span><br><span class="line"><span class="string">'Cookie'</span>:<span class="string">' __jsluid=27be3fa08d7aa7c457f79068cd77bc79; Hm_lvt_1761fabf3c988e7f04bec51acd4073f4=1555141241,1555144721,1555152744,1555155158; Hm_lpvt_1761fabf3c988e7f04bec51acd4073f4=1555155531'</span>,</span><br><span class="line"><span class="string">'User-Agent'</span>:<span class="string">' Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36'</span>&#125;</span><br><span class="line">response = opener.open(base_url)</span><br><span class="line">print(response.read().decode(<span class="string">'gb2312'</span>))</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">base_url = <span class="string">'http://www.baidu.com'</span></span><br><span class="line"><span class="comment">#发送请求</span></span><br><span class="line">response = requests.get(base_url)</span><br><span class="line"><span class="comment">#获取相应内容===1.获取字符串2.获取二进制bytes</span></span><br><span class="line"><span class="comment">#指定编码格式</span></span><br><span class="line">print(response)</span><br><span class="line">response.encoding=<span class="string">'utf-8'</span></span><br><span class="line">print(response.text)</span><br><span class="line"><span class="comment">#返回bytes格式 content</span></span><br><span class="line">print(response.content.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">****************************************非认证代理****************************************</span><br><span class="line"><span class="comment">#使用代理ip爬取网页</span></span><br><span class="line"><span class="comment">#非认证代理</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line">base_url = <span class="string">'http://www.baidu.com'</span></span><br><span class="line">proxy = &#123;</span><br><span class="line">    <span class="string">'http'</span>:<span class="string">'http://124.205.143.213:41372'</span>,</span><br><span class="line">    <span class="string">'https'</span>:<span class="string">'http://124.205.143.213:41372'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#创建proxy管理器</span></span><br><span class="line">proxy_handler = request.ProxyHandler(proxy)</span><br><span class="line"><span class="comment">#创建opener</span></span><br><span class="line">opener = request.build_opener(proxy_handler)</span><br><span class="line"><span class="comment">#发送请求</span></span><br><span class="line">response = opener.open(base_url)</span><br><span class="line">print(response.read().decode(<span class="string">'utf-8'</span>))</span><br><span class="line">*****************************************认证代理*****************************************</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line">base_url = <span class="string">'http://www.baidu.com'</span></span><br><span class="line">proxy = &#123;</span><br><span class="line">    <span class="string">'http'</span>:<span class="string">'http://alice:123456@120.78.166.84:6666'</span>,</span><br><span class="line">    <span class="string">'https'</span>:<span class="string">'https://alice:123456@120.78.166.84:6666'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#创建ip处理器</span></span><br><span class="line">proxy_handler = request.ProxyHandler(proxy)</span><br><span class="line"><span class="comment">#chuangjianoperer</span></span><br><span class="line">opener = request.build_opener(proxy_handler)</span><br><span class="line"><span class="comment">#发送请求</span></span><br><span class="line">response = opener.open(base_url)</span><br><span class="line">print(response.read().decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure><p>requests</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line">*********************************************get*****************************************</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">base_url = <span class="string">'https://www.xicidaili.com/'</span></span><br><span class="line"><span class="comment">#定义请求头</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line">res = requests.get(base_url,headers=headers)</span><br><span class="line">print(res.text)</span><br><span class="line">***********************************************post***************************************</span><br><span class="line"><span class="keyword">import</span> requests,json</span><br><span class="line">base_url = <span class="string">'https://fanyi.baidu.com/sug'</span></span><br><span class="line">data = &#123;</span><br><span class="line"><span class="string">'kw'</span>: <span class="string">'hello'</span></span><br><span class="line">&#125;</span><br><span class="line">response = requests.post(base_url,data=data)</span><br><span class="line">response.encoding=<span class="string">'UTF-8'</span></span><br><span class="line">res = json.loads(response.text)</span><br><span class="line"><span class="comment"># with open('2.json','w',encoding='utf-8')as f:</span></span><br><span class="line"><span class="comment">#     f.write(json.loads())</span></span><br><span class="line">print(res)</span><br><span class="line">******************************************添加请求头**************************************</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">base_url = <span class="string">'http://www.baidu.com'</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line">response = requests.get(base_url,headers=headers)</span><br><span class="line">print(response.text)</span><br><span class="line"></span><br><span class="line">********************************************xpath匹配*************************************</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">base_url = <span class="string">'https://www.mzitu.com/'</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'user-agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36'</span></span><br><span class="line">,<span class="string">'referer'</span>:<span class="string">'https://www.mzitu.com/xinggan/'</span>,</span><br><span class="line"><span class="string">'cookie'</span>: <span class="string">'Hm_lvt_dbc355aef238b6c32b43eacbbf161c3c=1555144582,1555144596,1555144615,1555145046; Hm_lpvt_dbc355aef238b6c32b43eacbbf161c3c=1555145072'</span></span><br><span class="line">&#125;</span><br><span class="line">respond = requests.get(base_url,headers = headers)</span><br><span class="line"><span class="comment"># print(respond.text)</span></span><br><span class="line">html = etree.HTML(respond.text)</span><br><span class="line">html_xpath = html.xpath(<span class="string">'//a/img[@class="lazy"]/@data-original'</span>)</span><br><span class="line"><span class="comment"># print(html_xpath)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> html_xpath:</span><br><span class="line">    respond = requests.get(i,headers=headers)</span><br><span class="line">    j = i[<span class="number">-14</span>:<span class="number">-4</span>]</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'./pic/&#123;&#125;.jpg'</span>.format(j),<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(respond.content)</span><br><span class="line">*******************************************添加代理***************************************</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">base_url = <span class="string">'http://www.baidu.com'</span></span><br><span class="line">proxy=&#123;</span><br><span class="line">    <span class="string">'http'</span>:<span class="string">'http://alice:123456@120.78.166.84:6666'</span>,</span><br><span class="line">    <span class="string">'https'</span>:<span class="string">'https://alice:123456@120.78.166.84:6666'</span></span><br><span class="line">&#125;</span><br><span class="line">response = requests.get(base_url,proxies= proxy)</span><br><span class="line">response.encoding=<span class="string">'utf-8'</span></span><br><span class="line">print(response.text)</span><br><span class="line">********************************************综合*******************************************</span><br><span class="line"><span class="keyword">import</span> requests,re</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line">base_url = <span class="string">'http://www.ccdi.gov.cn/'</span></span><br><span class="line">proxy = &#123;</span><br><span class="line">    <span class="string">'http'</span>:<span class="string">'http://alice:123456@120.78.166.84:6666'</span>,</span><br><span class="line">    <span class="string">'https'</span>:<span class="string">'https://alice:123456@120.78.166.84:6666'</span></span><br><span class="line">&#125;</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line">response = requests.get(base_url,headers=headers,proxies =proxy)</span><br><span class="line"><span class="comment"># with open('3.html','wb')as f:</span></span><br><span class="line"><span class="comment">#     f.write(response.content)</span></span><br><span class="line">html_ele = etree.HTML(response.text)</span><br><span class="line">url_list = html_ele.xpath(<span class="string">'//nav/span[5]/a/@href'</span>)</span><br><span class="line"><span class="comment"># print(url_list)</span></span><br><span class="line">response_jdbgpage = requests.get(url_list[<span class="number">0</span>],headers = headers,proxies =proxy)</span><br><span class="line"><span class="comment"># with open('3.html','wb')as f:</span></span><br><span class="line"><span class="comment"># #     f.write(response_jdbgpage.content)</span></span><br><span class="line">html = etree.HTML(response_jdbgpage.text)</span><br><span class="line">url2_list = html.xpath(<span class="string">'//ul[@class="menu_list"]/li[position()&gt;1]/a/@href'</span>)[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line"><span class="comment"># print(url2_list)</span></span><br><span class="line"><span class="keyword">for</span> url3 <span class="keyword">in</span> url2_list:</span><br><span class="line">    new_url = parse.urljoin(url_list[<span class="number">0</span>],url3)</span><br><span class="line">    print(new_url)</span><br><span class="line">    resp = requests.get(new_url,headers = headers,proxies =proxy)</span><br><span class="line">    <span class="comment"># with open('3.html','wb')as f:</span></span><br><span class="line">    <span class="comment">#     f.write(resp.content)</span></span><br><span class="line">    pat = re.compile(<span class="string">'&lt;li class="on"&gt;&lt;a href="../../(.*?)/"&gt;'</span>)</span><br><span class="line">    res = pat.findall(resp.text)[<span class="number">2</span>:<span class="number">-1</span>]</span><br><span class="line">    print(res)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">        base_url2 = <span class="string">'http://www.ccdi.gov.cn/special/jdbg3/&#123;&#125;/'</span></span><br><span class="line">        <span class="comment"># print(base_url2.format(i))</span></span><br><span class="line">        res2 = requests.get(base_url2.format(i),headers=headers)</span><br><span class="line">        <span class="comment"># with open('4.html','wb')as f:</span></span><br><span class="line">        <span class="comment">#     f.write(res2.content)</span></span><br><span class="line">        pat = re.compile(<span class="string">'&lt;a href="(.*?)"'</span>)</span><br><span class="line">        print(pat.findall(res2.text))</span><br><span class="line">******************************************多进程共享数据********************************</span><br><span class="line"><span class="comment">#爬取中央纪检委举报违纪的实例</span></span><br><span class="line"><span class="keyword">import</span> requests,re</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">from</span> day14.day14_2 <span class="keyword">import</span> Db</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool,Manager</span><br><span class="line"></span><br><span class="line"><span class="comment">#爬取基本页信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">First_webpage</span><span class="params">(url,queue)</span>:</span></span><br><span class="line">    print(<span class="string">'函数1'</span>,url)</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36'</span></span><br><span class="line">    &#125;</span><br><span class="line">    first_webpage_response = requests.get(url,headers=headers,proxies = proxy())</span><br><span class="line">    <span class="comment">#匹配所有省份</span></span><br><span class="line">    pat = re.compile(<span class="string">'&lt;a href="./(.*?)/"&gt;'</span>)</span><br><span class="line">    province_list = pat.findall(first_webpage_response.text)</span><br><span class="line">    print(province_list)</span><br><span class="line">    <span class="keyword">for</span> province <span class="keyword">in</span> province_list[<span class="number">2</span>:<span class="number">-1</span>]:</span><br><span class="line">        type_list = [<span class="string">'fjbxgdwt_jdbg3'</span>, <span class="string">'sffbwt_jdbg3'</span>, <span class="string">'sfjds_jdbg3'</span>]</span><br><span class="line">        <span class="keyword">for</span> type1 <span class="keyword">in</span> type_list:</span><br><span class="line">            second_webpage_url = <span class="string">'http://www.ccdi.gov.cn/special/jdbg3/&#123;&#125;/&#123;&#125;'</span>.format(province,type1)</span><br><span class="line">            print(second_webpage_url)</span><br><span class="line">            queue.put((divoce_page_url,second_webpage_url))</span><br><span class="line"><span class="comment"># 函数2 http://www.ccdi.gov.cn/special/jdbg3/bt_bgt/sfjds_jdbg3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divoce_page_url</span><span class="params">(url,queue)</span>:</span></span><br><span class="line">    print(<span class="string">'函数2'</span>,url)</span><br><span class="line">    response = requests.get(url,proxies = proxy())</span><br><span class="line">    pat = re.compile(<span class="string">'createPageHTML\((.*?), 0, "index", "html"\)'</span>)</span><br><span class="line">    page_count = pat.findall(response.text)</span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> range(int(page_count[<span class="number">0</span>])):</span><br><span class="line">        <span class="keyword">if</span> page == <span class="number">0</span>:</span><br><span class="line">            page_url = url + <span class="string">'/index.html'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            page_url = url + <span class="string">'/index_&#123;&#125;.html'</span>.format(page)</span><br><span class="line">        response = requests.get(page_url,proxies = proxy())</span><br><span class="line">        pat = re.compile(<span class="string">'&lt;li class="fixed"&gt;\s+&lt;dl&gt;\s+&lt;dt&gt;\s+&lt;a href="./(.*?)" target="_blank"'</span>)</span><br><span class="line">        url_list = pat.findall(response.text)</span><br><span class="line">        <span class="keyword">for</span> url_content <span class="keyword">in</span> url_list:</span><br><span class="line">            new_url = url +<span class="string">'/'</span>+ url_content</span><br><span class="line">            queue.put((get_content_url,new_url))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_content_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'函数3:'</span>,url)</span><br><span class="line">    response = requests.get(url,proxies = proxy())</span><br><span class="line">    response.encoding=<span class="string">'utf-8'</span></span><br><span class="line">    html = etree.HTML(response.text)</span><br><span class="line">    content_list = html.xpath(<span class="string">'//div[@class="content"]/div[1]/div[@class="TRS_Editor"]//text()'</span>)</span><br><span class="line">    content = <span class="string">'\n'</span>.join([item.strip() <span class="keyword">for</span> item <span class="keyword">in</span> content_list <span class="keyword">if</span> item.strip() != <span class="string">''</span>])</span><br><span class="line">    print(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proxy</span><span class="params">()</span>:</span></span><br><span class="line">    proxy = &#123;</span><br><span class="line">        <span class="string">'http'</span>:<span class="string">'http://alice:123456@120.78.166.84:6666'</span>,</span><br><span class="line">        <span class="string">'https'</span>:<span class="string">'https://alice:123456@120.78.166.84:6666'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proxy</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pool = Pool(<span class="number">5</span>)</span><br><span class="line">    url = <span class="string">'http://www.ccdi.gov.cn/special/jdbg3/index.html'</span></span><br><span class="line">    queue = Manager().Queue()</span><br><span class="line">    queue.put((First_webpage,url))</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        func,url=queue.get()</span><br><span class="line">        pool.apply_async(func=func,args=(url,queue))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Db</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,database=<span class="string">'kl'</span>,user=<span class="string">'root'</span>,password=<span class="string">'123456'</span>,port=<span class="number">3306</span>,host=<span class="string">'localhost'</span>)</span>:</span></span><br><span class="line">        self.db = pymysql.connect(database=database,port=port,password=password,user=user,host=host,charset=<span class="string">'utf8mb4'</span>)</span><br><span class="line">        self.cursor = self.db.cursor()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self,sql,data)</span>:</span></span><br><span class="line">        self.cursor.execute(sql,data)</span><br><span class="line">        self.db.commit()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self,sql,data)</span>:</span></span><br><span class="line">        self.cursor.execute(sql,data)</span><br><span class="line">        self.db.commit()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        self.cursor.close()</span><br><span class="line">        self.db.close()</span><br></pre></td></tr></table></figure><h6 id="beautifulsoup"><a href="#beautifulsoup" class="headerlink" title="beautifulsoup"></a>beautifulsoup</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">text = <span class="string">"""</span></span><br><span class="line"><span class="string">    &lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;p class="title p8" id="p1" data="1"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;b&gt;----2b&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;p class="story"&gt;</span></span><br><span class="line"><span class="string">        Once upon a time there were three little sisters; and their names were</span></span><br><span class="line"><span class="string">        &lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;&lt;span&gt;&lt;b&gt;Elsie&lt;/b&gt;&lt;/span&gt;&lt;/span&gt;--alice&lt;/span&gt;&lt;/a&gt;,</span></span><br><span class="line"><span class="string">        &lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and</span></span><br><span class="line"><span class="string">        &lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;</span></span><br><span class="line"><span class="string">        and they lived at the bottom of a well.</span></span><br><span class="line"><span class="string">    &lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;p class="story"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;div class="item1"&gt;我是div&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div class="item2"&gt;我是div2&lt;/div&gt;</span></span><br><span class="line"><span class="string">    我是body</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment">#实例化对象</span></span><br><span class="line">soup = BeautifulSoup(text,<span class="string">'lxml'</span>)</span><br><span class="line"><span class="comment"># #格式化</span></span><br><span class="line"><span class="comment"># print(soup.prettify())</span></span><br><span class="line"><span class="comment">#取第一个元素</span></span><br><span class="line">print(soup.div)</span><br><span class="line"><span class="comment">#获取标签名</span></span><br><span class="line">print(soup.div.name)</span><br><span class="line"><span class="comment">#获取文本内容</span></span><br><span class="line">print(soup.div.string)</span><br><span class="line"><span class="comment">#获取标签中的所有内容包括子标签内的内容</span></span><br><span class="line">print(soup.body.get_text)</span><br><span class="line"><span class="comment">#获取属性的方法</span></span><br><span class="line">print(soup.p[<span class="string">'id'</span>])</span><br><span class="line"><span class="comment">#获取当前标签的所有的属性和值</span></span><br><span class="line">print(soup.p.attrs)</span><br><span class="line"></span><br><span class="line"><span class="comment">#find_all</span></span><br><span class="line">print(soup.find_all(<span class="string">'div'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#find</span></span><br><span class="line">print(soup.find(<span class="string">'p'</span>))</span><br><span class="line"><span class="comment">#元素节点</span></span><br><span class="line">print(soup.body.contents)</span><br><span class="line">print(soup.body.descendants)</span><br><span class="line"></span><br><span class="line"><span class="comment">#css选择器</span></span><br><span class="line">print(soup.select(<span class="string">'p'</span>))</span><br><span class="line">print(soup.select(<span class="string">'a.sister'</span>))</span><br><span class="line">res = soup.select(<span class="string">'p&gt;b'</span>)</span><br><span class="line">print(res)</span><br><span class="line">res = soup.select(<span class="string">'#p1,.story'</span>)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><h5 id="scrapy框架"><a href="#scrapy框架" class="headerlink" title="scrapy框架"></a>scrapy框架</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">流程:<span class="number">1.</span>cd 到想要创建scrapy框架的文件夹里</span><br><span class="line">     <span class="number">2.</span>scrapy startproject 框架名</span><br><span class="line">     <span class="number">3.</span>生成爬虫程序scrapy genspider 程序名  网址</span><br><span class="line"><span class="number">4.</span>执行爬虫程序  scrapy crawl 爬虫名字</span><br><span class="line">    <span class="number">5.</span>调试平台scrapy shell</span><br></pre></td></tr></table></figure><h5 id="selenium"><a href="#selenium" class="headerlink" title="selenium"></a>selenium</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="db类"><a href="#db类" class="headerlink" title="db类"></a>db类</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlDatabase</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.db = pymysql.connect(host=<span class="string">'localhost'</span>,user = <span class="string">'root'</span>,password=<span class="string">'123456'</span>,port = <span class="number">3306</span>,database = <span class="string">'kl'</span>,charset = <span class="string">'utf8mb4'</span>)</span><br><span class="line">        self.cursor = self.db.cursor()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self,sql,data)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.cursor.execute(sql,data)</span><br><span class="line">            self.db.commit()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            print(<span class="string">'插入失败'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self,sql,data)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.cursor.execute(sql, data)</span><br><span class="line">            self.db.commit()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            print(<span class="string">'更新失败'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.cursor.close()</span><br><span class="line">        self.db.close()</span><br></pre></td></tr></table></figure><h6 id="proxy代理类"><a href="#proxy代理类" class="headerlink" title="proxy代理类"></a>proxy代理类</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests,time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyHelper</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.url = <span class="string">'http://mvip.piping.mogumiao.com/proxy/api/get_ip_al?appKey=4015b4545c6545d5b21a3b49fec0671c&amp;count=1&amp;expiryDate=0&amp;format=2&amp;newLine=2'</span></span><br><span class="line">        self.version = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_proxy</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'获取了一个代理'</span>)</span><br><span class="line">        self.proxy = requests.get(self.url).text.strip()</span><br><span class="line">        <span class="keyword">return</span> self.proxy,self.version</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_proxy</span><span class="params">(self,version)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> version == self.version:</span><br><span class="line">            self.proxy,self.version = self.get_proxy()</span><br><span class="line">            self.version += <span class="number">1</span></span><br><span class="line">            print(<span class="string">'更新了一个代理:'</span>+self.proxy)</span><br><span class="line">        <span class="keyword">return</span> self.proxy</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    helper = ProxyHelper()</span><br><span class="line">    <span class="comment"># proxy, version = helper.get_proxy()</span></span><br><span class="line">    <span class="comment"># print(proxy)</span></span><br><span class="line">    <span class="comment"># time.sleep(30)</span></span><br><span class="line">    helper.update_proxy(<span class="number">0</span>)</span><br><span class="line">    print(helper.update_proxy(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度例题</title>
      <link href="/2020/04/07/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BE%8B%E9%A2%98/"/>
      <url>/2020/04/07/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BE%8B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>可理解为程序运行步骤,主要看每一步需要运行的次数</p><p>大O表示法表明忽略常数项,只保留最核心,最特征的部分,忽略常量,低阶,系数</p><h5 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">a + b + c = 1000 and a**2 + b**2 = c**2  </span><br><span class="line">假设使用穷举法(枚举法),三层循环循环a,b,c的所有可能,加上两个if判断条件 得到时间复杂读1000*1000*1000*2</span><br><span class="line">若 a + b + c = 2000,则时间复杂度为 2000*2000*2000*2 </span><br><span class="line">若 a + b + c = N ,则时间复杂度为 N*N*N*2 O(n**3)</span><br><span class="line">解:</span><br><span class="line">for a in range(0, n):</span><br><span class="line">    (循环用乘法计算)</span><br><span class="line">    这句代码的运行步骤是:O(n)</span><br><span class="line"> </span><br><span class="line">for b in range(0, n):</span><br><span class="line">    (循环用乘法计算)</span><br><span class="line">    这句代码的运行步骤是:O(n)</span><br><span class="line"> </span><br><span class="line">c = n - a -b</span><br><span class="line">    (基本操作语句为1)</span><br><span class="line">    运行步骤为:O(1)</span><br><span class="line"> </span><br><span class="line">if a ^ 2 + b ^ 2 = c ^ 2:</span><br><span class="line">print(a,b,c)</span><br><span class="line">进入判断语句, 有两个分支</span><br><span class="line">(当碰到分支语句的时候,取分支步骤最多的)</span><br><span class="line">    分支1执行print(a,b,c)</span><br><span class="line">        步骤为1</span><br><span class="line">    分支2是判断条件失败,直接跳过了</span><br><span class="line">        步骤为0</span><br><span class="line">假设令c = N - a - b,使用双层循环,则时间复杂读为N*N *(1+max(0,1))   O(n**2)</span><br></pre></td></tr></table></figure><p>######例题2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">阅读电话簿中每个人的电话号码O(n)</span><br><span class="line">在电话簿中根据电话号码找人O(n)</span><br><span class="line">阅读电话簿中的以a开头的人的电话号码 O(n)</span><br><span class="line">在电话里簿中根据名字查找电话号码  O(logn)</span><br></pre></td></tr></table></figure><p>学习思路</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Python数据结构与算法----&gt;机器学习和深度学习和数据挖掘----&gt;大数据-----&gt;NLP自然语言处理-------&gt;linux--------&gt;数据库底层-------&gt;其他底层知识</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>json存储格式问题</title>
      <link href="/2020/03/31/json%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2020/03/31/json%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">问题:TypeError: Object of type <span class="string">'int64'</span> <span class="keyword">is</span> <span class="keyword">not</span> JSON serializable (或者float32)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NpEncoder</span><span class="params">(json.JSONEncoder)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(obj, np.integer):</span><br><span class="line">            <span class="keyword">return</span> int(obj)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(obj, np.floating):</span><br><span class="line">            <span class="keyword">return</span> float(obj)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(obj, np.ndarray):</span><br><span class="line">            <span class="keyword">return</span> obj.tolist()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> super(NpEncoder, self).default(obj)</span><br><span class="line">json.dumps(cxy_data, ensure_ascii=<span class="literal">False</span>,cls=NpEncoder)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> json存储格式报错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础指令</title>
      <link href="/2020/01/07/Linux%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/"/>
      <url>/2020/01/07/Linux%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<ol><li>Linux基础</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">根目录下的文件</span><br><span class="line">/bin   存放着系统必备执行文件</span><br><span class="line">    /boot  linux启动核心文件</span><br><span class="line">    /dev   linux的外部设备(device)</span><br><span class="line">/etc   配置文件和子目录</span><br><span class="line">    /home  用户目录</span><br><span class="line">    /lib   类似于windowns里的dll文件,动态连接共享库</span><br><span class="line">    /media  将识别到的光驱\u盘等挂载到这个目录下</span><br><span class="line">    /misc   存放杂项文件或目录</span><br><span class="line">    /mnt    临时挂载别的文件系统的(eg:光驱)</span><br><span class="line">    /net   存放和网络相关的一些文件</span><br><span class="line">    /opt   主机额外安装软件存放的位置</span><br><span class="line">    /proc   虚拟目录,系统内存的映射,可获取系统信息</span><br><span class="line">    /root   系统管理员的主目录</span><br><span class="line">    /run是系统运行时需要的</span><br><span class="line">    /sbin  存放系统管理员使用的系统管理程序</span><br><span class="line">    /srv   存放一些启动服务后需要提取的数据</span><br><span class="line">    /sys   安装的新文件系统sysfs</span><br><span class="line">    /tmp   存放临时文件</span><br><span class="line">    /usr   等同于windows的program files,存放着很多用户文件和程序</span><br><span class="line">    /var   存放着不断扩充的内容,如日志</span><br></pre></td></tr></table></figure><h6 id="复制文件或文件夹"><a href="#复制文件或文件夹" class="headerlink" title="复制文件或文件夹"></a>复制文件或文件夹</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp test1.py test2.py   复制文件</span><br><span class="line">cp -r test test1  递归复制整个文件夹</span><br></pre></td></tr></table></figure><h5 id="显示当前路径"><a href="#显示当前路径" class="headerlink" title="显示当前路径"></a>显示当前路径</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd:显示当前路径</span><br></pre></td></tr></table></figure><h5 id="find查找文件"><a href="#find查找文件" class="headerlink" title="find查找文件"></a>find查找文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find *.log  找到所有以.log结尾的文件名</span><br><span class="line">find kl 找到kl名的文件夹</span><br></pre></td></tr></table></figure><h5 id="grep过滤"><a href="#grep过滤" class="headerlink" title="grep过滤"></a>grep过滤</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep 字符串 文件名</span><br></pre></td></tr></table></figure><h5 id="管道符"><a href="#管道符" class="headerlink" title="|管道符"></a>|管道符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在命令之间建立管道,将前面命令的输出作为后面命令的输入</span><br><span class="line">通过命令查找tomcat进程：ps -ef | grep tomcat</span><br><span class="line">通过命令查找到占用此端口的进程编号：netstat -apn|grep 8080</span><br></pre></td></tr></table></figure><p>#####移除文件或目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm test1.py</span><br><span class="line">rm -rf test  递归删除文件夹</span><br><span class="line">rmdir test  删除空文件夹</span><br></pre></td></tr></table></figure><h6 id="重命名和移动文件"><a href="#重命名和移动文件" class="headerlink" title="重命名和移动文件"></a>重命名和移动文件</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv test1.py test2.py 重命名</span><br><span class="line">mv /temp/movefile  /targetFolder  移动文件夹</span><br></pre></td></tr></table></figure><h5 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat test1.py  会将所有的内容打印出来</span><br><span class="line">cat -n 文件名  列出行号,连同空白行</span><br><span class="line">cat -v 文件名  列出一些看不出来的特殊字符</span><br><span class="line">cat -b 文件名  列出行号,空白行不标注</span><br><span class="line"></span><br><span class="line">tac 文件名   从最后一行倒着行数打印</span><br><span class="line">more test1.py  查看文件内容,一页一页查看</span><br><span class="line">less test1.py  查看文档内容</span><br><span class="line">head -n 10 test1.py 查看文件头10行内容</span><br><span class="line">tail -n 10 test1.py  查看文件最后10行内容</span><br></pre></td></tr></table></figure><h6 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l&gt;a.txt  将列表的内容写入a.txt 覆盖写</span><br><span class="line">ls -al&gt;a.txt  将列表的内容写入a.txt  追加写</span><br></pre></td></tr></table></figure><h5 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 222 &gt;&gt; a.txt  将要显示的内容,存储到文件中</span><br><span class="line">echo 变量 显示变量的值</span><br></pre></td></tr></table></figure><h6 id="查看历史命令"><a href="#查看历史命令" class="headerlink" title="查看历史命令"></a>查看历史命令</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history</span><br></pre></td></tr></table></figure><h5 id="时间日期类型"><a href="#时间日期类型" class="headerlink" title="时间日期类型"></a>时间日期类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date +%Y%m%d</span><br></pre></td></tr></table></figure><h6 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd 用户名</span><br><span class="line">passwd atguigu #设置密码</span><br></pre></td></tr></table></figure><h5 id="进程线程类"><a href="#进程线程类" class="headerlink" title="进程线程类"></a>进程线程类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -aux  查看系统中所有进程</span><br><span class="line">top 查看系统健康状态</span><br><span class="line">kill-9 id 终止进程,表示强迫进程立即停止</span><br></pre></td></tr></table></figure><p>touch 文件名  创建一个文件</p><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">top -u -kuailiang 可以查看自己账户下的进程</span><br><span class="line">或直接u后输入账号名称也可</span><br><span class="line">top下:</span><br><span class="line">shift + m 进程按照内存使用倒叙排</span><br><span class="line">shift + &gt;或&lt; 翻页</span><br><span class="line">shift + p 进程按照cpu使用情况倒叙排</span><br></pre></td></tr></table></figure><p>批量kill: ps -ef|grep main_func|grep -v grep|cut -c 9-15|xargs kill -9</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据挖掘概念与技术</title>
      <link href="/2019/12/30/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
      <url>/2019/12/30/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>必备知识概念</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">数据挖掘,最简单的就是统计应用,进一步基于用户的浏览点击,收藏推断用户的年龄,性别等,更深层次的如预测</span><br><span class="line">机器学习是实现数据挖掘的一种方法和手段</span><br><span class="line">数据的最基本形式是数据库数据、数据仓库数据、和事务数据</span><br><span class="line">数据仓库:是一个从多个数据源收集的信息存储库</span><br><span class="line">数据挖掘(data mining):旨在从大量的、不完全的、有噪声的、模糊的、随机的数据中，提取隐含在其中的、人们实现不知道、但又是潜在有用的信息和知识</span><br><span class="line">数据挖掘的主要任务是关联分析、聚类分析、分类、预测、时序模式和偏差分析</span><br><span class="line">关联分析：两个或两个以上变量的取值之间存在的规律性称为关联。数据关联是数据库中存在的一类重要的、可被发现的知识。</span><br><span class="line">关联分析分为简单关联、时序关联和因果关联。关联分析的目的是找出数据库中隐藏的关联网。一般用支持度和可信度两个阈值来度量关联规则的相关性,还不断引入兴趣度、相关性等参数，使得挖掘的规则更符合需求。</span><br><span class="line">数据挖掘的<span class="number">6</span>个步骤(基本)：</span><br><span class="line"><span class="number">1.</span>理解业务：从商业的角度理解项目目标和需求，将其转换为一种数据挖掘的问题定义</span><br><span class="line"><span class="number">2.</span>理解数据：收集初步的数据，进行数据的描述、数据探索和数据质量验证</span><br><span class="line"><span class="number">3.</span>准备数据：将最初始的原始数据构造成适合建模的数据集</span><br><span class="line"><span class="number">4.</span>建模： 选择和应用各种建模技术，并对其参数进行优化</span><br><span class="line"><span class="number">5.</span>建模评估：对模型进行较为彻底的评价，并检查构建模型的每个步骤，确定其是否真正实现了预定的商业目的</span><br><span class="line"><span class="number">6.</span>模型部署：</span><br></pre></td></tr></table></figure><p>数据挖掘的基本技术</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.统计学====&gt;即指将数据集合假设一个分布或者概率模型,然后按照模型采用相同的方法来进行挖掘</span><br><span class="line"><span class="number">2.</span>聚类分析和模式识别</span><br><span class="line"><span class="number">3.</span>决策树分类技术</span><br><span class="line"><span class="number">4.</span>人工神经网络和遗传基因算法</span><br><span class="line"><span class="number">5.</span>规则归纳</span><br><span class="line"><span class="number">6.</span>可视化技术</span><br><span class="line">7.关联规则 --&gt;关联可分为简单关联、时序关联、因果关联。目的是找出数据库中的隐藏的关联网</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据规范化:将数据按照指定比例进行缩放,映射到指定区域.  常用方法:min-max规范化,z-score规范化,按小数定标规范化</span><br><span class="line">数据规范化和数据标准化和数据归一化的区别: 数据规范化是一个大的概念,将不同渠道的数据按照同尺度进行度量,让数据句有可比较性。而数据归一化和数据标准化都是规范化的方式</span><br><span class="line">数据归一化：将数据映射到【<span class="number">0</span>，<span class="number">1</span>】的区间范围</span><br><span class="line">数据标准化是让规范化的数据呈现正态分布</span><br></pre></td></tr></table></figure><p>数据仓库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">数据仓库:是一个从多个数据源收集的信息存储,存放在一个一致的模式下,并通常驻留在单个站点</span><br><span class="line">数据仓库是一个面向主题的,集成的,随时间变化的,但信息本身相对稳定的数据集合,用于对管理决策过程的支持</span><br><span class="line">四个特点:</span><br><span class="line">    <span class="number">1.</span>面向主题:数据仓库都是基于某个明确主题,仅需要与主题相关的数据,无关细节数据被排除</span><br><span class="line">    <span class="number">2.</span>集成的:从不同的数据源采集数据到同一数据源</span><br><span class="line">    <span class="number">3.</span>随时间变化的:关键数据隐式或显式的基于时间变化</span><br><span class="line">    <span class="number">4.</span>数据仓库的数据是不可更新的:数据装入后一般只进行查询操作,没有传统数据库的增删改查</span><br><span class="line">数据仓库与数据库的区别:</span><br><span class="line">    数据仓库是数据哭的升级,从逻辑上来说,数据仓库与数据库没有区别,都是通过数据库软件实现的存放数据的地方,从数据量来说,数据仓库要比数据库更庞大的说.数据仓库主要用于数据挖掘和数据分析,辅助领导者做决策.数据仓库的表结构是依照分析需求,分析维度,分析指标进行设计的</span><br><span class="line">数据仓库架构图:</span><br><span class="line">    ODS层:为临时存储层,是接口数据的临时存储区域,为后一步的数据处理作准备.ods层的表通常包括两类,一类是用于存储当前需要加载的数据,一个用于存储处理完后的历史数据.数据粒度通常是最细的.</span><br><span class="line">    PDW层:为数据仓库层,pdw层的数据应该是一致的,准确的,干净的数据,即对源系统数据进行了清洗后的数据,数据粒度通常和ods层相同.</span><br><span class="line">    DM层:为数据集市层,这层数据是面向主题来组织数据的,通常是星型或者雪花结构的数据,从数据粒度来说轻度汇总级的数据.</span><br><span class="line">    APP层:为应用层,这层数据完全是为了满足具体的分析需求而构建的数据,也是星型或雪花结构的数据.从数据粒度来说是高度汇总的数据.</span><br><span class="line">为什么构建分离的数据仓库:</span><br><span class="line">    <span class="number">1.</span>提高两个系统的性能,操作数据库是为已知的任务和负载设计的,如使用主关键字索引和散列,检索特定的记录,和优化查询</span><br><span class="line">    <span class="number">2.</span>宁一方面数据仓库的查询通常是复杂的,涉及大量数据在汇总级别计算</span><br></pre></td></tr></table></figure><p>聚类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">聚类是一个把数据对象集划分成多个组或簇的过程,是的簇内的对象具有很高的相似性,但与其他簇的对象很不相似</span><br><span class="line">聚类的应用:数据分割和离群点检测(如信用卡欺诈检测)</span><br><span class="line"></span><br><span class="line">层次聚类:分为凝聚(自下而上)和分裂(自上而下)</span><br><span class="line">划分依据:距离(曼哈顿和欧式距离,但是只能聚成球状簇),密度(任意形状的簇,过滤噪声或离群点,将对象集划分成多个互斥的簇或簇的分层结构)</span><br><span class="line"></span><br><span class="line">聚类最本质最基本的是划分,他把对象组织成多个互斥的组或簇最著名的、最常用的为k均值和k中心点。</span><br><span class="line">k-均值（基于形心的划分技术（形心代表该簇），形心可以为该组对象的均值或者 中心点等）</span><br></pre></td></tr></table></figure><p>k-均值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">算法:k-均值.用于划分的k-均值算法,其中每个簇的中心都用簇中所有对象的均值来表示</span><br><span class="line">输入:</span><br><span class="line">    k:簇的数目</span><br><span class="line">    D:包含N个对象的数据集</span><br><span class="line">输出:k个簇的集合</span><br><span class="line">方法:</span><br><span class="line">    <span class="number">1</span>)从D中任意选择k个对象作为初始簇中心</span><br><span class="line">    <span class="number">2</span>)repeat</span><br><span class="line">    <span class="number">3</span>)根据簇中对象的均值,将每个对象分配到最相思的簇</span><br><span class="line">    <span class="number">4</span>)更新簇均值,即重新计算每个簇对象的均值</span><br><span class="line">    <span class="number">5</span>)until不在发生变化</span><br><span class="line">不能保证得到的结果为全局最优解,通常情况下都是局部最优解,变种,k-众数</span><br><span class="line"></span><br><span class="line">怎样提高k-均值算法的可伸缩性?</span><br><span class="line"><span class="number">1.</span>在聚类时使用合适规模的的样本</span><br><span class="line"><span class="number">2.</span>使用过滤方法,使用空间层次数据索引节省计算均值的开销</span><br><span class="line"><span class="number">3.</span>利用微聚类的方法,首先把临近的对象划分到微簇中,然后对这些微簇使用k-均值方法进行聚类</span><br><span class="line"></span><br><span class="line">K-Means是个简单实用的聚类算法，这里对K-Means的优缺点做一个总结。</span><br><span class="line">　　　　·K-Means的主要优点有：</span><br><span class="line">　　　　<span class="number">1</span>）原理比较简单，实现也是很容易，收敛速度快。</span><br><span class="line">　　　　<span class="number">2</span>）聚类效果较优。</span><br><span class="line">　　　　<span class="number">3</span>）算法的可解释度比较强。</span><br><span class="line">　　　　<span class="number">4</span>）主要需要调参的参数仅仅是簇数k。</span><br><span class="line">　　　　·K-Means的主要缺点有：</span><br><span class="line">　　　　<span class="number">1</span>）K值的选取不好把握</span><br><span class="line">　　　　<span class="number">2</span>）对于不是凸的数据集比较难收敛</span><br><span class="line">　　　　<span class="number">3</span>）如果各隐含类别的数据不平衡，比如各隐含类别的数据量严重失衡，或者各隐含类别的方差不同，则聚类效果不佳。</span><br><span class="line">　　　　<span class="number">4</span>）采用迭代方法，得到的结果只是局部最优。</span><br><span class="line">　　　　<span class="number">5</span>）对噪音和异常点比较的敏感。</span><br></pre></td></tr></table></figure><p>k-中心点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">k-均值算法对离群点敏感,因为存在对象远离大多数数据,因此分配到一个簇时候可能严重影响簇的均值。而k-中心点聚类的基本思想和K-means的思想相同，实质上是对K-means算法的优化和改进。</span><br><span class="line">算法步骤：</span><br><span class="line">（<span class="number">1</span>）确定聚类的个数K。</span><br><span class="line">（<span class="number">2</span>）在所有数据集合中选择K个点作为各个聚簇的中心点。</span><br><span class="line">（<span class="number">3</span>）计算其余所有点到K个中心点的距离，并把每个点到K个中心点最短的聚簇作为自己所属的聚簇。</span><br><span class="line">（<span class="number">4</span>）在每个聚簇中按照顺序依次选取点，计算该点到当前聚簇中所有点距离之和，最终距离之后最小的点，则视为新的中心点。</span><br><span class="line">（<span class="number">5</span>）重复（<span class="number">2</span>），（<span class="number">3</span>）步骤，直到各个聚簇的中心点不再改变。</span><br></pre></td></tr></table></figure><p>5种主要聚类算法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.k-means聚类(优化:k-medians)原理见上面   ===&gt;优势:速度非常快,只计算了点和群中心的距离  缺点:离群值点较敏感,同时还需要确定划分的组数/类,也会影响最终的结果.</span><br><span class="line"><span class="number">2.</span>均值偏移聚类算法 一种基于滑动窗口的算法,试图找到密集的数据点(如:给定一个半径的圆移动直至圆里面点的数量最大),均值偏移是一个爬山算法,他需要在每步中反复地将这个内核移动到一个更高的密度区域,直到收敛.  优势:与k-means相比,均值偏移不需要选择聚类的数量,他会自动的发现. 缺点是:窗口大小和半径的选取非常重要.</span><br><span class="line"><span class="number">3.</span>DBSCAN聚类算法:比较代表性的基于密度的聚类算法,类似均值偏移聚类算法  优势:不需要预设定的聚类数量,并且将异常值识别为噪声,同时可以很好的找到任意形状和大小的簇类.   缺点:当聚类具有不同密度的时候,他的性能不像其他聚类算法那样好.当密度变化的时候,距离阈值和识别临近点的minpoints的设置会随着聚类的不同而变化.</span><br><span class="line"><span class="number">4.</span>层次聚类算法:分为自下而上和自上而下.自下而上指的是一开始将每个数据点视为一个单一的聚类,然后依次合并(聚集类),知道所有的类合并成一个包含所有数据点的单一聚类,自上而下的层次聚类称为合成聚类或HAC.(选择一个度量两个聚类之间距离的距离变量如平均连接聚类) 优势:无需确定聚类的数量,对距离度量的选择不敏感.(是以低效率为代价的)</span><br><span class="line"><span class="number">5.</span>使用高斯混合模型(GMM)和期望最大化(EM)聚类  初始选择聚类的数量,给定每个聚类的高斯分布,计算每个点属于特定簇的概率,离中心越近越可能属于那个聚类.基于这些概率,我们为高斯分布计算一组新的参数,这样我们就能最大程度的利用聚类中的数据点的概率.</span><br></pre></td></tr></table></figure><p>文本挖掘</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文本数据挖掘跟自然语言处理不是一回事,但是有很多的相通之处</span><br><span class="line">自然语言处理是计算机科学领域与人工智能领域的一个重要方向.它研究能实现人与计算机之间用自然语言进行有效通信的各种理论和方法.</span><br><span class="line">文本挖掘利用智能算法,分析大量的非结构化文本源,抽取或标记关键字概念,文本挖掘是一个多学科混杂的领域,包括数据挖掘技术、信息检索、机器学习、自然语言处理、计算机语言学、统计数据分析、线性几何、概率论、图论等等。（总结：将结构化数据挖掘技术应用于文本数据）</span><br><span class="line"></span><br><span class="line">理论上自然语言处理是文本挖掘的基础</span><br></pre></td></tr></table></figure><p>谱聚类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">谱:方阵作为线性算子,它的所有特征值得全体称为方阵的谱.方阵的谱半径为最大的特征值.矩阵A的谱半径为矩阵A转置A的最大特征值</span><br><span class="line"></span><br><span class="line">谱聚类:谱聚类是一种基于图论的聚类方法,通过对样本数据的拉普拉斯矩阵的特征向量进行聚类</span><br><span class="line">的目的.谱聚类可以理解为将高维空间的数据映射到低维,然后在低维空间用其他聚类算法进行聚类.</span><br><span class="line">谱聚类算法的描述:</span><br><span class="line">    <span class="number">1.</span>输入:n个样本点X=&#123;X1,X2,.....,Xn&#125;和聚类簇的数目k</span><br><span class="line">    <span class="number">2.</span>输出:聚类簇A1,A2,...Ak</span><br><span class="line">    (<span class="number">1</span>)计算n*n的相似度矩阵W</span><br><span class="line">    (<span class="number">2</span>)计算对角矩阵D</span><br><span class="line">    (<span class="number">3</span>)计算拉普拉斯矩阵L = D - W</span><br><span class="line">    (<span class="number">4</span>)计算L的特征值,将特征值从小到大排序,取前K个特征值,并计算前k个特征值的特征向量</span><br><span class="line">    (<span class="number">5</span>)将特征向量组成矩阵U</span><br><span class="line">    (<span class="number">6</span>)使用k-means算法将新样本点Y=&#123;Y1,Y2,....,Yn&#125;聚类成簇C1,C2,....,Ck</span><br><span class="line">    (<span class="number">7</span>)输出A1,A2,A3....,Ak</span><br><span class="line">相似度矩阵:</span><br><span class="line">    相似度矩阵就是样本中点的距离,在聚类算法中可以表示为距离近的点他们之间的相似度比较高,而距离远的点他们之间的相似度低,甚至可以忽略.表示相似度矩阵的三种方式:<span class="number">1.</span>KNN <span class="number">2.</span>伊普西塔-近邻法 <span class="number">3.</span>全连接法</span><br></pre></td></tr></table></figure><p>数学概念</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>中心趋势度量:均值、中位数、众数</span><br><span class="line">截尾均值：丢掉高低极端值后的均值</span><br><span class="line">加权算术均值(加权平均)</span><br><span class="line">中位数:是有序数据的中间值,对于非对称数据是数据中心跟好的度量</span><br><span class="line">极差:最大值与最小值之差, 分位数:取自数据分布的每隔一定间隔上的点,把数据划分为基本上大小相等的连贯集合,<span class="number">2</span>-分位相当于中位数,<span class="number">4</span>-分位相当于三个数据点</span><br><span class="line">五数概括:识别可疑离群点的通常规则是,挑选落在第三个四分位数之上</span><br><span class="line">标称属性:</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据挖掘概念与技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pandas数据处理</title>
      <link href="/2019/12/25/pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
      <url>/2019/12/25/pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>###pandas数据算术运算</p><p>pandas元素相加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df1+df2</span><br></pre></td></tr></table></figure><p>pandsa和series相减</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df1-s1</span><br></pre></td></tr></table></figure><p>apply和applymap</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#apply操作DataFrame的每一列,而applymap操作DataFrame的每一个元素</span></span><br><span class="line">f1 = <span class="keyword">lambda</span> x : <span class="string">"%.3f"</span>%x</span><br><span class="line">df1.applymap(f1)</span><br><span class="line">f2 = <span class="keyword">lambda</span> x:x.max() - x.min()</span><br><span class="line">df1.apply(f2)</span><br></pre></td></tr></table></figure><h3 id="pandas数据修改"><a href="#pandas数据修改" class="headerlink" title="pandas数据修改"></a>pandas数据修改</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>数据复制-直接赋值</span><br><span class="line">df1 = df.head()</span><br><span class="line">df1.iloc[<span class="number">0</span>,<span class="number">0</span>]  <span class="comment">#原数据</span></span><br><span class="line">df.iloc[<span class="number">0</span>,<span class="number">0</span>] = <span class="number">10</span> <span class="comment">#对应df1的数据也会变化</span></span><br><span class="line"><span class="number">2.</span>数据复制-copy()函数</span><br><span class="line">df1 = df.head().copy()  </span><br><span class="line">df1.iloc[<span class="number">0</span>,<span class="number">0</span>]  <span class="comment">#原数据</span></span><br><span class="line">df.iloc[<span class="number">0</span>,<span class="number">0</span>] = <span class="number">10</span> <span class="comment">#对应df1的数据不会变化</span></span><br><span class="line"><span class="number">3.</span>行列删除</span><br><span class="line">  ·删除一列 <span class="keyword">del</span> df1[<span class="string">'sad'</span>]</span><br><span class="line">  ·删除多列 pd.drop([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>],axis=<span class="number">1</span>)</span><br><span class="line">  ·删除一列并赋值  pd.pop()</span><br><span class="line">  ·删除行 pd.drop([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>],axis=<span class="number">0</span>)</span><br><span class="line"><span class="number">4.</span>列增加</span><br><span class="line">  ·[],列名方式增加多列  df[<span class="string">'s1'</span>,<span class="string">'s2'</span>] = </span><br><span class="line">  ·loc,不能新增多列  pd.loc[:,<span class="string">'new_column'</span>] = </span><br><span class="line">  ·insert 在指定位置  df1.insert(<span class="number">4</span>,<span class="string">'ss'</span>,np.linspace(<span class="number">0</span>,<span class="number">1</span>,len(train1 )))</span><br><span class="line"><span class="number">5.</span>行增加</span><br><span class="line">  ·pd.loc[:<span class="string">'new_index'</span>] =</span><br></pre></td></tr></table></figure><h4 id="索引顺序调整"><a href="#索引顺序调整" class="headerlink" title="索引顺序调整"></a>索引顺序调整</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>同时调整行和列</span><br><span class="line">  reindex(index=,columns=[])</span><br><span class="line"><span class="number">2.</span>单独调整行或列</span><br><span class="line">  reindex_axis()</span><br></pre></td></tr></table></figure><h4 id="列格式修改"><a href="#列格式修改" class="headerlink" title="列格式修改"></a>列格式修改</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">astype(dtype.copy=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h4 id="数据排序"><a href="#数据排序" class="headerlink" title="数据排序"></a>数据排序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pd.sort_index(axis,ascending=,inplace)</span><br><span class="line">pd.sort_values(by=<span class="string">'a'</span>,ascending=<span class="literal">False</span>,inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h4 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df2 = df.T</span><br><span class="line">df3 = df.transpose()</span><br></pre></td></tr></table></figure><h4 id="重复值"><a href="#重复值" class="headerlink" title="重复值"></a>重复值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>重复值查看</span><br><span class="line">  ·df.duplicated() 返回的为布尔值   duplicated(subset = <span class="literal">None</span> ,keep=<span class="string">'first'</span>,inplace=<span class="literal">False</span>)</span><br><span class="line"><span class="number">2.</span>删除重复值</span><br><span class="line">  drop_duplicates() <span class="comment">#默认所有列去重,可以选择指定列</span></span><br></pre></td></tr></table></figure><p>####部分值替换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df1.replace([<span class="number">-99</span>,<span class="number">-100</span>],[NA,<span class="number">0</span>]) <span class="comment">#替换多个值为不同值</span></span><br><span class="line">df1.replace(&#123;<span class="number">-99</span>:Na,<span class="number">33</span>:<span class="number">0</span>&#125;) <span class="comment">#替换指定数据为指定值</span></span><br><span class="line">df1.replace([<span class="number">1</span>,<span class="number">2</span>],Na)  <span class="comment">#替换为同一个值</span></span><br></pre></td></tr></table></figure><h4 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#缺失值确认:isnull、notnull</span></span><br><span class="line"><span class="comment">#缺失值处理：dropna、fillna</span></span><br><span class="line">df1.dropna() <span class="comment">#删除存在Nan的所有行</span></span><br><span class="line">df1.dropna(axis=<span class="number">1</span>,how=<span class="string">"all"</span>) <span class="comment">#删除所有行数据全为Nan的列 </span></span><br><span class="line">df2.fillna(&#123;<span class="number">1</span>:<span class="number">111</span>,<span class="number">4</span>:<span class="number">444</span>&#125;) <span class="comment">#传入字典,将第一列和第四列的所有空值都替换成指定的数据</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pandas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql进阶知识点汇总</title>
      <link href="/2019/12/24/mysql%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
      <url>/2019/12/24/mysql%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>mysql引擎</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">水平分表:当一个表的数据太大时效率大大降低,水平分表就是将整个大表拆成不同的小表,每一次查询会判断数据在哪个表中,每一次查询会判断在那个表中,然后对应去查找,提高效率</span><br><span class="line">垂直分表:当表中某些字段不常用的时候可以把不常用的字段切到宁一个表中,然后建立关联关系</span><br><span class="line">innodb:最常用的引擎,支持事务,行锁,外键等</span><br><span class="line">MyISAM:存储效率高,支持分表</span><br><span class="line">Memory:速度快</span><br></pre></td></tr></table></figure><p>mysql锁机制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">锁原理:锁是计算机协调多个进程或线程并发访问某一资源的机制</span><br><span class="line">分类: 一.对数据操作的类型划分为读锁和写锁</span><br><span class="line">·读锁(共享锁):针对同一份数据,多个读操作可以同时进行而不会相互影响</span><br><span class="line">·写锁(排它锁):当前写操作没完成时会阻断其他写锁和读锁</span><br><span class="line">总:读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞</span><br><span class="line">     二.对数据操作粒度划分为表锁、行锁和页锁</span><br><span class="line">     ·Mysiam、memory支持表锁，innodb既支持表锁也支持行锁,innodb与mysiam的最大区别一个是支持事务,宁一个就是支持行锁</span><br><span class="line">三种锁的区别</span><br><span class="line">表锁:开销小,加锁快,不会出现死锁,发生锁冲突的概率最高,并发度最低</span><br><span class="line">行锁:开销大,加锁慢,会出现死锁,发生锁冲突的概率最低,并发度最高</span><br><span class="line">页锁:开销介于表和行锁之间,会出现死锁,并发度一般</span><br><span class="line">mysql行锁变表锁,Innodb只有在通过索引条件检索数据时使用行级锁,否则使用表锁</span><br><span class="line">总结:Innodb的行锁是针对索引加的锁,不是针对记录加的锁.并且该索引不会失效,否则都会从行锁升级为表锁.</span><br><span class="line">表锁加锁方式:自动加锁,查询操作,会自动给涉及的所有表加读锁,更新操作(update,delete,insert),会自动给涉及的表加锁</span><br><span class="line">行锁加锁方式:自动加锁,对于update,delete和insert,innodb会自动给涉及数据集加排它锁,对于普通select语句,Innodb不会加任何锁,当然我们也可以显示的加锁</span><br><span class="line">表锁读锁会阻塞写但不会阻塞读,而写锁则会把读写都阻塞</span><br></pre></td></tr></table></figure><p>mysql的索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql中索引的存储类型有两种BTREE和HASH,也就是用树或者hash值来存储该字段</span><br><span class="line">Myisam和InnoDB引擎只支持BTREE索引</span><br><span class="line">Memory 支持HASH和BTREE索引</span><br><span class="line">分类(常用):</span><br><span class="line">    ·单列索引:只有一列的索引,</span><br><span class="line">    ·组合索引:在表中的多个字段组合上创建的索引(最左前缀原则)</span><br><span class="line">    ·全文索引:只在myisam引擎上才能使用</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pandas数据分析书籍内容</title>
      <link href="/2019/12/18/pandas%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%A6%E7%B1%8D%E5%86%85%E5%AE%B9/"/>
      <url>/2019/12/18/pandas%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%A6%E7%B1%8D%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<p>针对Series和Pandas如果传入的列没有数据则默认全部为nan值</p><h3 id="Series方法"><a href="#Series方法" class="headerlink" title="Series方法"></a>Series方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">s1.values</span><br><span class="line">s1.index</span><br><span class="line">s1.reset_index</span><br><span class="line">s1.isnull</span><br><span class="line">s1.notnull</span><br><span class="line">s1.sort_values</span><br><span class="line">s1.sort_index</span><br><span class="line">df.reindex([])  重造索引,不存在的值为nan,也可以使用fill_value=自己补值,也可以method向前向后填充</span><br><span class="line">s1+s1会按照索引相加减,索引不同的值为nan</span><br><span class="line">s1.index.is_unique</span><br><span class="line">s1.rank()</span><br><span class="line">s1.unique()</span><br><span class="line">s1.value_counts()</span><br><span class="line">s1.isin(容器)</span><br></pre></td></tr></table></figure><p>###Pandas方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">df.字段名 == df [<span class="string">'字段名'</span>]</span><br><span class="line"><span class="keyword">del</span> 删除列 drop默认删除行,axis=<span class="number">1</span>表示列</span><br><span class="line">df.T</span><br><span class="line">df3.index.name</span><br><span class="line">df3.columns.name</span><br><span class="line">df.reset_index 重置索引</span><br><span class="line">df.sort_index() 里面加by可以针对某列效果同sort_values</span><br><span class="line">df.sort_values()</span><br><span class="line">df.rank(ascending,method)</span><br><span class="line">df.columns/index/具体字段名.is_unique</span><br><span class="line">df.sum\max\min\consum\describe</span><br><span class="line">df[<span class="string">'one'</span>].unique()</span><br><span class="line">df[<span class="string">'one].isin(容器)</span></span><br><span class="line"><span class="string">df.fillna()</span></span><br><span class="line"><span class="string">fillna\dropna</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python代码规范</title>
      <link href="/2019/12/16/Python%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>/2019/12/16/Python%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h4 id="函数规范"><a href="#函数规范" class="headerlink" title="函数规范"></a>函数规范</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#声明函数的作用以及各个参数的用法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a,b,c)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    :param a: </span></span><br><span class="line"><span class="string">    :param b: </span></span><br><span class="line"><span class="string">    :param c: </span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    '''</span></span><br></pre></td></tr></table></figure><h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">四个空格或者直接使用tab符号</span><br></pre></td></tr></table></figure><h4 id="行最大长度"><a href="#行最大长度" class="headerlink" title="行最大长度"></a>行最大长度</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每行代码最大字符不超过<span class="number">80</span>个</span><br></pre></td></tr></table></figure><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类与类之间空两行</span><br><span class="line">类中方法与方法空<span class="number">1</span>行,类与方法空一行</span><br><span class="line">类命名使用驼峰命名法</span><br></pre></td></tr></table></figure><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单行注释：若注释独占一行，<span class="comment">#号顶头，空1格后写注释；若是行尾注释，空2格后#号再空1格写注释</span></span><br><span class="line">多行注释：三对双引号（推荐使用）和三对单引号</span><br><span class="line">复杂逻辑一定要写注释</span><br></pre></td></tr></table></figure><h4 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">自然语言使用双引号,机器标识使用单引号,代码里多数使用单引号</span><br><span class="line">正则表达式使用双引号</span><br><span class="line">解释说明文档使用三引号(三单或三双)</span><br></pre></td></tr></table></figure><h4 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">模块级函数和类定义之间空两行</span><br><span class="line">类成员函数之间空一行</span><br><span class="line">函数中可以使用空行分隔出逻辑相关的代码</span><br></pre></td></tr></table></figure><h4 id="开头规范"><a href="#开头规范" class="headerlink" title="开头规范"></a>开头规范</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on 2019-11-26  代码简化  多进程</span></span><br><span class="line"><span class="string">@author: lxy</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h4 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>语句应该分开写不推荐一下写两个</span><br><span class="line"><span class="keyword">import</span>语句应该按照顺序排列,每组之间用一个空行分隔</span><br><span class="line">模块尽量使用小写命名，首字母保持小写，尽量不要用下划线(除非多个单词，且数量不多的情况)</span><br><span class="line"><span class="comment"># 正确的模块名</span></span><br><span class="line"><span class="keyword">import</span> decoder</span><br><span class="line"><span class="keyword">import</span> html_parser</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐的模块名</span></span><br><span class="line"><span class="keyword">import</span> Decoder</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确的写法</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐的写法</span></span><br><span class="line"><span class="keyword">import</span> sys,os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确的写法</span></span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> Popen, PIPE</span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数名一律小写,如有多个单词,用下划线隔开</span><br><span class="line">私有函数在函数前加一个下划线</span><br></pre></td></tr></table></figure><h4 id="变量名命名规则"><a href="#变量名命名规则" class="headerlink" title="变量名命名规则"></a>变量名命名规则</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">变量严格区分大小写</span><br><span class="line">变量不能以数字开头</span><br><span class="line">变量不能含有特殊符号</span><br><span class="line">变量不能含有中文</span><br><span class="line">变量命名要有实际意义</span><br></pre></td></tr></table></figure><h4 id="编码建议"><a href="#编码建议" class="headerlink" title="编码建议"></a>编码建议</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>编码中要考虑其他Python实现的效率问题,比如运算符‘+’在CPython（Python）中效率很高，都是Jython中却非常低，所以应该采用.join()的方式。</span><br><span class="line"><span class="number">2.</span>尽可能使用<span class="keyword">is</span> <span class="keyword">is</span> <span class="keyword">not</span> 取代 == </span><br><span class="line"><span class="number">3.</span>异常中<span class="keyword">try</span>的代码尽可能少</span><br><span class="line"><span class="number">4.</span>startswith()和endswith()优于切片前缀或后缀查看</span><br><span class="line"><span class="number">5.</span>字符串不要以空格结尾</span><br><span class="line"><span class="number">6.</span>二进制数据判断,使用<span class="keyword">if</span> boolvalue的方式</span><br></pre></td></tr></table></figure><p><img src="/2019/12/16/Python代码规范/python规范.png" alt="1576560854824"></p>]]></content>
      
      
      <categories>
          
          <category> 规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python将列表分成很多小列表</title>
      <link href="/2019/11/26/python%E5%B0%86%E5%88%97%E8%A1%A8%E5%88%86%E6%88%90%E5%BE%88%E5%A4%9A%E5%B0%8F%E5%88%97%E8%A1%A8/"/>
      <url>/2019/11/26/python%E5%B0%86%E5%88%97%E8%A1%A8%E5%88%86%E6%88%90%E5%BE%88%E5%A4%9A%E5%B0%8F%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h5 id="方法1-推荐"><a href="#方法1-推荐" class="headerlink" title="方法1:推荐"></a>方法1:推荐</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">15</span>)]</span><br><span class="line">n = <span class="number">3</span>  <span class="comment">#大列表中几个数据组成一个小列表</span></span><br><span class="line">ls[i:i+n] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(ls),n)</span><br></pre></td></tr></table></figure><p>#####方法2:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_of_groups</span><span class="params">(init_list, childern_list_len)</span>:</span></span><br><span class="line">    list_of_group = zip(*(iter(init_list),) *childern_list_len)</span><br><span class="line">    end_list = [list(i) <span class="keyword">for</span> i <span class="keyword">in</span> list_of_group]</span><br><span class="line">    count = len(init_list) % childern_list_len</span><br><span class="line">    end_list.append(init_list[-count:]) <span class="keyword">if</span> count !=<span class="number">0</span> <span class="keyword">else</span> end_list</span><br><span class="line">    <span class="keyword">return</span> end_list</span><br><span class="line">list_of_groups(ls,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>re模块断言</title>
      <link href="/2019/11/21/re%E6%A8%A1%E5%9D%97%E6%96%AD%E8%A8%80/"/>
      <url>/2019/11/21/re%E6%A8%A1%E5%9D%97%E6%96%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<p>对于<title>xxx</title>这种格式当我们想要获取title的标题内容的时候,方法一是通过的括号分组实现,宁外一种方法就是断言</p><p>pattern = re.compile(‘(?&lt;=title&gt;).*(?=)’)<br>re.findall(pattern,’<title>xxx</title>‘)</p><table><thead><tr><th>断言条件</th><th>解释</th></tr></thead><tbody><tr><td>(?=exp)</td><td>匹配exp前面的位置</td></tr><tr><td>(?!exp)</td><td>匹配后面跟的不是exp的内容</td></tr><tr><td>(?&lt;=exp)</td><td>匹配exp后面的内容</td></tr><tr><td>(?&lt;!exp)</td><td>匹配前面不是exp的位置</td></tr><tr><td>(?:exp)</td><td>匹配exp,不捕获匹配的文本,也不给此分组分配组号</td></tr><tr><td>(exp)</td><td>匹配exp,并捕获文本到自动命名的组里</td></tr></tbody></table><p>匹配exp前面后匹配exp后面的可以一起使用,这样就可以获取到中间的数据了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.   表示一切字符</span><br><span class="line">\   起转义作用</span><br><span class="line">[...]  方括号中的任意字符</span><br><span class="line">\d   数字0-9</span><br><span class="line">\D    非数字</span><br><span class="line">\w   数字,字母,下划线</span><br><span class="line">\W   非数字,字母下划线</span><br><span class="line">\s   空格换行符等</span><br><span class="line">\S   非空格</span><br><span class="line">*   前面字符&gt;=0</span><br><span class="line">+   &gt;=1</span><br><span class="line">?   0或1</span><br><span class="line">&#123;m&#125;  匹配m次</span><br><span class="line">&#123;m,n&#125; 匹配m到n次</span><br><span class="line">&#123;m,&#125;  至少匹配m次</span><br></pre></td></tr></table></figure><h5 id="re模块字符串匹配"><a href="#re模块字符串匹配" class="headerlink" title="re模块字符串匹配"></a>re模块字符串匹配</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">方式1 :re.findall(r&apos;([a-z]):&apos;,s1,re.I)   #匹配获得所有括号内的内容,re.I表示不分大小写</span><br><span class="line">方式2 :patten = re.compile(r&apos;\d+&apos;)</span><br><span class="line">  patten.findall(s1)</span><br><span class="line">s = &apos;sim@163.com work-da intrest:pingpang&apos;</span><br><span class="line">re.split(&apos;[@\-:\s+]&apos;,s)</span><br><span class="line">返回结果: [&apos;sim&apos;, &apos;163.com&apos;, &apos;work&apos;, &apos;da&apos;, &apos;intrest&apos;, &apos;pingpang&apos;]</span><br><span class="line">re.sub(&apos;1.5[lLtT]&apos;,&apos;1.5L&apos;,s)  #将1.5l,1.5t,1.5T全部替换为1.5L</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> re正则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PCA降维</title>
      <link href="/2019/11/21/PCA%E9%99%8D%E7%BB%B4/"/>
      <url>/2019/11/21/PCA%E9%99%8D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="PCA主成分分析"><a href="#PCA主成分分析" class="headerlink" title="PCA主成分分析"></a>PCA主成分分析</h2><p>1.降维的概念:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">降维是一种对高维度数据预处理的方法,保留重要的特征,去除噪声和不重要的特征,从而实现提升数据处理速度的目的.</span><br><span class="line">降维的方法:</span><br><span class="line">1.SVD奇异值分解</span><br><span class="line">2.PCA主成分分析(使用最广泛)</span><br><span class="line">3.FA因子分析</span><br><span class="line">4.ICA独立成分分析</span><br></pre></td></tr></table></figure><p>2.PCA的概念</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">思想是将n为特征映射到k维上,k维为全新的正交特征,也被称为主成分.第一个坐标轴为原始数据中方差最大的方向,第二个坐标轴是与第一个坐标轴正交的平面中使得方差最大的,第三个轴是与第一、二个轴正交的平面中方差最大的.后面的坐标轴的方差几乎为<span class="number">0</span>,可以忽略,从而实现降维.</span><br></pre></td></tr></table></figure><p>如何获得主成分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算数据矩阵的协方差矩阵,得到协方差矩阵的特征值、特征向量，选择特征值最大的k个特征所对应的特征向量组成的矩阵。这样就实现了降维。====获取特征值、特征向量的两种方法，特征值分解和奇异值分解</span><br></pre></td></tr></table></figure><p>sklearn调用PCA</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">X = np.array([[<span class="number">-1</span>,<span class="number">2</span>],[<span class="number">-1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>]])</span><br><span class="line">pca=PCA(n_components=<span class="number">1</span>)</span><br><span class="line">pca.fit(X)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据预处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遇到的问题及总结</title>
      <link href="/2019/11/21/%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2019/11/21/%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span>Series重命名s1.name=<span class="string">'hello'</span>,rename不好使</span><br><span class="line"><span class="number">3.</span>方差是协方差的特殊情况，两者公式基本无差别，方差针对一维，协方差针对二维，n<span class="number">-1</span>对应无偏估计</span><br><span class="line"><span class="number">4.</span>re模块.想要匹配换行符时候,可以在pattern里面添加re.DOTALL</span><br><span class="line">eg:pattern = re.compile(<span class="string">'&lt;meta name="description" content="(.*)?_百度百科'</span>,re.DOTALL)</span><br><span class="line">re.findall(pattern,response.text)</span><br><span class="line">5.re模块断言(?&lt;="description" content=) 匹配"description" content=后面的内容,除了findall能匹配括号内的内容,正常会将条件全部获取到,而断言可以实现只获取指定部分.</span><br></pre></td></tr></table></figure><table><thead><tr><th>问题</th><th>出现原因</th><th>错误表现</th><th>解决方法</th></tr></thead><tbody><tr><td>mysql死锁</td><td>查询和删除同时进行,或者连接未关闭进行删除操作等</td><td>Navicat打不开表,一直显示正在加载</td><td>首先show processlist查询状态中有lock字样的进程id,然后分别杀死</td></tr><tr><td>数据仓库和数据库的区别</td><td>看书想到的</td><td>概念性</td><td>数据仓库(DataWareHouse,DW或DWH)是一种面向主题,集成的,稳定的,反映历史变化的数据集合,用于支持管理决策.面向主题:数据仓库中的数据按照一定的主题域进行组织.集成:原有分散的数据库数据经过系统加工,消除源数据中的不一致性相对稳定:指一旦某个数据进入数据仓库后只需定期的加载和更新反映历史变化:指通过信息,对企业未来趋势定量做出分析预测.数据仓库与数据库区别:1.数据库是面向事务的,而数据仓库是面向主题设计的2.数据库中存储的一般为实时数据,而数据仓库一般为历史数据3.数据库设计尽量避免冗余,而数据仓库是有意引入冗余4.数据库是为了存储数据设计的,而数据仓库是为了分析数据引入的.</td></tr><tr><td>内存泄漏</td><td>代码出现</td><td></td><td>指程序中动态分配的堆内存由于某种原因程序未释放或无法释放,造成内存的浪费,导致程序运行缓慢甚至系统崩溃的后果</td></tr><tr><td>折旧率</td><td>代码出现</td><td></td><td>折旧率指的是一个物品在使用一段时间后，其市场价格的变化率，例如一部汽车用100万元购入，经过一年如果想脱手，大概只能卖70万，要折价30万才卖得掉，这部车的首年折旧率就是30%，在卖方来说，折旧率低表示使用成本低，当然折旧率越低越好</td></tr><tr><td>SSH</td><td>想到的</td><td></td><td>SSH 为 Secure Shell,SSH是一种网络协议，用于计算机之间的加密登录</td></tr><tr><td>NULL</td><td>mysql必知必会</td><td></td><td>NULL表示无值,与空字符串、空格等均不同。要使用IS NULL或者IS NOT  NULL去判断,通常不返回他们,返回整条数据或者其他字段</td></tr><tr><td>mysql操作符优先级</td><td>mysql必知必会</td><td></td><td>在无括号情况下,and的优先级高于or</td></tr><tr><td>mysql模糊匹配区分大小写</td><td>mysql必知必会</td><td></td><td>正常情况不区分大小写,SELECT * FROM  kl WHERE BINARY name like ‘C%’ (binary也可以放到like后面,或者在建表的时候字段限制时候使用binary也可以)</td></tr><tr><td>mysql字段拼接</td><td>mysql必知必会</td><td></td><td>SELECT CONCAT(company,’:’,’参保人数:’,insured_num) FROM kl</td></tr><tr><td>mysql去除字段左右的空格</td><td>mysql必知必会</td><td></td><td>TRIM()去除左右两边的空格.ltrim()去除左边的空格,rtrim()去除右侧的空格</td></tr><tr><td>mysql文本处理函数</td><td>mysql必知必会</td><td></td><td>UPPER()将小写转换为大写,LOWER()将大写转换为小写,LENGTH()返回字 符的长度,一个中文3个字符</td></tr><tr><td>时间日期函数</td><td>mysql必知必会</td><td></td><td>DATE()转为日期格式yyyy-mm-dd,year()返回年份,curdate()返回当前日期,curtime()返回当前时间,DATEDIFF()计算两个日期之差,time、day、month、minute、second、hour一样适用</td></tr><tr><td>数值处理函数</td><td>mysql必知必会</td><td></td><td>sin、cos、tan、pi、abs、sqrt等函数均支持，以及聚合函数avg、min、max、sum、count，注意：AVG()函数忽略列值为NULL的行。如果指定列名，则指定列的值为空的行被COUNT()函数忽略，但如果COUNT()函数中用的是星号（*），则不忽略。</td></tr><tr><td>获取列表\元组对应的索引和具体的内容</td><td>代码</td><td></td><td>enumerate  —&gt;     for  key,value in enumerate()</td></tr><tr><td>Python有哪些常见的web框架</td><td>问题</td><td></td><td>常用Flask\Django,其中flask属于轻量级适合刚入门的使用,Django需要了解很多的知识,全能型框架.   除此以外,还有性能高的tornado,基本的web.py以及对应二次开发web2.py,以及豆瓣所使用的的quixote框架</td></tr><tr><td>代码忽略警告</td><td>代码</td><td></td><td>import  warnings <br><br>warnings.filterwarnings(‘ignore’)</td></tr><tr><td>.spydata文件读取</td><td></td><td></td><td>001</td></tr></tbody></table><p>#####001.spydata文件读取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> tarfile</span><br><span class="line"><span class="comment"># open a .spydata file</span></span><br><span class="line">filename = <span class="string">'D:\谷歌下载\技术统一表.spydata'</span></span><br><span class="line">tar = tarfile.open(filename, <span class="string">"r"</span>)</span><br><span class="line"><span class="comment"># extract all pickled files to the current working directory</span></span><br><span class="line">tar.extractall()</span><br><span class="line">extracted_files = tar.getnames()</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> extracted_files:</span><br><span class="line">    <span class="keyword">if</span> f.endswith(<span class="string">'.pickle'</span>):</span><br><span class="line">         <span class="keyword">with</span> open(f, <span class="string">'rb'</span>) <span class="keyword">as</span> fdesc:</span><br><span class="line">            data = pickle.loads(fdesc.read())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> day_analyse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作常用函数总结</title>
      <link href="/2019/11/21/%E5%B7%A5%E4%BD%9C%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/"/>
      <url>/2019/11/21/%E5%B7%A5%E4%BD%9C%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>####将结果存excel</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">writer=pd.ExcelWriter(<span class="string">r'C://user/desktop'</span>)</span><br><span class="line">data.to_excel(writer,sheet_name=<span class="string">'heet1'</span>)</span><br><span class="line">writer.save()</span><br></pre></td></tr></table></figure><h4 id="从excel读取数据"><a href="#从excel读取数据" class="headerlink" title="从excel读取数据"></a>从excel读取数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.read_excel(<span class="string">r'C:\users\adminstrator\desktop'</span>,sheet_name=<span class="string">'Sheet1'</span>)</span><br></pre></td></tr></table></figure><p>####从mysql读取数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conn=pymysql.connect(host=<span class="string">'localhost'</span>,user=<span class="string">'root'</span>,password=<span class="string">'123456'</span>,databse=<span class="string">'comp,port=3306)</span></span><br><span class="line"><span class="string">sql='</span>SELECT * FROM kl<span class="string">'</span></span><br><span class="line"><span class="string">data = pd.read_sql(sql,conn)</span></span><br><span class="line"><span class="string">conn.close()</span></span><br><span class="line"><span class="string">datasss</span></span><br></pre></td></tr></table></figure><h4 id="将DataFrame存入mysql"><a href="#将DataFrame存入mysql" class="headerlink" title="将DataFrame存入mysql"></a>将DataFrame存入mysql</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line">engine = create_engine(<span class="string">'mysql+pymysql://root:123456@localhost:3306/work?charset=UTF8mb4'</span>)</span><br><span class="line">pd.io.sql.to_sql(df2, <span class="string">'industry_1'</span>, engine, index=<span class="literal">False</span>, if_exists=<span class="string">'append'</span>, chunksize=<span class="number">10000</span>)</span><br><span class="line">engine.dispose()</span><br></pre></td></tr></table></figure><h4 id="一条一条存入mysql"><a href="#一条一条存入mysql" class="headerlink" title="一条一条存入mysql"></a>一条一条存入mysql</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db = pymysql.connect(host=<span class="string">'localhost'</span>,port=<span class="number">3306</span>,user=<span class="string">'root'</span>,database=<span class="string">'ceshi'</span>,password=<span class="string">'123456'</span>,charset=<span class="string">'utf8mb4'</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line">sql = <span class="string">'insert into kll (name,sex,age) values(%s,%s,%s)'</span></span><br><span class="line">data = (<span class="string">'张三'</span>,<span class="string">'男'</span>,<span class="number">23</span>)</span><br><span class="line">cursor.execute(sql,data)</span><br><span class="line">db.commit()</span><br><span class="line">cursor.close()</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure><h4 id="批量插入mysql"><a href="#批量插入mysql" class="headerlink" title="批量插入mysql"></a>批量插入mysql</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db = pymysql.connect(host=<span class="string">'localhost'</span>,port=<span class="number">3306</span>,user=<span class="string">'root'</span>,database=<span class="string">'ceshi'</span>,password=<span class="string">'123456'</span>,charset=<span class="string">'utf8mb4'</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line">sql = <span class="string">'insert into kl (name,sex,age) values(%s,%s,%s)'</span></span><br><span class="line">data = [(<span class="string">'张三'</span>,<span class="string">'男'</span>,<span class="number">23</span>),(<span class="string">'李四'</span>,<span class="string">'男'</span>,<span class="number">32</span>),(<span class="string">'小美'</span>,<span class="string">'女'</span>,<span class="number">18</span>)]</span><br><span class="line">cursor.executemany(sql,data)</span><br><span class="line">db.commit()</span><br><span class="line">cursor.close()</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure><h4 id="进程池代码"><a href="#进程池代码" class="headerlink" title="进程池代码"></a>进程池代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pool = Pool(<span class="number">30</span>)</span><br><span class="line">n = <span class="number">10000</span></span><br><span class="line">count = (len(company_name) // n) + <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(count):</span><br><span class="line">    company_list = company_name[num * n:(num + <span class="number">1</span>) * n]</span><br><span class="line">    pool.apply_async(func, args=(company_list,))</span><br><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br></pre></td></tr></table></figure><h4 id="将一对多转换成多对多"><a href="#将一对多转换成多对多" class="headerlink" title="将一对多转换成多对多"></a>将一对多转换成多对多</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">con2 = pymysql.connect(host=<span class="string">"192.168.0.222"</span>, port=<span class="number">3306</span>, user=<span class="string">"user_r"</span>, password=<span class="string">'1q2w3e4r'</span>, db=<span class="string">'industry_cn_test'</span>,charset=<span class="string">"utf8"</span>)</span><br><span class="line">sql_zong = <span class="string">"select `names` as jiqun_name ,ipc_5_list from ipc_split_10000_c_list_v1 "</span></span><br><span class="line">res = pd.read_sql(sql_zong, con2)</span><br><span class="line">ipc_group_unique = res.drop(<span class="string">'ipc_5_list'</span>, axis=<span class="number">1</span>).join(res[<span class="string">'ipc_5_list'</span>].str.split(<span class="string">','</span>, expand=<span class="literal">True</span>).stack().reset_index(level=<span class="number">1</span>, drop=<span class="literal">True</span>).rename(<span class="string">'ipcr'</span>))</span><br></pre></td></tr></table></figure><p>####将df中某两列互换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">4</span>,<span class="number">3</span>],[<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line">df.columns = [<span class="string">'one'</span>,<span class="string">'two'</span>]</span><br><span class="line">df[<span class="string">'three'</span>] = df[<span class="string">'one'</span>]</span><br><span class="line">print(df)</span><br><span class="line">df.loc[df.one&gt;df.two,<span class="string">'three'</span>] = df.loc[df.one&gt;df.two,<span class="string">'two'</span>]</span><br><span class="line">df</span><br></pre></td></tr></table></figure><h4 id="es返回不符合条件的个数"><a href="#es返回不符合条件的个数" class="headerlink" title="es返回不符合条件的个数"></a>es返回不符合条件的个数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">es.search(index=[<span class="string">'patent_cn_v71'</span>],body=&#123;</span><br><span class="line">    <span class="string">'query'</span>:&#123;</span><br><span class="line">        <span class="string">'bool'</span>:&#123;</span><br><span class="line">            <span class="string">'must_not'</span>:&#123;</span><br><span class="line">                <span class="string">'exists'</span>:&#123;</span><br><span class="line">                    <span class="string">'fields'</span>:<span class="string">'app_text'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="连接250数据-读"><a href="#连接250数据-读" class="headerlink" title="连接250数据(读)"></a>连接250数据(读)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn1 = pymysql.connect(host=<span class="string">'192.168.0.250'</span>,user=<span class="string">'user_r'</span>,password=<span class="string">'1q2w3e4r'</span>,database=<span class="string">'pre_formal_2'</span>)</span><br></pre></td></tr></table></figure><p>####连接250高权限</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn1=pymysql.connect(host=<span class="string">'192.168.0.250'</span>,user=<span class="string">'user_rwd_2'</span>,password=<span class="string">'5d6f7g8h'</span>,database=<span class="string">'pre_formal_2'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql必知必会学习</title>
      <link href="/2019/11/06/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/11/06/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.查看表信息:</span><br><span class="line"> DESC kl(<span class="keyword">describe</span>的缩写,为后面的简写版<span class="comment">---&gt;) 或者 SHOW COLUMNS FROM  kl</span></span><br><span class="line"><span class="number">2.</span>表名筛选</span><br><span class="line"> <span class="keyword">SELECT</span> TABLE_NAME <span class="keyword">FROM</span> INFORMATION_SCHEMA.TABLES <span class="keyword">WHERE</span>  TABLE_NAME <span class="keyword">LIKE</span> <span class="string">'SHEET%'</span>;</span><br><span class="line">3.查看加锁情况</span><br><span class="line"> <span class="keyword">SHOW</span>  <span class="keyword">OPEN</span>  <span class="keyword">TABLES</span> <span class="keyword">WHERE</span>  IN_USE &gt; <span class="number">0</span></span><br><span class="line"><span class="number">4.</span>通过检查table_locks_waited和table_locks_immediate状态变量分析系统上的表锁定:</span><br><span class="line"> <span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'table_locks%'</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python实现栈和队列</title>
      <link href="/2019/09/30/python%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/2019/09/30/python%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h5 id="python实现栈"><a href="#python实现栈" class="headerlink" title="python实现栈"></a>python实现栈</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items[len(self.items) - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items)</span><br><span class="line"><span class="comment">#将一个新项添加到栈顶</span></span><br><span class="line">s.push(<span class="string">'dog'</span>)</span><br><span class="line"><span class="comment">#从栈返回顶部元素但不会删除</span></span><br><span class="line">s.peek()</span><br><span class="line"><span class="comment">#返回栈中的item数量</span></span><br><span class="line">s.size()</span><br><span class="line"><span class="comment">#判断栈是否为空</span></span><br><span class="line">s.isEmpty()</span><br><span class="line"><span class="comment">#从栈中删除顶部项</span></span><br><span class="line">s.pop()</span><br><span class="line"></span><br><span class="line">方式二:直接导包(下载)</span><br><span class="line"><span class="keyword">from</span> pythonds.basic.stack <span class="keyword">import</span> Stack</span><br></pre></td></tr></table></figure><h5 id="python实现队列"><a href="#python实现队列" class="headerlink" title="python实现队列"></a>python实现队列</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.items.insert(<span class="number">0</span>,item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items)</span><br><span class="line"><span class="comment">#入队</span></span><br><span class="line">enqueue</span><br><span class="line"><span class="comment">#出队</span></span><br><span class="line">dequeue</span><br><span class="line"><span class="comment">#查看队列大小</span></span><br><span class="line">size</span><br><span class="line"><span class="comment">#查看是否为空</span></span><br><span class="line">isEmpty</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据结构与算法</title>
      <link href="/2019/09/30/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2019/09/30/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>数据结构与算法对于Python而言是他的核心,但对于Python而言内置了基础的数据结构与算法,弱化了数据结构与算法的使用</p><p>数据结构主要涉及，顺序表，链表，堆栈（栈存储的为局部变量，而栈内存存储的为局部变量），队列，树，二叉树，平衡二叉树，红黑树</p><p>算法主要涉及排序算法（冒泡排序，选择排序，插入排序，快速排序，希尔排序，归并排序）和查找算法（顺序查找，二分法查找，二叉树查找，哈希查找）</p><h5 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Python中的list和tuple都是顺序表结构,list是动态顺序表,支持内部结构变化如增加或者减少元素,而tuple并不支持结构的改变,其他性能和list一致</span><br><span class="line">list结构中,append的时间复杂度为O(<span class="number">1</span>),而insert插入函数是在插入位置之后的元素依次向下挪动一个位置,复杂度为O(n),同理pop()删除最后一个位置时,时间复杂度为O(<span class="number">1</span>),当删除指定元素时,则该元素其后的元素依次挪动一个位置,时间复杂度为O(n)</span><br></pre></td></tr></table></figure><h5 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">链表是由一个个节点连接而成,节点由两部分构成:元素域、链接域；链接域链接下一个节点</span><br><span class="line">    节点对象</span><br><span class="line">Class node：</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,item)</span>:</span></span><br><span class="line">self.item = item</span><br><span class="line">         self.next = <span class="literal">None</span></span><br><span class="line">     链表对象</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SinglyLinkedList</span>:</span></span><br><span class="line">    <span class="string">"""链表对象"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        头部添加节点</span></span><br><span class="line"><span class="string">        :param item: 节点值</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        node.next = self._head</span><br><span class="line">        self._head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        尾部添加节点</span></span><br><span class="line"><span class="string">        :param items:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur:  <span class="comment"># 判断是否为空链表</span></span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = Node(item)</span><br><span class="line">            <span class="keyword">while</span> cur.next:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            cur.next = node</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法代码练习</title>
      <link href="/2019/09/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2019/09/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>推荐网址:<a href="https://blog.csdn.net/weixin_41624982/article/details/89486592" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41624982/article/details/89486592</a></p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>描述:抽象数据类型(ADT),是计算机领域中被广泛接受的一种思想和方法,也是一种设计和实现程序模块的有效技术.模块通过接口来提供功能所需的信息,并不涉及具体实现细节.</span><br><span class="line"><span class="number">2.</span>概念:①数据表示的完全暴露②对象表示和操作对具体表示的依赖性③抽象数据类型提供的操作包括三类,构造操作,解析操作,变动操作.④Python所有的内置类型都是一种抽象数据类型⑤ADT是一种思想也是一种技术</span><br><span class="line">数据结构:指相互之间存在一种或多种特定关系的的数据元素的集合</span><br><span class="line">数据结构划分:逻辑结构、物理结构、数据运算</span><br><span class="line">数据结构的分类：栈（Stack）、队列（Queue）、树（Tree）、堆（Heap）、数组（Array）、链表（Linked List）、图（Graph）、散列（Hash）</span><br><span class="line"><span class="number">3.</span>几种排序算法介绍:</span><br><span class="line">    <span class="number">1.</span>冒泡排序:就是两两比较,互换位置,每一轮找到一个最大值放在数组右边,多轮循环就排好了.代码主要涉及循环次数和两两互换条件的判断.  优化:当一轮交换后数组顺序没有变化的时候停止排序</span><br><span class="line">    2.快速排序(左右指针法,挖坑法):数组中确定一个基准数,将大于基准数的放在右边,小于基准数的放在左边.具体实现是首先确定一个基准数(通常为数组第一个数),从后往前找到小于基准数的第一个数,并记下位置,与基准数互换位置,然后在从前往后找到大于基准数的第一个数,与基准数互换位置,再从后往前(前一次记录的位置开始)找到小于基准数的第一个数,重复,直到从前找的位置和从后找的位置大于等于,左边的全部比基准数小,右边比基准数大.然后两边再分别使用相同方法,循环    优化:①随机选取基准值(否则在一个完全有序的数组里，我们的快速排序就会退化为log（n^2②配合使用插入排序③当大量数据且重复数据较多时,用三路快排(小于,等于,大于)---&gt;推出双路快排为将等于部分分散到左右两端</span><br><span class="line">    <span class="number">3.</span>选择排序:首先在数组中找到最大(最小)的元素,然后在剩余数组中找到最大(最小),以此类推,直到排序完成</span><br><span class="line">    <span class="number">4.</span>插入排序,类似于排序扑克牌,取出一个数据然后与已经排好序数组的比较,插入到合适的位置,以此类推,</span><br><span class="line">    <span class="number">5.</span>归并排序:采用分治法,分为分和治两个阶段,分,指的是将一个数组分成两部分,然后重复不断的分直到只剩一个个单一的元素.然后在对左右两边的数组进行治,将左右两边的数组分别排序好,得到两个排好序的数组.最后进行合并.合并的原理是两个数组第一个数字比较,小的放到新的数组里的第一位,然后小的数的那个数组的第二个数,继续与宁一个数组的第一位数相比较,两者小的放入到新数组第二位,如此循环得到排序好的新数组</span><br><span class="line">    6.希尔排序===&gt;插入排序的改进(缩小增量排序):首先选择一个间隔x(小于n)将全部数组分成若干个子序列(相同间隔x的放一起),每一个子序列中进行插入排序,合并后.缩小间隔,重复子序列划分和排序,直到间隔x为1(https://blog.csdn.net/weixin_37818081/article/details/79202115?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)</span><br><span class="line">x每次减半或者<span class="number">1</span>/<span class="number">3</span>都可</span><br><span class="line"><span class="number">7.</span>堆排序:堆是一颗完全二叉树,每个节点的值总是不大于或者不小于父节点的值,由此形成大顶堆和小顶堆.首先将所有数字存储在堆中,按照大顶堆建堆,每次将最大的数取出,剩下的数继续可以找到最大的数,如此可以找到倒叙新的数组,将取出的数字按照相反的顺序进行排列,数字就完成了排序</span><br><span class="line"><span class="number">8.</span>桶排序:根据待排序数组中的最大和最小值(差值和映射规则判断)确定桶的个数,然后遍历每一个元素放在指定的桶中,最后得到排序好的结果,</span><br><span class="line">顺序表、链表、堆栈、队列、树、二叉树、平衡二叉树、红黑树；算法将涉及排序算法（冒泡排序、选择排序、插入排序、快速排序、希尔排序、归并排序）、查找算法（顺序查找、二分法查找、二叉树查找、哈希查找）</span><br></pre></td></tr></table></figure><h6 id="几种树"><a href="#几种树" class="headerlink" title="几种树"></a>几种树</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">满二叉树:除了叶子结点,每一个节点都有两个子节点(深度k  节点总数为(2^k)-1,则它就是满二叉树)</span><br><span class="line">完全二叉树:若二叉树的深度为k,除了k层外,其余各层的结点数都达到最大,第k层所有的节点都连续集中在最左边</span><br><span class="line">平衡二叉树:左子树和右子树的的深度之差的绝对值不能超过1,且左右子树都是平衡二叉树</span><br><span class="line">最优二叉树(哈夫曼树):树的带权路径长度达到最小,</span><br></pre></td></tr></table></figure><p>####python实现链表</p><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList(牛客网)==形如栈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="comment">#例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> listNode:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        l = []</span><br><span class="line">        head = listNode</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            l.insert(<span class="number">0</span>,head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure><h5 id="二分法-仅当列表是有序的时候有用-第一种算法"><a href="#二分法-仅当列表是有序的时候有用-第一种算法" class="headerlink" title="二分法(仅当列表是有序的时候有用)=====第一种算法"></a>二分法(仅当列表是有序的时候有用)=====第一种算法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">简单查找(傻找):如<span class="number">1</span>到<span class="number">100</span>中找<span class="number">99</span>,一个个找需要<span class="number">99</span>次.</span><br><span class="line">二分查找每次排除一半的数字</span><br><span class="line">对于简单查找找到需要n步,而对于二分法查找找到需要log以<span class="number">2</span>为底n的对数</span><br><span class="line">low = <span class="number">0</span>  high = len(ls) - <span class="number">1</span></span><br><span class="line">mid = (low + high)//<span class="number">2</span></span><br><span class="line">然后根据值对比修改high和low,小了low = mid +<span class="number">1</span> ,大了high = mid<span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="大O表示法-记录的是最糟糕最长的时间情况"><a href="#大O表示法-记录的是最糟糕最长的时间情况" class="headerlink" title="大O表示法(记录的是最糟糕最长的时间情况)"></a>大O表示法(记录的是最糟糕最长的时间情况)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">用来表示算法的运行时间,以及运行时间随着列表的增长的变化情况:如对数越往后几乎不增长,而线性一直增长很快</span><br><span class="line">常见的五种大O表示法</span><br><span class="line">O(logn)、O(n)、O(n*logn)、O(n**<span class="number">2</span>)、O(n!)</span><br><span class="line">logn优于n优于nlogn优于n**<span class="number">2</span>优于n!</span><br><span class="line">·算法的速度并非指的是时间而是操作数的增速</span><br><span class="line">·讨论算法的速度时,我们说的是随着输入的增加,其运行时间将以怎样的速度增加</span><br><span class="line">·算法的运行时间用大O表示法表示</span><br><span class="line">·O(logn)比O(n)快,当需要搜索的元素越多时,前者比后者快的多</span><br><span class="line"></span><br><span class="line">计算机内存可以看成一个个抽屉,每个抽屉有对应的物理地址</span><br><span class="line"></span><br><span class="line">常见的大O运行时间:</span><br><span class="line">    <span class="number">1.</span>二分查找  O(logn)、简单查找 O(n)、 快速排序 O（平均nlogn，最糟糕n**<span class="number">2</span>）、选择排序O（n**<span class="number">2</span>）、旅行商问题O（n！）</span><br></pre></td></tr></table></figure><p>####数组和链表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数组表明所有代办事项在计算机的内存中是相连的,紧靠在一起,当后面位置被占用的时候,就需要整体迁移到有空闲位置的地方(他们必须相连),添加元素速度很慢</span><br><span class="line">解决方法:</span><br><span class="line">    <span class="number">1.</span>给预留位置,先占内存  缺点:①额外预留的位置用不上 ②待办事项超过指定预留后,还得转移</span><br><span class="line">    <span class="number">2.</span>使用链表解决</span><br><span class="line">链表:链表中的元素可以存储在内存中的任何地方,链表中的每一个元素都存储了下一个元素的地址,使一系列内存连接在一起.链表中添加元素很简单,只要将后一个元素的地址放到前一个元素中即可</span><br><span class="line">    </span><br><span class="line">使用链表时根本就不需要移动元素,如为数组分配<span class="number">1000</span>个位置,内存有<span class="number">1000</span>个位置但不在一起,就无法为该数组分配内存.而链表不需要考虑那么多</span><br></pre></td></tr></table></figure><p>链表在插入数据上面的优势特别明显(无论结尾插入还是中间插入),数组在随机读取速度的优势特别明显,链表删除数据也比较方便。不同如插入，删除操作一定能成功，插入操作当内存空间不够时，插入操作可能会失败。删除操作任何情况都能成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链表读取时间O(n),存储时间O(<span class="number">1</span>),删除时间O(<span class="number">1</span>)</span><br><span class="line">数组读取时间O(<span class="number">1</span>),存储时间O(n),删除时间O(n)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">为什么数组都是以0为开头的索引?</span><br><span class="line">从<span class="number">0</span>开始让基于数组的代码编写起来更容易,因此程序员都坚持这么做.</span><br><span class="line"></span><br><span class="line">通常情况下数组用的多,数组支持随机访问,而链表只支持顺序访问</span><br></pre></td></tr></table></figure><h4 id="选择排序-第二种算法"><a href="#选择排序-第二种算法" class="headerlink" title="选择排序=====第二种算法"></a>选择排序=====第二种算法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如一堆数中按照大小进行排序,每次的时间复杂读为O(n),执行n次,总的为O(n**<span class="number">2</span>)</span><br><span class="line">每次取一个最大,依次排</span><br></pre></td></tr></table></figure><h6 id="python实现选择排序"><a href="#python实现选择排序" class="headerlink" title="python实现选择排序"></a>python实现选择排序</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(ls,data_max)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ls)):</span><br><span class="line">        <span class="keyword">if</span> ls[i]&gt;data_max:</span><br><span class="line">            data_max = ls[i]</span><br><span class="line">    <span class="keyword">return</span> data_max</span><br><span class="line">ls = [<span class="number">1</span>,<span class="number">21</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">13</span>]</span><br><span class="line">ls2 = []</span><br><span class="line">data_max = ls[<span class="number">0</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span>  i  <span class="keyword">in</span>  range(len(ls)):</span><br><span class="line">        max_data = func(ls,data_max)</span><br><span class="line">        ls2.append(max_data)</span><br><span class="line">        ls.remove(max_data)</span><br><span class="line">    <span class="keyword">return</span> ls2</span><br><span class="line">func2()</span><br></pre></td></tr></table></figure><h4 id="快速排序-D-amp-C算法-第三种算法-基础-递归"><a href="#快速排序-D-amp-C算法-第三种算法-基础-递归" class="headerlink" title="快速排序(D&amp;C算法)=====第三种算法(基础:递归)"></a>快速排序(D&amp;C算法)=====第三种算法(基础:递归)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">快排比选择排序快很多,是一个优雅的算法(并非一种解决问题的算法,而是一种解决问题的思路)</span><br><span class="line">工作原理:<span class="number">1.</span>找出简单的基线条件  <span class="number">2.</span>确定如何缩小问题的规模,使其符合基线条件</span><br><span class="line"></span><br><span class="line">有时候循环可以简单的完成任务,为何还要使用递归方式呢,因为函数式编程语言(如Haskell)没有循环,只能使用递归来编写这样的函数</span><br><span class="line"></span><br><span class="line">快速排序思想为通过一趟排序将要排序的数据分割成独立的两部分,其中一部分的所有数据都比宁一部分的所有数据都要小,然后按此方法对两部分数据进行快速排序,整个排序过程可以递归进行</span><br><span class="line"></span><br><span class="line">快排流程:</span><br><span class="line">    <span class="number">1.</span>首先设定一个分界值,通过该分界值将数组分成左右两部分(随机选取通常为数组的第一个值)</span><br><span class="line">    <span class="number">2.</span>将大于或等于分界值的数据集中到数组右边,小于分界值的数据集中到数组的左边.使得左边的数值都小于等于分界值.右边的元素都大于或等于分界值</span><br><span class="line">    <span class="number">3.</span>然后左边和右边的数据可以独立排序.左边的数据又可以取一个分界值,将此部分数据局变成左右两部分,同样在左边放置最小值,右边放置最大值.右侧的数据做类似的处理</span><br><span class="line">    <span class="number">4.</span>重复上述步骤.递归进行.</span><br></pre></td></tr></table></figure><p>图地址:<a href="https://bkimg.cdn.bcebos.com/pic/b7003af33a87e950707fdf2110385343fbf2b416?x-bce-process=image/resize,m_lfit,w_220,h_220,limit_1" target="_blank" rel="noopener">https://bkimg.cdn.bcebos.com/pic/b7003af33a87e950707fdf2110385343fbf2b416?x-bce-process=image/resize,m_lfit,w_220,h_220,limit_1</a></p><p><img src="https://bkimg.cdn.bcebos.com/pic/b7003af33a87e950707fdf2110385343fbf2b416?x-bce-process=image/resize,m_lfit,w_220,h_220,limit_1" alt="快排图"></p><p>####合并排序(归并排序)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">合并排序的时间总是O(nlogn),而快排平均时间为O(nlogn),最糟糕时候为n**<span class="number">2</span></span><br><span class="line">流程:</span><br><span class="line">    <span class="number">1.</span>将待排序的元素分成大小大致相同的两个字序列</span><br><span class="line">    <span class="number">2.</span>将两个字序列进行合并排序</span><br><span class="line">    <span class="number">3.</span>将排序好的有序序列进行合并,得到最终的有序序列</span><br></pre></td></tr></table></figure><p>图地址:<a href="https://upload-images.jianshu.io/upload_images/13629684-ba3a964b7c17782c.png?imageMogr2/auto-orient/strip|imageView2/2/w/487/format/webp" target="_blank" rel="noopener">https://upload-images.jianshu.io/upload_images/13629684-ba3a964b7c17782c.png?imageMogr2/auto-orient/strip|imageView2/2/w/487/format/webp</a></p><p><img src="https://upload-images.jianshu.io/upload_images/13629684-ba3a964b7c17782c.png?imageMogr2/auto-orient/strip|imageView2/2/w/487/format/webp" alt="img"></p><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本思想:把待排序的记录按照其关键码值的大小逐个插入到一个已经排好序的有序序列中,知道所有的记录插完为止,得到一个新的有序序列</span><br></pre></td></tr></table></figure><h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">散列表也称为散列映射、映射、字典和关联数组。</span><br><span class="line">散列表：散列函数和数组共同创建的一种数据结构。散列表使用数组来存储数据</span><br><span class="line">①散列函数总是将同样的输入映射到相同的索引。</span><br><span class="line">②散列函数将不同的输入映射到不同的函数。</span><br><span class="line">③散列函数知道数组有多大，只返回有效的索引。</span><br><span class="line"></span><br><span class="line">散列表适用于:①模拟映射关系 ②防止重复 ③缓存\记住数据,以免服务器通过处理来生成它们</span><br><span class="line">冲突:当键已经存在时,再赋给它新值,就会覆盖原来的值,这种情况称为冲突</span><br><span class="line"></span><br><span class="line">对比:</span><br><span class="line">    散列表查找花费的时间为常量O(<span class="number">1</span>),简单查找的运行时间为线性时间,二分查找的花费的时间为对数时间</span><br><span class="line">    </span><br><span class="line">小结:</span><br><span class="line">    <span class="number">1.</span>可以结合散列函数和数组来创建散列</span><br><span class="line">    <span class="number">2.</span>冲突很糟糕,应该使用可以最大程度的减小冲突的散列函数</span><br><span class="line">    <span class="number">3.</span>散列表的查找、插入和删除速度都非常快</span><br><span class="line">    <span class="number">4.</span>散列表适合用于模拟映射关系</span><br><span class="line">    <span class="number">5.</span>一旦填装因子超过<span class="number">0.7</span>，就该调整散列表的长度</span><br><span class="line">    <span class="number">6.</span>散列表可用于调整长度</span><br><span class="line">    <span class="number">7.</span>散列表非常适合用于防止重复</span><br></pre></td></tr></table></figure><h4 id="广度优先搜索-通过队列实现-顺序添加-顺序查找"><a href="#广度优先搜索-通过队列实现-顺序添加-顺序查找" class="headerlink" title="广度优先搜索(通过队列实现,顺序添加,顺序查找)"></a>广度优先搜索(通过队列实现,顺序添加,顺序查找)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">广度优先搜索是用来解决最短路径问题的,是一种用于图的查找算法,主要解决两类问题</span><br><span class="line">·从节点A出发,有前往节点B的路径吗</span><br><span class="line">    ·从节点A出发,前往节点B的哪条路径最短</span><br><span class="line">基础(图相关知识):</span><br><span class="line">    图由节点和边组成,一个节点可能与众多节点直接相连,这些节点被称为邻居</span><br><span class="line">    有向图:有箭头指向自己但没有指向别人.rama-&gt;adit</span><br><span class="line">    无向图:没有箭头,直接相连的节点互为邻居.ross-lilei</span><br><span class="line">一度关系胜过二度关系,二度胜过三度,关系以此类推.因而先在一度中搜索,然后二度...一直到搜索到为止.</span><br><span class="line"></span><br><span class="line">队列是先进先出的,栈是后进后出的,你需要按加入顺序检查搜索列表中的人,否则找到的就不是最短路径,因此搜索列表必须为队列</span><br><span class="line">对于检查过的人务必不要再去检查,否则会陷入无限循环</span><br><span class="line"></span><br><span class="line">运行时间：</span><br><span class="line">时间至少为O（边数）。将每一个添加到队列的时间是O(<span class="number">1</span>),因此广度搜索的运行时间O(人数加边数)</span><br></pre></td></tr></table></figure><h4 id="狄克斯特拉算法"><a href="#狄克斯特拉算法" class="headerlink" title="狄克斯特拉算法"></a>狄克斯特拉算法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">加权图:带权重的图</span><br><span class="line">非加权图:不带权重的图</span><br><span class="line">获取加权图的最短路径使用狄克斯特拉算法,获取非加权图的最短路径使用广度优先搜索算法(狄克斯特拉算法只适用于有向无环图)</span><br><span class="line">当权重为正时狄克斯特拉算法才管用</span><br><span class="line">如果包含负权边,请使用贝尔曼-福德算法</span><br><span class="line"></span><br><span class="line">基本思路:</span><br><span class="line">    <span class="number">1.</span>找出最便宜的节点,即可在最短时间内到达的节点</span><br><span class="line">    <span class="number">2.</span>更新该节点的邻居的开销</span><br><span class="line">    <span class="number">3.</span>重复这个过程,直到对图中的每个节点都这样做了</span><br><span class="line">    <span class="number">4.</span>计算最短路径</span><br></pre></td></tr></table></figure><p>第一步:找出最便宜的节点.使用散列表,把它当成一个列表</p><table><thead><tr><th>父节点</th><th>节点</th><th>耗时</th></tr></thead><tbody><tr><td>起点</td><td>A</td><td>6</td></tr><tr><td>起点</td><td>B</td><td>2</td></tr><tr><td>起点</td><td>终点</td><td>未知</td></tr></tbody></table><p><img src="/2019/09/27/数据结构与算法/2.png" alt="2"></p><p>找出最短耗时2,节点B是最近的</p><p>第二步:计算经节点B前往其各个邻居所需的时间</p><table><thead><tr><th>父节点</th><th>节点</th><th>耗时</th></tr></thead><tbody><tr><td>B</td><td>A</td><td>5(2+3)</td></tr><tr><td>B</td><td>B</td><td>2</td></tr><tr><td>B</td><td>终点</td><td>7(2+5)</td></tr></tbody></table><p>第三步:重复操作</p><h4 id="贪婪算法-贪心算法-局部最优解-企图以这种方式获得全局最优解"><a href="#贪婪算法-贪心算法-局部最优解-企图以这种方式获得全局最优解" class="headerlink" title="贪婪算法(贪心算法)===局部最优解,企图以这种方式获得全局最优解"></a>贪婪算法(贪心算法)===局部最优解,企图以这种方式获得全局最优解</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">指的是,在对问题求解时,总是做出当前看来最好的选择,也就是说,不从整体最优上加以考虑,做出的是某种意义的局部最优解</span><br><span class="line">常见的问题:</span><br><span class="line">    <span class="number">1.</span>背包问题:有一个背包，背包容量是M=<span class="number">150</span>kg。有<span class="number">7</span>个物品，物品不可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量(每次挑选最大价值\每次挑选重量最大\每次挑选单位价值最大)===不一定最优,可能局部最优</span><br><span class="line">    <span class="number">2.</span>马踏棋盘:在<span class="number">8</span>×<span class="number">8</span>方格的棋盘上，从任意指定方格出发，为马寻找一条走遍棋盘每一格并且只经过一次的一条路径.</span><br><span class="line">    <span class="number">3.</span>集合覆盖问题：假设存在需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区都可以接收到信号。</span><br><span class="line"></span><br><span class="line">基本思路:</span><br><span class="line">    <span class="number">1.</span>建立数学模型来描述问题</span><br><span class="line">    <span class="number">2.</span>把求解的问题分解成若干子问题</span><br><span class="line">    <span class="number">3.</span>对每一个子问题求解,得到子问题的局部最优解</span><br><span class="line">    <span class="number">4.</span>把子问题对应的局部最优解合成原来整个问题的一个近似最优解</span><br><span class="line">优点:贪婪算法易于实现、运行速度快，是不错的近似算法</span><br></pre></td></tr></table></figure><h4 id="动态规划-DP-dynamic-programming"><a href="#动态规划-DP-dynamic-programming" class="headerlink" title="动态规划(DP=dynamic programming)"></a>动态规划(DP=dynamic programming)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">这是一种解决棘手问题的方法,将问题分解成若干个小问题,先着手解决这些小问题</span><br><span class="line">动态规划原理:</span><br><span class="line">    编号动态规划:最大不下降子序列</span><br><span class="line">    划分动态规划:矩阵链乘、凸多边形三角剖分</span><br><span class="line">    数轴动态规划:<span class="number">0</span><span class="number">-1</span>背包</span><br><span class="line">    前缀动态规划:最长公共子序列</span><br><span class="line">    树形动态规划:最优二分搜索树</span><br><span class="line">        </span><br><span class="line">基本思想:问题的最优解如果可以由子问题的最优解推导得到,则可以先求子问题的最优解,在构造原问题的最优解,若子问题的有较多的重复出现,则可以自底向上从最终子问题向原问题逐步求解</span><br><span class="line"></span><br><span class="line">使用条件:可分为多个相关子问题,子问题的解被重复使用</span><br><span class="line">    </span><br><span class="line">动态规划算法的设计步骤:</span><br><span class="line">    <span class="number">1.</span>分析优化解的结构</span><br><span class="line">    <span class="number">2.</span>递归的定义最优解的代价</span><br><span class="line">    <span class="number">3.</span>自底向上地计算优化解的代价保存,并获取构造最优解的信息</span><br><span class="line">    <span class="number">4.</span>根据构造最优解的信息构造最优解</span><br><span class="line">    </span><br><span class="line">动态规划的特点:</span><br><span class="line">    <span class="number">1.</span>把原始问题分成一系列子问题</span><br><span class="line">    <span class="number">2.</span>求解每个子问题,并将结果保存在一个表里,以后用到时直接存取,不重复计算,节省计算时间</span><br><span class="line">    <span class="number">3.</span>自底向上的计算</span><br><span class="line">    <span class="number">4.</span>整体问题最优解取决于子问题的最优解</span><br><span class="line">DP核心思想:尽可能缩小解空间</span><br></pre></td></tr></table></figure><h4 id="树算法"><a href="#树算法" class="headerlink" title="树算法"></a>树算法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">树:树是一种管理有像树干、树枝、树叶一样关系的数据得数据结构</span><br><span class="line">   树由节点（顶点）和边（枝）构成，并且有一个节点作为起始点。这个起始点作为树的根节点。由此形成父节点、子节点、叶子节点</span><br><span class="line">节点的子树的根称为节点的孩子，相应的该节点称为孩子的双亲，同一双亲的孩子之间互称为兄弟，节点的祖先是从该节点所经分支上的所有结点</span><br><span class="line"></span><br><span class="line">基本概念：</span><br><span class="line"></span><br><span class="line">节点的度：一个节点含有的子树的个数称为该节点的度</span><br><span class="line">叶节点或终端节点：度为<span class="number">0</span>的节点称为叶节点</span><br><span class="line">非终端节点或分支节点：度不为<span class="number">0</span>的节点</span><br><span class="line">双亲结点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点</span><br><span class="line">孩子节点或子节点:一个节点含有的子树的根节点称为该节点的子节点</span><br><span class="line">兄弟节点:具有相同父节点的节点互称为兄弟节点</span><br><span class="line">树的度:一棵树中,最大的节点的度称为树的度</span><br><span class="line">节点的层次:从根开始定义起,跟为第一层,根的子节点为第二层</span><br><span class="line">树的高度或深度:树中节点的最大层次</span><br><span class="line">堂兄弟节点:双亲在同一层的节点称为堂兄弟节点</span><br><span class="line">节点的祖先:从跟到该节点所经分支上的所有节点</span><br><span class="line">子孙:以某节点为根的子树中任一节点都称为该节点的子孙</span><br><span class="line">森林:由m棵互不相交的树的集合称为森林</span><br><span class="line"></span><br><span class="line">在计算机中数据的存储有两种结构,顺序存储和链式存储,对树而言,顺序存储结构显然是不行的,而链式存储结构也是有缺点的</span><br><span class="line">第一种:链式存储结构中的节点需含有子节点的引用和指针,但在树中子节点的不确定性导致无法固定具体节点中有几个引用或指针</span><br><span class="line">第一种(改): 对于上面的存储结构会过多的浪费空间,那么在结点中声明一个动态链表Nodes来存放可能的子节点node</span><br><span class="line">第二种:使用数组+链表结合的方式表示树</span><br></pre></td></tr></table></figure><p>图地址:<a href="https://img2018.cnblogs.com/blog/1244002/201809/1244002-20180921160023094-1488648937.png" target="_blank" rel="noopener">https://img2018.cnblogs.com/blog/1244002/201809/1244002-20180921160023094-1488648937.png</a></p><p><img src="https://img2018.cnblogs.com/blog/1244002/201809/1244002-20180921160023094-1488648937.png" alt="img"></p><h4 id="各种树介绍"><a href="#各种树介绍" class="headerlink" title="各种树介绍"></a>各种树介绍</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#有序树与无序树</span></span><br><span class="line">有序树:树中任意节点的子节点之间有顺序关系</span><br><span class="line">无序树:树中任意节点的子节点之间没有顺序关系,这种树称为无序树,也称自由树</span><br><span class="line"><span class="comment">#二叉树</span></span><br><span class="line">完全二叉树:叶结点只能出现在最底层的两层,且最底层叶节点均处于次底层叶节点的左侧.</span><br><span class="line">满二叉树:除了叶子结点外每一个节点都有左右子叶,且叶子结点都处在最底层的二叉树(最标准那种)</span><br><span class="line">平衡二叉树:又被称为avl树(非avl算法),且具有以下性质,它是一颗空树或它的左右两个子树的高度差的绝对值不超过<span class="number">1</span>,并且左右两个子树都是一颗平衡二叉树,平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。</span><br><span class="line">红黑树:是一种自平衡二叉查找树,典型的用途是实现关联数组</span><br></pre></td></tr></table></figure><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">堆就是用数组实现的二叉树,所以它没有使用父指针或者子指针,堆根据堆属性来排序,堆属性决定了树中节点的位置</span><br><span class="line">堆的常用方法:</span><br><span class="line">    ·构建优先队列</span><br><span class="line">    ·支持堆排序</span><br><span class="line">    ·快速找出一个集合中的最小值(或者最大值)</span><br><span class="line">堆分为最大堆和最小堆</span><br><span class="line">最大堆:父节点的值比每一个子节点的值都要大.</span><br><span class="line">最小堆:父节点中的值比每一个子节点的值都要小</span><br><span class="line">堆属性非常有用,常常被当做优先队列使用,因为可以快速访问到最重要的元素</span><br></pre></td></tr></table></figure><p><img src="/2019/09/27/数据结构与算法/排序算法时间复杂读.png" alt="排序算法时间复杂读"></p><p><img src="/2019/09/27/数据结构与算法/数据结构与算法.png" alt="数据结构与算法"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP学习</title>
      <link href="/2019/09/26/NLP%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/09/26/NLP%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>TF-IDF算法:代码及原理</p><p><a href="https://blog.csdn.net/asialee_bird/article/details/81486700" target="_blank" rel="noopener">https://blog.csdn.net/asialee_bird/article/details/81486700</a></p><p>stop_words 停用词</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">概念:搜索的时候会自动忽略这些词</span><br><span class="line">作用:有效的提高关键词密度</span><br></pre></td></tr></table></figure><p>自然语言处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">概念:是研究人与人交际以及人与计算机交际中的语言问题的一门学科,涉及语言学\计算机科学\数学\自动化等不同学科.</span><br><span class="line">自然语言处理的基本理论:语言模型,隐马尔可夫模型(HMM)</span><br><span class="line">    ·语言模型:根据语言客观事实而进行语言抽象数学建模,是一种对应关系</span><br><span class="line">    ·隐马尔可夫模型:用来描述一个含有隐含未知参数的马尔可夫过程</span><br><span class="line">语言资源:语料库和词汇知识库</span><br><span class="line">自然语言处理研究的内容:<span class="number">1.</span>机器翻译  <span class="number">2.</span>自动文摘  <span class="number">3.</span>信息检索  <span class="number">4.</span>文档分类  <span class="number">5.</span>问答系统  <span class="number">6.</span>信息过滤  <span class="number">7.</span>信息抽取  <span class="number">8.</span>文本挖掘  <span class="number">9.</span>舆情分析  <span class="number">10.</span>隐喻计算  <span class="number">11.</span>文字编辑和自动校对  <span class="number">12.</span>作文自动评分 <span class="number">13.</span>语音识别  <span class="number">14.</span>文语转换  <span class="number">15.</span>人声识别/认证/验证</span><br><span class="line">自然语言处理的困难:①自然语言大量的歧义现象②对于特定的系统可能会出现未知的词汇,未知的结构等未知情况</span><br><span class="line">自然语言处理的用处:为了让众多的非结构化数据(文本,语音,视频等数据)能够进行分析和利用</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">分词:单词组成句子,句子之间由空格隔开</span><br><span class="line">中文:字、词、句、段、篇</span><br></pre></td></tr></table></figure><h3 id="NLP训练营"><a href="#NLP训练营" class="headerlink" title="NLP训练营"></a>NLP训练营</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">NLP = NLU + NLG             natural language processing</span><br><span class="line">NLU:语音/文本---&gt;转换成理解  natural language understanding</span><br><span class="line">    五大难点:</span><br><span class="line">        语言的多样性</span><br><span class="line">语言的歧义性</span><br><span class="line">语言的鲁棒性</span><br><span class="line">语言的知识依赖</span><br><span class="line">语言的上下文</span><br><span class="line">NLG:理解----&gt;转化为语音/文本 natural language generator</span><br><span class="line">    NLG 的<span class="number">6</span>个步骤：</span><br><span class="line">内容确定 – Content Determination</span><br><span class="line">文本结构 – Text Structuring</span><br><span class="line">句子聚合 – Sentence Aggregation</span><br><span class="line">语法化 – Lexicalisation</span><br><span class="line">参考表达式生成 – Referring Expression Generation|REG</span><br><span class="line">语言实现 – Linguistic Realisation</span><br><span class="line">NLP的面临的及格问题:</span><br><span class="line">    <span class="number">1.</span>一个意思多种表达方法</span><br><span class="line">    <span class="number">2.</span>一词多义(苹果,包袱等)</span><br><span class="line">cv computer vision 计算机视觉,所见即所得 因而较nlp简单</span><br><span class="line">机器翻译:基于语料库的统计翻译以及概率--&gt;发展模型</span><br><span class="line">语料库的统计翻译缺点:慢,未考虑语境,未区分一词多义,未考虑上下文,语法问题等</span><br><span class="line">翻译步骤:(如中译英)</span><br><span class="line">    中文---&gt;分词---&gt;TM(transalation Model)----&gt;broken English----&gt;Language Model----&gt;输出</span><br><span class="line">    TM:将每个中文/词翻译成对应的英文(step <span class="number">1</span>)</span><br><span class="line">    LM:将英文排列组合找到最符合人话的句子(概率最高的即为输出)(step <span class="number">2</span>)</span><br><span class="line">缺点:时间复杂度高,比如<span class="number">10</span>个词,排列组合为<span class="number">10</span>!复杂度为指数级别,np hard问题</span><br><span class="line">优化:step1 和 step2合并到一起===&gt;经典算法 decoding Algorithm (viterbi Algorithm)语音识别经典算法(使用贝叶斯公式)p(e/c)</span><br></pre></td></tr></table></figure><h4 id="NLP基础理解"><a href="#NLP基础理解" class="headerlink" title="NLP基础理解"></a>NLP基础理解</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">NLP的<span class="number">2</span>个核心任务：</span><br><span class="line">自然语言理解 – NLU</span><br><span class="line">自然语言生成 – NLG</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">NLP 的<span class="number">5</span>个难点：</span><br><span class="line">语言是没有规律的，或者说规律是错综复杂的。</span><br><span class="line">语言是可以自由组合的，可以组合复杂的语言表达。</span><br><span class="line">语言是一个开放集合，我们可以任意的发明创造一些新的表达方式。</span><br><span class="line">语言需要联系到实践知识，有一定的知识依赖。</span><br><span class="line">语言的使用要基于环境和上下文。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">NLP 的<span class="number">4</span>个典型应用：</span><br><span class="line">情感分析</span><br><span class="line">聊天机器人</span><br><span class="line">语音识别</span><br><span class="line">机器翻译</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">NLP 的<span class="number">6</span>个实现步骤：</span><br><span class="line">分词-tokenization</span><br><span class="line">次干提取-stemming</span><br><span class="line">词形还原-lemmatization</span><br><span class="line">词性标注-pos tags</span><br><span class="line">命名实体识别-ner</span><br><span class="line">分块-chunking</span><br><span class="line">    </span><br><span class="line">中文分词工具</span><br><span class="line">下面排名根据 GitHub 上的 star 数排名：</span><br><span class="line"></span><br><span class="line">Hanlp</span><br><span class="line">Stanford 分词</span><br><span class="line">ansj 分词器</span><br><span class="line">哈工大 LTP</span><br><span class="line">KCWS分词器</span><br><span class="line">jieba</span><br><span class="line">IK</span><br><span class="line">清华大学THULAC</span><br><span class="line">ICTCLAS</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">英文分词工具</span><br><span class="line">Keras</span><br><span class="line">Spacy</span><br><span class="line">Gensim</span><br><span class="line">NLTK</span><br></pre></td></tr></table></figure><h4 id="1、中文分词"><a href="#1、中文分词" class="headerlink" title="1、中文分词"></a>1、中文分词</h4><h5 id="规则分词"><a href="#规则分词" class="headerlink" title="规则分词"></a>规则分词</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">正向最大匹配</span><br><span class="line">逆向最大匹配</span><br><span class="line">双向最大匹配</span><br></pre></td></tr></table></figure><h5 id="统计分词"><a href="#统计分词" class="headerlink" title="统计分词"></a>统计分词</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.建立语言统计模型:根据上下文的相关特性建立数学模型,核心是判断一个句子在文本中出现的概率</span><br><span class="line">2.对句子进行单词划分,对划分结果进行概率计算,获得概率最大的分词方式.===&gt;统计学习算法:HMM,CRF</span><br></pre></td></tr></table></figure><h3 id="2、词性标注和命名实体识别"><a href="#2、词性标注和命名实体识别" class="headerlink" title="2、词性标注和命名实体识别"></a>2、词性标注和命名实体识别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">词性标注:标注动词,名词等</span><br><span class="line">命名实体:常用的人名,地名,日期,组织,货币等等</span><br></pre></td></tr></table></figure><h3 id="3、关键词提取"><a href="#3、关键词提取" class="headerlink" title="3、关键词提取"></a>3、关键词提取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">常用方法:IF-IDF,textrank算法,主题模型</span><br><span class="line">主题模型:是以非监督学习的方法,对文集中的隐含语义结构进行聚类</span><br></pre></td></tr></table></figure><h4 id="3-1TF-IDF算法—-gt-统计算法—-gt-词频–逆文档频次算法"><a href="#3-1TF-IDF算法—-gt-统计算法—-gt-词频–逆文档频次算法" class="headerlink" title="3.1TF-IDF算法—&gt;统计算法—&gt;词频–逆文档频次算法"></a>3.1TF-IDF算法—&gt;统计算法—&gt;词频–逆文档频次算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TF算法:统计一个词在文档中的频次</span><br><span class="line">IDF算法:统计词在文档集中多少个文档出现的频次</span><br><span class="line">以上为传统的,tf-idf也有很多变种的加权方法</span><br></pre></td></tr></table></figure><h4 id="3-2Text-Rank"><a href="#3-2Text-Rank" class="headerlink" title="3.2Text_Rank"></a>3.2Text_Rank</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">优点:脱离语料库只对单文档分析即可提取文档关键词</span><br><span class="line">用法:最早用于自动摘要,</span><br><span class="line">思想来源于谷歌的pagerank,pagerank思想:一个网页被越多的网页链接说明越重要,或者一个网页被一个越高权值的网页链接,也能表明网页重要</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python实现迁表</title>
      <link href="/2019/09/25/Python%E5%AE%9E%E7%8E%B0%E8%BF%81%E8%A1%A8/"/>
      <url>/2019/09/25/Python%E5%AE%9E%E7%8E%B0%E8%BF%81%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="python实现mysql的迁表"><a href="#python实现mysql的迁表" class="headerlink" title="python实现mysql的迁表"></a>python实现mysql的迁表</h3><p>注意事项:</p><p>​        1.表结构问题</p><p>​        2.权限问题(无删除权限时,不能truncate表重置索引)</p><p>​        3.思路问题(读表结构,修改表结构数据,读表数据,在新服务器库里建表,插入数据)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#获取pre_formal_2中所有以expect开头的表名称</span></span><br><span class="line">db1 = pymysql.connect(host=<span class="string">'192.168.0.222'</span>,port=<span class="number">3306</span>,user=<span class="string">'user_r_2'</span>,database=<span class="string">'pre_formal_2'</span>,password=<span class="string">'4f5g6h7j'</span>,charset=<span class="string">'utf8mb4'</span>)</span><br><span class="line">cursor1 = db1.cursor()</span><br><span class="line">db2 = pymysql.connect(host=<span class="string">'localhost'</span>, port=<span class="number">3306</span>, user=<span class="string">'root'</span>, database=<span class="string">'ceshi'</span>,</span><br><span class="line">                             password=<span class="string">'123456'</span>,</span><br><span class="line">                             charset=<span class="string">'UTF8mb4'</span>)</span><br><span class="line">cursor2 = db2.cursor()</span><br><span class="line">sql = <span class="string">"SELECT distinct TABLE_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME LIKE 'expect%'"</span></span><br><span class="line">cursor1.execute(sql)</span><br><span class="line">data = cursor1.fetchall()</span><br><span class="line">data = pd.DataFrame(list(data))</span><br><span class="line">data = data[<span class="number">0</span>].tolist()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(table_name_list)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> table_name <span class="keyword">in</span> table_name_list:</span><br><span class="line">        <span class="comment"># 查看建表语句</span></span><br><span class="line">        sql = <span class="string">f"show create table <span class="subst">&#123;table_name&#125;</span>"</span></span><br><span class="line">        cursor1.execute(sql)</span><br><span class="line">        data = cursor1.fetchone()</span><br><span class="line">        <span class="comment"># 重置自增值</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            patten = re.compile(<span class="string">'AUTO_INCREMENT=(.*) DEFAULT'</span>)</span><br><span class="line">            result = patten.findall(data[<span class="number">1</span>])</span><br><span class="line">            data1 = data[<span class="number">1</span>].replace(result[<span class="number">0</span>], <span class="string">'0'</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            data1 = data[<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 获取数据内容</span></span><br><span class="line">        engine = create_engine(<span class="string">'mysql+pymysql://user_r_2:4f5g6h7j@192.168.0.222:3306/pre_formal_2'</span>)</span><br><span class="line">        sql = <span class="string">f'select * from <span class="subst">&#123;table_name&#125;</span>'</span></span><br><span class="line">        df = pd.read_sql_query(sql, engine)</span><br><span class="line">        print(df)</span><br><span class="line">        <span class="comment"># 将表数据存入数据库</span></span><br><span class="line">        print(data1)</span><br><span class="line">        sql_1 = <span class="string">f"<span class="subst">&#123;data1&#125;</span>"</span></span><br><span class="line">        cursor2.execute(sql_1)</span><br><span class="line">        engine = create_engine(<span class="string">'mysql+pymysql://root:123456@localhost:3306/ceshi?charset=UTF8mb4'</span>)</span><br><span class="line">        pd.io.sql.to_sql(df, <span class="string">f'<span class="subst">&#123;table_name&#125;</span>'</span>, engine, index=<span class="literal">False</span>, if_exists=<span class="string">'append'</span>, chunksize=<span class="number">10000</span>, )</span><br><span class="line">        engine.dispose()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pool = Pool(<span class="number">5</span>)</span><br><span class="line">    n = <span class="number">300</span></span><br><span class="line">    count = (len(data) // n) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> range(count):</span><br><span class="line">        table_name_list = data[num * n:(num + <span class="number">1</span>) * n]</span><br><span class="line">        print(table_name_list)</span><br><span class="line">        <span class="comment">#参数是指各个不同进程使用的参数本能当成传递使用</span></span><br><span class="line">        pool.apply_async(func, args=(table_name_list,))</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es分页三种方式比较</title>
      <link href="/2019/09/20/es%E5%88%86%E9%A1%B5%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83/"/>
      <url>/2019/09/20/es%E5%88%86%E9%A1%B5%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<p>(1) from / size : 该查询的实现原理类似于mysql中的limit，比如查询第10001条数据，那么需要将前面的10000条都拿出来，进行过滤，最终才得到数据。(性能较差，实现简单，适用于少量数据，数据量不超过10w)。<br>(2) scroll：该查询实现类似于消息消费的机制，首次查询的时候会在内存中保存一个历史快照以及游标(scroll_id)，记录当前消息查询的终止位置，下次查询的时候将基于游标进行消费(性能良好，维护成本高，在游标失效前，不会更新数据，不够灵活，一旦游标创建size就不可改变，适用于大量数据导出或者索引重建)<br>(3) search_after: 性能优秀，类似于优化后的分页查询，历史条件过滤掉数据。</p><p><strong>scroll</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#scroll深度分页</span></span><br><span class="line">result = es.search(index=[<span class="string">'patent_cn_v71'</span>],body=</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="string">'query'</span>:&#123;</span><br><span class="line">             <span class="string">'match_all'</span>:&#123;&#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="string">'sort'</span>:&#123;</span><br><span class="line">             <span class="string">'app_text'</span>:<span class="string">'asc'</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;,scroll=<span class="string">'1m'</span>,size=<span class="number">10000</span>)</span><br><span class="line">mdata = result.get(<span class="string">"hits"</span>).get(<span class="string">"hits"</span>)</span><br><span class="line">scroll_id = result[<span class="string">"_scroll_id"</span>]</span><br><span class="line">total = result[<span class="string">"hits"</span>][<span class="string">"total"</span>]</span><br><span class="line">j = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(total//<span class="number">10</span>):</span><br><span class="line">    res = es.scroll(scroll_id=scroll_id, scroll=<span class="string">'1m'</span>) <span class="comment">#scroll参数必须指定否则会报错</span></span><br><span class="line">    mdata += res[<span class="string">"hits"</span>][<span class="string">"hits"</span>]</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">for</span>  result <span class="keyword">in</span> mdata:</span><br><span class="line">    print(result[<span class="string">'_source'</span>][<span class="string">'app_text'</span>])</span><br></pre></td></tr></table></figure><p><strong>search_after</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> elasticsearch <span class="keyword">import</span> Elasticsearch</span><br><span class="line"></span><br><span class="line">es = Elasticsearch(hosts=&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="string">'192.168.0.220'</span>,</span><br><span class="line"></span><br><span class="line">                    <span class="string">'192.168.0.225'</span>,</span><br><span class="line"></span><br><span class="line">                    <span class="string">'192.168.0.221'</span>,</span><br><span class="line"></span><br><span class="line">                    &#125;,</span><br><span class="line"></span><br><span class="line">                    timeout=<span class="number">3600</span>)</span><br><span class="line">i = <span class="number">5000</span></span><br><span class="line">next_id = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i == <span class="number">5000</span>:</span><br><span class="line">    result_2 = es.search(index=[<span class="string">'patent_cn_v71'</span>],</span><br><span class="line"></span><br><span class="line">                           body=&#123;</span><br><span class="line">                               <span class="string">"query"</span>: &#123;</span><br><span class="line">                                   <span class="string">"match_all"</span>: &#123;&#125;</span><br><span class="line">                               &#125;,</span><br><span class="line">                                    <span class="string">"sort"</span>: [</span><br><span class="line">                                        &#123;<span class="string">"app_text"</span>: <span class="string">"asc"</span>&#125;</span><br><span class="line">                                    ],</span><br><span class="line">                            <span class="string">"search_after"</span>: [next_id],</span><br><span class="line">                           &#125;,</span><br><span class="line">                            filter_path=[</span><br><span class="line">                               <span class="string">'hits.hits._source.ipcr_text'</span>,</span><br><span class="line">                               <span class="string">'hits.hits._source.ipc_text'</span>,</span><br><span class="line">                               <span class="string">'hits.hits._source.id'</span>,</span><br><span class="line">                               <span class="string">'hits.hits._source.app_text'</span>,</span><br><span class="line">                           ],</span><br><span class="line">                           size=<span class="number">5000</span>,</span><br><span class="line">                           )</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result_2 = result_2[<span class="string">'hits'</span>][<span class="string">'hits'</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> result_2:</span><br><span class="line">        app_text = result[<span class="string">'_source'</span>][<span class="string">'app_text'</span>]</span><br><span class="line">    i = len(result_2)</span><br></pre></td></tr></table></figure><p><strong>from size</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">10</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i == <span class="number">10</span>:</span><br><span class="line">    result = es.search(index=[<span class="string">'patent_cn_v71'</span>],body=</span><br><span class="line">                      &#123;</span><br><span class="line">                          <span class="string">'query'</span>:&#123;</span><br><span class="line">                              <span class="string">'match_all'</span>:&#123;&#125;</span><br><span class="line">                          &#125;,</span><br><span class="line">                       <span class="string">'sort'</span>:[&#123;</span><br><span class="line">                           <span class="string">'app_text'</span>:<span class="string">'asc'</span></span><br><span class="line">                       &#125;],</span><br><span class="line">                      <span class="string">'from'</span>:j,</span><br><span class="line">                      <span class="string">'size'</span>:<span class="number">10</span></span><br><span class="line">                      &#125;,</span><br><span class="line">                      filter_path = [<span class="string">'hits.hits._source.app_text'</span>],</span><br><span class="line">                      )</span><br><span class="line">    j+=<span class="number">10</span></span><br><span class="line">    i = len(result[<span class="string">'hits'</span>][<span class="string">'hits'</span>])</span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pandas常用方法总结</title>
      <link href="/2019/09/19/pandas%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2019/09/19/pandas%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="to-dict-将dataframe转换成字典格式-对应的为json格式-十分常用"><a href="#to-dict-将dataframe转换成字典格式-对应的为json格式-十分常用" class="headerlink" title="to_dict(将dataframe转换成字典格式)===对应的为json格式(十分常用)"></a>to_dict(将dataframe转换成字典格式)===对应的为json格式(十分常用)</h3><h4 id="常用的有records和index"><a href="#常用的有records和index" class="headerlink" title="常用的有records和index"></a>常用的有records和index</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">df = pd.DataFrame(np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>),columns=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>])</span><br><span class="line">df</span><br><span class="line">    A   B   C   D</span><br><span class="line"><span class="number">0</span>   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">1</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span></span><br><span class="line"><span class="number">2</span>   <span class="number">8</span>   <span class="number">9</span>   <span class="number">10</span>  <span class="number">11</span></span><br><span class="line">df.to_dict(<span class="string">'records'</span>)    <span class="comment"># 使用频繁</span></span><br><span class="line">[&#123;<span class="string">'A'</span>: <span class="number">0</span>, <span class="string">'B'</span>: <span class="number">1</span>, <span class="string">'C'</span>: <span class="number">2</span>, <span class="string">'D'</span>: <span class="number">3</span>&#125;,</span><br><span class="line"> &#123;<span class="string">'A'</span>: <span class="number">4</span>, <span class="string">'B'</span>: <span class="number">5</span>, <span class="string">'C'</span>: <span class="number">6</span>, <span class="string">'D'</span>: <span class="number">7</span>&#125;,</span><br><span class="line"> &#123;<span class="string">'A'</span>: <span class="number">8</span>, <span class="string">'B'</span>: <span class="number">9</span>, <span class="string">'C'</span>: <span class="number">10</span>, <span class="string">'D'</span>: <span class="number">11</span>&#125;]</span><br><span class="line">df.to_dict(<span class="string">'index'</span>)   <span class="comment"># 使用频繁，一般报表的横坐标为日期，将date作为Index</span></span><br><span class="line">&#123;<span class="number">0</span>: &#123;<span class="string">'A'</span>: <span class="number">0</span>, <span class="string">'B'</span>: <span class="number">1</span>, <span class="string">'C'</span>: <span class="number">2</span>, <span class="string">'D'</span>: <span class="number">3</span>&#125;,</span><br><span class="line"> <span class="number">1</span>: &#123;<span class="string">'A'</span>: <span class="number">4</span>, <span class="string">'B'</span>: <span class="number">5</span>, <span class="string">'C'</span>: <span class="number">6</span>, <span class="string">'D'</span>: <span class="number">7</span>&#125;,</span><br><span class="line"> <span class="number">2</span>: &#123;<span class="string">'A'</span>: <span class="number">8</span>, <span class="string">'B'</span>: <span class="number">9</span>, <span class="string">'C'</span>: <span class="number">10</span>, <span class="string">'D'</span>: <span class="number">11</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="次要的有dict-默认-list-series-split都必须掌握"><a href="#次要的有dict-默认-list-series-split都必须掌握" class="headerlink" title="次要的有dict(默认)\list\series\split都必须掌握"></a>次要的有dict(默认)\list\series\split都必须掌握</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">df = pd.DataFrame(np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>),columns=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>])</span><br><span class="line">df</span><br><span class="line">    A   B   C   D</span><br><span class="line"><span class="number">0</span>   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">1</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span></span><br><span class="line"><span class="number">2</span>   <span class="number">8</span>   <span class="number">9</span>   <span class="number">10</span>  <span class="number">11</span></span><br><span class="line">df.to_dict(<span class="string">'dict'</span>)   <span class="comment"># 默认是dict</span></span><br><span class="line">&#123;<span class="string">'A'</span>: &#123;<span class="number">0</span>: <span class="number">0</span>, <span class="number">1</span>: <span class="number">4</span>, <span class="number">2</span>: <span class="number">8</span>&#125;,</span><br><span class="line"> <span class="string">'B'</span>: &#123;<span class="number">0</span>: <span class="number">1</span>, <span class="number">1</span>: <span class="number">5</span>, <span class="number">2</span>: <span class="number">9</span>&#125;,</span><br><span class="line"> <span class="string">'C'</span>: &#123;<span class="number">0</span>: <span class="number">2</span>, <span class="number">1</span>: <span class="number">6</span>, <span class="number">2</span>: <span class="number">10</span>&#125;,</span><br><span class="line"> <span class="string">'D'</span>: &#123;<span class="number">0</span>: <span class="number">3</span>, <span class="number">1</span>: <span class="number">7</span>, <span class="number">2</span>: <span class="number">11</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">df.to_dict(<span class="string">'list'</span>) </span><br><span class="line">&#123;<span class="string">'A'</span>: [<span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>], <span class="string">'B'</span>: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], <span class="string">'C'</span>: [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], <span class="string">'D'</span>: [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>]&#125;</span><br><span class="line"></span><br><span class="line">df.to_dict(<span class="string">'series'</span>) </span><br><span class="line">&#123;<span class="string">'A'</span>: <span class="number">0</span>    <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>    <span class="number">4</span></span><br><span class="line"> <span class="number">2</span>    <span class="number">8</span></span><br><span class="line"> Name: A, dtype: int64, <span class="string">'B'</span>: <span class="number">0</span>    <span class="number">1</span></span><br><span class="line"> <span class="number">1</span>    <span class="number">5</span></span><br><span class="line"> <span class="number">2</span>    <span class="number">9</span></span><br><span class="line"> Name: B, dtype: int64, <span class="string">'C'</span>: <span class="number">0</span>     <span class="number">2</span></span><br><span class="line"> <span class="number">1</span>     <span class="number">6</span></span><br><span class="line"> <span class="number">2</span>    <span class="number">10</span></span><br><span class="line"> Name: C, dtype: int64, <span class="string">'D'</span>: <span class="number">0</span>     <span class="number">3</span></span><br><span class="line"> <span class="number">1</span>     <span class="number">7</span></span><br><span class="line"> <span class="number">2</span>    <span class="number">11</span></span><br><span class="line"> Name: D, dtype: int64&#125;</span><br><span class="line"></span><br><span class="line">df.to_dict(<span class="string">'split'</span>)</span><br><span class="line">&#123;<span class="string">'index'</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line"> <span class="string">'columns'</span>: [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>],</span><br><span class="line"> <span class="string">'data'</span>: [[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>], [<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]]&#125;</span><br></pre></td></tr></table></figure><h3 id="astype-强制数据类型转换"><a href="#astype-强制数据类型转换" class="headerlink" title="astype(强制数据类型转换)"></a>astype(强制数据类型转换)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">'A'</span>] = df[<span class="string">'A'</span>].astype(float)</span><br></pre></td></tr></table></figure><h3 id="group-by-分组"><a href="#group-by-分组" class="headerlink" title="group_by(分组)"></a>group_by(分组)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(如果groupby后并sum,如果存在数字求和,则其他类型组合会清除,如果不存在数字求和,则字符串会出现拼接效果,如下所示)====通常的group都是与apply一起使用的,需要进一步了解</span><br><span class="line">df = pd.DataFrame([[<span class="string">'0'</span>,<span class="number">1</span>,<span class="string">'boy'</span>,<span class="string">'3'</span>],[<span class="string">'0'</span>,<span class="string">'5'</span>,<span class="string">'girl'</span>,<span class="string">'7'</span>]], columns=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>])</span><br><span class="line">df</span><br><span class="line"></span><br><span class="line">ABC D</span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">1</span>boy <span class="number">3</span></span><br><span class="line"><span class="number">1</span><span class="number">0</span><span class="number">5</span>girl <span class="number">7</span></span><br><span class="line">df.groupby(<span class="string">'A'</span>).sum()</span><br><span class="line">df</span><br><span class="line">C    D</span><br><span class="line">A</span><br><span class="line"><span class="number">0</span>  boygirl<span class="number">37</span></span><br></pre></td></tr></table></figure><h3 id="map-applymap-apply用法"><a href="#map-applymap-apply用法" class="headerlink" title="map\applymap\apply用法"></a>map\applymap\apply用法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">map===将series中的每一个元素通过函数进行处理(常用于dataframe中数据某一个字段整体的清洗)</span><br><span class="line">df1 = pd.DataFrame([[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>],[<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>]],columns=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>])</span><br><span class="line">df1</span><br><span class="line">ABC</span><br><span class="line"><span class="number">0</span>abc</span><br><span class="line"><span class="number">1</span>def</span><br><span class="line">df1[<span class="string">'A'</span>] = df1[<span class="string">'A'</span>].map(<span class="keyword">lambda</span> x:x+<span class="string">'号'</span>)</span><br><span class="line">df1</span><br><span class="line">ABC</span><br><span class="line"><span class="number">0</span>a号bc</span><br><span class="line"><span class="number">1</span>d号ef</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">applymap对于dataframe中的每一个元素进行操作</span><br><span class="line">df1.applymap(<span class="keyword">lambda</span> x:x+<span class="string">'球'</span>)</span><br><span class="line">  A   B    C</span><br><span class="line"><span class="number">0</span>a号球b球c球</span><br><span class="line"><span class="number">1</span>d号球e球f球</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apply方法可选定对于dataframe中行或者列进行操作</span><br><span class="line">df1.apply(<span class="keyword">lambda</span> x:x.sum(),axis=<span class="number">0</span>)</span><br><span class="line">A    a号d号</span><br><span class="line">B      be</span><br><span class="line">C      cf</span><br><span class="line">dtype: object</span><br><span class="line">df1.apply(<span class="keyword">lambda</span> x:x.sum(),axis=<span class="number">1</span>)</span><br><span class="line"><span class="number">0</span>    a号bc</span><br><span class="line"><span class="number">1</span>    d号ef</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure><h3 id="dataframe索引操作"><a href="#dataframe索引操作" class="headerlink" title="dataframe索引操作"></a>dataframe索引操作</h3><p><strong>reset_index</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">重置行索引(若果不加drop=<span class="literal">True</span>,则原来的索引成为新的列,加上则替换原索引)</span><br><span class="line">df1.index = [<span class="string">'s'</span>,<span class="string">'b'</span>]</span><br><span class="line">df1</span><br><span class="line">ABC</span><br><span class="line">sa号bc</span><br><span class="line">bd号ef</span><br><span class="line">df1.reset_index(drop=<span class="literal">True</span>)</span><br><span class="line">ABC</span><br><span class="line"><span class="number">0</span>a号bc</span><br><span class="line"><span class="number">1</span>d号ef</span><br><span class="line">df1.reset_index()</span><br><span class="line">  index A B C</span><br><span class="line"><span class="number">0</span>sa号bc</span><br><span class="line"><span class="number">1</span>bd号ef</span><br></pre></td></tr></table></figure><p><strong>reindex</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">重构或者任意重排索引,没有的数据会显示nan</span><br><span class="line">df = pd.DataFrame(np.random.randint(<span class="number">1</span>,<span class="number">100</span>,(<span class="number">5</span>,<span class="number">5</span>)))</span><br><span class="line">df</span><br><span class="line"><span class="number">0</span><span class="number">1</span><span class="number">2</span><span class="number">3</span><span class="number">4</span></span><br><span class="line"><span class="number">0</span><span class="number">94</span><span class="number">14</span><span class="number">86</span><span class="number">30</span><span class="number">9</span></span><br><span class="line"><span class="number">1</span><span class="number">94</span><span class="number">19</span><span class="number">7</span><span class="number">29</span><span class="number">40</span></span><br><span class="line"><span class="number">2</span><span class="number">53</span><span class="number">7</span><span class="number">45</span><span class="number">57</span><span class="number">18</span></span><br><span class="line"><span class="number">3</span><span class="number">71</span><span class="number">75</span><span class="number">56</span><span class="number">53</span><span class="number">36</span></span><br><span class="line"><span class="number">4</span><span class="number">96</span><span class="number">11</span><span class="number">92</span><span class="number">97</span><span class="number">53</span></span><br><span class="line">df.reindex([<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>])</span><br><span class="line"> <span class="number">0</span>       <span class="number">1</span> <span class="number">2</span>      <span class="number">3</span>      <span class="number">4</span></span><br><span class="line"><span class="number">4</span><span class="number">96.0</span><span class="number">11.0</span><span class="number">92.0</span><span class="number">97.0</span><span class="number">53.0</span></span><br><span class="line"><span class="number">2</span><span class="number">53.0</span><span class="number">7.0</span>    <span class="number">45.0</span><span class="number">57.0</span><span class="number">18.0</span></span><br><span class="line"><span class="number">3</span><span class="number">71.0</span><span class="number">75.0</span><span class="number">56.0</span><span class="number">53.0</span><span class="number">36.0</span></span><br><span class="line"><span class="number">5</span> NaNNaN NaN     NaNNaN</span><br></pre></td></tr></table></figure><p><strong>rename</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.rename(columns=lambda x: x + 1)：批量更改列名</span><br></pre></td></tr></table></figure><h3 id="数据处理相关"><a href="#数据处理相关" class="headerlink" title="数据处理相关"></a>数据处理相关</h3><p><strong>fillna补值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#直接替换原数据的nan为0,不加inplace不对原数据操作</span></span><br><span class="line">df.fillna(<span class="number">0</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#通过字典对不同的列填充不同的常数</span></span><br><span class="line">df1.fillna(&#123;<span class="number">0</span>:<span class="number">10</span>,<span class="number">1</span>:<span class="number">20</span>,<span class="number">2</span>:<span class="number">30</span>&#125;)</span><br><span class="line"><span class="comment">#用前面的值来填充</span></span><br><span class="line">df2.fillna(method=<span class="string">'ffill'</span>)</span><br><span class="line"><span class="comment">#用后面的值来填充</span></span><br><span class="line">df2.bfill(method=<span class="string">'bfill'</span>)</span><br><span class="line"><span class="comment">#limit限制填充的个数,axis修改填充的方向</span></span><br><span class="line">df2.fillna(method=<span class="string">"ffill"</span>,limit=<span class="number">1</span>,axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong>dropna删除空值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">df.dropna(how=<span class="string">''</span>)  all删除全为空值那一行,any删除存在空值那一行(默认<span class="number">0</span>表示行,<span class="number">1</span>代表列)</span><br><span class="line">DataFrame.dropna(axis=<span class="number">0</span>, how=<span class="string">'any'</span>, thresh=<span class="literal">None</span>, subset=<span class="literal">None</span>, inplace=<span class="literal">False</span>)</span><br><span class="line">参数说明：</span><br><span class="line"></span><br><span class="line">axis:</span><br><span class="line">axis=<span class="number">0</span>: 删除包含缺失值的行</span><br><span class="line">axis=<span class="number">1</span>: 删除包含缺失值的列</span><br><span class="line">how: 与axis配合使用</span><br><span class="line">how=‘any’ :只要有缺失值出现，就删除该行货列</span><br><span class="line">how=‘all’: 所有的值都缺失，才删除行或列</span><br><span class="line">thresh： axis中至少有thresh个非缺失值，否则删除</span><br><span class="line">比如 axis=<span class="number">0</span>，thresh=<span class="number">10</span>：标识如果该行中非缺失值的数量小于<span class="number">10</span>，将删除改行</span><br><span class="line">subset: list</span><br><span class="line">在哪些列中查看是否有缺失值</span><br><span class="line">inplace: 是否在原数据上操作。如果为真，返回<span class="literal">None</span>否则返回新的copy，去掉了缺失值</span><br></pre></td></tr></table></figure><p><strong>unique去重(针对series的去重)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[&apos;A&apos;].unique()</span><br></pre></td></tr></table></figure><p><strong>drop_duplicates(针对dataframe去重也可series)</strong>====实质针对的是所有的列字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">全部字段</span><br><span class="line">df.drop_duplicates()</span><br><span class="line">指定字段</span><br><span class="line">df.drop_duplicates([&apos;colA&apos;, &apos;colB&apos;])</span><br></pre></td></tr></table></figure><p><strong>replace替换指定字符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.replace(np.nan,0,inplace=True)</span><br><span class="line">将所有的空值替换成0</span><br></pre></td></tr></table></figure><p><strong>describe\info</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">查看汇总统计</span><br><span class="line">df.describe()</span><br><span class="line"><span class="number">0</span><span class="number">1</span><span class="number">2</span><span class="number">3</span><span class="number">4</span></span><br><span class="line">count<span class="number">4.000000</span><span class="number">4.000000</span><span class="number">4.000000</span><span class="number">4.000000</span><span class="number">4.00000</span></span><br><span class="line">mean<span class="number">55.000000</span><span class="number">23.250000</span><span class="number">48.250000</span><span class="number">51.750000</span><span class="number">26.75000</span></span><br><span class="line">std<span class="number">40.685788</span><span class="number">34.798228</span><span class="number">37.915476</span><span class="number">39.811012</span><span class="number">22.85279</span></span><br><span class="line">min<span class="number">0.000000</span><span class="number">0.000000</span><span class="number">0.000000</span><span class="number">0.000000</span><span class="number">0.00000</span></span><br><span class="line"><span class="number">25</span>%<span class="number">39.750000</span><span class="number">5.250000</span><span class="number">33.750000</span><span class="number">39.750000</span><span class="number">13.50000</span></span><br><span class="line"><span class="number">50</span>%<span class="number">62.000000</span><span class="number">9.000000</span><span class="number">50.500000</span><span class="number">55.000000</span><span class="number">27.00000</span></span><br><span class="line"><span class="number">75</span>%<span class="number">77.250000</span><span class="number">27.000000</span><span class="number">65.000000</span><span class="number">67.000000</span><span class="number">40.25000</span></span><br><span class="line">max<span class="number">96.000000</span><span class="number">75.000000</span><span class="number">92.000000</span><span class="number">97.000000</span><span class="number">53.00000</span></span><br><span class="line"></span><br><span class="line">查看索引、数据类型和内存信息</span><br><span class="line">df.info()</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">Int64Index</span>:</span> <span class="number">4</span> entries, <span class="number">4</span> to <span class="number">6</span></span><br><span class="line">Data columns (total <span class="number">5</span> columns):</span><br><span class="line"><span class="number">0</span>    <span class="number">4</span> non-null float64</span><br><span class="line"><span class="number">1</span>    <span class="number">4</span> non-null float64</span><br><span class="line"><span class="number">2</span>    <span class="number">4</span> non-null float64</span><br><span class="line"><span class="number">3</span>    <span class="number">4</span> non-null float64</span><br><span class="line"><span class="number">4</span>    <span class="number">4</span> non-null float64</span><br><span class="line">dtypes: float64(<span class="number">5</span>)</span><br><span class="line">memory usage: <span class="number">192.0</span> bytes</span><br></pre></td></tr></table></figure><p><strong>数据合并merge\concat\join</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pd.merge(df1, df2, on=&apos;key&apos;, how=&apos;left&apos;)</span><br><span class="line">pd.concat([df1,df2],join=&quot;inner&quot;,axis=1)===不会去重</span><br><span class="line">pd.concat([df1,df2],ignore_index=True).drop_duplicates() ====会去重</span><br><span class="line">df1.join(df2,how=&apos;inner&apos;)</span><br></pre></td></tr></table></figure><p><strong>date_range 创建时间数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pd.date_range(&apos;2018-09-10&apos;,periods=8,freq=&apos;m&apos;)</span><br><span class="line">DatetimeIndex([&apos;2018-09-30&apos;, &apos;2018-10-31&apos;, &apos;2018-11-30&apos;, &apos;2018-12-31&apos;,</span><br><span class="line">               &apos;2019-01-31&apos;, &apos;2019-02-28&apos;, &apos;2019-03-31&apos;, &apos;2019-04-30&apos;],</span><br><span class="line">              dtype=&apos;datetime64[ns]&apos;, freq=&apos;M&apos;)</span><br></pre></td></tr></table></figure><p><strong>value_counts数据频数统计</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对某一行或者某一列数据进行频数统计</span><br><span class="line">df.loc[2].value_counts()</span><br><span class="line">7.0     1</span><br><span class="line">额外请问    1</span><br><span class="line">45.0    1</span><br><span class="line">57.0    1</span><br><span class="line">18.0    1</span><br><span class="line">Name: 2, dtype: int64</span><br></pre></td></tr></table></figure><p><strong>数据统计</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">df.describe()：查看数据值列的汇总统计</span><br><span class="line">df.mean()：返回所有列的均值</span><br><span class="line">df.corr()：返回列与列之间的相关系数</span><br><span class="line">df.count()：返回每一列中的非空值的个数</span><br><span class="line">df.max()：返回每一列的最大值</span><br><span class="line">df.min()：返回每一列的最小值</span><br><span class="line">df.median()：返回每一列的中位数</span><br><span class="line">df.std()：返回每一列的标准差</span><br></pre></td></tr></table></figure><h4 id="数据选取-isin和str-contains"><a href="#数据选取-isin和str-contains" class="headerlink" title="数据选取(isin和str.contains)"></a>数据选取(isin和str.contains)</h4><p><strong>isin</strong>(df和series都可用)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">判断是否含所有某个数据(完全匹配)等于多个数值或者字符串时  内容为列表格式--符合任意一个都会返回</span><br><span class="line">df</span><br><span class="line"><span class="number">0</span><span class="number">1</span><span class="number">2</span><span class="number">3</span><span class="number">4</span></span><br><span class="line"><span class="number">4</span>委屈翁<span class="number">11.0</span><span class="number">92.0</span><span class="number">97.0</span><span class="number">53.0</span></span><br><span class="line"><span class="number">2</span>额外请问<span class="number">7.0</span><span class="number">45.0</span><span class="number">57.0</span><span class="number">18.0</span></span><br><span class="line"><span class="number">3</span>问问<span class="number">75.0</span><span class="number">56.0</span><span class="number">53.0</span><span class="number">36.0</span></span><br><span class="line"><span class="number">6</span>委屈翁群<span class="number">0.0</span><span class="number">0.0</span><span class="number">0.0</span><span class="number">0.0</span></span><br><span class="line">df[<span class="number">0</span>][df[<span class="number">0</span>].isin([<span class="string">'委屈翁'</span>,<span class="string">'问问'</span>])]</span><br><span class="line"><span class="number">4</span>    委屈翁</span><br><span class="line"><span class="number">3</span>     问问</span><br><span class="line">Name: <span class="number">0</span>, dtype: object</span><br></pre></td></tr></table></figure><p><strong>str.contains</strong>(针对的为series)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">判断某个数据中是否包含指定字符(字符串的模糊筛选)</span><br><span class="line">df[<span class="number">0</span>][df[<span class="number">0</span>].str.contains(<span class="string">'委屈'</span>)]</span><br><span class="line"><span class="number">4</span>     委屈翁</span><br><span class="line"><span class="number">6</span>    委屈翁群</span><br><span class="line">Name: <span class="number">0</span>, dtype: object</span><br><span class="line">多条件筛选用|符号</span><br><span class="line">df[<span class="number">0</span>][df[<span class="number">0</span>].str.contains(<span class="string">'翁|问'</span>)]</span><br><span class="line"><span class="number">4</span>     委屈翁</span><br><span class="line"><span class="number">2</span>    额外请问</span><br><span class="line"><span class="number">3</span>      问问</span><br><span class="line"><span class="number">6</span>    委屈翁群</span><br><span class="line">Name: <span class="number">0</span>, dtype: object</span><br><span class="line">        </span><br><span class="line"> <span class="comment">#参数解释    </span></span><br><span class="line">Series.str.contains(</span><br><span class="line">                    pat,        <span class="comment"># 要查询的字符串、要查询的或者正则表达式</span></span><br><span class="line">                    case=<span class="literal">True</span>,  <span class="comment"># 是否对大小写敏感</span></span><br><span class="line">                    flags=<span class="number">0</span>,    <span class="comment"># 用来传给正则模块的参数，比如 flags=re.INGNORECASE 等价于 case=False</span></span><br><span class="line">                    na=nan,     <span class="comment"># 默认对空值不处理，即输出结果还是 NaN</span></span><br><span class="line">                    regex=<span class="literal">True</span>  <span class="comment"># 即第一个参数 pat部分 要不要按照正则表达式的规则。</span></span><br><span class="line">                                 <span class="comment">#所以针对特殊符号，默认情况下我们必须使用转义符，或者设置 regex=False</span></span><br><span class="line">                    )</span><br></pre></td></tr></table></figure><h5 id="set-index-和-reset-index"><a href="#set-index-和-reset-index" class="headerlink" title="set_index 和 reset_index"></a>set_index 和 reset_index</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">将df1中A这一列设为索引,并且不删除原来的A那一列</span><br><span class="line">df1.set_index(<span class="string">'A'</span>,drop=<span class="literal">False</span>)</span><br><span class="line">将df1中A这一列设为索引,并且删除原来的A那一列</span><br><span class="line">df1.set_index(<span class="string">'A'</span>,drop=<span class="literal">True</span>)</span><br><span class="line">将df1中的索引还原,并且添加一列新的列(原来的索引列)</span><br><span class="line">df1.reset_index(<span class="string">'A'</span>,drop=<span class="literal">False</span>)</span><br><span class="line">将df1中的索引重置,索引那一列直接删除</span><br><span class="line">df1.reset_index(<span class="string">'A'</span>,drop=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h5 id="rank"><a href="#rank" class="headerlink" title="rank"></a>rank</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df.rank()  <span class="comment">#默认按照列排序,返回的结果为对应各自排名的矩阵</span></span><br><span class="line">df.rank(axis=<span class="number">1</span>) <span class="comment">#按照行进行排序</span></span><br><span class="line">df.rank(axis=<span class="number">1</span>,method=<span class="string">'average'</span>) <span class="comment">#数据相同的排名全部取对应排名的平均值</span></span><br><span class="line">df.rank(axis=<span class="number">1</span>,method=<span class="string">'max'</span>) <span class="comment">#取最大排名</span></span><br><span class="line">df.rank(axis=<span class="number">1</span>,method=<span class="string">'first'</span>) 原始数据中出现的顺序进行排名</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sorted(cxy_data, key=<span class="keyword">lambda</span> i: i[<span class="string">'num'</span>], reverse=<span class="literal">True</span>)  按照字典中的某个值倒叙</span><br><span class="line">sorted(dict1.items(),key=<span class="keyword">lambda</span> i:i[<span class="number">1</span>])  按照字典的值排序</span><br></pre></td></tr></table></figure><p>#####to_excel<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">writer = pd.ExcelWriter(<span class="string">r'C:\Users\Administrator\Desktop\ceshe.xlsx'</span>)</span><br><span class="line">data.to_excel(writer,sheet_name=<span class="string">'Sheet1'</span>)</span><br><span class="line">writer.save()    <span class="comment">#直接将df导出到excel中</span></span><br></pre></td></tr></table></figure></p><p>#####stack和unstack<br><img src="/2019/09/19/pandas常用方法总结/stack和unstack.png" alt="stack和unstack"></p><h5 id="pandas分行取top多少"><a href="#pandas分行取top多少" class="headerlink" title="pandas分行取top多少"></a>pandas分行取top多少</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Series.nlargest([n, 保持])</span><br><span class="line"></span><br><span class="line">返回最大的n 个元素。</span><br><span class="line"></span><br><span class="line">Series.nsmallest([n, 保持])</span><br><span class="line"></span><br><span class="line">返回最小的n 个元素。</span><br></pre></td></tr></table></figure><h4 id="Python操作excel方法-对比"><a href="#Python操作excel方法-对比" class="headerlink" title="Python操作excel方法 对比"></a>Python操作excel方法 对比</h4><p><img src="/2019/09/19/pandas常用方法总结/bdf6b66e3614a73cab83cc34ae864063.jpg" alt="bdf6b66e3614a73cab83cc34ae864063"></p><h4 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df.eval(</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    c = a + b</span><br><span class="line">    d = a + b + c</span><br><span class="line">    a = 1</span><br><span class="line">    &quot;&quot;&quot;,inplace=False)</span><br><span class="line">df.query(&quot;strings == &apos;a&apos; and nums == 1&quot;)</span><br></pre></td></tr></table></figure><h5 id="等长列表两两元素操作"><a href="#等长列表两两元素操作" class="headerlink" title="等长列表两两元素操作"></a>等长列表两两元素操作</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(map(<span class="keyword">lambda</span> x :x[<span class="number">0</span>]+x[<span class="number">1</span>] ,zip(a,b)))</span><br></pre></td></tr></table></figure><h4 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">outer_params = [company_table,zl_zu_table,replace_rate_group_table,techonology_life_replace_table,zhibiao]</span><br><span class="line">outer_params = &apos; &apos;.join(outer_params)</span><br><span class="line">os.system(f&quot;python3 tech_life_grant_ceased_num_2.py &#123;outer_params&#125;&quot;)</span><br></pre></td></tr></table></figure><h4 id="dataframe插入clickhouse"><a href="#dataframe插入clickhouse" class="headerlink" title="dataframe插入clickhouse"></a>dataframe插入clickhouse</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client = Client(host=&apos;192.168.0.170&apos;, port=&apos;9000&apos;, user=&apos;algorithm&apos;, password=&apos;1a2s3d4f&apos;, database=&apos;algorithm_dis&apos;,settings=&#123;&apos;use_numpy&apos;: True&#125;)</span><br><span class="line"></span><br><span class="line">sql_insert = &apos;insert into industryid_name_20211208 values&apos;</span><br><span class="line">client.insert_dataframe(sql_insert,df)</span><br></pre></td></tr></table></figure><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">超级好用,支持在原有基础上新增一列,支持groupby后的操作</span><br><span class="line"></span><br><span class="line">hold_df.groupby([&apos;PORT_ID&apos;,&apos;SEC_ID&apos;,&apos;VALID_DATE&apos;]).REAL_SEC_ID.transform(&apos;count&apos;)</span><br><span class="line"></span><br><span class="line">transform相当于新增了一列,好东西</span><br></pre></td></tr></table></figure><h4 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">整体向下平移,支持groupby后shift,搭配assigh使用</span><br><span class="line">group.assign(PRE_NAV=(group.groupby( [&apos;GROUP_ID&apos;] + [&apos;GROUP_NAME&apos;] + [&apos;SEC_ID&apos;] + [&apos;SEC_ABBR&apos;])[&apos;ADJ_NAV&apos;].shift(1)))</span><br></pre></td></tr></table></figure><h2 id="python离线安装第三方whl文件"><a href="#python离线安装第三方whl文件" class="headerlink" title="python离线安装第三方whl文件"></a>python离线安装第三方whl文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pip download pandas -d  E:\光大POC\fin_indicators</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># download online</span><br><span class="line">pip download package_name -d target_dir</span><br><span class="line"># install offline</span><br><span class="line">pip install --no-index -f target_dir -r requirements.txt</span><br></pre></td></tr></table></figure><p>其他</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip freeze &gt; requirments.txt</span><br><span class="line">pip download -d py_pkgs -r requirments.txt</span><br></pre></td></tr></table></figure><p>从windows到linux部署</p><p><img src="/2019/09/19/pandas常用方法总结/image-20230825160339198.png" alt="image-20230825160339198"></p><h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据使用的进程不销毁,占用的内存不会减少,因而可以通过创建子进程实现回收</span><br><span class="line">with concurrent.futures.ProcessPoolExecutor(max_workers=1) as executor:</span><br><span class="line">    result = executor.submit(func).result()</span><br></pre></td></tr></table></figure><blockquote></blockquote><h2 id="转换数类型神器"><a href="#转换数类型神器" class="headerlink" title="转换数类型神器"></a>转换数类型神器</h2><p>df.convert_dtypes</p><p>补充:其他的常用方</p><p>法总结<a href="https://www.cnblogs.com/rexyan/p/7975707.html" target="_blank" rel="noopener">https://www.cnblogs.com/rexyan/p/7975707.html</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口获取数据</title>
      <link href="/2019/09/19/%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/"/>
      <url>/2019/09/19/%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>注意json格式的转换和data中[]符号不能缺</p><p>方式一:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests,json</span><br><span class="line">url = <span class="string">'http://192.168.0.226:9557/api/internal/findQxbInfo'</span></span><br><span class="line">data = &#123;<span class="string">"company"</span>:[<span class="string">"华为技术有限公司"</span>]&#125;</span><br><span class="line">result = requests.post(url,json.dumps(data))</span><br><span class="line">result.text</span><br></pre></td></tr></table></figure><p>方式二:(一的提升)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests,json</span><br><span class="line">url = <span class="string">'http://192.168.0.226:9557/api/internal/findQxbInfo'</span></span><br><span class="line">data = &#123;<span class="string">'company'</span>:[<span class="string">"华为技术有限公司"</span>]&#125;</span><br><span class="line">headers = &#123;<span class="string">'Content-type'</span>:<span class="string">'application/json'</span>&#125;</span><br><span class="line">data = json.dumps(data)</span><br><span class="line">result = requests.post(url,data,headers)</span><br><span class="line">json.loads(result.text)</span><br></pre></td></tr></table></figure><p>获取公司曾用名和现用名接口操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zl_list = []</span><br><span class="line"><span class="keyword">for</span> applicant <span class="keyword">in</span> applicant_list:</span><br><span class="line">    url = <span class="string">f'http://192.168.0.226:9666/api/search/patentStatisticData?companyName=<span class="subst">&#123;applicant&#125;</span>'</span></span><br><span class="line">    result = requests.get(url)</span><br><span class="line">    inventionNum = json.loads(result.text)[<span class="string">'result'</span>][<span class="string">'inventionNum'</span>]</span><br><span class="line">    zl_list.append([applicant,inventionNum])</span><br></pre></td></tr></table></figure><p>python flask写接口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request, Flask, jsonify</span><br><span class="line"><span class="keyword">from</span> http <span class="keyword">import</span> client</span><br><span class="line"></span><br><span class="line">client.HTTPConnection._http_vsn = <span class="number">10</span></span><br><span class="line">client.HTTPConnection._http_vsn_str = <span class="string">'HTTP/1.0'</span></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">'JSON_AS_ASCII'</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/test', methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post_Data</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        info = request.json</span><br><span class="line">        app_texts = info[<span class="string">'app_texts'</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        result = &#123;<span class="string">'FlagCode'</span>:<span class="number">0</span>,<span class="string">'message'</span>:<span class="string">'格式错误'</span>&#125;</span><br><span class="line">        <span class="keyword">return</span> jsonify(result)</span><br><span class="line">    <span class="keyword">if</span> type(app_texts) != list:</span><br><span class="line">        result = &#123;<span class="string">'FlagCode'</span>:<span class="number">0</span>,<span class="string">'message'</span>:<span class="string">'格式错误'</span>&#125;</span><br><span class="line">        <span class="keyword">return</span> jsonify(result)</span><br><span class="line">    <span class="keyword">if</span> app_texts == []:</span><br><span class="line">        result = &#123;<span class="string">'FlagCode'</span>:<span class="number">0</span>,<span class="string">'message'</span>:<span class="string">'缺少数据'</span>&#125;</span><br><span class="line">        <span class="keyword">return</span> jsonify(result) </span><br><span class="line">    <span class="comment">#查数据写成对应格式</span></span><br><span class="line">    result = &#123;<span class="string">'FlagCode'</span>:<span class="number">1</span>,<span class="string">'message'</span>:<span class="string">'操作成功'</span>,<span class="string">'result'</span>:res&#125;</span><br><span class="line">    <span class="keyword">return</span> jsonify(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>, host=<span class="string">'0.0.0.0'</span>, port=<span class="number">9525</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pandas读取mysql</title>
      <link href="/2019/09/18/pandas%E8%AF%BB%E5%8F%96mysql/"/>
      <url>/2019/09/18/pandas%E8%AF%BB%E5%8F%96mysql/</url>
      
        <content type="html"><![CDATA[<p>#读取</p><h3 id="方式一-元组嵌套格式"><a href="#方式一-元组嵌套格式" class="headerlink" title="方式一:(元组嵌套格式)"></a>方式一:(元组嵌套格式)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db=pymysql.connect(host=<span class="string">'localhost'</span>,port=<span class="number">3306</span>,user=<span class="string">'root'</span>,database=<span class="string">'comp'</span>,password=<span class="string">'123456'</span>,charset=<span class="string">'utf8mb4'</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line">sql = <span class="string">'select * from company_message '</span></span><br><span class="line">cursor.execute(sql)</span><br><span class="line">company_data = cursor.fetchall()</span><br></pre></td></tr></table></figure><h3 id="方式二-dataframe格式"><a href="#方式二-dataframe格式" class="headerlink" title="方式二:(dataframe格式)"></a>方式二:(dataframe格式)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conn=pymysql.connect(host=<span class="string">'localhost'</span>,port=<span class="number">3306</span>,user=<span class="string">'root'</span>,database=<span class="string">'comp'</span>,password=<span class="string">'123456'</span>,charset=<span class="string">'utf8mb4'</span>)</span><br><span class="line">sql = <span class="string">'select * from company_message '</span></span><br><span class="line">datasss = pd.read_sql(sql,conn)</span><br><span class="line">datasss</span><br></pre></td></tr></table></figure><h3 id="方式三-dataframe格式"><a href="#方式三-dataframe格式" class="headerlink" title="方式三:(dataframe格式)"></a>方式三:(dataframe格式)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line">engine = create_engine(<span class="string">'mysql+pymysql://root:123456@localhost:3306/comp'</span>)</span><br><span class="line">sql = <span class="string">'select * from company_message '</span></span><br><span class="line">df = pd.read_sql_query(sql,engine)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure><p>#存储</p><h3 id="方式一-直接dataframe保存到mysql"><a href="#方式一-直接dataframe保存到mysql" class="headerlink" title="方式一:直接dataframe保存到mysql"></a>方式一:直接dataframe保存到mysql</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">engine = create_engine(<span class="string">'mysql+pymysql://root:123456@localhost:3306/comp?charset=UTF8'</span>)</span><br><span class="line">pd.io.sql.to_sql(app_times,<span class="string">'app_times'</span>, engine, index=<span class="literal">False</span>, if_exists=<span class="string">'append'</span>, chunksize=<span class="number">10000</span>,)    </span><br><span class="line">engine.dispose()</span><br></pre></td></tr></table></figure><p>###方式二:正常存储<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db = pymysql.connect(host=<span class="string">'localhost'</span>, port=<span class="number">3306</span>, user=<span class="string">'root'</span>,database=<span class="string">'comp'</span>,password=<span class="string">'123456'</span>,</span><br><span class="line">                             charset=<span class="string">'utf8mb4'</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line">data = (data[<span class="number">0</span>], data[<span class="number">1</span>])</span><br><span class="line">sql = <span class="string">'insert into patent_apply_date (app_text,apply_msg) values (%s,%s)'</span></span><br><span class="line">cursor.execute(sql, data)</span><br><span class="line">db.commit()</span><br><span class="line">cursor.close()</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> pandas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jupyter修改字体颜色大小</title>
      <link href="/2019/09/17/%E4%BF%AE%E6%94%B9%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E5%A4%A7%E5%B0%8F/"/>
      <url>/2019/09/17/%E4%BF%AE%E6%94%B9%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E5%A4%A7%E5%B0%8F/</url>
      
        <content type="html"><![CDATA[<p>原文转载:<a href="https://blog.csdn.net/AlanGuoo/article/details/86318381" target="_blank" rel="noopener">https://blog.csdn.net/AlanGuoo/article/details/86318381</a></p><p>改变字体颜色(color)<br>红色+加粗<br><strong><font color="red">红色+加粗</font></strong></p><p>蓝色+斜体<br><em><font color="blue">蓝色+斜体</font></em><br>或<br><em><font color="blue">蓝色+斜体</font></em></p><p>绿色+加粗+斜体<br><strong><em><font color="green">绿色+加粗+斜体</font></em></strong><br>或<br><em><strong><font color="green">绿色+加粗+斜体</font></strong></em><br>或<br><strong><em><font color="green">绿色+加粗+斜体</font></em></strong></p><p>改变字体(face)、大小(size)<br>5号雅黑</p><font color="steel" size="5" face="雅黑">5号雅黑</font><p>可以看出来 color, size, font 的顺序可以随意调整，且参数不需要加引号<br>文字进行高亮显示<br>通过<mark>标签<br><mark>黄色高亮<mark></mark></mark></mark></p><p>改变高亮颜色<br><mark style="background-color:red">改变高亮颜色</mark> </p><p>叠加字体的变化<br><mark><font color="red" size="4" face="雅黑">叠加字体的变化<font><mark></mark></font></font></mark></p>]]></content>
      
      
      
        <tags>
            
            <tag> jupyter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>selenium爬取企查查案例</title>
      <link href="/2019/09/12/selenium%E7%88%AC%E5%8F%96%E4%BC%81%E6%9F%A5%E6%9F%A5%E6%A1%88%E4%BE%8B/"/>
      <url>/2019/09/12/selenium%E7%88%AC%E5%8F%96%E4%BC%81%E6%9F%A5%E6%9F%A5%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">chrome_options = Options()</span><br><span class="line">    chrome_options.add_argument(<span class="string">'--headless'</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">'--disable-gpu'</span>)</span><br><span class="line">    <span class="comment"># 驱动路径</span></span><br><span class="line">    path = <span class="string">'C:\Program Files (x86)\Google\Chrome\Application\chromedriver.exe'</span></span><br><span class="line">    <span class="comment"># 创建浏览器对象</span></span><br><span class="line">    driver = webdriver.Chrome(executable_path=path, chrome_options=chrome_options)</span><br><span class="line">    url = <span class="string">'https://www.qichacha.com/'</span></span><br><span class="line">    driver = webdriver.Chrome()</span><br><span class="line">    driver.get(url)</span><br><span class="line">    driver.find_element_by_xpath(<span class="string">'//input[@id="searchkey"]'</span>).send_keys(<span class="string">f'<span class="subst">&#123;company_name&#125;</span>'</span>)</span><br><span class="line">    driver.find_element_by_xpath(<span class="string">"//input[@value ='查一下']"</span>).click()</span><br><span class="line">    driver.find_element_by_xpath(<span class="string">"//a[@class ='ma_h1']"</span>).click()</span><br><span class="line"></span><br><span class="line">    cookies = driver.get_cookies()</span><br><span class="line"></span><br><span class="line">    cookies_list= []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> cookie_dict <span class="keyword">in</span> cookies:</span><br><span class="line">        cookie =cookie_dict[<span class="string">'name'</span>]+<span class="string">'='</span>+cookie_dict[<span class="string">'value'</span>]</span><br><span class="line">        cookies_list.append(cookie)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    header_cookie = <span class="string">';'</span>.join(cookies_list)</span><br><span class="line">    print(header_cookie)</span><br><span class="line"></span><br><span class="line">    headers2 = &#123;</span><br><span class="line">        <span class="string">'cookie'</span>:header_cookie,</span><br><span class="line">        <span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36'</span></span><br><span class="line">    &#125;</span><br><span class="line">    fin_url = driver.current_url</span><br><span class="line">    response = requests.get(fin_url,headers=headers2)</span><br><span class="line">    mainhandle=driver.current_window_handle <span class="comment">#主页面句柄  每个浏览器标签页都有一个句柄</span></span><br><span class="line">    <span class="comment"># print(response.text)</span></span><br><span class="line">    handles = driver.window_handles</span><br><span class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles:<span class="comment"># 轮流得出标签页的句柄 切换窗口 因为只有两个标签页实际是假for循环 </span></span><br><span class="line">        <span class="keyword">if</span> handle!=mainhandle:</span><br><span class="line">            driver.switch_to_window(handle)</span><br><span class="line">            <span class="comment">#获得数据</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                raw=driver.find_element_by_xpath(<span class="string">"//table[@class='ntable']"</span>)</span><br><span class="line">                <span class="keyword">print</span> (raw.text)</span><br><span class="line">                <span class="keyword">for</span>  data1 <span class="keyword">in</span> raw.text.split(<span class="string">'\n'</span>):</span><br><span class="line">                    <span class="keyword">if</span> <span class="string">'-'</span> <span class="keyword">in</span> data1:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment">#流通市值</span></span><br><span class="line">                    ltsz = data1.split(<span class="string">' '</span>)[<span class="number">3</span>]</span><br><span class="line">                    <span class="comment">#市盈率</span></span><br><span class="line">                    syl = data1.split(<span class="string">' '</span>)[<span class="number">1</span>]</span><br><span class="line">                    <span class="comment">#市净率</span></span><br><span class="line">                    sjl = data1.split(<span class="string">' '</span>)[<span class="number">3</span>]</span><br><span class="line">                    print(ltsz,syl,sjl)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                print(<span class="string">"无该数据"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python实现排序算法</title>
      <link href="/2019/09/12/python%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2019/09/12/python%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>##冒泡排序<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)-i<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>]:</span><br><span class="line">                nums[j],nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>],nums[j]</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure></p><p>##插入排序<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(arr)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(arr)):</span><br><span class="line">key = arr[i]</span><br><span class="line">j = i<span class="number">-1</span></span><br><span class="line"><span class="keyword">while</span> j&gt;<span class="number">0</span> <span class="keyword">and</span> key &lt; arr[j]:</span><br><span class="line">arr[j+<span class="number">1</span>] = arr[j]</span><br><span class="line">j -= <span class="number">1</span></span><br><span class="line">arr[j+<span class="number">1</span>] = key</span><br></pre></td></tr></table></figure></p><p>##归并排序<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line"><span class="keyword">if</span> len(alist) &lt;= <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> alist</span><br><span class="line">nums = len(alist)/<span class="number">2</span></span><br><span class="line">left = merge_sort(alist[:num])</span><br><span class="line">right = merge_sort(alist[num:]</span><br><span class="line"><span class="keyword">return</span> merge(left,right)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left,right)</span>:</span></span><br><span class="line">l,r = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">while</span> l&lt;len(left) <span class="keyword">and</span> r&lt;len(right):</span><br><span class="line"><span class="keyword">if</span> left[<span class="number">1</span>] &lt; right[r]</span><br><span class="line">result.append(left[<span class="number">1</span>])</span><br><span class="line">l+=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">result.append(right[r])</span><br><span class="line">r+=<span class="number">1</span></span><br><span class="line">result += left[l:]</span><br><span class="line">result += rifht[r:]</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p>##快速排序<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(alist,start,end)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> start &gt;= end:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    mid = alist[start]</span><br><span class="line">    low = start</span><br><span class="line">    high = end</span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> alist[high] &gt;= mid:</span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">        alist[low] = alist[high]</span><br><span class="line">        <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> alist[low] &lt; mid:</span><br><span class="line">            low+=<span class="number">1</span></span><br><span class="line">        alist[high] = alist[low]</span><br><span class="line">    alist[low] = mid</span><br><span class="line">    quick_sort(alist,start,low<span class="number">-1</span>)</span><br><span class="line">    quick_sort(alist,low+<span class="number">1</span>,end)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 几种常见的排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python操作es查询</title>
      <link href="/2019/09/12/python%E6%93%8D%E4%BD%9Ces%E6%9F%A5%E8%AF%A2/"/>
      <url>/2019/09/12/python%E6%93%8D%E4%BD%9Ces%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<p>#es查询相关</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">aggs聚合中terms和cardinality的区别:</span><br><span class="line">    terms:聚合分组，类似于sql中group by，结果为每个单位出现的次数，需要给定size值，不然默认最大为<span class="number">10</span></span><br><span class="line">    举例:</span><br><span class="line">    <span class="string">"aggs"</span>: &#123;</span><br><span class="line">    <span class="string">"classid"</span>: &#123;</span><br><span class="line">      <span class="string">"terms"</span>: &#123;</span><br><span class="line">        <span class="string">"field"</span>: <span class="string">"classid"</span>,</span><br><span class="line">        <span class="string">"size"</span>: <span class="number">10</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;    </span><br><span class="line">    返回结果为classid去重后对应每个classid出现的次数</span><br><span class="line">        </span><br><span class="line">    cardinality: 去重，类似于sql中distinct ,结果为单位数量，</span><br><span class="line">    举例:</span><br><span class="line">    <span class="string">"aggs"</span>: &#123;</span><br><span class="line">        <span class="string">"classid"</span>: &#123;</span><br><span class="line">          <span class="string">"cardinality"</span>: &#123;</span><br><span class="line">            <span class="string">"field"</span>: <span class="string">"classid"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">返回结果为classid去重后的个数</span><br></pre></td></tr></table></figure><p>–match–<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">query==match==query实现模糊查询        分词查询含有的会被找出(如下含有学校或者公司的会被找出)===自动分词或者自己设计</span><br><span class="line">result_list = es.search(index=[<span class="string">'patent_cn_v7'</span>],</span><br><span class="line">                     body=&#123;</span><br><span class="line">                         <span class="string">"query"</span>: &#123;</span><br><span class="line">                             <span class="string">"match"</span>: &#123;</span><br><span class="line">                                 <span class="string">'applicant_address_other'</span>: &#123;</span><br><span class="line">                                     <span class="string">'query'</span>:<span class="string">'公司'</span></span><br><span class="line">                                 &#125;,</span><br><span class="line">                                 <span class="comment">#  检索条件</span></span><br><span class="line">                             &#125;,</span><br><span class="line"><span class="comment">#                              'match':&#123;</span></span><br><span class="line"><span class="comment">#                                  'app_text':'CN01316971'</span></span><br><span class="line"><span class="comment">#                              &#125;</span></span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;,</span><br><span class="line">                        filter_path=[</span><br><span class="line">                               <span class="string">'hits.hits._source.applicant_address_other'</span>,</span><br><span class="line">                                <span class="string">'hits.hits._source.app_text'</span>,</span><br><span class="line">                            <span class="string">'hits.hits._source.applicant_other'</span></span><br><span class="line">                           ],</span><br><span class="line">                                          <span class="comment"># 数据量</span></span><br><span class="line">                        size=<span class="number">10</span></span><br><span class="line">                     )</span><br><span class="line">result_list</span><br></pre></td></tr></table></figure></p><p>–match_phrase<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">query==match_phase_query 必须符合全部分词才会被找出来添加slop可以放宽条件</span><br><span class="line">result_list = es.search(index=[<span class="string">'patent_cn_v7'</span>],</span><br><span class="line">                     body=&#123;</span><br><span class="line">                         <span class="string">"query"</span>: &#123;</span><br><span class="line">                             <span class="string">"match_phrase"</span>: &#123;</span><br><span class="line">                                     <span class="string">'applicant_address_other'</span>: &#123;</span><br><span class="line">                                     <span class="string">'query'</span>:<span class="string">'山东学校'</span>,</span><br><span class="line">                                         <span class="string">'slop'</span>: <span class="number">1</span></span><br><span class="line">                                         </span><br><span class="line">                                 &#125;,         <span class="comment">#  检索条件</span></span><br><span class="line">                                 </span><br><span class="line">                                 </span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;,</span><br><span class="line">                       filter_path=[</span><br><span class="line">                               <span class="string">'hits.hits._source.applicant_address_other'</span>,</span><br><span class="line">                                <span class="string">'hits.hits._source.app_text'</span>,</span><br><span class="line">                           ],                    <span class="comment"># 数据量</span></span><br><span class="line">                     )</span><br><span class="line">result_list</span><br></pre></td></tr></table></figure></p><p>–multi_match–<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">multi_match 多字段匹配其中一个满足即可========也是自动分词</span><br><span class="line">result_list = es.search(index=[<span class="string">'patent_cn_v7'</span>],</span><br><span class="line">                     body=&#123;</span><br><span class="line">                         <span class="string">"query"</span>: &#123;</span><br><span class="line">                             <span class="string">"multi_match"</span>: &#123;</span><br><span class="line">                                     <span class="string">'query'</span>:<span class="string">'山东电学校'</span>,</span><br><span class="line">                                     <span class="string">'fields'</span>:[<span class="string">'applicant_address_other'</span>,<span class="string">'applicant_other'</span>]</span><br><span class="line">                                 ,         <span class="comment">#  检索条件</span></span><br><span class="line">                                 </span><br><span class="line">                                 </span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;,</span><br><span class="line">                       filter_path=[</span><br><span class="line">                               <span class="string">'hits.hits._source.applicant_address_other'</span>,</span><br><span class="line">                           <span class="string">'hits.hits._source.applicant_other'</span>,</span><br><span class="line">                                <span class="string">'hits.hits._source.app_text'</span>,</span><br><span class="line">                           ],                    <span class="comment"># 数据量</span></span><br><span class="line">                     )</span><br><span class="line">result_list</span><br></pre></td></tr></table></figure></p><p>–term–<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">term表示完全匹配不会经过分词器</span><br><span class="line">result_list = es.search(index=[<span class="string">'patent_cn_v7'</span>],</span><br><span class="line">                     body=&#123;</span><br><span class="line">                         <span class="string">"query"</span>: &#123;</span><br><span class="line">                             <span class="string">"term"</span>: &#123;</span><br><span class="line">                                     <span class="string">'applicant_other.keyword'</span>:<span class="string">'山东省电力学校'</span>,         </span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;,</span><br><span class="line">                       filter_path=[</span><br><span class="line">                               <span class="string">'hits.hits._source.applicant_address_other'</span>,</span><br><span class="line">                           <span class="string">'hits.hits._source.applicant_other'</span>,</span><br><span class="line">                                <span class="string">'hits.hits._source.app_text'</span>,</span><br><span class="line">                           ],                    <span class="comment"># 数据量</span></span><br><span class="line">                     )</span><br><span class="line">result_list</span><br></pre></td></tr></table></figure></p><p>–terms–<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">terms多条件精准匹配</span><br><span class="line">result_list = es.search(index=[<span class="string">'patent_cn_v7'</span>],</span><br><span class="line">                     body=&#123;</span><br><span class="line">                         <span class="string">"query"</span>: &#123;</span><br><span class="line">                             <span class="string">"terms"</span>: &#123;</span><br><span class="line">                                     <span class="string">'applicant_other.keyword'</span>:[<span class="string">'孙向柔'</span>,<span class="string">'吕百顺'</span>],         </span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;,</span><br><span class="line">                       filter_path=[</span><br><span class="line">                               <span class="string">'hits.hits._source.applicant_address_other'</span>,</span><br><span class="line">                           <span class="string">'hits.hits._source.applicant_other'</span>,</span><br><span class="line">                                <span class="string">'hits.hits._source.app_text'</span>,</span><br><span class="line">                           ],</span><br><span class="line">                        size=<span class="number">1000</span><span class="comment"># 数据量</span></span><br><span class="line">                     )</span><br><span class="line">result_list</span><br></pre></td></tr></table></figure></p><p>–bool   filter–<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">bool====filter双重过滤(相当于mysql中的where)</span><br><span class="line">result_list = es.search(index=[<span class="string">'patent_cn_v7'</span>],</span><br><span class="line">                     body=&#123;</span><br><span class="line">                         <span class="string">"query"</span>: &#123;<span class="string">'bool'</span>:&#123;</span><br><span class="line">                             <span class="string">'must'</span>:&#123;<span class="string">"match"</span>: &#123;</span><br><span class="line">                                     <span class="string">'applicant_other.keyword'</span>:<span class="string">'吕百顺'</span>        </span><br><span class="line">                             &#125;&#125;,</span><br><span class="line"></span><br><span class="line">                              <span class="string">'filter'</span>:&#123;</span><br><span class="line">                                  <span class="string">'match'</span>:&#123;</span><br><span class="line">                                          <span class="string">'app_text'</span>:<span class="string">'CN89215264'</span></span><br><span class="line">                                      </span><br><span class="line">                                  &#125;</span><br><span class="line">                              &#125;</span><br><span class="line">                         &#125;&#125;&#125;,</span><br><span class="line">                     filter_path=[<span class="string">'hits.hits._source.applicant_other'</span>]</span><br><span class="line">                            </span><br><span class="line">                             </span><br><span class="line">                         </span><br><span class="line">                                       </span><br><span class="line">                     )</span><br><span class="line">result_list</span><br></pre></td></tr></table></figure></p><p>–prefix–<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">prefix以什么指定开头</span><br><span class="line">result_list = es.search(index=[<span class="string">'patent_cn_v7'</span>],</span><br><span class="line">                     body=&#123;</span><br><span class="line">                         <span class="string">"query"</span>: &#123;</span><br><span class="line">                             <span class="string">"prefix"</span>: &#123;</span><br><span class="line">                                     <span class="string">'applicant_other.keyword'</span>:<span class="string">'三江瓦力'</span>,         </span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;,</span><br><span class="line">                       filter_path=[</span><br><span class="line">                               <span class="string">'hits.hits._source.applicant_address_other'</span>,</span><br><span class="line">                           <span class="string">'hits.hits._source.applicant_other'</span>,</span><br><span class="line">                                <span class="string">'hits.hits._source.app_text'</span>,</span><br><span class="line">                           ],</span><br><span class="line">                        size=<span class="number">1000</span><span class="comment"># 数据量</span></span><br><span class="line">                     )</span><br><span class="line">result_list</span><br></pre></td></tr></table></figure></p><p>–regexp–<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">正则表达式检索</span><br><span class="line">result_list = es.search(index=[<span class="string">'patent_cn_v7'</span>],</span><br><span class="line">                     body=&#123;</span><br><span class="line">                         <span class="string">"query"</span>: &#123;</span><br><span class="line">                             <span class="string">"regexp"</span>: &#123;</span><br><span class="line">                                     <span class="string">'applicant_other.keyword'</span>:<span class="string">'C.*'</span>,         </span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;,</span><br><span class="line">                       filter_path=[</span><br><span class="line">                               <span class="string">'hits.hits._source.applicant_address_other'</span>,</span><br><span class="line">                           <span class="string">'hits.hits._source.applicant_other'</span>,</span><br><span class="line">                                <span class="string">'hits.hits._source.app_text'</span>,</span><br><span class="line">                           ],</span><br><span class="line">                        size=<span class="number">4000</span><span class="comment"># 数据量</span></span><br><span class="line">                     )</span><br><span class="line">result_list</span><br></pre></td></tr></table></figure></p><p>–wildcard–<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">通配符查询(?和*)</span><br><span class="line">result_list = es.search(index=[<span class="string">'patent_cn_v7'</span>],</span><br><span class="line">                     body=&#123;</span><br><span class="line">                         <span class="string">"query"</span>: &#123;</span><br><span class="line">                             <span class="string">"wildcard"</span>: &#123;</span><br><span class="line">                                     <span class="string">'applicant_other.keyword'</span>:<span class="string">'CDT??有限公司'</span>,         </span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;,</span><br><span class="line">                       filter_path=[</span><br><span class="line">                               <span class="string">'hits.hits._source.applicant_address_other'</span>,</span><br><span class="line">                           <span class="string">'hits.hits._source.applicant_other'</span>,</span><br><span class="line">                                <span class="string">'hits.hits._source.app_text'</span>,</span><br><span class="line">                           ],</span><br><span class="line">                        size=<span class="number">4000</span><span class="comment"># 数据量</span></span><br><span class="line">                     )</span><br><span class="line">result_list</span><br></pre></td></tr></table></figure></p><p>–聚合查询–(avg\sum\min\max\stats)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">result_list = es.search(index=[<span class="string">'patent_cn_v7'</span>],</span><br><span class="line">                     body=&#123;<span class="string">'size'</span>:<span class="number">0</span>,</span><br><span class="line">                         <span class="string">"query"</span>: &#123;</span><br><span class="line">                             <span class="string">"match_all"</span>: &#123; &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                     ,</span><br><span class="line">                     <span class="string">'aggs'</span>:&#123;</span><br><span class="line">                         <span class="string">'agg_terms'</span>:&#123;</span><br><span class="line">                              <span class="string">'stats'</span>:&#123;</span><br><span class="line">                             <span class="string">'field'</span>:<span class="string">'country_id'</span></span><br><span class="line">                         &#125;   </span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                     )</span><br><span class="line">result_list</span><br></pre></td></tr></table></figure></p><p>–聚合分组–<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">result_list = es.search(index=[<span class="string">'patent_cn_v7'</span>],</span><br><span class="line">                     body=&#123;<span class="string">'size'</span>:<span class="number">0</span>,</span><br><span class="line">                         <span class="string">"query"</span>: &#123;</span><br><span class="line">                             <span class="string">"match"</span>: &#123;<span class="string">'applicant_other'</span>:<span class="string">'CJ第一制糖株式会社'</span> &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                     ,</span><br><span class="line">                           <span class="comment">#分组</span></span><br><span class="line">                     <span class="string">'aggs'</span>:&#123;</span><br><span class="line">                         <span class="string">'agg_terms'</span>:&#123;</span><br><span class="line">                              <span class="string">'terms'</span>:&#123;</span><br><span class="line">                             <span class="string">'field'</span>:<span class="string">'ipcr_text'</span></span><br><span class="line">                         &#125;   </span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                     )</span><br><span class="line">result_list</span><br></pre></td></tr></table></figure></p><p>–聚合分组后计算–<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">result_list = es.search(index=[<span class="string">'patent_cn_v7'</span>],</span><br><span class="line">                     body=&#123;<span class="string">'size'</span>:<span class="number">0</span>,</span><br><span class="line">                         <span class="string">"query"</span>: &#123;</span><br><span class="line">                             <span class="string">"match"</span>: &#123;<span class="string">'applicant_other'</span>:<span class="string">'CJ第一制糖株式会社'</span> &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                     ,</span><br><span class="line">                           <span class="comment">#分组</span></span><br><span class="line">                     <span class="string">'aggs'</span>:&#123;</span><br><span class="line">                         <span class="string">'agg_terms'</span>:&#123;</span><br><span class="line">                              <span class="string">'terms'</span>:&#123;</span><br><span class="line">                             <span class="string">'field'</span>:<span class="string">'ipcr_text'</span></span><br><span class="line">                         &#125;,</span><br><span class="line">                             <span class="string">'aggs'</span>:&#123;</span><br><span class="line">                                 <span class="string">'avg_id'</span>:&#123;</span><br><span class="line">                                     <span class="string">'stats'</span>:&#123;</span><br><span class="line">                                         <span class="string">'field'</span>:<span class="string">'country_id'</span></span><br><span class="line">                                     &#125;</span><br><span class="line">                                 &#125;</span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                     )</span><br><span class="line">result_list</span><br></pre></td></tr></table></figure></p><p>—返回聚合分组后的某一组数据(post_filter)—<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">返回聚合分组后的某一组数据(post_filter)</span><br><span class="line">result = es.search(index=[&apos;patent_cn_v71&apos;],body=&#123;</span><br><span class="line">        &apos;query&apos;:&#123;</span><br><span class="line">        &apos;match_all&apos;:&#123;&#125;</span><br><span class="line">                </span><br><span class="line">        &#125;,</span><br><span class="line">        &apos;aggs&apos;:&#123;</span><br><span class="line">            &apos;ipcr&apos;:&#123;</span><br><span class="line">                    &apos;terms&apos;:&#123;</span><br><span class="line">                        &apos;field&apos;: &quot;applicant_type&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &apos;post_filter&apos;:&#123;</span><br><span class="line">        &apos;term&apos;:&#123;&apos;applicant_type&apos;:&apos;individual&apos;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">                  filter_path=[&apos;hits.hits._source.app_text&apos;])</span><br><span class="line">result</span><br></pre></td></tr></table></figure></p><p>—聚合嵌套-(注意写的位置)–<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">result = es.search(index=[&apos;patent_cn_v71&apos;],body=&#123;</span><br><span class="line">        &apos;query&apos;:&#123;</span><br><span class="line">        &apos;match_all&apos;:&#123;&#125;</span><br><span class="line">                </span><br><span class="line">        &#125;,</span><br><span class="line">        &apos;aggs&apos;:&#123;</span><br><span class="line">            &apos;ipcr&apos;:&#123;</span><br><span class="line">                    &apos;terms&apos;:&#123;</span><br><span class="line">                        &apos;field&apos;:&apos;ipcr_text&apos;</span><br><span class="line"></span><br><span class="line">                &#125;,</span><br><span class="line">                &apos;aggs&apos;:&#123;</span><br><span class="line">                    &apos;ipcrs&apos;:&#123;</span><br><span class="line">                        &apos;terms&apos;:&#123;</span><br><span class="line">                            &apos;field&apos;:&apos;ipcr_text&apos;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">&#125;)</span><br><span class="line">result</span><br></pre></td></tr></table></figure></p><p>—聚合返回拼接字段聚合(script)—<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">result = es.search(index=[&apos;patent_cn_v71&apos;],body=&#123;</span><br><span class="line">    &apos;query&apos;:&#123;</span><br><span class="line">        &apos;match_all&apos;:&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;aggs&apos;:&#123;</span><br><span class="line">        &apos;kl&apos;:&#123;</span><br><span class="line">            &apos;terms&apos;:&#123;</span><br><span class="line">                &apos;script&apos;:&#123;</span><br><span class="line">                    &apos;inline&apos;:&quot;doc[&apos;app_country&apos;].value+&apos; &apos;+doc[&apos;app_date&apos;].value+&apos; &apos;+doc[&apos;id&apos;].value&quot;,</span><br><span class="line">                &#125;, &apos;size&apos;:&apos;1000&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">result</span><br></pre></td></tr></table></figure></p><p>–聚合结果排序–</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">result = es.search(index=[<span class="string">'patent_cn_v71'</span>],body=&#123;</span><br><span class="line">            <span class="string">'query'</span>:&#123;</span><br><span class="line">                    <span class="string">'match_all'</span>: &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ,</span><br><span class="line">            <span class="string">'aggs'</span>:&#123;</span><br><span class="line">                <span class="string">'company_name'</span>:&#123;</span><br><span class="line">                    <span class="string">'terms'</span>:&#123;</span><br><span class="line">                        <span class="string">'field'</span>:<span class="string">'ipcr_text'</span>,</span><br><span class="line">                        <span class="string">'order'</span>:[&#123;</span><br><span class="line">                            <span class="string">'_count'</span>:<span class="string">'asc'</span></span><br><span class="line">                        &#125;]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            )</span><br><span class="line">result</span><br></pre></td></tr></table></figure><p>–对聚合结果排序顺序倒叙–</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">result = es.search(index=[<span class="string">'patent_us_v71'</span>],body=&#123;<span class="string">'size'</span>:<span class="number">0</span>,</span><br><span class="line">            <span class="string">'query'</span>:&#123;</span><br><span class="line">                    <span class="string">'match_all'</span>: &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ,</span><br><span class="line">            <span class="string">'aggs'</span>:&#123;</span><br><span class="line">                <span class="string">'company_name'</span>:&#123;</span><br><span class="line">                    <span class="string">'terms'</span>:&#123;</span><br><span class="line">                        <span class="string">'field'</span>:<span class="string">'app_text'</span>,</span><br><span class="line">                        <span class="string">'order'</span>:[&#123;</span><br><span class="line">                            <span class="string">'_count'</span>:<span class="string">'desc'</span></span><br><span class="line">                        &#125;]</span><br><span class="line">                    ,</span><br><span class="line">                    <span class="string">'size'</span>:<span class="string">'200000'</span>&#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            )</span><br><span class="line">result</span><br></pre></td></tr></table></figure><p>–nested嵌套查询–</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#例1</span></span><br><span class="line">es = Elasticsearch(hosts=&#123;<span class="string">'192.168.0.220'</span>, <span class="string">'192.168.0.225'</span>, <span class="string">'192.168.0.221'</span>, &#125;, timeout=<span class="number">3600</span>)</span><br><span class="line">result_2 = es.search(index=<span class="string">'patent_cn_v71'</span>,</span><br><span class="line"></span><br><span class="line">                     body=&#123;</span><br><span class="line">                         <span class="string">"query"</span>: &#123;</span><br><span class="line">                         <span class="string">"bool"</span>: &#123;</span><br><span class="line">                             <span class="string">"must"</span>: [</span><br><span class="line">                                 &#123;<span class="string">"terms"</span>: &#123;<span class="string">"patent_type"</span>: [<span class="number">1</span>, <span class="number">2</span>]&#125;&#125;,</span><br><span class="line">                                 &#123;</span><br><span class="line">                                     <span class="string">"nested"</span>: &#123;</span><br><span class="line">                                         <span class="string">"path"</span>: <span class="string">"applicants"</span>,</span><br><span class="line">                                         <span class="string">"query"</span>: &#123;</span><br><span class="line">                                             <span class="string">"bool"</span>: &#123;</span><br><span class="line">                                                 <span class="string">"must"</span>: [</span><br><span class="line">                                                     &#123;<span class="string">"term"</span>: &#123;</span><br><span class="line">                                                         <span class="string">"applicants.name_other.keyword"</span>: <span class="string">'宝洁公司'</span>&#125;&#125;,</span><br><span class="line">                                                 ]</span><br><span class="line">                                             &#125;</span><br><span class="line">                                         &#125;</span><br><span class="line"></span><br><span class="line">                                     &#125;&#125;</span><br><span class="line">                             ]</span><br><span class="line">                         &#125;&#125;,</span><br><span class="line">                         <span class="comment">#三层三次聚合,一次进里面.二次再进一步,三次进入到inventors中</span></span><br><span class="line">                         <span class="string">"aggs"</span>: &#123;</span><br><span class="line">                             <span class="string">"aggs"</span>: &#123;</span><br><span class="line">                                 <span class="string">"aggs"</span>: &#123;<span class="string">"de_inventor"</span>: &#123;</span><br><span class="line">                                     <span class="string">"terms"</span>: &#123;<span class="string">"field"</span>: <span class="string">"inventors.name_other.keyword"</span>, <span class="string">"size"</span>: <span class="number">200000</span>&#125;&#125;&#125;,</span><br><span class="line">                                 <span class="string">"nested"</span>: &#123;<span class="string">"path"</span>: <span class="string">"inventors"</span>&#125;</span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;,</span><br><span class="line">                     )</span><br><span class="line">result2_list</span><br><span class="line"><span class="comment">#例2</span></span><br><span class="line">result_2 = es.search(index=[<span class="string">'patent_cn_v7'</span>],</span><br><span class="line">                     body=&#123;</span><br><span class="line">                         <span class="string">"query"</span>: &#123;</span><br><span class="line">                             <span class="string">"nested"</span>: &#123;</span><br><span class="line">                                         <span class="string">"path"</span>: <span class="string">"applicants"</span>,</span><br><span class="line">                                 <span class="string">'query'</span>:&#123;</span><br><span class="line">                                     <span class="string">'term'</span>:&#123;</span><br><span class="line">                                          <span class="string">'applicants.name_other.keyword'</span>: <span class="string">'CJ第一制糖株式会社'</span>,</span><br><span class="line">                                     &#125;</span><br><span class="line">                                       </span><br><span class="line">                                 &#125;,</span><br><span class="line">                             </span><br><span class="line">                             &#125;</span><br><span class="line">                    </span><br><span class="line">                             &#125;,</span><br><span class="line">                        <span class="string">"aggs"</span>: &#123;</span><br><span class="line">                             <span class="string">"aggs"</span>: &#123;</span><br><span class="line">                                 <span class="string">"aggs"</span>: &#123;<span class="string">"de_inventor"</span>: &#123;</span><br><span class="line">                                     <span class="string">"terms"</span>: &#123;<span class="string">"field"</span>: <span class="string">"inventors.name_other.keyword"</span>, <span class="string">"size"</span>: <span class="number">200000</span>&#125;&#125;&#125;,</span><br><span class="line">                                 <span class="string">"nested"</span>: &#123;<span class="string">"path"</span>: <span class="string">"inventors"</span>&#125;</span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                     )</span><br><span class="line">result_2[<span class="string">'aggregations'</span>][<span class="string">'aggs'</span>]</span><br></pre></td></tr></table></figure><p>–复合查询bool–<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">result = es.search(index = [<span class="string">'patent_cn_v7'</span>],</span><br><span class="line">                   body=&#123;</span><br><span class="line">                        <span class="string">'query'</span>:&#123;</span><br><span class="line">                            <span class="string">'bool'</span>:&#123;</span><br><span class="line">                                <span class="string">'must'</span>:[&#123;</span><br><span class="line">                                   <span class="string">'term'</span>:&#123;</span><br><span class="line">                                             <span class="string">'applicant_other.keyword'</span>:<span class="string">'孙长友'</span></span><br><span class="line">                                             &#125;</span><br><span class="line">                                                         &#125;</span><br><span class="line">                                ],</span><br><span class="line">                                <span class="string">'must_not'</span>:</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        <span class="string">'term'</span>:&#123;</span><br><span class="line">                                            <span class="string">'app_text'</span>:<span class="string">'CN201320765434'</span></span><br><span class="line">                                        &#125;,</span><br><span class="line">                                        </span><br><span class="line">                                    &#125;,</span><br><span class="line">                               </span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                   filter_path=[</span><br><span class="line">                               <span class="string">'hits.hits._source.applicant_address_other'</span>,</span><br><span class="line">                           <span class="string">'hits.hits._source.applicant_other'</span>,</span><br><span class="line">                                <span class="string">'hits.hits._source.app_text'</span>,</span><br><span class="line">                   ],</span><br><span class="line">                   size=<span class="number">10</span>)</span><br><span class="line">result</span><br></pre></td></tr></table></figure></p><p>–切片式查询from size–<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">result = es.search(index = [<span class="string">'patent_cn_v7'</span>],</span><br><span class="line">                   body=&#123;</span><br><span class="line">                        <span class="string">'query'</span>:&#123;</span><br><span class="line">                            <span class="string">'bool'</span>:&#123;</span><br><span class="line">                                <span class="string">'must'</span>:[&#123;</span><br><span class="line">                                   <span class="string">'term'</span>:&#123;</span><br><span class="line">                                             <span class="string">'applicant_other.keyword'</span>:<span class="string">'孙长友'</span></span><br><span class="line">                                             &#125;</span><br><span class="line">                                                         &#125;</span><br><span class="line">                                ],</span><br><span class="line">                                <span class="string">'must_not'</span>:</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        <span class="string">'term'</span>:&#123;</span><br><span class="line">                                            <span class="string">'app_text'</span>:<span class="string">'CN201320765434'</span></span><br><span class="line">                                        &#125;,</span><br><span class="line">                                        </span><br><span class="line">                                    &#125;,</span><br><span class="line">                               </span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                   filter_path=[</span><br><span class="line">                               <span class="string">'hits.hits._source.applicant_address_other'</span>,</span><br><span class="line">                           <span class="string">'hits.hits._source.applicant_other'</span>,</span><br><span class="line">                                <span class="string">'hits.hits._source.app_text'</span>,</span><br><span class="line">                   ],</span><br><span class="line">                   size=<span class="number">10</span>)</span><br><span class="line">result</span><br></pre></td></tr></table></figure></p><p>–范围查询range–<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">result  = es.search(index = [<span class="string">'patent_cn_v7'</span>],body=&#123;</span><br><span class="line">    <span class="string">'query'</span>:&#123;</span><br><span class="line">        <span class="string">'range'</span>:&#123;</span><br><span class="line">            <span class="string">'id'</span>:&#123;</span><br><span class="line">                <span class="string">'gte'</span>:<span class="number">1000</span>,</span><br><span class="line">                <span class="string">'lte'</span>:<span class="number">10000</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">    filter_path = [</span><br><span class="line">                         <span class="string">'hits.hits._source.applicant_address_other'</span>,</span><br><span class="line">                           <span class="string">'hits.hits._source.applicant_other'</span>,</span><br><span class="line">                            <span class="string">'hits.hits._source.app_text'</span>,</span><br><span class="line">                        <span class="string">'hits.hits._source.id'</span>,</span><br><span class="line">                   ],</span><br><span class="line">                   )</span><br></pre></td></tr></table></figure></p><p>–sort排序–<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">result= es.search(index=[<span class="string">'patent_cn_v7'</span>],</span><br><span class="line">                 body=&#123;</span><br><span class="line">                     <span class="string">'query'</span>:&#123;</span><br><span class="line">                         <span class="string">'match_all'</span>:&#123;&#125;</span><br><span class="line">                     &#125;,</span><br><span class="line">                     <span class="string">'sort'</span>:&#123;</span><br><span class="line">                         <span class="string">'app_text'</span>:&#123;</span><br><span class="line">                             <span class="string">'order'</span>:<span class="string">'asc'</span></span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;,</span><br><span class="line">                  filter_path=[</span><br><span class="line">                         <span class="string">'hits.hits._source.applicant_address_other'</span>,</span><br><span class="line">                           <span class="string">'hits.hits._source.applicant_other'</span>,</span><br><span class="line">                            <span class="string">'hits.hits._source.app_text'</span>,</span><br><span class="line">                        <span class="string">'hits.hits._source.id'</span>,</span><br><span class="line">                   ])</span><br></pre></td></tr></table></figure></p><p>–keyword与text的区别是分词与不分词的区别</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">result = es.search(index=[<span class="string">'patent_cn_v71'</span>],body=&#123;</span><br><span class="line">                  <span class="string">'query'</span>:&#123;</span><br><span class="line">                      <span class="string">'nested'</span>:&#123;</span><br><span class="line">                          <span class="string">'path'</span>:<span class="string">'applicants'</span>,</span><br><span class="line">                          <span class="string">'query'</span>:&#123;</span><br><span class="line">                              <span class="string">'term'</span>:&#123;</span><br><span class="line">                                  <span class="string">'applicants.name_en.keyword'</span>:<span class="string">'ELECTROLUX APPLIANCES'</span></span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;&#125;)</span><br><span class="line">result</span><br></pre></td></tr></table></figure><p>–count–获取匹配到的数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result = es.count(index=[<span class="string">'patent_cn_v7'</span>],</span><br><span class="line">                 body=&#123;</span><br><span class="line">                     <span class="string">'query'</span>:&#123;</span><br><span class="line">                         <span class="string">'match'</span>:&#123;</span><br><span class="line">                                 <span class="string">'applicant_other.keyword'</span>:<span class="string">'蒋子刚'</span>  </span><br><span class="line">                         &#125;</span><br><span class="line"></span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;)</span><br></pre></td></tr></table></figure><p>–es_scroll进行深度分页you表获取内容–</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># list1 = []</span></span><br><span class="line">result = es.search(index=[<span class="string">'patent_cn_v71'</span>],body=</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="string">'query'</span>:&#123;</span><br><span class="line">             <span class="string">'match_all'</span>:&#123;&#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="string">'sort'</span>:&#123;</span><br><span class="line">             <span class="string">'app_text'</span>:<span class="string">'asc'</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;,scroll=<span class="string">'1m'</span>,size=<span class="number">10</span>)</span><br><span class="line">mdata = result.get(<span class="string">"hits"</span>).get(<span class="string">"hits"</span>)</span><br><span class="line">scroll_id = result[<span class="string">"_scroll_id"</span>]</span><br><span class="line">total = result[<span class="string">"hits"</span>][<span class="string">"total"</span>]</span><br><span class="line">j = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(total//<span class="number">100</span>):</span><br><span class="line">    res = es.scroll(scroll_id=scroll_id, scroll=<span class="string">'1m'</span>) <span class="comment">#scroll参数必须指定否则会报错</span></span><br><span class="line">    mdata += res[<span class="string">"hits"</span>][<span class="string">"hits"</span>]</span><br><span class="line">    <span class="keyword">if</span> j==<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    j+=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span>  result <span class="keyword">in</span> mdata:</span><br><span class="line">    print(result[<span class="string">'_source'</span>][<span class="string">'app_text'</span>])</span><br></pre></td></tr></table></figure><p>–是否存在某个字段exists–</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方法1</span></span><br><span class="line">result = es.search(index=[<span class="string">'patent_cn_v7'</span>],</span><br><span class="line">                  body=&#123;</span><br><span class="line">                      <span class="string">'query'</span>:&#123;</span><br><span class="line">                          <span class="string">'exists'</span>:&#123;</span><br><span class="line">                              <span class="string">'field'</span>:<span class="string">'applicant_other'</span></span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;&#125;    </span><br><span class="line">                  )</span><br><span class="line"><span class="comment">#方法2</span></span><br><span class="line">es.search(index=[<span class="string">'patent_jp_v71'</span>],</span><br><span class="line">                     body=&#123;</span><br><span class="line">                         <span class="string">"query"</span>: &#123;</span><br><span class="line">                             <span class="string">"bool"</span>:&#123;</span><br><span class="line">                                 <span class="string">"must_not"</span>:&#123;</span><br><span class="line">                                     <span class="string">"nested"</span>:&#123;</span><br><span class="line">                                         <span class="string">"path"</span>: <span class="string">"prime_notified"</span>,</span><br><span class="line">                                             <span class="string">"query"</span>:&#123;</span><br><span class="line">                                                     <span class="string">"match_all"</span>:&#123;&#125;</span><br><span class="line">                                                         &#125;&#125;&#125;</span><br><span class="line">                                             &#125;</span><br><span class="line">                             &#125;,</span><br><span class="line"><span class="comment">#                          'aggs':&#123;</span></span><br><span class="line"><span class="comment">#                          'agg_terms':&#123;</span></span><br><span class="line"><span class="comment">#                               'terms':&#123;</span></span><br><span class="line"><span class="comment">#                              'field':'app_date',</span></span><br><span class="line"><span class="comment">#                                   'size':'10000'</span></span><br><span class="line"><span class="comment">#                          &#125; &#125;&#125;</span></span><br><span class="line"></span><br><span class="line">                     &#125; ,filter_path=[<span class="string">'hits.total'</span>,</span><br><span class="line">              <span class="string">'hits.hits._source.app_text'</span>],size=<span class="number">300</span>)</span><br><span class="line"><span class="comment">#方法3</span></span><br><span class="line">es.search(index=[<span class="string">'patent_jp_v71'</span>],</span><br><span class="line">                     body=&#123;</span><br><span class="line">                         <span class="string">"query"</span>: &#123;</span><br><span class="line">                             <span class="string">"nested"</span>: &#123;</span><br><span class="line">                                         <span class="string">"path"</span>: <span class="string">"inventors"</span>,</span><br><span class="line">                                 <span class="string">'query'</span>:&#123;</span><br><span class="line">                                        <span class="string">"bool"</span>:&#123;</span><br><span class="line">                                            <span class="string">'must'</span>:[</span><br><span class="line">                                        &#123;</span><br><span class="line">                                        <span class="string">'exists'</span>:&#123;</span><br><span class="line">                                            <span class="string">'field'</span>:<span class="string">'inventors.name_other'</span></span><br><span class="line">                                        &#125;&#125;,</span><br><span class="line">                                                 &#123;</span><br><span class="line">                                        <span class="string">'exists'</span>:&#123;</span><br><span class="line">                                            <span class="string">'field'</span>:<span class="string">'inventors.name_en'</span></span><br><span class="line">                                        &#125;&#125;,</span><br><span class="line">                                          ]</span><br><span class="line">                                        &#125;</span><br><span class="line">                                       </span><br><span class="line">                                 &#125;,</span><br><span class="line">                             </span><br><span class="line">                             &#125;</span><br><span class="line">                             &#125;,</span><br><span class="line"><span class="comment">#                         "aggs": &#123;</span></span><br><span class="line"><span class="comment">#                              "aggs": &#123;</span></span><br><span class="line"><span class="comment">#                                  "aggs": &#123;"de_inventor": &#123;</span></span><br><span class="line"><span class="comment">#                                      "terms": &#123;"field": "inventors.name_other.keyword", "size": 200000&#125;&#125;&#125;,</span></span><br><span class="line"><span class="comment">#                                  "nested": &#123;"path": "inventors"&#125;</span></span><br><span class="line"><span class="comment">#                              &#125;</span></span><br><span class="line"><span class="comment">#                          &#125;</span></span><br><span class="line">                     &#125;</span><br><span class="line">                     ,filter_path=[<span class="string">'hits.total'</span>,</span><br><span class="line">              <span class="string">'hits.hits._source.app_text'</span>],size=<span class="number">300</span>)</span><br></pre></td></tr></table></figure><p>–深度理解filter–</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = es.search(index=[<span class="string">'patent_cn_v71'</span>],</span><br><span class="line">                  body=&#123;</span><br><span class="line">                          <span class="string">'query'</span>:&#123;</span><br><span class="line">                              </span><br><span class="line">                          <span class="string">'bool'</span>:&#123;<span class="string">'must'</span>:&#123;<span class="string">'term'</span>:&#123;<span class="string">'id'</span>:<span class="string">'17640553'</span>&#125;&#125;,</span><br><span class="line">                                        <span class="string">'filter'</span>:&#123;<span class="string">'term'</span>:&#123;<span class="string">'applicant_other.keyword'</span>:<span class="string">'王永民'</span>&#125;&#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                       &#125;&#125;,</span><br><span class="line">                  filter_path=[<span class="string">'hits.hits._source.app_text'</span>])</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>–案例一filter放在bool下的等级等同于must</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">s1 = time.time()</span><br><span class="line">result = es.search(index=[<span class="string">'patent_cn_v71'</span>],</span><br><span class="line">                  body=&#123;</span><br><span class="line">                      <span class="string">'query'</span>:&#123;</span><br><span class="line">                           <span class="string">'bool'</span>:&#123;</span><br><span class="line">                        <span class="string">'must'</span>:&#123;<span class="string">'match'</span>:&#123;<span class="string">'applicant_address_other'</span>:&#123;<span class="string">'query'</span>:<span class="string">'北京市'</span>&#125;&#125;&#125;,</span><br><span class="line">                        <span class="string">'filter'</span>:&#123;<span class="string">'term'</span>:&#123;<span class="string">'applicant_other.keyword'</span>:<span class="string">'王永民'</span>&#125;&#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                   </span><br><span class="line">                  &#125;,</span><br><span class="line">                  filter_path =[<span class="string">'hits.hits._source.app_text'</span>])</span><br><span class="line">print(result)</span><br><span class="line">print(time.time()-s1)</span><br></pre></td></tr></table></figure><p>filter常与bool一起使用,等级同must(里面要加match\term之类的)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">result = es.search(index=[<span class="string">'patent_cn_v71'</span>],</span><br><span class="line">                  body=&#123;</span><br><span class="line">                      <span class="string">'query'</span>:&#123;</span><br><span class="line">                           <span class="string">'bool'</span>:&#123;</span><br><span class="line">                               <span class="string">'filter'</span>:&#123;<span class="string">'term'</span>:&#123;<span class="string">'applicant_other.keyword'</span>:<span class="string">'王永民'</span>&#125;&#125;,</span><br><span class="line">                         <span class="string">'must'</span>:&#123;<span class="string">'match'</span>:&#123;<span class="string">'applicant_address_other'</span>:&#123;<span class="string">'query'</span>:<span class="string">'北京市'</span>&#125;&#125;&#125;,</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                      &#125; </span><br><span class="line">                  &#125;,</span><br><span class="line">                  filter_path =[<span class="string">'hits.hits._source.app_text'</span>])</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注意事项:</span><br><span class="line">1.中文只能通过关键字查询</span><br><span class="line">2.match会系统自动分词,而term表示完全匹配不进行分词</span><br><span class="line">3.match对应模糊查找,term对应精确查找</span><br><span class="line">4.gte大于等于 gt大于 lte小于等于 lt小于</span><br><span class="line">5.terms表示符合其中任意一个条件即可</span><br><span class="line">分词:如我是中国人 会分成我 中国人类似,可以使用系统默认的亦可以自己设置</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es服务器查询api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>beautifulsoup4</title>
      <link href="/2019/06/21/beautifulsoup4/"/>
      <url>/2019/06/21/beautifulsoup4/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-选择器：BeautifulSoup4"><a href="#CSS-选择器：BeautifulSoup4" class="headerlink" title="CSS 选择器：BeautifulSoup4"></a><strong>CSS 选择器：BeautifulSoup4</strong></h1><p>Beautiful Soup 也是一个HTML/XML的解析器，主要的功能也是如何解析和提取 HTML/XML 数据。</p><table><thead><tr><th><strong>抓取工具</strong></th><th><strong>速度</strong></th><th><strong>使用难度</strong></th><th><strong>安装难度</strong></th><th></th></tr></thead><tbody><tr><td>正则</td><td>最快</td><td>困难</td><td>无（内置）</td><td></td></tr><tr><td>BeautifulSoup</td><td>慢</td><td>最简单</td><td>简单</td><td></td></tr><tr><td>lxml</td><td>快</td><td>简单</td><td>一般</td></tr></tbody></table><p>lxml 只会局部遍历，而Beautiful Soup 是基于HTML DOM的，会载入整个文档，解析整个DOM树，因此时间和内存开销都会大很多，所以性能要低于lxml。</p><p>官方文档：<a href="http://beautifulsoup.readthedocs.io/zh_CN/v4.4.0" target="_blank" rel="noopener">http://beautifulsoup.readthedocs.io/zh_CN/v4.4.0</a></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h1><p>安装：</p><p>pip install beautifulsoup4 </p><p>使用：</p><p>from bs4 import BeautifulSoup</p><p>text = “””<br>    <html><head><meta name="generator" content="Hexo 3.8.0"><title>The Dormouse’s story</title></head><br>    <body><br>    <p class="title" id="p1"><b>The Dormouse’s story</b><b>—-2b</b></p></body></html></p><p>​    </p><p class="story">Once upon a time there were three little sisters; and their names were<br>​    <a href="http://example.com/elsie" class="sister" id="link1" target="_blank" rel="noopener"><span><b>Elsie</b></span>–alice</a>,<br>​    <a href="http://example.com/lacie" class="sister" id="link2" target="_blank" rel="noopener">Lacie</a> and<br>​    <a href="http://example.com/tillie" class="sister" id="link3" target="_blank" rel="noopener">Tillie</a>;<br>​    and they lived at the bottom of a well.</p><p></p><p>​    </p><p class="story">…</p><br>​    <div>我是div</div><br>​    “””<p></p><p># 创建beautifulsoup对象<br>soup = BeautifulSoup(text,’lxml’)</p><p># 格式化输出<br>soup.prettify()<br>实例化对象<br>html_bs4 = BeautifulSoup(text,’lxml’)<br>格式化<br>print(html_bs4.prettify())</p><p>获取元素 只能获取第一个<br>print(html_bs4.div,type(html_bs4.div))<br>print(html_bs4.div[‘class’])<br>获取标签名<br>print(html_bs4.div.name)</p><p>获取文本内容<br>print(html_bs4.div.string,type(html_bs4.div.string))<br>print(html_bs4.p.string)<br>获取标签中的素有内容包括字标签内的内容<br>print(html_bs4.body.get_text)</p><p>获取属性的方法<br>print(html_bs4.p[‘id’])<br>获取当前标签所有的属性和值<br>print(html_bs4.p.attrs)</p><p>find()<br>find_all() 返回的是列表<br>print(html_bs4.find(‘p’))<br>print(html_bs4.find(id=’p1’))<br>print(html_bs4.find_all(‘p’))<br>print(html_bs4.find_all(id=’p1’))<br>print(html_bs4.find_all(data=”1”))</p><p>元素节点<br>print(html_bs4.body.contents)<br>chil = html_bs4.body.children<br>for item in chil:<br>    print(item)<br>print(html_bs4.body.descendants)</p><p>css选择器</p><p>标签选择器<br>print(html_bs4.select(‘p’))<br>所有含类选择器title的<br>print(html_bs4.select(‘.title’))</p><p>同时获取id=p1的元素和 class=story 的标签<br>res = html_bs4.select(‘#p1,.story’)<br>print(res)</p><p>获取class属性为sister的按标签<br>print(html_bs4.select(‘a.sister’))<br>print(type(html_bs4.select(‘a.sister’)[0]))</p><p>查找只要满足选择器条件的 b 标签==组合查找,同时满足<br>res = html_bs4.select(‘p b’)<br>print(res)<br>获取 页面中所有p标签中的 直接子元素b标签==子类选择器<br>res = html_bs4.select(‘p&gt;b’)<br>print(res)</p><h1 id="查找包含指定属性的标签"><a href="#查找包含指定属性的标签" class="headerlink" title="查找包含指定属性的标签"></a>查找包含指定属性的标签</h1><p>print(soup.select(‘[name]’))</p><p>获取文本内容 text属性<br>get(属性名) 获取指定属性的值<br>res = html_bs4.select(‘a’)<br>print(res)<br>for i in res:<br>    print(i.text)<br>    print(i.get(‘href’))</p><h1 id="获取标签和标签属性"><a href="#获取标签和标签属性" class="headerlink" title="获取标签和标签属性"></a><strong>获取标签和标签属性</strong></h1><p> tag = soup.p<br> 获取标签名<br> tag.name<br> 获取标签属性<br> tag = soup.p[‘class’]  #返回指定属性的值<br> tag = soup.p.attrs     # 返回当前标签的所有属性</p><h1 id="获取所有的子节点"><a href="#获取所有的子节点" class="headerlink" title="获取所有的子节点"></a><strong>获取所有的子节点</strong></h1><p>soup.body.contents   # 返回列表形式<br>soup.body.children   # 返回迭代器类型<br>soup.body.denscendants  #返回所有后代元素</p><h1 id="find-all"><a href="#find-all" class="headerlink" title="find_all()"></a><strong>find_all()</strong></h1><p>soup.find_all(‘p’)   # 获取所有的p元素<br>soup.find_all(‘p’，attrs = {‘class’:’title’})   # 获取所有class=title的p元素</p><h1 id="选择器的用法"><a href="#选择器的用法" class="headerlink" title="选择器的用法 ***"></a><strong>选择器的用法 ***</strong></h1><p>soup.select(‘p.title’) # 获取class=title的素有p标签<br>soup.select(‘p .title’) # 获取p里面class=title的素有元素<br>soup.select(‘#p1’)      # 获取id=p1的元素<br>soup.select(‘p &gt; a’) # 获取p的子元素a<br>soup.select(‘p,div’)<br>soup.select(‘a[class=”item1”]’)<br>soup.select(‘a[class]’)<br>soup.select(‘a[class*=”o”]’)  #模糊查询<br>soup.select(‘a[class^=”o”]’) # 限制开头<br>soup.select(‘a[class$=”0”]’) # 限制结尾</p><h1 id="获取文本和属性的方法"><a href="#获取文本和属性的方法" class="headerlink" title="获取文本和属性的方法"></a><strong>获取文本和属性的方法</strong></h1><p>.text()<br>.get(src)</p><h3 id="练习-使用bs4获取腾讯招聘的信息"><a href="#练习-使用bs4获取腾讯招聘的信息" class="headerlink" title="练习 使用bs4获取腾讯招聘的信息"></a><strong>练习 使用bs4获取腾讯招聘的信息</strong></h3>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsonpath</title>
      <link href="/2019/06/21/jsonpath/"/>
      <url>/2019/06/21/jsonpath/</url>
      
        <content type="html"><![CDATA[<h1 id="jsonpath"><a href="#jsonpath" class="headerlink" title="jsonpath"></a><strong>jsonpath</strong></h1><p>JsonPath 是一种信息抽取类库，是从JSON文档中抽取指定信息的工具，提供多种语言实现版本，包括：Javascript, Python， PHP 和 Java。</p><p>官方文档：<a href="http://goessner.net/articles/JsonPath" target="_blank" rel="noopener">http://goessner.net/articles/JsonPath</a></p><p>JSONPath    描述</p><p>$           根节点<br>@           现行节点<br>.or[]       取子节点<br>..          就是不管位置，选择所有符合条件的条件</p><ul><li>匹配所有元素节点<br>[]          迭代器标示（可以在里边做简单的迭代操作，如数组下标，根据内容选值等）<br>[,]         支持迭代器中做多选。<br>?()         支持过滤操作.<br>()          支持表达式计算</li></ul><p>根据要求获取下面数据中的内容</p><p>1.将字符串转换成 python可操作性的数据类型<br>dic = json.loads(strs)<br>print(dic,type(dic))<br>2.实例化jsonpath对象 获取根路径下的所有的数据<br>json_obj = jsonpath.jsonpath(dic,’$..*’)<br>获取根节点下的store的所有数据<br>json_obj = jsonpath.jsonpath(dic,’$.store’)<br>1.获取所有书籍的作者<br>json_obj = jsonpath.jsonpath(dic,’$..author’)<br>获取第二本书的详细信息 []里写的是索引值<br>json_obj = jsonpath.jsonpath(dic,’$..book[1]’)<br>获取第二本书和第三本书的详细信息<br>json_obj = jsonpath.jsonpath(dic,’$..book[1,3]’)<br>获取前两本书<br>json_obj = jsonpath.jsonpath(dic,’$..book[:2]’)<br>获取后两本书<br>json_obj = jsonpath.jsonpath(dic,’$..book[-2:]’)<br>获取所有的book信息<br>json_obj = jsonpath.jsonpath(dic,’$..book’)<br>获取价格大于10的数据<br>json_obj = jsonpath.jsonpath(dic,’$..book[?(@.price&gt;10)]’)<br>找价格等于22.99的书籍 是否相等 ==<br>json_obj = jsonpath.jsonpath(dic,’$..book[?(@.price==22.99)]’)<br>找有书号的书籍信息<br>json_obj = jsonpath.jsonpath(dic,’$..book[?(@.isbn)]’)<br>查看所有书籍的价格<br>json_obj = jsonpath.jsonpath(dic,’$..book..price’)<br>取个 价格   &gt;8    并且小于20 的 书看下<br>json_obj = jsonpath.jsonpath(dic,’$..book[?(@.price<20 && @.price>8.99)]’)<br>$..book[?(8&lt;@.price&lt;20)<br>json_obj = jsonpath.jsonpath(dic,’$..book[?(8&lt;@.price&lt;20)]’)<br>print(json_obj)</20></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spss</title>
      <link href="/2019/06/19/spss/"/>
      <url>/2019/06/19/spss/</url>
      
        <content type="html"><![CDATA[<p>源文件:有道云笔记 链接<a href="http://note.youdao.com/noteshare?id=4a5d306357317ee80a5415af19e00d0a" target="_blank" rel="noopener">http://note.youdao.com/noteshare?id=4a5d306357317ee80a5415af19e00d0a</a></p><h1 id="spss概括"><a href="#spss概括" class="headerlink" title="spss概括"></a>spss概括</h1><p>1.1 Spss历史  </p><p>  SPSS是世界上最早的统计分析软件，由美国斯坦福大学的三位研究生Norman H. Nie、C. Hadlai (Tex) Hull 和 Dale H. Bent于1968年研究开发成功，同时成立了SPSS公司，并于1975年成立法人组织、在芝加哥组建了SPSS总部。</p><p>  2009年7月28日，IBM公司宣布将用12亿美元现金收购统计分析软件提供商SPSS公司。如今SPSS的最新版本为25，而且更名为IBM SPSS Statistics。迄今，SPSS公司已有40余年的成长历史。（百度）</p><p>1.2 Spss特点</p><p>操作简便</p><p>界面非常友好，类似于windows的风格界面，类似于Excel布局的数据视图给初学者一种天然的亲切感。除了数据录入及部分命令程序等少数输入工作需要键盘键入外，大多数操作可通过鼠标拖曳、点击“菜单”、“按钮”和“对话框”来完成。可以说只要了解统计分析的原理，无需通晓统计方法的各种算法，即可得到需要的统计分析结果。</p><p>编程方便</p><p>强大的编程互动性，常见的统计方法，SPSS的命令语句、子命令及选择项的选择绝大部分由“对话框”的操作完成。因此，用户无需花大量时间记忆大量的命令、过程、选择项。</p><p>功能强大</p><p>涵盖主要的数据分析流程，例如数据获取、数据处理、数据分析、数据展现等数据分析流程环节能够快速实现。尤其是数据分析环节，SPSS提供了从简单的统计描述到复杂的多因素统计分析方法，比如数据的探索性分析、统计描述、列联表分析、二维相关、秩相关、方差分析、多元回归、生存分析、协方差分析、聚类分析、Logistic回归等。</p><p>数据兼容</p><p>能够读取及输出多种格式的文件。比如SPSS可以读取文本、Excel、Stata、SAS；把表格、图像导出</p><p>为word、excel、powerpoint、txt文本、pdf、html等格式文件。</p><p>模块组合</p><p>SPSS for Windows软件分为若干功能模块。用户可以根据自己的分析需要和计算机的实际配置情况灵活选择。</p><p>1.3 Spss安装</p><p>助教帮助安装</p><p>1.4 认识Spss</p><p>一、数据窗口</p><p>我们，Spss窗口和Excel窗口貌似很类似，但细细看来，还是有很大不同。整体来看，Spss窗口主要有两部分构成：</p><ol><li>菜单栏</li></ol><p>主要包括 “文件”、“编辑”、“查看”、“数据”、“转换”、“分析”、“直销”、“图形”、“实用程序”、“窗口”、“帮助” 11个菜单。其中 “数据”、“转换”、“分析”三个菜单最常用。</p><ol><li>数据视图</li></ol><p>顾名思义就是输入、编辑和显示数据的视图窗口。在Spss中每一行数据被称为一条记录，被称为个案，每一列代表一个特征，在Spss中被称为变量</p><ol><li>变量视图</li></ol><p>用于设置、定义变量属性的窗口。</p><p>可以设置或者查看变量的属性，例如“名称”、“类型”、“宽度”等信息</p><p>注意：在设置变量属性时，注意数据类型、数据测量和数据角色的设置，因为这三个很容易设置错。一旦设置错误，将会造成无法进行数据处理、或者数据分析；更可怕的是有时会导致出现错误的分析结果。整个数据窗口可以被保存，默认格式为sav。</p><p>二、输出窗口</p><p>输出窗口又叫结果查看器，主要用于输出数据分析结果或绘制的相关图表。</p><p>输出窗口分为两个部分，左边是由目录组成的导航窗口，右边为内容区，所显示内容与右边目录一一对应。我们可以对输出结果进行复制、编辑等操作。</p><p>输出窗口可以被保存，可以把分析结果或者图表保存以备随时查看。保存格式默认为sav。</p><h1 id="spss数据处理"><a href="#spss数据处理" class="headerlink" title="spss数据处理"></a>spss数据处理</h1><p>1.1 Spss历史  </p><p>  SPSS是世界上最早的统计分析软件，由美国斯坦福大学的三位研究生Norman H. Nie、C. Hadlai (Tex) Hull 和 Dale H. Bent于1968年研究开发成功，同时成立了SPSS公司，并于1975年成立法人组织、在芝加哥组建了SPSS总部。</p><p>  2009年7月28日，IBM公司宣布将用12亿美元现金收购统计分析软件提供商SPSS公司。如今SPSS的最新版本为25，而且更名为IBM SPSS Statistics。迄今，SPSS公司已有40余年的成长历史。（百度）</p><p>1.2 Spss特点</p><p>操作简便</p><p>界面非常友好，类似于windows的风格界面，类似于Excel布局的数据视图给初学者一种天然的亲切感。除了数据录入及部分命令程序等少数输入工作需要键盘键入外，大多数操作可通过鼠标拖曳、点击“菜单”、“按钮”和“对话框”来完成。可以说只要了解统计分析的原理，无需通晓统计方法的各种算法，即可得到需要的统计分析结果。</p><p>编程方便</p><p>强大的编程互动性，常见的统计方法，SPSS的命令语句、子命令及选择项的选择绝大部分由“对话框”的操作完成。因此，用户无需花大量时间记忆大量的命令、过程、选择项。</p><p>功能强大</p><p>涵盖主要的数据分析流程，例如数据获取、数据处理、数据分析、数据展现等数据分析流程环节能够快速实现。尤其是数据分析环节，SPSS提供了从简单的统计描述到复杂的多因素统计分析方法，比如数据的探索性分析、统计描述、列联表分析、二维相关、秩相关、方差分析、多元回归、生存分析、协方差分析、聚类分析、Logistic回归等。</p><p>数据兼容</p><p>能够读取及输出多种格式的文件。比如SPSS可以读取文本、Excel、Stata、SAS；把表格、图像导出</p><p>为word、excel、powerpoint、txt文本、pdf、html等格式文件。</p><p>模块组合</p><p>SPSS for Windows软件分为若干功能模块。用户可以根据自己的分析需要和计算机的实际配置情况灵活选择。</p><p>1.3 Spss安装</p><p>助教帮助安装</p><p>1.4 认识Spss</p><p>一、数据窗口</p><p>我们，Spss窗口和Excel窗口貌似很类似，但细细看来，还是有很大不同。整体来看，Spss窗口主要有两部分构成：</p><ol><li>菜单栏</li></ol><p>主要包括 “文件”、“编辑”、“查看”、“数据”、“转换”、“分析”、“直销”、“图形”、“实用程序”、“窗口”、“帮助” 11个菜单。其中 “数据”、“转换”、“分析”三个菜单最常用。</p><ol><li>数据视图</li></ol><p>顾名思义就是输入、编辑和显示数据的视图窗口。在Spss中每一行数据被称为一条记录，被称为个案，每一列代表一个特征，在Spss中被称为变量</p><ol><li>变量视图</li></ol><p>用于设置、定义变量属性的窗口。</p><p>可以设置或者查看变量的属性，例如“名称”、“类型”、“宽度”等信息</p><p>注意：在设置变量属性时，注意数据类型、数据测量和数据角色的设置，因为这三个很容易设置错。一旦设置错误，将会造成无法进行数据处理、或者数据分析；更可怕的是有时会导致出现错误的分析结果。整个数据窗口可以被保存，默认格式为sav。</p><p>二、输出窗口</p><p>输出窗口又叫结果查看器，主要用于输出数据分析结果或绘制的相关图表。</p><p>输出窗口分为两个部分，左边是由目录组成的导航窗口，右边为内容区，所显示内容与右边目录一一对应。我们可以对输出结果进行复制、编辑等操作。</p><p>输出窗口可以被保存，可以把分析结果或者图表保存以备随时查看。保存格式默认为sav</p><h1 id="描述性分析"><a href="#描述性分析" class="headerlink" title="描述性分析"></a>描述性分析</h1><p>常见数据分析的分类：</p><p>\1. 描述性数据分析</p><p>对所收集的数据进行分析，得出反映客观现象的各种数量特征的一种分析方法，主要分析方向为集中趋势分析、离散程度分析、频数分析等。描述性分析是所有继续数据分析的基础。</p><p>\2. 探索性数据分析</p><p>通过某些分析方法从大量的数据中发现未知有价值信息的过程。特点是不受分析模型和研究假设的限制，尽可能地寻找变量间的关联性，常见的分析方法有聚类、因子、对应分析等。</p><p>3.推断数据分析</p><p>通过样本数量特征对研究总体数量特征进行推断的过程。常见分析有相关分析、回归分析、假设检验等。</p><p>我们的课程主要集中于描述性数据分析和部分推断数据分析。</p><p>3.1 频率分析 </p><p>主要分为两类：</p><p>3.1.1 分类变量频率分析</p><p>读入‘问卷调查.csv’文件，点击‘分析’菜单，选择‘描述统计’，此时右侧弹出子菜单，选择并点击‘频率’按钮，跳出如下对话框：</p><p>在左选择需要进行频率栏中的分类变量，然后点击转换按钮，待分析变量会自动跑到右边框内，然后点击确定就会得到分析结果：            </p><p>如何理解有效百分比：</p><p>|有效值|/|总体|</p><p>还有很多其他变量，留作大家课下练着玩吧！</p><p>3.1.2 连续变量频率分析</p><p>step1: 完全和分类变量频率分析一致。</p><p>step2: 在‘频率’对话框中点击‘统计’按钮，弹出以下对话框：</p><p>在‘频率:统计对话框中，选择你所需的任意统计量，点击‘继续’。回到‘频率’对话框。点击‘确定’。生成下列图表。</p><p>接下来，让我们稍停步伐，看一看在‘频率：统计’对话框中的四个功能区，他们分别是‘百分位值‘、’集中趋势‘、’离散趋势‘、’分布特征‘；接下来我们逐一讲解：</p><p>百分位值：</p><p>有三个功能项，分别是四分位数、分割点、和百分位数。四分位数意思是用三个数据点把整体数据分成四等份，百分位数是用99个数据点把整体数据分成100等份。分割点功能可以实现整体数据的任意等分。</p><p>集中趋势：</p><p>主要有四个功能项，平均值、中位数、众数、总和。我们这里主要关注平均值、中位数、和众数的区别。</p><p>离散趋势：</p><p>主要功能项有，方差、标准差和范围。</p><p>范围就是数据中最大值与最小值得差，计算简单，容易理解。但是对极端值敏感，无法正确反映离散情况。相对而言，方差和标准差能够反映数据的离散情况，对极端值有一定忍受程度，但是极端值过大，也会造成对数据的离散程度描述失真。</p><p>分布特征：</p><p>对于较大数据，人们通常希望了解他的分布状况，峰度和偏度是描述其分布的两个重要的统计参数。它们的值都依赖于标准正态分布，描述的是与标准正态分布的偏离程度。</p><p>让我们再次回答频率对话框，此时我们已经选好了所想展示的统计参数，如果我们不去直接按‘确定‘，而是单击第二个按钮’图表‘，然后跳出’频率：图标‘对话框： </p><p>在’频率：图表‘对话框中主要的功能项有’条形图‘，’饼图‘，’直方图‘。我们可以根据数据的类型和分析目的来选择合适的图表功能，比如对于离散数据，如果想了解其分布状态，通常选择条形图，如果想了解数据结构，通常选择饼图。对于连续数据，可通过直方图了解其分布状态。因此，这里我们选择直方图来描述连续变量Q3的分布状态。</p><p>从上图可以发现，变量Q3是近似正态，并且右偏的分布</p><p>3.2 描述分析 </p><p>单击’分析菜单‘，在下拉框中选择’描述统计‘，在右边下拉框中找到并点击’描述分析‘，弹出下列对话框：</p><p>在左栏选择变量’Q3‘，点击转换按钮，Q3自动转换到右栏。点击’选项‘按钮，弹出’描述：选项‘。</p><p>在该对话框中选择所需的统计参数，点击继续，重新回到’描述‘对话框，然后点击确定。产生下面的描述统计表。</p><p>描述统计分析的结果和频率分析结果没有任何区别，甚至在某些方面还不如频率分析。但是，它也有自己的独到之处，比如利用描述分析对话框，可直接进行数据标准化。</p><p>3.3 交叉表分析</p><p>交叉表是一种行列交叉的分类汇总表格，行和列上至少各有一个分类变量，行和列的交叉处可以对数据进行多种汇总计算。</p><p>交叉表分析一般分析分类变量，以交叉表格的形式对两个或两个以上分类变量的关系进行多角度对比分析。</p><p>单击’分析菜单‘，在下拉框中选择’描述统计‘，在右边下拉框中找到并点击’交叉表‘，然后将会弹出下面的对话框：</p><p>利用一贯使用的方法，分别把’Q3‘和’Q13‘转移到’行‘功能框里，把Q2转移到’列‘功能框里，然后点击’单元格‘按钮’，弹出‘交叉表：单元格显示’对话框：</p><p>我们在‘计数’和‘百分比’与‘非整数权重’复选功能框内选取合适的功能项，然后点击继续，又回到‘交叉表’对话框，点击‘确定’按钮，返回结果。</p><p>3.4 多分类定义</p><p>分类数据可以通过二分类与多分类进行录入。二分类数据录入非常容易，通过一个带有变量值‘0’和‘1’的变量来完成即可，多分类数据录入也没有想象中的那么难。只要用合适的数字表示就可以了。接下来我们举例说明：</p><p>假设有这样一个问卷，有四个选项:</p><p>我们可以通过四个二分类变量的设置来保存问卷结果：</p><table><thead><tr><th>ID</th><th>有钱</th><th>有权</th><th>长的帅</th><th>有钱有权长得丑</th></tr></thead><tbody><tr><td>妹子1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>妹子2</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>妹子3</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>妹子4</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>妹子5</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>妹子6</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>妹子7</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>妹子8</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>妹子9</td><td>0</td><td>1</td><td>0</td><td>0</td></tr></tbody></table><p>也可以通过一个分类变量来保存问卷结果，如果我们把‘妹子的择偶标准’的四个分类分别赋予1，2，3，4四个值：</p><p>问卷结果的单变量多分类存储方式：</p><table><thead><tr><th>ID</th><th>选择结果</th></tr></thead><tbody><tr><td>妹子1</td><td>2</td></tr><tr><td>妹子2</td><td>1</td></tr><tr><td>妹子3</td><td>3</td></tr><tr><td>妹子4</td><td>3</td></tr><tr><td>妹子5</td><td>4</td></tr><tr><td>妹子6</td><td>4</td></tr><tr><td>妹子7</td><td>1</td></tr><tr><td>妹子8</td><td>1</td></tr><tr><td>妹子9</td><td>2</td></tr></tbody></table><p>如果是多选，我们可以根据多选的数量来设置变量数量，比如可以多选，最多选三个：</p><p>多重分类法来存储多选结果：</p><table><thead><tr><th>ID</th><th>选择结果1</th><th>选择结果2</th><th>选择结果3</th></tr></thead><tbody><tr><td>妹子1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>妹子2</td><td>1</td><td>2</td><td>4</td></tr><tr><td>妹子3</td><td>1</td><td>2</td><td>3</td></tr><tr><td>妹子4</td><td>1</td><td>2</td><td>3</td></tr><tr><td>妹子5</td><td>2</td><td>3</td><td>4</td></tr><tr><td>妹子6</td><td>2</td><td>3</td><td>4</td></tr><tr><td>妹子7</td><td>1</td><td>2</td><td>4</td></tr><tr><td>妹子8</td><td>1</td><td>2</td><td>3</td></tr><tr><td>妹子9</td><td>2</td><td>3</td><td>4</td></tr></tbody></table><p>二分类法存储多选结果：</p><table><thead><tr><th>ID</th><th>有钱</th><th>有权</th><th>长的帅</th><th>有钱有权长得丑</th></tr></thead><tbody><tr><td>妹子1</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>妹子2</td><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr><td>妹子3</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>妹子4</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>妹子5</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>妹子6</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>妹子7</td><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr><td>妹子8</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>妹子9</td><td>0</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>无论是二分法还是多重分类法，只要使用多变量存储多选结果，那么无论如何就要对这些变量进行定义。否则spss将无法分析数据。因为这些变量其实归属于一个特征，我们必须把它们集中成一个集合，定义成一个被我们统称之为‘多重响应集’的集合。其本质含义就是使用多变量记录结果，其中每条数据（每个个案）包含多个选择结果。</p><p>单击‘分析’菜单，选择‘定制表’，在弹出的右侧子菜单里选择并点击‘多重响应集’，则弹出’定义多重响应集’对话框：</p><p>Q5明显是二分类多变量记录存储，因此必须把它们合并成一个多重响应集。</p><p>把对话框所有Q5变量的分类项全部转移到右框中，选择二分法，计数值填写‘1’也就是说按类标签‘1’计数。在‘类别标签来源’处，选择功能项‘变量标签’才有意义。</p><p>Q8明显是多分类多变量存储记录，因此必须把它们合并成一个多重响应集。其方法和上面雷同，仅仅在‘变量编码’处选择‘类别’，与上面不同。</p><h1 id="相关分析"><a href="#相关分析" class="headerlink" title="相关分析"></a>相关分析</h1><p>第四章: 相关分析</p><p>相关分析分为两种：线性相关关系和非线性相关关系，线性相关又叫直线相关，非线性相关通常指的是曲线相关。</p><p>我们这里主要关注于‘皮尔森线性相关’</p><p>接下来我们首先进行散点图绘制。单击‘图形’菜单，选择‘旧对话框’，此时在右侧出现的菜单中选择并点击‘散点图/电图’，然后弹出下面的对话框：</p><p>选择‘简单散点图’然后点击‘定义’按钮。</p><p>然后把右边栏目中的合适变量分别通过转换按钮转移到’Y轴‘和’X轴‘功能框里。单击’确定‘按钮，即可得到下面的散点图：</p><p>很明显，变量‘Season’和‘Retail Sales’之间存在明显的线性正相关关系，‘Retail Sales’随着变量‘Season’单调增变化。</p><p>散点图帮助我们实现了对变量间关系的可视化直观判断，若想量化这种关系，就必须通过相关分析来实现了。</p><p>单击‘分析’菜单，选择‘相关’，在右侧弹出子菜单，单击‘双变量’，弹出‘双变量相关性’对话框。</p><h1 id="回归分析"><a href="#回归分析" class="headerlink" title="回归分析"></a>回归分析</h1><p>第五章: 回归分析</p><p>定义:回归分析是统计分析方法，旨在模拟一个因变量与一个或多个自变量之间的关系。主要用来定量描述相关性或者对因变量的值进行预测。</p><p>换成通俗语言：研究自变量与因变量之间数量变化关系的一种分析方法，它主要是通过确定因变量Y与影响它的自变量Xi之间的函数关系，衡量自变量Xi对因变量Y的影响能力，进而可以预测因变量Y的发展趋势。</p><p>回归分析包括线性和非线性回归，非线性回归可以通过适合的数学变换转化为线性回归。这里我们主要着力于线性回归。</p><p>5.1 线性回归分析流程</p><p>\1. 根据预测目标选择合适的自变量和因变量</p><p>\2. 对于简单回归分析，可以绘制散点图，直观地观察因变量是否随自变量呈线性发展趋势</p><p>\3. 利用最小二法进行模型参数估计，确定回归模型</p><p>\4. 对回归模型进行检验</p><p>\5. 利用回归模型进行预测</p><p>线性回归的理论依据是最小二算法，这在下一阶段的算法课上会有介绍。</p><p>下面我们通过一个例子来学习下用Spss处理线性回归问题。</p><p>1，数据聚合，数据初判断</p><p>打开文件’Sales5000.xls’，单击‘数据’，选择并单击‘汇总’后，跳出下面的对话框：</p><p>通过转换按钮把选定的分组变量从左框中转移到‘分界变量’功能框里；把待聚合变量转移到‘汇总变量’功能框里，具体内容见下表：</p><p>按下‘确定’按钮，就会产生一个新的承载聚合结果的数据集‘New_data’。此时，数据量从原始的50000条数据聚合到2766条数据。</p><p>为了进一步聚合，我们通过变量计算把变量‘OrderDate’转换成只包含年月的字符串，然后按转换后的变量聚合。</p><p>按转换后的变量‘Orderdata_new1’继续聚合：</p><p>最终得到下面的结果：</p><p>聚合后的数据减少到91行</p><p>2，回归分析</p><p>我们确定Orderdata_new1为自变量，UnitsSold_sum_sum为因变量，然后对二者做散点图：</p><p>同理，我们也可以对‘TotalRevenue_sum_sum’作图。</p><p>我们发现其中并没有很强规律性，当然还是可以做回归分析的，只不过效果不会太好。尽管无法实施我们的最终目的，但是从中我们可以总结出，对于单变量或双变量回归，通过作图，在一定程度上可以判断数据是否具有回归价值。</p><p>打开数据‘推广效果数据’，画出散点图，方法如上：</p><p>点击‘确定’后，产生下面的图像：</p><p>很明显，上面图像告诉我们，广告费用与购买用户数存在明显正相关。两者之间的皮尔森相关系数为：0.952。下面我们对其建立线性回归模型：</p><p>单击‘分析’，在下拉菜单中选择‘回归’，在右边的下拉菜单中点击‘线性’，则跳出‘线性回归’对话框：</p><p>参数设置：</p><p>\1. 设置‘因变量’与‘自变量’</p><p>\2. 回归系数与拟合度设置</p><p>单击‘统计’按钮，弹出‘线性回归：统计’对话框。</p><p>在‘回归系数’功能框中选择‘估算值’功能框,返回回归系数。</p><p>在该框的右边选择‘模型拟合’返回拟合优度R的值。</p><p>\3. 自变量步进标准及常数项设置</p><p>点击‘线性回归’对话框中的‘选项’按钮，跳出‘线性回归：选项’对话框</p><p>步进法条件实际就是模型输入变量和移去变量的条件，具体如下：</p><p>准则: F-to-enter 的概率 &lt;= .050，F-to-remove 的概率 &gt;= .100，F指的是F-检验，它通常来检验正态假定下两个变量（自变量与因变量）之间的相关性。F值对应的概率越小，自变量与因变量的关系越强，也就意味着越有资格进入。这样的设置避免了经验缺乏的新手不知道如何通过F值作变量存移。</p><p>另外，还需在‘在方程中包括常量’前面的方框里打上对号。</p><p>点击‘继续’回到线性回归对话框。单机确定，完成回归分析。</p><p>\4. 模型检验，运行结果分析：</p><p>这个表格没什么可说的。</p><p>这个表格中最重要的参数是R方，因为简单的线性回归主要采用R方来考量模型模拟效果，而调整后R方用于修正因自变量个数的增加而导致的模型过拟合问题，因此多用于衡量多重线性回归模型的拟合效果。</p><p>对于这个表格我们只需关注显著性（p值）即可。也即直接与显著性水平a（0.01,或0.05）比较得出结果。表格中的显著性=0.000&lt;=0.01,说明0假设不合理，对立假设成立。也即自变量和因变量间存在的线性关系具有极其显著性的统计学意义。如果0.01&lt;显著性（p值）&lt;=0.05，则结果具有显著的统计学意义；如果显著性（p值）&lt;=0.01，则结果具有极其显著的统计学意义。</p><p>上面的表格是线性回归模型回归系数表。这里重要的信息是‘B’列数据和‘显著性’列数据。‘B’列数据描述的是回归系数；‘显著性’列是回归系数显著性检验的结果，即研究回归模型中的每个自变量与因变量之间是否存在显著的线性关系。p值越小，两者之间的线性关系就越显著；反之，则越不显著。如果检验不显著，则其对应的回归系数要从模型中删去。</p><p>根据‘B’列我们可以确定该线性回归模型：</p><p>Y=77.687x+1835.016</p><p>\5. 回归模型进行预测</p><p>点击‘分析’ 按钮，在下拉框中选择‘回归’标签，然后在右边的下拉框中选择并点击‘线性‘，在弹出的对话框中点击保存：</p><p>在弹出的对话框中按下图设置参数：</p><p>点击‘继续’再次回到’线性回归‘对话框中。然后点击确定，就会发现一个新列产生，该列就是预测值。</p>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据的加载,存储,清洗,转换合并</title>
      <link href="/2019/06/17/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8A%A0%E8%BD%BD-%E5%AD%98%E5%82%A8-%E6%B8%85%E6%B4%97-%E8%BD%AC%E6%8D%A2%E5%90%88%E5%B9%B6/"/>
      <url>/2019/06/17/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8A%A0%E8%BD%BD-%E5%AD%98%E5%82%A8-%E6%B8%85%E6%B4%97-%E8%BD%AC%E6%8D%A2%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<p><strong>拼接</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">以下皆是以3x3的矩阵进行拼接</span><br><span class="line">np.hstack((a,b)) 水平拼接 行数相等</span><br><span class="line">如两个3x3拼接</span><br><span class="line">[[ 7, 34, 37, 70, 11, 67],</span><br><span class="line">        [56, 12, 35, 66, 38, 85],</span><br><span class="line">        [84, 80, 89, 49, 23, 88]]</span><br><span class="line">np.vstack((a,b)) 垂直拼接  列数相等</span><br><span class="line">如两个3x3拼接</span><br><span class="line">[[21, 62,  2],</span><br><span class="line">       [41,  8, 48],</span><br><span class="line">       [46, 37, 91],</span><br><span class="line">       [ 1, 62, 72],</span><br><span class="line">       [82, 84,  4],</span><br><span class="line">       [ 4, 88, 81]]</span><br><span class="line">concatenate((a,b),axis=0) 可拼接多个,axis默认垂直拼接=0(主要用于大数据的处理)</span><br><span class="line">axis=0默认的              </span><br><span class="line">[[80, 45, 33],   </span><br><span class="line">        [18, 39, 41],</span><br><span class="line">        [10, 80, 32],</span><br><span class="line">        [71, 23, 95],</span><br><span class="line">        [67, 58, 21],</span><br><span class="line">        [ 2, 42, 31]]</span><br><span class="line">axis=1水平的</span><br><span class="line">[[78, 81, 99, 58, 76, 46],</span><br><span class="line">        [30, 47, 52, 22, 66, 42],</span><br><span class="line">        [21, 89, 84,  2, 56, 31]]</span><br><span class="line">column_stack((a,b)) 水平拼接 列拼接</span><br><span class="line">[[86, 10, 90, 27, 23, 28],</span><br><span class="line">        [20, 23, 45, 37, 82, 34],</span><br><span class="line">        [14, 57, 86, 72,  6, 27]]</span><br><span class="line">row_stack(a,b) 垂直拼接 行拼接</span><br><span class="line">[[51, 90, 24],</span><br><span class="line">        [63, 90, 37],</span><br><span class="line">        [27, 79, 91],</span><br><span class="line">        [90,  2, 45],</span><br><span class="line">        [74,  4, 48],</span><br><span class="line">        [54, 70, 11]]</span><br><span class="line">merge(a,b,on=&apos;对应键a&apos;) 按照对应键进行笛卡尔乘积(内连接)键相同的保留,合并的连个数据框需要列名相同(pandas的函数)</span><br><span class="line">ab_xc_xb_yc_y</span><br><span class="line">09 3 9 1 2</span><br><span class="line">其中merge中有一个参数修改连接方式(how=&apos;left&apos;左连接,how=&apos;right&apos;右连接),若果键名不同通过left_on\right_on实现</span><br><span class="line">join 同merge,默认使用左连接,how = &apos;right&apos;右连接</span><br><span class="line">两个dataframe的列索引不能有一样的</span><br><span class="line">concat((a1,a2),axis=0) 默认垂直拼接,axis=1变成水平拼接</span><br><span class="line">axis=1 </span><br><span class="line">abcabc</span><br><span class="line">0939912</span><br><span class="line">1815711</span><br><span class="line">2187287</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pandas.read_csv参数</title>
      <link href="/2019/06/14/pandas-read-csv%E5%8F%82%E6%95%B0/"/>
      <url>/2019/06/14/pandas-read-csv%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>读取csv文件：pd.read_csv(),写入csv文件:pd.to_csv()<br>pandas还可以读取一下文件：<br>read_csv,<br>read_excel,<br>read_hdf,<br>read_sql,<br>read_json,<br>read_msgpack (experimental),<br>read_html,<br>read_gbq (experimental),<br>read_stata,<br>read_sas,<br>read_clipboard,<br>read_pickle;<br>相应的写入：<br>to_csv,<br>to_excel,<br>to_hdf,<br>to_sql,<br>to_json,<br>to_msgpack (experimental),<br>to_html,<br>to_gbq (experimental),<br>to_stata,<br>to_clipboard,<br>to_pickle.</p><h3 id="常用参数的读取csv文件"><a href="#常用参数的读取csv文件" class="headerlink" title="常用参数的读取csv文件"></a>常用参数的读取csv文件</h3><p><strong>header=None时，即指明原始文件数据没有列索引，这样read_csv为自动加上列索引，除非你给定列索引的名字。</strong></p><p><strong>header=0，表示文件第0行（即第一行，python，索引从0开始）为列索引，这样加names会替换原来的列索引。</strong></p><p><strong>index_col为指定数据中哪一列作为Dataframe的行索引，也可以可指定多列，形成层次索引，默认为None,即不指定行索引，这样系统会自动加上行索引（0-）</strong></p><p><strong>usecols:可以指定原数据集中，所使用的列。在本例中，共有4列，当usecols=[0,1,2,3]时，即选中所有列，之后令第一列为行索引，当usecols=[1,2,3]时，即从第二列开始，之后令原始数据集的第二列为行索引。</strong></p><p><strong>nrows：可以给出从原始数据集中的所读取的行数，目前只能从第一行开始到nrows行。</strong></p><p><strong>sep </strong>指定分隔符  sep=’\s+’</p><h5 id="delimiter-定界符，备选分隔符（如果指定该参数，则sep参数失效）"><a href="#delimiter-定界符，备选分隔符（如果指定该参数，则sep参数失效）" class="headerlink" title="delimiter : 定界符，备选分隔符（如果指定该参数，则sep参数失效）"></a>delimiter : 定界符，备选分隔符（如果指定该参数，则sep参数失效）</h5><p><strong>squeeze</strong> : boolean, default False  如果文件值包含一列，则返回一个Series</p><p><strong>prefix</strong> : str, default None</p><p>在没有列标题时，给列添加前缀。例如：添加‘X’ 成为 X0, X1, …</p><p><strong>mangle_dupe_cols</strong> : boolean, default True</p><p>重复的列，将‘X’…’X’表示为‘X.0’…’X.N’。如果设定为false则会将所有重名列覆盖。</p><p><strong>dtype</strong> : Type name or dict of column -&gt; type, default None</p><p>每列数据的数据类型。例如 {‘a’: np.float64, ‘b’: np.int32}</p><p><strong>converters</strong> : dict, default None</p><p>列转换函数的字典。key可以是列名或者列的序号</p><p><strong>skipinitialspace</strong> : boolean, default False</p><p>忽略分隔符后的空白（默认为False，即不忽略）</p><p><strong>skiprows</strong> : list-like or integer, default None</p><p>需要忽略的行数（从文件开始处算起），或需要跳过的行号列表（从0开始）</p><p><strong>skipfooter</strong> : int, default 0</p><p>从文件尾部开始忽略。 (c引擎不支持)</p><p><strong>skip_footer</strong> : int, default 0</p><p>不推荐使用：建议使用skipfooter ，功能一样</p><p><strong>keep_default_na</strong> : bool, default True</p><p>如果指定na_values参数，并且keep_default_na=False，那么默认的NaN将被覆盖，否则添加。</p><p><strong>na_filter</strong> : boolean, default True</p><p>是否检查丢失值（空字符串或者是空值）。对于大文件来说数据集中没有空值，设定na_filter=False可以提升读取速度</p><p><strong>verbose</strong> : boolean, default False</p><p>是否打印各种解析器的输出信息，例如：“非数值列中缺失值的数量”等。</p><p><strong>skip_blank_lines</strong> : boolean, default True</p><p>如果为True，则跳过空行；否则记为NaN。</p><p><strong>keep_date_col</strong> : boolean, default False</p><p>如果连接多列解析日期，则保持参与连接的列。默认为False。</p><p><strong>dayfirst</strong> : boolean, default False</p><p>DD/MM格式的日期类型</p><p><strong>chunksize</strong> : int, default None</p><p>文件块的大小</p><p><strong>thousands</strong> : str, default None</p><p>千分位分割符，如“，”或者“.”</p><p><strong>decimal</strong> : str, default ‘.’</p><p>字符中的小数点 (例如：欧洲数据使用’，‘).</p><p><strong>quotechar</strong> : str (length 1), optional</p><p>引号，用作标识开始和解释的字符，引号内的分割符将被忽略。</p><p><strong>doublequote</strong> : boolean, default True</p><p>双引号，当单引号已经被定义，并且quoting 参数不是QUOTE_NONE的时候，使用双引号表示引号内的元素作为一个元素使用。</p><p><strong>escapechar</strong> : str (length 1), default None</p><p>当quoting 为QUOTE_NONE时，指定一个字符使的不受分隔符限值。</p><p><strong>error_bad_lines</strong> : boolean, default True</p><p>如果一行包含太多的列，那么默认不会返回DataFrame ，如果设置成false，那么会将改行剔除（只能在C解析器下使用）。</p>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论</title>
      <link href="/2019/06/12/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
      <url>/2019/06/12/%E6%A6%82%E7%8E%87%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h4 id="条件概率分布函数"><a href="#条件概率分布函数" class="headerlink" title="条件概率分布函数"></a>条件概率分布函数</h4><p><img src="/2019/06/12/概率论/838ba61ea8d3fd1f5f7d0564334e251f95ca5f73.png" alt="38ba61ea8d3fd1f5f7d0564334e251f95ca5f7"></p><p><img src="/2019/06/12/概率论/gif.gif" alt="i"></p><p><img src="/2019/06/12/概率论/20180715220611230.png" alt="018071522061123"></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pandas和绘图课件</title>
      <link href="/2019/06/11/pandas%E5%92%8C%E7%BB%98%E5%9B%BE%E8%AF%BE%E4%BB%B6/"/>
      <url>/2019/06/11/pandas%E5%92%8C%E7%BB%98%E5%9B%BE%E8%AF%BE%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Pandas的数据结构"><a href="#Pandas的数据结构" class="headerlink" title="Pandas的数据结构"></a>Pandas的数据结构</h2><h4 id="Series"><a href="#Series" class="headerlink" title="Series:"></a>Series:</h4><p>Series数据的建立 -&gt;<br>In [1]: import numpy as np</p><p>In [2]: import pandas as pd</p><p>In [3]: pddata_1=pd.Series([1,2,3])</p><p>In [4]: pddata_1<br>Out[4]:<br>0 1<br>1 2<br>2 3<br>dtype: int64<br>数据取值和获取搜索索引<br>In [7]: pddata_1.values<br>Out[7]: array([1, 2, 3], dtype=int64)<br>In [8]: pddata_1.index<br>Out[8]: RangeIndex(start=0, stop=3, step=1)</p><p>例子：</p><p>In [9]: pddata_2=pd.Series([‘this’,’is’,’pandas’])</p><p>In [10]: pddata_2.values<br>Out[10]: array([‘this’, ‘is’, ‘pandas’], dtype=object)</p><p>In [11]: pddata_2.index<br>Out[11]: RangeIndex(start=0, stop=3, step=1)</p><p>带有独特索引的Series数据：</p><p>In [15]: pddata_3=pd.Series([344,33,-456],index=[‘andereas’,’hachenberger’,’dieter’])<br>In [16]: pddata_3<br>Out[16]:<br>andereas 344<br>hachenberger 33<br>dieter -456<br>dtype: int64<br>In [17]: pddata_3.index,pddata_3.values<br>Out[17]:<br>(Index([‘andereas’, ‘hachenberger’, ‘dieter’], dtype=’object’),<br>array([ 344, 33, -456], dtype=int64))</p><p>例子：<br>In [21]: testa=[245,788,90]<br>In [22]: pddata_4=pd.Series(testa,index=[‘wir’,’sind’,’Menschen’])<br>In [23]: pddata_4<br>Out[23]:<br>wir 245<br>sind 788<br>Menschen 90<br>dtype: int64<br>In [25]: pddata_4[‘wir’]<br>Out[25]: 245<br>In [27]: pddata_4[[‘wir’,’sind’,’Menschen’]]<br>Out[27]:<br>wir 245<br>sind 788<br>Menschen 90<br>dtype: int64</p><p>例子：<br>In [31]: seriesdata_1=pd.Series([‘Profession’,’student’,’bechelor’,’professor’,’informatics developer’],index=[‘Name’,’Linker’,’Hamacher’,’Schuhmacher’,’Heintze’])</p><p>In [32]: seriesdata_1<br>Out[32]:<br>Name Profession<br>Linker student<br>Hamacher bechelor<br>Schuhmacher professor<br>Heintze informatics developer<br>dtype: object</p><p>Series数据中的过滤、计算。</p><p>In [33]: seriesdata_2=pd.Series([34,-4,-45,-37,32,9,1,3],index=[‘a’,’d’,’e’,’y’,’f’,’t’,’u’,’o’])</p><p>In [34]: seriesdata_2<br>Out[34]:<br>a 34<br>d -4<br>e -45<br>y -37<br>f 32<br>t 9<br>u 1<br>o 3<br>dtype: int64</p><p>In [35]: seriesdata_2[seriesdata_2&gt;1]<br>Out[35]:<br>a 34<br>f 32<br>t 9<br>o 3<br>dtype: int64</p><p>In [36]: seriesdata_2[seriesdata_2&gt;0]<br>Out[36]:<br>a 34<br>f 32<br>t 9<br>u 1<br>o 3<br>dtype: int64</p><p>In [37]: seriesdata_2*3<br>Out[37]:<br>a 102<br>d -12<br>e -135<br>y -111<br>f 96<br>t 27<br>u 3<br>o 9<br>dtype: int64</p><p>In [38]: np.sin(seriesdata_2)<br>Out[38]:<br>a 0.529083<br>d 0.756802<br>e -0.850904<br>y 0.643538<br>f 0.551427<br>t 0.412118<br>u 0.841471<br>o 0.141120<br>dtype: float64</p><p>Serie 和字典十分相似，因此原本字典的函数也可以用：</p><p>我们先复习下字典：<br>例子：</p><p>In [39]: dic={‘Winne’:178,’Johanis’:189,’Banach’:186}</p><p>In [40]: dic[‘Li’]=176</p><p>In [41]: dic<br>Out[41]: {‘Banach’: 186, ‘Johanis’: 189, ‘Li’: 176, ‘Winne’: 178}</p><p>例子：<br>In [19]: list11=[‘zhang’,’wang’,’li’]</p><p>In [20]: list22=range(3)</p><p>In [21]: indirect=zip(list22,list11)</p><p>In [22]: diction={index:value for index,value in indirect}</p><p>In [23]: diction<br>Out[23]: {0: ‘zhang’, 1: ‘wang’, 2: ‘li’}</p><p>例3：</p><p>In [26]: list11=[‘a’,’b’,’c’]</p><p>In [27]: list22=[1,2,3]</p><p>In [28]: dfgeg=zip(list11,list22)</p><p>In [29]: sss=dict((index,value) for index,value in dfgeg)</p><p>In [30]: sss<br>Out[30]: {‘a’: 1, ‘b’: 2, ‘c’: 3}</p><p>应用字典函数“in”和“Update”到Series</p><p>例子<br>In [34]: datas_pys=pd.Series(range(4),index=[‘i’,’want’,’to’,’do’])</p><p>In [35]: datas_pys<br>Out[35]:<br>i 0<br>want 1<br>to 2<br>do 3<br>dtype: int32</p><p>In [36]: ‘want’ in datas_pys<br>Out[36]: True<br>例子：<br>In [56]: datas_pys.update(pd.Series([2,3,4],index=[‘want’,’to’,’do’]))</p><p>In [57]: datas_pys<br>Out[57]:<br>i 0<br>want 2<br>to 3<br>do 4<br>dtype: int32</p><p>In [58]: s1 = pd.Series([1, 2, 3])</p><p>In [59]: s2 = pd.Series([4, 5, 6])</p><p>In [60]: s3 = pd.Series([4, 5, 6], index=[3,4,5])</p><p>In [61]: s1.append(s2)<br>Out[61]:<br>0 1<br>1 2<br>2 3<br>0 4<br>1 5<br>2 6<br>dtype: int64</p><p>In [62]: s1.append(s3)<br>Out[62]:<br>0 1<br>1 2<br>2 3<br>3 4<br>4 5<br>5 6<br>dtype: int64</p><p>In [63]: s1.append(s2, ignore_index=True)<br>Out[63]:<br>0 1<br>1 2<br>2 3<br>3 4<br>4 5<br>5 6<br>dtype: int64<br>重新编号</p><p>字典可以直接转化为Serie</p><p>In [68]: dicttna={1:’foo’,3:’drt’,8:’tyue’}</p><p>In [69]: serie_12=pd.Series(dicttna)</p><p>In [70]: serie_12<br>Out[70]:<br>1 foo<br>3 drt<br>8 tyue<br>dtype: object</p><p>isnull和notnull函数可用于检测数据缺失。</p><p>In [79]: dit_113={‘lin’:139,’zhang’:134,’wang’:173,’tan’:None}</p><p>In [80]: serie_123=pd.Series(dit_113)</p><p>In [81]: serie_123<br>Out[81]:<br>lin 139.0<br>tan NaN<br>wang 173.0<br>zhang 134.0<br>dtype: float64</p><p>In [82]: pd.isnull(serie_123)<br>Out[82]:<br>lin False<br>tan True<br>wang False<br>zhang False<br>dtype: bool</p><p>In [83]: pd.notnull(serie_123)<br>Out[83]:<br>lin True<br>tan False<br>wang True<br>zhang True<br>dtype: bool</p><p>serie_123.notnull()<br>Out[85]:<br>lin       True<br>tan      False<br>wang      True<br>zhang     True<br>dtype: bool</p><p>Series 的索引可以修改：<br>In [87]: serie_123.index<br>Out[87]: Index([‘lin’, ‘tan’, ‘wang’, ‘zhang’], dtype=’object’)<br>In [88]: serie_123.index=[‘lin’, ‘tan’, ‘shan’, ‘zhang’]<br>In [90]: serie_123<br>Out[90]:<br>lin 139.0<br>tan NaN<br>shan 173.0<br>zhang 134.0<br>dtype: float64</p><h4 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h4><p>简单数据框的构成：<br>由字典直接形成</p><p>In [93]: sales=[12365,34563,45673,23461,89034]</p><p>In [94]: seller=[‘zhanghui’,’dongyibo’,’yangqian’,’liujuntao’,’zhangshanshan’]</p><p>In [95]: sales_quantity=[213,305,452,302,190]</p><p>In [96]: table_sales={‘Seller’:seller,’Sales’:sales,’SalesQuantity’:sales_quantity}</p><p>In [97]: framesample_1=pd.DataFrame(table_sales)</p><p>In [98]: framesample_1<br>Out[98]:<br>Sales SalesQuantity Seller<br>0 12365 213 zhanghui<br>1 34563 305 dongyibo<br>2 45673 452 yangqian<br>3 23461 302 liujuntao<br>4 89034 190 zhangshanshan</p><p>与Series一样，索引会自动加上。</p><p>我们还可以指定列序列的左右顺序。</p><p>In [99]: framesample_1=pd.DataFrame(table_sales,columns=[‘SalesQuantity’,’Seller’,’Sales’])</p><p>In [100]: framesample_1<br>Out[100]:<br>SalesQuantity Seller Sales<br>0 213 zhanghui 12365<br>1 305 dongyibo 34563<br>2 452 yangqian 45673<br>3 302 liujuntao 23461<br>4 190 zhangshanshan 89034</p><p>如果数据框中不包含所要找的值，自动返回NaN</p><p>In [101]: framesample_1=pd.DataFrame(table_sales,columns=[‘SalesQuantity’,’Seller’,’Sales’,’Profit’])</p><p>In [102]: framesample_1<br>Out[102]:<br>SalesQuantity Seller Sales Profit<br>0 213 zhanghui 12365 NaN<br>1 305 dongyibo 34563 NaN<br>2 452 yangqian 45673 NaN<br>3 302 liujuntao 23461 NaN<br>4 190 zhangshanshan 89034 NaN</p><p>索引DataFrame 的数据。类似字典</p><p>列数据索引<br>In [104]: framesample_1[‘Seller’]<br>Out[104]:<br>0 zhanghui<br>1 dongyibo<br>2 yangqian<br>3 liujuntao<br>4 zhangshanshan<br>Name: Seller, dtype: object</p><p>行数据索引：</p><p>In [106]: framesample_1.ix[2]<br>Out[106]:<br>SalesQuantity 452<br>Seller yangqian<br>Sales 45673<br>Prodit NaN<br>Name: 2, dtype: object</p><p>Dateframe的索引也可以改变。</p><p>In [108]: framesample_1.index=[5,6,7,8,9]</p><p>In [109]: framesample_1<br>Out[109]:<br>SalesQuantity Seller Sales Prodit<br>5 213 zhanghui 12365 NaN<br>6 305 dongyibo 34563 NaN<br>7 452 yangqian 45673 NaN<br>8 302 liujuntao 23461 NaN<br>9 190 zhangshanshan 89034 NaN</p><p>NAN值可以通过赋值语句替换。<br>In [13]: framesample_1[‘Profit’]=[278,967,654,234,432]<br>In [14]: framesample_1<br>Out[14]:<br>SalesQuantity Seller Sales Profit<br>5 213 zhanghui 12365 278<br>6 305 dongyibo 34563 967<br>7 452 yangqian 45673 654<br>8 302 liujuntao 23461 234<br>9 190 zhangshanshan 89034 432</p><p>当用Series赋值时，可以精确地赋值到行列交叉位，没有指定的行列交叉位不会被赋值，将会以NAN的形式显示。<br>In [17]: val_Series=pd.Series([0,1,1],index=[6,7,9])<br>In [19]: framesample_1[‘Profit’]=val_Series<br>In [20]: framesample_1<br>Out[20]:<br>SalesQuantity Seller Sales Profit<br>5 213 zhanghui 12365 NaN<br>6 305 dongyibo 34563 0.0<br>7 452 yangqian 45673 1.0<br>8 302 liujuntao 23461 NaN<br>9 190 zhangshanshan 89034 1.0</p><p>为不存在的列赋值会产生新的列。<br>In [21]: framesample_1[‘loss’]=pd.Series([165,0,0,34,0],index=range(5,10,1))<br>In [22]: framesample_1<br>Out[22]:<br>SalesQuantity Seller Sales Profit loss<br>5 213 zhanghui 12365 NaN 165<br>6 305 dongyibo 34563 0.0 0<br>7 452 yangqian 45673 1.0 0<br>8 302 liujuntao 23461 NaN 34<br>9 190 zhangshanshan 89034 1.0 0</p><p>可用del删除列</p><p>In [25]: del framesample_1[‘Profit’]</p><p>In [26]: framesample_1<br>Out[26]:<br>SalesQuantity Seller Sales loss<br>5 213 zhanghui 12365 165<br>6 305 dongyibo 34563 0<br>7 452 yangqian 45673 0<br>8 302 liujuntao 23461 34<br>9 190 zhangshanshan 89034 0</p><p>嵌套字典：<br>In [28]: Qtditc={‘TeacherLiu’:{‘height’:172,’weight’:67,’age’:34},’TeacherHuang’:{‘height’:182,’weight’:77,’age’:36},’TeacherTao’:{‘height’:192,’weight’:98,’age’:56} }</p><p>In [29]: Qtditc<br>Out[29]:<br>{‘TeacherHuang’: {‘age’: 36, ‘height’: 182, ‘weight’: 77},<br>‘TeacherLiu’: {‘age’: 34, ‘height’: 172, ‘weight’: 67},<br>‘TeacherTao’: {‘age’: 56, ‘height’: 192, ‘weight’: 98}}</p><p>如果把嵌套字典传给数据框，构造数据框，外键为列，内键为行索引。<br>In [30]: GetNewFrame=pd.DataFrame(Qtditc)</p><p>In [31]: GetNewFrame<br>Out[31]:<br>TeacherHuang TeacherLiu TeacherTao<br>age 36 34 56<br>height 182 172 192<br>weight 77 67 98</p><p>数据框的转置 </p><p>In [32]: GetNewFrame.T<br>Out[32]:<br>age height weight<br>TeacherHuang 36 182 77<br>TeacherLiu 34 172 67<br>TeacherTao 56 192 98</p><p>Series组成的字典也可以直接转化为数据框：</p><p>In [33]: Popdic={‘LinFeng’:pd.Series([23,45,165],index=[‘age’,’weight’,’height’]),’Zhangduoli’:pd.Series([43,75,175],index=[‘age’,’weight’,’height’]),’JinChang’:pd.Series([51,46,185],index=[‘age’,’weight’,’height’])}</p><p>In [35]: Getnumerpop=pd.DataFrame(Popdic)</p><p>In [36]: Getnumerpop<br>Out[36]:<br>JinChang LinFeng Zhangduoli<br>age 51 23 43<br>weight 46 45 75<br>height 185 165 175</p><p>数据框名字的添加：</p><p>In [45]: Getnumerpop.columns.name=’Name’</p><p>In [46]: Getnumerpop.index.name=’personal information’</p><p>In [47]: Getnumerpop<br>Out[47]:<br>Name              JinChang LinFeng Zhangduoli<br>personal information<br>age                    51     23       43<br>weight                 46     45       75<br>height                 185    165      175</p><p>数据框的值：<br>In [53]: Getnumerpop.values<br>Out[53]:<br>array([[ 51, 23, 43],<br>[ 46, 45, 75],<br>[185, 165, 175]], dtype=int64)</p><p>数据框的index：</p><p>例1：</p><p>Getnumerpop.index=[‘p_age’,’p_weight’,’p_height’]</p><p>Getnumerpop.index<br>Out[57]: Index([‘p_age’, ‘p_weight’, ‘p_height’], dtype=’object’)</p><p>Getnumerpop<br>Out[58]:<br>Name      JinChang  LinFeng  Zhangduoli<br>p_age           51       23          43<br>p_weight        46       45          75<br>p_height       185      165         175</p><p>In [64]:index1=Getnumerpop.index<br>In [65]:index2=GetNewFrame.index</p><p>In [66]:index1.append(index2)<br>Out[66]: Index([‘p_age’, ‘p_weight’, ‘p_height’, ‘age’, ‘height’, ‘weight’], dtype=’object’)</p><p>例2<br>index2.intersection(index1)<br>Out[82]: Index([], dtype=’object’)</p><p>例3：<br>index2.union(index1)<br>Out[86]: Index([‘age’, ‘height’, ‘p_age’, ‘p_height’, ‘p_weight’, ‘weight’], dtype=’object’)</p><p>例4<br>index1.delete(1)<br>Out[94]: Index([‘p_age’, ‘p_height’], dtype=’object’)<br>22<br>例5<br>index1.insert(1,’pheight’)<br>Out[97]: Index([‘p_age’, ‘pheight’, ‘p_weight’, ‘p_height’], dtype=’object’)<br>index1.is_monotonic<br>Out[104]: False<br>index1.is_unique<br>Out[105]: True<br>index1.unique()<br>Out[107]: Index([‘p_age’, ‘p_weight’, ‘p_height’], dtype=’object’)<br>Series索引重建<br>In [2]: import numpy as np<br>In [3]: import pandas as pd<br>In [4]: Seriestest_1=pd.Series([10,-34,-89,36,50],index=[‘a’,’b’,’c’,’d’,’e’])</p><p>In [5]: Seriestest_1<br>Out[5]:<br>a 10<br>b -34<br>c -89<br>d 36<br>e 50<br>dtype: int64</p><p>In [7]: Seriestest_2=Seriestest_1.reindex([‘c’,’b’,’d’,’a’,’e’,’f’])</p><p>In [8]: Seriestest_2<br>Out[8]:<br>c -89.0<br>b -34.0<br>d 36.0<br>a 10.0<br>e 50.0<br>f NaN<br>dtype: float64</p><p>NAN值可以被替换</p><p>In [10]: Seriestest_2=Seriestest_1.reindex([‘c’,’b’,’d’,’a’,’e’,’f’],fill_value=0)</p><p>In [11]: Seriestest_2<br>Out[11]:<br>c -89<br>b -34<br>d 36<br>a 10<br>e 50<br>f 0<br>dtype: int64</p><p>使用ffill 和 bfill函数可以自动向前和向后补充缺失索引。（缺失值补充）<br>In [6]: testarray1=pd.Series([23,22,34],index=[3,7,9])<br>In [10]: test_12=testarray1.reindex(range(11),method=’ffill’)</p><p>In [11]: test_12<br>Out[11]:<br>0 NaN<br>1 NaN<br>2 NaN<br>3 23.0<br>4 23.0<br>5 23.0<br>6 23.0<br>7 22.0<br>8 22.0<br>9 34.0<br>10 34.0<br>dtype: float64</p><p>In [12]: test_12=testarray1.reindex(range(11),method=’bfill’)</p><p>In [13]: test_12<br>Out[13]:<br>0 23.0<br>1 23.0<br>2 23.0<br>3 23.0<br>4 22.0<br>5 22.0<br>6 22.0<br>7 22.0<br>8 34.0<br>9 34.0<br>10 NaN<br>dtype: float64</p><p>数据框的索引修改：（reindex可以任意删除，添加，交换行列）</p><p>对于数据框，reindex可以修改行索引和列，或两个都更改。</p><p>In [14]: #这里我用一个新的方法构造数据框<br>In [18]: frame_1=pd.DataFrame(np.arange(9).reshape(3,3),index=[‘row1’,’row2’,’row3’],columns=[‘one’,’two’,’three’])</p><p>In [19]: frame_1<br>Out[19]:<br>one two three<br>row1 0 1 2<br>row2 3 4 5<br>row3 6 7 8</p><p>In [20]: frame2=frame_1.reindex([‘row0’,’row1’,’row2’,’row3’])</p><p>In [21]: frame2<br>Out[21]:<br>one two three<br>row0 NaN NaN NaN<br>row1 0.0 1.0 2.0<br>row2 3.0 4.0 5.0<br>row3 6.0 7.0 8.0</p><p>In [22]: #reindex 修改列<br>In [28]: frame3=frame2.reindex(columns=[‘four’,’three’])</p><p>In [29]: frame3<br>Out[29]:<br>four three<br>row0 NaN NaN<br>row1 NaN 2.0<br>row2 NaN 5.0<br>row3 NaN 8.0</p><p>In [30]: #同时修改列和行索引</p><p>In [31]: frame4=frame_1.reindex([‘row1’,’row2’,’row3’,’row4’],columns=[‘five’,’three’,’six’])</p><p>In [32]: frame_1<br>Out[32]:<br>one two three<br>row1 0 1 2<br>row2 3 4 5<br>row3 6 7 8</p><p>In [33]: frame4<br>Out[33]:<br>five three six<br>row1 NaN 2.0 NaN<br>row2 NaN 5.0 NaN<br>row3 NaN 8.0 NaN<br>row4 NaN NaN NaN</p><p>利用ix函数修改数据框行索引与列，快捷整洁，节约时间。但是Ix已经几乎被启用，现在用loc函数。<br>In [35]: frame5=frame_1.reindex(columns=[‘one’,’four’,’two’,’three’])</p><p>In [36]: frame5<br>Out[36]:<br>one four two three<br>row1 0 NaN 1 2<br>row2 3 NaN 4 5<br>row3 6 NaN 7 8</p><p>In [40]: frame5[‘four’]=pd.Series([34,56,78],index=[‘row1’,’row2’,’row3’])</p><p>In [41]: frame5<br>Out[41]:<br>one four two three<br>row1 0 34 1 2<br>row2 3 56 4 5<br>row3 6 78 7 8<br>In [42]: frame5.ix[[‘row2’,’row1’,’row3’],[‘one’,’two’,’four’,’three’]]<br>C:\Users\dongfeng\Anaconda3\lib\site-packages\ipykernel_launcher.py:1: DeprecationWarning:<br>.ix is deprecated. Please use<br>.loc for label based indexing or<br>.iloc for positional indexing</p><p>See the documentation here:<br><a href="http://pandas.pydata.org/pandas-docs/stable/indexing.html#ix-indexer-is-deprecated" target="_blank" rel="noopener">http://pandas.pydata.org/pandas-docs/stable/indexing.html#ix-indexer-is-deprecated</a><br>“””Entry point for launching an IPython kernel.<br>Out[42]:<br>one two four three<br>row2 3 4 56 5<br>row1 0 1 34 2<br>row3 6 7 78 8</p><p>#现在用loc的比较多，ix已经不再推荐使用。</p><p>In [44]: frame5.loc[[‘row2’,’row1’,’row3’],[‘one’,’two’,’four’,’three’]]<br>Out[44]:<br>one two four three<br>row2 3 4 56 5<br>row1 0 1 34 2<br>row3 6 7 78 8</p><p>指定轴上项目的丢弃：</p><p>Drop 函数应用到“Series”<br>In [46]: Seriestest_1=pd.Series([233,356,997],index=[‘as’,’a’,’sample’])<br>In [47]: Seriestest_1<br>Out[47]:<br>as 233<br>a 356<br>sample 997<br>dtype: int64</p><p>Seriestest_1.drop(‘a’)<br>Out[95]:<br>as        233<br>sample    997<br>dtype: int64</p><p>In [48]: #drop函数或者说方法返回的是一个在指定轴上删除指定值的新对象</p><p>Drop函数应用到“DataFrame”<br>Drop函数删除指定值时必须指定轴，如果不指定轴，默认零轴。也就是说删除“1”轴上的指定项时必须指定轴号。删除“0”轴上的指定项时不需要指定轴号。<br>In [53]: Dataframe_1_test=pd.DataFrame(np.floor(np.random.randn(4,4)),index=[‘xu’,’liu’,’zhang’,’feng’],columns=[‘stufe’,’klasse’,’degree’,’group’])</p><p>In [54]: Dataframe_1_test<br>Out[54]:<br>stufe klasse degree group<br>xu -1.0 0.0 -1.0 1.0<br>liu 0.0 -2.0 -1.0 -1.0<br>zhang 0.0 -3.0 -2.0 1.0<br>feng -1.0 0.0 -1.0 0.0</p><p>In [57]: Dataframe_1_test.drop([‘stufe’,’klasse’],axis=1)<br>Out[57]:<br>degree group<br>xu -1.0 1.0<br>liu -1.0 -1.0<br>zhang -2.0 1.0<br>feng -1.0 0.0</p><p>In [59]: Dataframe_1_test.drop([‘xu’,’feng’])<br>Out[59]:<br>stufe klasse degree group<br>liu 0.0 -2.0 -1.0 -1.0<br>zhang 0.0 -3.0 -2.0 1.0</p><p>In [60]: Dataframe_1_test.drop([‘liu’])<br>Out[60]:<br>stufe klasse degree group<br>xu -1.0 0.0 -1.0 1.0<br>zhang 0.0 -3.0 -2.0 1.0<br>feng -1.0 0.0 -1.0 0.0</p><p>索引与选取</p><p>Series的索引和字典没有太大不同,唯一的区别是Series不仅可以通过设置的索引进行检索，也可以用默认的索引进行检索。另外Series也可以做切片，下面我们先看几个例子：<br>In [6]: Testser_1=pd.Series([23,43,789,674,90,65],index=[‘apple’,’pear’,’persimmon’,’watermelon’,’strawberry’,’orange’])</p><p>In [7]: Testser_1<br>Out[7]:<br>apple 23<br>pear 43<br>persimmon 789<br>watermelon 674<br>strawberry 90<br>orange 65<br>dtype: int64</p><p>#按默认索引检索<br>In [9]: Testser_1[2:4]<br>Out[9]:<br>persimmon 789<br>watermelon 674<br>dtype: int64</p><p>#按给定索引检索<br>In [25]: Testser_1[‘apple’:’watermelon’]<br>Out[25]:<br>apple 23<br>pear 43<br>persimmon 789<br>watermelon 674<br>dtype: int64</p><p>#注意，按给定标签（也叫索引）检索切片末端不会减一末端是被包含的，这就是说末端是封闭区间。（是’]’，不是‘）’）<br>In [26]: Testser_1[[‘apple’,’watermelon’]]<br>Out[26]:<br>apple 23<br>watermelon 674<br>dtype: int64</p><p>#注意上面两个例子的区别</p><p>#也可单个索引，按默认和按给定索引（也叫标签）均可检索<br>In [27]: Testser_1[‘apple’]<br>Out[27]: 23</p><p>In [28]: Testser_1[0]<br>Out[28]: 23</p><p>#也可以按照bool值进行索引，此时检索不再按照给定的默认索引，而是与Series中的数据进行比较。</p><p>In [30]: Testser_1[Testser_1&gt;100]<br>Out[30]:<br>persimmon 789<br>watermelon 674<br>dtype: int64</p><p>给Series赋值：<br>In [31]: Testser_1[‘apple’:’watermelon’]=[112,22,32,42]</p><p>In [32]: Testser_1<br>Out[32]:<br>apple 112<br>pear 22<br>persimmon 32<br>watermelon 42<br>strawberry 90<br>orange 65<br>dtype: int64<br>In [34]: Testser_1[‘apple’:’watermelon’]=56</p><p>In [35]: Testser_1<br>Out[35]:<br>apple 56<br>pear 56<br>persimmon 56<br>watermelon 56<br>strawberry 90<br>orange 65<br>dtype: int64<br>例子：<br>In [37]: Testser_1[[2,3]]=34</p><p>In [38]: Testser_1<br>Out[38]:<br>apple 56<br>pear 56<br>persimmon 34<br>watermelon 34<br>strawberry 90<br>orange 65<br>dtype: int64</p><p>In [39]: Testser_1[‘apple’]=34</p><p>In [40]: Testser_1<br>Out[40]:<br>apple 34<br>pear 56<br>persimmon 34<br>watermelon 34<br>strawberry 90<br>orange 65<br>dtype: int64</p><p>DataFrame的索引</p><p>In [5]: Data=pd.DataFrame(np.arange(16).reshape(4,4),index=(‘one’,’two’,’three’,’four’),columns=(‘wir’,’sie’,’ihr’,’ich’))</p><p>In [6]: Data<br>Out[6]:<br>wir sie ihr ich<br>one 0 1 2 3<br>two 4 5 6 7<br>three 8 9 10 11<br>four 12 13 14 15</p><p>In [7]: Data[‘wir’]<br>Out[7]:<br>one 0<br>two 4<br>three 8<br>four 12<br>Name: wir, dtype: int32</p><p>#单个索引时只能索引列，因此用“bool”值来检索时只能先检索出列数据，然后再与设定值比较，得出bool值Series，见下例：<br>In [22]: Data[Data[‘ihr’]&gt;6]<br>Out[22]:<br>wir sie ihr ich<br>three 8 9 10 11<br>four 12 13 14 15</p><p>Bool Series是可以当做索引的，见下<br>Data[pd.Series([True,False,True,False],index=[‘one’,’two’,’three’,’four’])]<br>Out[44]:<br>       wir  sie  ihr  ich<br>one      0    1    2    3<br>three    8    9   10   11<br>但这种索引容易出错，往往结果与我们的目的不一致，比如：<br>ata=pd.DataFrame([[1,2,3,4],[0,4,8,2],[0.3,0.6,2.3,4],[3,8,9,0]],index=(‘one’,’two’,’three’,’four’),columns=(‘wir’,’sie’,’ihr’,’ich’))</p><p>ata<br>Out[54]:<br>       wir  sie  ihr  ich<br>one    1.0  2.0  3.0    4<br>two    0.0  4.0  8.0    2<br>three  0.3  0.6  2.3    4<br>four   3.0  8.0  9.0    0</p><p>ata[ata[‘ihr’]&gt;3]<br>Out[55]:<br>      wir  sie  ihr  ich<br>two   0.0  4.0  8.0    2<br>four  3.0  8.0  9.0    0</p><p>我们想选出大于‘3’，而结果并非如此。</p><p>In [8]: Data[[‘wir’,’ihr’]]<br>Out[8]:<br>wir ihr<br>one 0 2<br>two 4 6<br>three 8 10<br>four 12 14<br>In [13]: #DataFrame 切片只能依靠行索引</p><p>In [16]: Data[‘one’:’three’]<br>Out[16]:<br>wir sie ihr ich<br>one 0 1 2 3<br>two 4 5 6 7<br>three 8 9 10 11</p><p>In [17]: Data[1:3]<br>Out[17]:<br>wir sie ihr ich<br>two 4 5 6 7<br>three 8 9 10 11</p><p>bool值索引：<br>In [23]: Data&gt;8<br>Out[23]:<br>wir sie ihr ich<br>one False False False False<br>two False False False False<br>three False True True True<br>four True True True True<br>In [25]: Data[Data&gt;8]=0</p><p>In [26]: Data<br>Out[26]:<br>wir sie ihr ich<br>one 0 1 2 3<br>two 4 5 6 7<br>three 8 0 0 0<br>four 0 0 0 0<br>上面我们已经讲过单个索引时我们只能索引列，为了解决这个问题numpy创造了ix方法。但是ix函数或许太老了，目前已经有新的函数loc来替代它。通过这个函数你几乎可以为所欲为。loc函数只能用给定行列索引进行检索</p><p>In [31]: Data.loc[‘two’]<br>Out[31]:<br>wir 4<br>sie 5<br>ihr 6<br>ich 7<br>Name: two, dtype: int32<br>In [33]: Data.loc[‘four’,’wir’:’ihr’]<br>Out[33]:<br>wir 12<br>sie 13<br>ihr 14<br>Name: four, dtype: int32</p><p>In [34]: Data.loc[‘four’,[‘wir’,’ihr’]]<br>Out[34]:<br>wir 12<br>ihr 14<br>Name: four, dtype: int32</p><p>Data.loc[[‘one’,’four’],[‘wir’,’ich’]]<br>Out[136]:<br>      wir  ich<br>one     0    3<br>four   12   15</p><p>In [35]: Data.loc[‘one’:’three’,’ich’]<br>Out[35]:<br>one 3<br>two 7<br>three 11<br>Name: ich, dtype: int32<br>In [38]: Data.loc[‘one’:,’wir’]<br>Out[38]:<br>one 0<br>two 4<br>three 8<br>four 12<br>Name: wir, dtype: int32</p><p>bool值索引<br>In [45]: Data.loc[Data.wir&gt;5,:’ich’]<br>Out[45]:<br>wir sie ihr ich<br>three 8 9 10 11<br>four 12 13 14 15</p><p>Reindex 方法：</p><p>In [50]: Data<br>Out[50]:<br>wir sie ihr ich<br>one 0 1 2 3<br>two 4 5 6 7<br>three 8 9 10 11<br>four 12 13 14 15</p><p>In [51]: Data.reindex(index=[‘one’,’three’,’four’,’two’])<br>Out[51]:<br>wir sie ihr ich<br>one 0 1 2 3<br>three 8 9 10 11<br>four 12 13 14 15<br>two 4 5 6 7</p><p>In [52]: Data.reindex(columns=[‘wir’,’ihr’,’sie’,’ich’])<br>Out[52]:<br>wir ihr sie ich<br>one 0 2 1 3<br>two 4 6 5 7<br>three 8 10 9 11<br>four 12 14 13 15</p><p>Xs方法：根据标签选取单行和单列，返回‘Series’</p><p>In [66]: Data.xs(‘one’)<br>Out[66]:<br>wir 0<br>sie 1<br>ihr 2<br>ich 3<br>Name: one, dtype: int32</p><p>In [69]: Data.xs(‘sie’,axis=1)<br>Out[69]:<br>one 1<br>two 5<br>three 9<br>four 13<br>Name: sie, dtype: int32</p><p>Get_value 方法得到数据框内单个值：</p><p>Data.get_value(‘three’,’ihr’)<br>Out[72]: 10</p><p>简单的算数运算和数据对齐</p><p>加法<br>Series数据相加必须按照索引一一相加，如果索引不能配对，将返回空值。<br>In [1]: import numpy as np</p><p>In [2]: import pandas as pd</p><p>In [3]: Se1=pd.Series([2.3,78,2.5,3.8],index=[‘as’,’a’,’pupil’,’and’])</p><p>In [4]: Se2=pd.Series([2,7.7,2.1,3.3,9,12],index=[‘as’,’a’,’studen’,’teacher’,’and’,’or’])<br>In [6]: tesseq_1=Se1+Se2</p><p>In [7]: tesseq_1<br>Out[7]:<br>a 85.7<br>and 12.8<br>as 4.3<br>or NaN<br>pupil NaN<br>studen NaN<br>teacher NaN<br>dtype: float64<br>与Series相同，DataFrame数据相加必须按照行索引和列一一相加，如果索引和列不能配对（也就是两个数据的行列标签不相等时），将返回空值。（先行索引匹配，然后在进行列匹配）<br>In [22]: add1=pd.DataFrame(np.arange(9).reshape(3,3),index=[‘ein’,’zwei’,’drei’],columns=list(‘bde’))</p><p>In [23]: add2=pd.DataFrame(np.arange(12).reshape(4,3),index=[‘zwei’,’sechs’,’drei’,’seven’],columns=list(‘bef’))<br>In [26]: add1<br>Out[26]:<br>b d e<br>ein 0 1 2<br>zwei 3 4 5<br>drei 6 7 8</p><p>In [27]: add2<br>Out[27]:<br>b e f<br>zwei 0 1 2<br>sechs 3 4 5<br>drei 6 7 8<br>seven 9 10 11</p><p>In [24]: Test_add=add1+add2</p><p>In [25]: Test_add<br>Out[25]:<br>b d e f<br>drei 12.0 NaN 15.0 NaN<br>ein NaN NaN NaN NaN<br>sechs NaN NaN NaN NaN<br>seven NaN NaN NaN NaN<br>zwei 3.0 NaN 6.0 NaN<br>这里我们发现如果我们没有把两个数据框的行标签和列完全一一对应或者说一一相等的话，就会出现很多空值。空值的重新赋值比较麻烦，所以尽量不要出现这种情况。<br>接下来我们尝试给这个数据框赋值。也就是说消除空值.</p><p>首先我们根据数据缺失的实际状况构造出一个新的数据框：</p><p>In [9]: Newframe=pd.DataFrame(np.array([[2,45,11,30],[-34,45,89,63],[44,90,36,27]]),index=[‘ein’,’sechs’,’seven’],columns=[‘b’,’d’,’e’,’f’])<br>In [10]: Test_add.add(Newframe,fill_value=0)<br>Out[10]:<br>b d e f<br>drei 12.0 NaN 15.0 NaN<br>ein 2.0 45.0 11.0 30.0<br>sechs -34.0 45.0 89.0 63.0<br>seven 44.0 90.0 36.0 27.0<br>zwei 3.0 NaN 6.0 NaN</p><p>In [12]: Diframe=Test_add.add(Newframe,fill_value=0)</p><p>In [13]: Diframe<br>Out[13]:<br>b d e f<br>drei 12.0 NaN 15.0 NaN<br>ein 2.0 45.0 11.0 30.0<br>sechs -34.0 45.0 89.0 63.0<br>seven 44.0 90.0 36.0 27.0<br>zwei 3.0 NaN 6.0 NaN<br>In [26]: Diframe.loc[‘drei’,’d’]=36<br>In [28]: Diframe.loc[‘zwei’,’d’]=0</p><p>In [29]: Diframe.loc[‘drei’,’f’]=0</p><p>In [30]: Diframe.loc[‘zwei’,’f’]=0</p><p>In [31]: Diframe<br>Out[31]:<br>b d e f<br>drei 12.0 36.0 15.0 0.0<br>ein 2.0 45.0 11.0 30.0<br>sechs -34.0 45.0 89.0 63.0<br>seven 44.0 90.0 36.0 27.0<br>zwei 3.0 0.0 6.0 0.0</p><p>减法乘法和除法<br>In [32]: S1=pd.Series([3,6,9])<br>In [34]: S2=pd.Series([4,3.2,3])<br>S3=S1-S2</p><p>S3<br>Out[38]:<br>0   -1.0<br>1    2.8<br>2    6.0<br>dtype: float64</p><p>S4=S1*S2</p><p>S4<br>Out[40]:<br>0    12.0<br>1    19.2<br>2    27.0<br>dtype: float64</p><p>S5=S1/S2</p><p>S5<br>Out[42]:<br>0    0.750<br>1    1.875<br>2    3.000<br>dtype: float64</p><p>In [43]: Frame1=pd.DataFrame([[2,2,1],[1,1,3],[0,2,3]],index=[‘Nr1’,’Nr2’,’Nr3’],columns=[‘mon’,’tue’,’wen’])</p><p>In [44]: Frame2=pd.DataFrame([[1,3,1],[0,1,2],[2,0,1]],index=[‘Nr1’,’Nr2’,’Nr3’],columns=[‘mon’,’tue’,’wen’])</p><p>In [45]: Frame3=Frame1-Frame2</p><p>In [46]: Frame3<br>Out[46]:<br>mon tue wen<br>Nr1 1 -1 0<br>Nr2 1 0 1<br>Nr3 -2 2 2</p><p>In [47]: Frame4=Frame1*Frame2</p><p>In [48]: Frame4<br>Out[48]:<br>mon tue wen<br>Nr1 2 6 1<br>Nr2 0 1 6<br>Nr3 0 0 3</p><p>In [49]: Frame5=Frame1/Frame2</p><p>In [50]: Frame5<br>Out[50]:<br>mon tue wen<br>Nr1 2.000000 0.666667 1.0<br>Nr2 inf 1.000000 1.5<br>Nr3 0.000000 inf 3.0</p><p>DataFrame 和 Series之间运算</p><p>数据框与Serie是之间的加减运算分为沿行和沿列运算的。</p><p>匹配列索引，沿行运算</p><p>In [1]: import numpy as np</p><p>In [2]: import pandas as pd</p><p>In [3]: Frame1=pd.DataFrame([[2,2,1],[1,1,3],[0,2,3]],index=[‘Nr1’,’Nr2’,’Nr3’],columns=[‘mon’,’tue’,’wen’])</p><p>In [4]: Frame1<br>Out[4]:<br>mon tue wen<br>Nr1 2 2 1<br>Nr2 1 1 3<br>Nr3 0 2 3<br>In [7]: S1=pd.Series([2,2,1],index=[‘mon’,’tue’,’wen’])</p><p>In [8]: Frame1-S1<br>Out[8]:<br>mon tue wen<br>Nr1 0 0 0<br>Nr2 -1 -1 2<br>Nr3 -2 0 2<br>这里我们要注意到数据框沿着行一行行的被Series减去。这种计算方法在Python里被称作广播。</p><p>如果某个索引不出现在在数据框的列索引或Series的索引里就会出现NaN。这对数据分析也是不利的，因此要求我们在设置索引时一定要一一对应。</p><p>In [9]: S1=pd.Series([2,2,1],index=[‘mon’,’wen’,’fri’])</p><p>In [10]: Frame1-S1<br>Out[10]:<br>fri mon tue wen<br>Nr1 NaN 0.0 NaN -1.0<br>Nr2 NaN -1.0 NaN 1.0<br>Nr3 NaN -2.0 NaN 1.0</p><p>匹配行索引，沿列运算(广播）<br>In [11]: S2=pd.Series([2,1,0],index=[‘Nr1’,’Nr2’,’Nr3’])<br>In [15]: Frame1.sub(S2,axis=0)<br>Out[15]:<br>mon tue wen<br>Nr1 0 0 -1<br>Nr2 0 0 2<br>Nr3 0 2 3<br>(乘法和除法可以按照.Multiply 和.devide方法就行求解！！！）</p><p>函数如何应用到数据框</p><p>适合数组的方法与函数，也可应用到pandas的数据结构上。</p><p>In [17]: frame12=pd.DataFrame(np.arange(12).reshape(4,3),index=[‘r1’,’r2’,’r3’,’r4’],columns=[‘c1’,’c2’,’c3’])</p><p>In [18]: frame12<br>Out[18]:<br>c1 c2 c3<br>r1 0 1 2<br>r2 3 4 5<br>r3 6 7 8<br>r4 9 10 11<br>In [20]: frame13=frame12*-1</p><p>In [21]: frame13<br>Out[21]:<br>c1 c2 c3<br>r1 0 -1 -2<br>r2 -3 -4 -5<br>r3 -6 -7 -8<br>r4 -9 -10 -11</p><p>In [22]: np.abs(frame13)<br>Out[22]:<br>c1 c2 c3<br>r1 0 1 2<br>r2 3 4 5<br>r3 6 7 8<br>r4 9 10 11</p><p>In [23]: f=lambda x:x.max()-x.min()</p><p>In [24]: frame12.apply(f)<br>Out[24]:<br>c1 9<br>c2 9<br>c3 9<br>dtype: int64</p><p>In [25]: frame12.apply(f,axis=1)<br>Out[25]:<br>r1 2<br>r2 2<br>r3 2<br>r4 2<br>dtype: int64</p><p>.Min（.max）方法和min（max）函数在计算上没有区别，只是方法有更多的选择性。</p><p>In [26]: frame12.min()<br>Out[26]:<br>c1 0<br>c2 1<br>c3 2<br>dtype: int32</p><p>#不做声明，默认轴为‘0’意思为沿行标签操作</p><p>#更多选择性<br>In [37]: frame12.min(0)<br>Out[37]:<br>c1 0<br>c2 1<br>c3 2<br>dtype: int32</p><p>In [38]: frame12.min(1)<br>Out[38]:<br>r1 0<br>r2 3<br>r3 6<br>r4 9<br>dtype: int32</p><p>In [28]: np.min(frame12)<br>Out[28]:<br>c1 0<br>c2 1<br>c3 2<br>dtype: int32</p><p>Lamda 函数应用：</p><p>In [23]: f=lambda x:x.max()-x.min()</p><p>In [24]: frame12.apply(f)<br>Out[24]:<br>c1 9<br>c2 9<br>c3 9<br>dtype: int64</p><p>In [25]: frame12.apply(f,axis=1)<br>Out[25]:<br>r1 2<br>r2 2<br>r3 2<br>r4 2<br>dtype: int64</p><p>#应用apply方法可以得到更为整齐的结果，试比较例1和例2<br>In [6]: frame11=pd.DataFrame(np.arange(12).reshape(3,4),index=[‘r1’,’r2’,’r3’],columns=[‘c1’,’c2’,’c3’,’c4’])</p><p>In [13]: def table_extrem (x):<br>    …: return pd.Series([x.min(),x.max()],index=[‘min’,’max’])<br>    …: </p><p>例子1：<br>In [14]: table_extrem(frame11)<br>Out[14]:<br>min c1 0<br>c2 1<br>c3 2<br>c4 3<br>dtype: int32<br>max c1 8<br>c2 9<br>c3 10<br>c4 11<br>dtype: int32<br>dtype: object<br>例子2.<br>In [15]: frame11.apply(table_extrem)<br>Out[15]:<br>c1 c2 c3 c4<br>min 0 1 2 3<br>max 8 9 10 11</p><p>DataFrame 的格式化（十分有用）<br>In [16]: frame11=pd.DataFrame(np.random.randn(3,4),index=[‘r1’,’r2’,’r3’],columns=[‘c1’,’c2’,’c3’,’c4’])</p><p>In [17]: frame11<br>Out[17]:<br>c1 c2 c3 c4<br>r1 -2.061714 0.584658 -0.540976 0.090904<br>r2 -0.517271 -0.077818 0.163807 0.418174<br>r3 0.321513 0.769480 2.131075 -0.535560</p><p>In [18]: formatierung=lambda x:’%.2f’ % x</p><p>In [19]: frame11.applymap(formatierung)<br>Out[19]:<br>c1 c2 c3 c4<br>r1 -2.06 0.58 -0.54 0.09<br>r2 -0.52 -0.08 0.16 0.42<br>r3 0.32 0.77 2.13 -0.54</p><p>排序和排名<br>Series 排序：<br>In [118]: import numpy as np</p><p>In [119]: import pandas as pd</p><p>In [120]: project_1=pd.Series(np.arange(1,5),index=[‘a’,’d’,’e’,’f’])</p><p>In [121]: project_1<br>Out[121]:<br>a 1<br>d 2<br>e 3<br>f 4<br>dtype: int32</p><p>In [122]: project_1.sort_index()<br>Out[122]:<br>a 1<br>d 2<br>e 3<br>f 4<br>dtype: int32</p><p>DataFrame 排序：<br>In [124]: DataFrame_12=pd.DataFrame(np.arange(8).reshape(2,4),index=[‘r1’,’r2’],columns=[‘ted’,’lie’,’qiu’,’send’])</p><p>In [125]: DataFrame_12.sort_index()<br>Out[125]:<br>ted lie qiu send<br>r1 0 1 2 3<br>r2 4 5 6 7</p><p>#给行标签排序<br>In [126]: DataFrame_12.sort_index(axis=1)<br>Out[126]:<br>lie qiu send ted<br>r1 1 2 3 0<br>r2 5 6 7 4</p><p>#给列标签排序</p><p>上面的程序行标签和列标签（也叫列索引）都是按升序进行排列。我们也可以按降序排列数据框。</p><p>In [7]: DataFrame_12.sort_index(axis=1,ascending=False)<br>Out[7]:<br>ted send qiu lie<br>r1 0 3 2 1<br>r2 4 7 6 5</p><p>我们上面都是按标签（索引）进行排序，其实我们还可以用sort_values方法对Series按值进行排序：<br>In [15]: Test_series_1=pd.Series([3,6,2,9,1,0],index=[‘r1’,’r2’,’r3’,’r4’,’r5’,’r6’])</p><p>In [16]: Test_series_1<br>Out[16]:<br>r1 3<br>r2 6<br>r3 2<br>r4 9<br>r5 1<br>r6 0<br>dtype: int64</p><p>In [17]: Test_series_1.sort_values()<br>Out[17]:<br>r6 0<br>r5 1<br>r3 2<br>r1 3<br>r2 6<br>r4 9<br>dtype: int64</p><p>我们也可以对DataFrame进行按值排序 </p><p>In [18]: Dataffdic=pd.DataFrame({‘liu’:[-1,0,2,-3],’wang’:[3,2,-5,7],’jiang’:[1,0,1,5]})</p><p>In [19]: Dataffdic<br>Out[19]:<br>jiang liu wang<br>0 1 -1 3<br>1 0 0 2<br>2 1 2 -5<br>3 5 -3 7</p><p>In [20]: Dataffdic.sort_index(by=’liu’)#对’liu’列进行排序<br>C:\Users\dongfeng\Anaconda3\lib\site-packages\ipykernel_launcher.py:1: FutureWarning: by argument to sort_index is deprecated, pls use .sort_values(by=…)<br>“””Entry point for launching an IPython kernel.<br>Out[20]:<br>jiang liu wang<br>3 5 -3 7<br>0 1 -1 3<br>1 0 0 2<br>2 1 2 -5</p><p>In [21]: #目前sort_index方法对数据框某列的值进行排序已经落后，现在用新的方法sort_values 对列值进行排序。</p><p>In [22]: Dataffdic.sort_values(by=’liu’)<br>Out[22]:<br>jiang liu wang<br>3 5 -3 7<br>0 1 -1 3<br>1 0 0 2<br>2 1 2 -5</p><p>#由于按‘liu’列进行排序，所以我们看到‘liu’列的数值排序是正确的。由于排序是整行移动，所以在对‘liu’列进行排序时，‘jiang’列和‘wang’列数值顺序一定会随其变得杂乱无章。</p><p>下面我们讲讲排名，排名和排序从结果上讲是完全不同的，排序是把一个没有顺序的标签或数据按照符号的自然排序规则（比如如果升序排列字符串“as”在顺序排位上应该在“at”之前）或者数值的太小进行排列。排名是通过打破数据的平级关系，从而产生一种有级别差的顺序。通俗的解释。一组没有排名的数据他们在级别上等级的，然后我们通过某种运算规则，使每个数据变成一个名次数值。</p><p>另外，排序可以对数据值本身和标签进行操作。而排名通常对数据本身操作。</p><p>In [1]: import numpy as np </p><p>In [2]: import pandas as pd</p><p>In [3]: Series_1=pd.Series(np.array([3,8,34,33]),index=[‘r1’,’r2’,’r3’,’r4’])</p><p>In [4]: Frame_1=pd.DataFrame(np.array([[3,2,5,0],[7,4,12,13],[1,0,1,-3],[3,6,2,0]]),index=[‘r1’,’r2’,’r3’,’r4’],columns=[‘a’,’b’,’c’,’d’])</p><p>Series排名的四种方法<br>1.‘average’法<br>In [6]: Series_1.rank(method=’average’)<br>Out[6]:<br>r1 1.0<br>r2 2.0<br>r3 4.0<br>r4 3.0<br>dtype: float64</p><p>2.‘min’法<br>In [8]: Series_1.rank(method=’min’)<br>Out[8]:<br>r1 1.0<br>r2 2.0<br>r3 4.0<br>r4 3.0<br>dtype: float64</p><p>3.‘max’法<br>In [7]: Series_1.rank(method=’max’)<br>Out[7]:<br>r1 1.0<br>r2 2.0<br>r3 4.0<br>r4 3.0<br>dtype: float64</p><p>4.‘first’法<br>In [9]: Series_1.rank(method=’first’)<br>Out[9]:<br>r1 1.0<br>r2 2.0<br>r3 4.0<br>r4 3.0<br>dtype: float64<br>上面所有的方法都是产生升序排名的结果，他们也可以产生降序的效果，如果我们填加“ascending”方法。</p><p>Series_1.rank(ascending=False, method=’first’)<br>Out[19]:<br>r1    4.0<br>r2    3.0<br>r3    1.0<br>r4    2.0<br>dtype: float64</p><p>DataFrame的排名<br>在Series排名上，我们没有发现这四种方法的区别，他们一定有区别，只是我们这个Series的排名结果就是这样，没有显现出区别。我们下面通过DataFrame来区别这四种方法。</p><p>In [14]: Frame_1.rank(method=’first’)<br>Out[14]:<br>a b c d<br>r1 2.0 2.0 3.0 2.0<br>r2 4.0 3.0 4.0 4.0<br>r3 1.0 1.0 1.0 1.0<br>r4 3.0 4.0 2.0 3.0</p><p>In [15]: Frame_1.rank(method=’average’)<br>Out[15]:<br>a b c d<br>r1 2.5 2.0 3.0 2.5<br>r2 4.0 3.0 4.0 4.0<br>r3 1.0 1.0 1.0 1.0<br>r4 2.5 4.0 2.0 2.5</p><p>In [16]: Frame_1.rank(method=’min’)<br>Out[16]:<br>a b c d<br>r1 2.0 2.0 3.0 2.0<br>r2 4.0 3.0 4.0 4.0<br>r3 1.0 1.0 1.0 1.0<br>r4 2.0 4.0 2.0 2.0</p><p>In [17]: Frame_1.rank(method=’max’)<br>Out[17]:<br>a b c d<br>r1 3.0 2.0 3.0 3.0<br>r2 4.0 3.0 4.0 4.0<br>r3 1.0 1.0 1.0 1.0<br>r4 3.0 4.0 2.0 3.0</p><p>我们发现这四种排名的方式是不一样的，尽管是不一样的，但是排名这个目的都十分正确的实现了。仅仅是穿了不同外壳。</p><p>上面都是逐行排名，实际上我们还可以逐列排名。</p><p>In [20]: Frame_1.rank(axis=1,method=’max’)<br>Out[20]:<br>a b c d<br>r1 3.0 2.0 4.0 1.0<br>r2 2.0 1.0 3.0 4.0<br>r3 4.0 2.0 4.0 1.0<br>r4 3.0 4.0 2.0 1.0</p><p>In [21]: Frame_1.rank(axis=1,method=’first’)<br>Out[21]:<br>a b c d<br>r1 3.0 2.0 4.0 1.0<br>r2 2.0 1.0 3.0 4.0<br>r3 3.0 2.0 4.0 1.0<br>r4 3.0 4.0 2.0 1.0</p><p>上面就是逐列排名。个人认为‘first’法排名最为规整，且符合我们的习惯思维。</p><p>名词解释：<br>逐列排名（或排序）实际上对一行数据进行排名。<br>逐行排名（或排序）实际上对一列数据进行排名。<br>计算机默认逐行排名。</p><p>带有重复值的轴索引</p><p>对于数据框来说，轴索引就是指的行标签（或者叫行索引）或列标签（或者叫列索引），也就是我们Excel里的行表头和列表头。如下图</p><p>很多时候我们要求轴索引是唯一的，但这个要求并不是强制性的，很多时候它可<br>以重复，重复的轴索引对我们数据分析人员来说，不见得是坏事。</p><p>例子:<br>In [1]: import numpy as np</p><p>In [2]: import pandas as pd</p><p>In [3]: framne_repeat=pd.DataFrame(np.arange(16).reshape(4,4),index=[‘r1’,’r2’,’r3’,’r1’],columns=[‘a’,’b’,’b’,’c’])</p><p>In [4]: framne_repeat<br>Out[4]:<br>a b b c<br>r1 0 1 2 3<br>r2 4 5 6 7<br>r3 8 9 10 11<br>r1 12 13 14 15</p><p>In [5]: framne_repeat[‘b’]<br>Out[5]:<br>b b<br>r1 1 2<br>r2 5 6<br>r3 9 10<br>r1 13 14<br>In [8]: framne_repeat.loc[‘r1’]<br>Out[8]:<br>a b b c<br>r1 0 1 2 3<br>r1 12 13 14 15</p><p>In [12]: framne_repeat.loc[(‘r1’)]<br>Out[12]:<br>a b b c<br>r1 0 1 2 3<br>r1 12 13 14 15<br>上面两个例子可以看出framne_repeat.loc[‘r1’]和framne_repeat.loc[(‘r1’)]运行结果是一样的。也就是说加不加括号都无所谓。</p><p>带有重复轴索引的Series<br>In [7]: testserie_1=pd.Series(np.array([1,2,3,9,10,3]),index=[‘a’,’b’,’a’,’d’,’e’,’a’])</p><p>In [8]: testserie_1<br>Out[8]:<br>a 1<br>b 2<br>a 3<br>d 9<br>e 10<br>a 3<br>dtype: int32</p><p>In [9]: testserie_1[‘a’]<br>Out[9]:<br>a 1<br>a 3<br>a 3<br>dtype: int32</p><p>可以通过is_unique 函数来判断是否存在重复轴索引。</p><p>In [1]: import pandas as pd</p><p>In [2]: import numpy as np</p><p>In [3]: testserie_1=pd.Series(np.array([1,2,3,9,10,3]),index=[‘a’,’b’,’a’,’d’,’e’,’a’])</p><p>In [4]: testserie_1.is_unique<br>Out[4]: False</p><p>In [5]: #False值说明有重复轴索引</p><p>In [6]: #如果对没有重复值的索引进行索引时，返回一个标量。</p><p>In [7]: testserie_1[‘b’]<br>Out[7]: 2</p><p>Serie 和 Dataframe 的计算</p><p>dataFrame_1=pd.DataFrame([range(4),[np.nan,2,3.6,0.9],[1.2,4,6,7],[3.4,7.9,0.4,8]],index=[‘r1’,’r2’,’r3’,’r4’],columns=[‘c1’,’c2’,’c3’,’c4’])<br>dataFrame_1<br>Out[9]:<br>     c1   c2   c3   c4<br>r1  0.0  1.0  2.0  3.0<br>r2  NaN  2.0  3.6  0.9<br>r3  1.2  4.0  6.0  7.0<br>r4  3.4  7.9  0.4  8.0<br>dataFrame_1.sum()<br>Out[12]:<br>c1     4.6<br>c2    14.9<br>c3    12.0<br>c4    18.9<br>dtype: float64</p><p>dataFrame_1.sum(1)<br>Out[13]:<br>r1     6.0<br>r2     6.5<br>r3    18.2<br>r4    19.7<br>dtype: float64</p><p>只要不是整行都是NaN值，python自动排除NAN值然后进行计算。通过skipna可以禁止该功能。</p><p>dataFrame_1.sum(axis=1,skipna=False)<br>Out[22]:<br>r1     6.0<br>r2     NaN<br>r3    18.2<br>r4    19.7<br>dtype: float64</p><p>dataFrame_1.idxmax()<br>Out[23]:<br>c1    r4<br>c2    r4<br>c3    r3<br>c4    r4<br>dtype: object</p><p>#求出每列最大值<br>dataFrame_1.idxmax(1)<br>Out[7]:<br>r1    c4<br>r2    c3<br>r3    c4<br>r4    c4<br>dtype: object</p><p>#求出每行最大值<br>dataFrame_1.idxmin(1)<br>Out[9]:<br>r1    c1<br>r2    c4<br>r3    c1<br>r4    c3<br>dtype: object<br>求出每行最小值，空值不参与比较。</p><p>dataFrame_1.idxmin(axis=1,skipna=False)<br>Out[10]:<br>r1     c1<br>r2    NaN<br>r3     c1<br>r4     c3<br>dtype: object</p><p>#修改skipna的默认值”True”,可以修改NaN值自动忽略功能。</p><p>#累计加</p><p>按列累计加，遇到NaN值自动忽略，不参与运算。<br>dataFrame_1.cumsum()<br>Out[8]:<br>     c1    c2    c3    c4<br>r1  0.0   1.0   2.0   3.0<br>r2  NaN   3.0   5.6   3.9<br>r3  1.2   7.0  11.6  10.9<br>r4  4.6  14.9  12.0  18.9</p><p>dataFrame_1.cumsum(1)<br>Out[10]:<br>     c1    c2    c3    c4<br>r1  0.0   1.0   3.0   6.0<br>r2  NaN   2.0   5.6   6.5<br>r3  1.2   5.2  11.2  18.2<br>r4  3.4  11.3  11.7  19.7</p><p>dataFrame_1.describe()<br>Out[12]:<br>             c1     c2        c3       c4<br>count  3.000000  4.000  4.000000  4.00000<br>mean   1.533333  3.725  3.000000  4.72500<br>std    1.724336  3.050  2.388863  3.34203<br>min    0.000000  1.000  0.400000  0.90000<br>25%    0.600000  1.750  1.600000  2.47500<br>50%    1.200000  3.000  2.800000  5.00000<br>75%    2.300000  4.975  4.200000  7.25000<br>max    3.400000  7.900  6.000000  8.00000</p><p>#上面的分位数我们后面会有介绍</p><p>去重，值计数以及值资格判断</p><p>series_3=pd.Series([‘c’,’d’,’we’,’a’,’c’,’d’,’e’,’f’,’we’])<br>series_3.unique()<br>Out[25]: array([‘c’, ‘d’, ‘we’, ‘a’, ‘e’, ‘f’], dtype=object)</p><p>#通过uique方法的调用，我们立即可以去除Series中的重复的项目<br>serie_unique=series_3.unique()<br>serie_unique.sort()<br>serie_unique<br>Out[40]: array([‘a’, ‘c’, ‘d’, ‘e’, ‘f’, ‘we’], dtype=object)</p><p>#通常去重后要进行排序</p><p>通过value_counts()方法对Series中的值进行计数<br>series_3.value_counts()<br>Out[43]:<br>we    2<br>c     2<br>d     2<br>a     1<br>f     1<br>e     1<br>dtype: int64</p><p>我们可以通过这种方法求出指定元素出现的次数。</p><p>serie_nr=series_3.value_counts()<br>serie_nr[‘we’]<br>Out[46]: 2</p><p>上面我们看到都是value_counts()作为方法在应用，其实它也可以作为函数（或者叫Pandas的方法）单独应用。</p><p>pd.value_counts(series_3.values)<br>Out[47]:<br>we    2<br>c     2<br>d     2<br>a     1<br>f     1<br>e     1<br>dtype: int64<br>也可以不把计算内容做降序处理：<br>pd.value_counts(series_3.values,sort=False)<br>Out[49]:<br>e     1<br>d     2<br>f     1<br>a     1<br>c     2<br>we    2<br>dtype: int64</p><p>value_counts()作为单独函数使用时，是一种超级牛的函数，他可以使用到任何序列和数组。</p><p>看下面例子：</p><p>list_1=[1,3,4,5,2,6,8,4,3,8,9]</p><p>pd.value_counts(list_1)<br>Out[51]:<br>8    2<br>4    2<br>3    2<br>9    1<br>6    1<br>5    1<br>2    1<br>1    1<br>dtype: int64</p><p>tuple_1=1,2,4,3,2,5,6,3,9</p><p>pd.value_counts(tuple_1)<br>Out[54]:<br>3    2<br>2    2<br>9    1<br>6    1<br>5    1<br>4    1<br>1    1<br>dtype: int64</p><p>array_1=[1,2,3,4,52,3,2]</p><p>pd.value_counts(array_1)<br>Out[56]:<br>3     2<br>2     2<br>4     1<br>1     1<br>52    1<br>dtype: int64<br>series_3<br>Out[60]:<br>0     c<br>1     d<br>2    we<br>3     a<br>4     c<br>5     d<br>6     e<br>7     f<br>8    we<br>dtype: object</p><p>series_3.isin([‘a’,’c’])<br>Out[61]:<br>0     True<br>1    False<br>2    False<br>3     True<br>4     True<br>5    False<br>6    False<br>7    False<br>8    False<br>dtype: bool</p><p>series_3.isin([‘a’])<br>Out[63]:<br>0    False<br>1    False<br>2    False<br>3     True<br>4    False<br>5    False<br>6    False<br>7    False<br>8    False<br>dtype: bool</p><p>#这是一个布尔Series，我们可以把他作为角码选出我们指定值在Series里的所有信息。<br>boolmatrix_2=series_3.isin([‘a’,’c’])</p><p>series_3[boolmatrix_2]<br>Out[68]:<br>0    c<br>3    a<br>4    c<br>dtype: object</p><p>我们也可以把value_counts()用到数据框，会得到一个你预料不到的结果。尽管这个结果很奇怪，但他却是巧妙的导出频数分布图。<br>dataFrame_1<br>Out[69]:<br>     c1   c2   c3   c4<br>r1  0.0  1.0  2.0  3.0<br>r2  NaN  2.0  3.6  0.9<br>r3  1.2  4.0  6.0  7.0<br>r4  3.4  7.9  0.4  8.0</p><p>dataFrame_1.fillna(0)<br>Out[71]:<br>     c1   c2   c3   c4<br>r1  0.0  1.0  2.0  3.0<br>r2  0.0  2.0  3.6  0.9<br>r3  1.2  4.0  6.0  7.0<br>r4  3.4  7.9  0.4  8.0</p><p>dataFrame_2=dataFrame_1.fillna(0)</p><p>result=dataFrame_2.apply(pd.value_counts).fillna(0)</p><p>result<br>Out[74]:<br>      c1   c2   c3   c4<br>0.0  2.0  0.0  0.0  0.0<br>0.4  0.0  0.0  1.0  0.0<br>0.9  0.0  0.0  0.0  1.0<br>1.0  0.0  1.0  0.0  0.0<br>1.2  1.0  0.0  0.0  0.0<br>2.0  0.0  1.0  1.0  0.0<br>3.0  0.0  0.0  0.0  1.0<br>3.4  1.0  0.0  0.0  0.0<br>3.6  0.0  0.0  1.0  0.0<br>4.0  0.0  1.0  0.0  0.0<br>6.0  0.0  0.0  1.0  0.0<br>7.0  0.0  0.0  0.0  1.0<br>7.9  0.0  1.0  0.0  0.0<br>8.0  0.0  0.0  0.0  1.0</p><p>NAN数据处理，</p><p>在数据处理工作中，我们经常遇到缺失数据，它们的处理往往很费时间。Pandas设计之初，就已经考虑到这种情况。可以说，快速轻松地处理缺失数据是pandas最大优点之一。</p><p>#NaN值和None值都可以被当做空值处理：<br>series_1=pd.Series([1,np.nan,3,None,2.3,6])</p><p>series_1<br>Out[5]:<br>0    1.0<br>1    NaN<br>2    3.0<br>3    NaN<br>4    2.3<br>5    6.0<br>dtype: float64</p><p>缺失值得快速补充法</p><p>frame_123=pd.DataFrame([[1,np.nan,np.nan,2,3],[1,2,3,None,8],[6,2.3,8,None,3],[2,3,2,3,2],[3.2,8.9,3,4.5,3],[2,3,0.45,None,8]])</p><p>frame_123<br>Out[8]:<br>     0    1     2    3  4<br>0  1.0  NaN   NaN  2.0  3<br>1  1.0  2.0  3.00  NaN  8<br>2  6.0  2.3  8.00  NaN  3<br>3  2.0  3.0  2.00  3.0  2<br>4  3.2  8.9  3.00  4.5  3<br>5  2.0  3.0  0.45  NaN  8</p><p>pd.isnull(frame_123)<br>Out[9]:<br>       0      1      2      3      4<br>0  False   True   True  False  False<br>1  False  False  False   True  False<br>2  False  False  False   True  False<br>3  False  False  False  False  False<br>4  False  False  False  False  False<br>5  False  False  False   True  False</p><p>boolmatrix_1=pd.isnull(frame_123)<br>frame_123[boolmatrix_1]=0<br>frame_123<br>Out[13]:<br>     0    1     2    3  4<br>0  1.0  0.0  0.00  2.0  3<br>1  1.0  2.0  3.00  0.0  8<br>2  6.0  2.3  8.00  0.0  3<br>3  2.0  3.0  2.00  3.0  2<br>4  3.2  8.9  3.00  4.5  3<br>5  2.0  3.0  0.45  0.0  8</p><p>Dropna过滤NaN数据<br>series_23=pd.Series([1,4,3,np.nan,4.5,None,3.4,4.5,6,np.nan,4,5,3])</p><p>series_23<br>Out[20]:<br>0     1.0<br>1     4.0<br>2     3.0<br>3     NaN<br>4     4.5<br>5     NaN<br>6     3.4<br>7     4.5<br>8     6.0<br>9     NaN<br>10    4.0<br>11    5.0<br>12    3.0<br>dtype: float64</p><p>series_23.dropna()<br>Out[21]:<br>0     1.0<br>1     4.0<br>2     3.0<br>4     4.5<br>6     3.4<br>7     4.5<br>8     6.0<br>10    4.0<br>11    5.0<br>12    3.0<br>dtype: float64</p><p>也可以通过Notnull</p><p>series_23[series_23.notnull()]<br>Out[22]:<br>0     1.0<br>1     4.0<br>2     3.0<br>4     4.5<br>6     3.4<br>7     4.5<br>8     6.0<br>10    4.0<br>11    5.0<br>12    3.0<br>dtype: float64</p><p>Dropna 用于DataFrame和用于Series稍有不同。用于DataFrame，含有NaN值的行会被删去。</p><p>frame_123=pd.DataFrame([[1,np.nan,np.nan,2,3],[1,2,3,None,8],[6,2.3,8,None,3],[2,3,2,3,2],[3.2,8.9,3,4.5,3],[2,3,0.45,None,8]])</p><p>frame_123<br>Out[28]:<br>     0    1     2    3  4<br>0  1.0  NaN   NaN  2.0  3<br>1  1.0  2.0  3.00  NaN  8<br>2  6.0  2.3  8.00  NaN  3<br>3  2.0  3.0  2.00  3.0  2<br>4  3.2  8.9  3.00  4.5  3<br>5  2.0  3.0  0.45  NaN  8</p><p>frame_123.dropna()<br>Out[27]:<br>     0    1    2    3  4<br>3  2.0  3.0  2.0  3.0  2<br>4  3.2  8.9  3.0  4.5  3</p><p>使用how=’all’只会消除全为NaN的行：<br>matrix_2=frame_123.dropna(how=’all’)</p><p>matrix_2<br>Out[32]:<br>     0    1     2    3  4<br>0  1.0  NaN   NaN  2.0  3<br>1  1.0  2.0  3.00  NaN  8<br>2  6.0  2.3  8.00  NaN  3<br>3  2.0  3.0  2.00  3.0  2<br>4  3.2  8.9  3.00  4.5  3<br>5  2.0  3.0  0.45  NaN  8</p><p>列行的添加和丢弃<br>frame_123<br>Out[47]:<br>     0    1     2    3  4<br>0  1.0  NaN   NaN  2.0  3<br>1  1.0  2.0  3.00  NaN  8<br>2  6.0  2.3  8.00  NaN  3<br>3  2.0  3.0  2.00  3.0  2<br>4  3.2  8.9  3.00  4.5  3<br>5  2.0  3.0  0.45  NaN  8</p><p>frame_123[5]=[1,3,56,32,np.nan,0.7]</p><p>frame_123<br>Out[49]:<br>     0    1     2    3  4     5<br>0  1.0  NaN   NaN  2.0  3   1.0<br>1  1.0  2.0  3.00  NaN  8   3.0<br>2  6.0  2.3  8.00  NaN  3  56.0<br>3  2.0  3.0  2.00  3.0  2  32.0<br>4  3.2  8.9  3.00  4.5  3   NaN<br>5  2.0  3.0  0.45  NaN  8   0.7</p><p>#列的添加<br>frame_123<br>Out[47]:<br>     0    1     2    3  4<br>0  1.0  NaN   NaN  2.0  3<br>1  1.0  2.0  3.00  NaN  8<br>2  6.0  2.3  8.00  NaN  3<br>3  2.0  3.0  2.00  3.0  2<br>4  3.2  8.9  3.00  4.5  3<br>5  2.0  3.0  0.45  NaN  8</p><p>frame_123.loc[6,:]=[np.nan,2,2.4,5,6]</p><p>frame_123<br>Out[53]:<br>     0    1     2    3    4<br>0  1.0  NaN   NaN  2.0  3.0<br>1  1.0  2.0  3.00  NaN  8.0<br>2  6.0  2.3  8.00  NaN  3.0<br>3  2.0  3.0  2.00  3.0  2.0<br>4  3.2  8.9  3.00  4.5  3.0<br>5  2.0  3.0  0.45  NaN  8.0<br>6  NaN  2.0  2.40  5.0  6.0</p><p>#行的添加<br>frame_123<br>Out[55]:<br>     0    1     2    3  4<br>0  1.0  NaN   NaN  2.0  3<br>1  1.0  2.0  3.00  NaN  8<br>2  6.0  2.3  8.00  NaN  3<br>3  2.0  3.0  2.00  3.0  2<br>4  3.2  8.9  3.00  4.5  3<br>5  2.0  3.0  0.45  NaN  8</p><p>frame_123[5]=np.nan</p><p>frame_123<br>Out[57]:<br>     0    1     2    3  4   5<br>0  1.0  NaN   NaN  2.0  3 NaN<br>1  1.0  2.0  3.00  NaN  8 NaN<br>2  6.0  2.3  8.00  NaN  3 NaN<br>3  2.0  3.0  2.00  3.0  2 NaN<br>4  3.2  8.9  3.00  4.5  3 NaN<br>5  2.0  3.0  0.45  NaN  8 NaN</p><p>frame_123[5]=np.nan</p><p>frame_123<br>Out[57]:<br>     0    1     2    3  4   5<br>0  1.0  NaN   NaN  2.0  3 NaN<br>1  1.0  2.0  3.00  NaN  8 NaN<br>2  6.0  2.3  8.00  NaN  3 NaN<br>3  2.0  3.0  2.00  3.0  2 NaN<br>4  3.2  8.9  3.00  4.5  3 NaN<br>5  2.0  3.0  0.45  NaN  8 NaN</p><p>frame_123.dropna(axis=1,how=’all’)<br>Out[60]:<br>     0    1     2    3  4<br>0  1.0  NaN   NaN  2.0  3<br>1  1.0  2.0  3.00  NaN  8<br>2  6.0  2.3  8.00  NaN  3<br>3  2.0  3.0  2.00  3.0  2<br>4  3.2  8.9  3.00  4.5  3<br>5  2.0  3.0  0.45  NaN  8</p><p>frame_1=pd.DataFrame(np.random.randn(7,4))</p><p>frame_1<br>Out[65]:<br>          0         1         2         3<br>0 -0.668146  0.034772  0.482339  1.444138<br>1 -1.167959 -0.703595  0.641404 -1.100771<br>2 -1.657068 -2.038607  0.141572  2.525831<br>3 -1.869547 -0.291923  0.275511 -0.459739<br>4 -0.287525 -0.966589  2.145633  0.703735<br>5  0.499207 -0.385792 -1.192131 -1.679805<br>6 -0.529885  2.053872  0.970785 -0.733382</p><p>frame_1.loc[:4,1]=np.nan;frame_1.loc[:2,2]=np.nan</p><p>frame_1<br>Out[67]:<br>          0         1         2         3<br>0 -0.668146       NaN       NaN  1.444138<br>1 -1.167959       NaN       NaN -1.100771<br>2 -1.657068       NaN       NaN  2.525831<br>3 -1.869547       NaN  0.275511 -0.459739<br>4 -0.287525       NaN  2.145633  0.703735<br>5  0.499207 -0.385792 -1.192131 -1.679805<br>6 -0.529885  2.053872  0.970785 -0.733382</p><p>[:4,1]注意这里切片是切到“4”，不是到“3”</p><p>frame_1.dropna()<br>Out[72]:<br>          0         1         2         3<br>5  0.499207 -0.385792 -1.192131 -1.679805<br>6 -0.529885  2.053872  0.970785 -0.733382</p><p>#把不想看的数据行部分赋值NaN，然后在通过dropna语句把含有NaN的行删除掉。</p><p>缺失数据的补充：</p><p>通过fillna指令我们可以更快地补充缺失数据。这与通过isnull把数据框转化为bool数据框，然后把bool数据框作为索引来赋值‘0’要快的多。（前面已经讲过）</p><p>但是这个指令只能赋一个值。通过字典，我们可以给每一列赋不同的值。</p><p>frame_1.fillna({1:5,2:4})<br>Out[7]:<br>          0         1         2         3<br>0  1.651360  5.000000  4.000000 -0.600997<br>1 -0.020649  5.000000  4.000000 -0.529843<br>2 -0.850476  5.000000  4.000000 -0.893813<br>3  0.812226  5.000000  0.614715  0.112509<br>4  0.074320  5.000000  1.145727  0.168718<br>5 -0.516371 -1.022050  0.774645  0.705847<br>6  0.617606  0.881843 -0.619870 -1.527961</p><p>_=frame_1.fillna(0,inplace=True)</p><p>frame_1<br>Out[13]:<br>          0         1         2         3<br>0  1.651360  0.000000  0.000000 -0.600997<br>1 -0.020649  0.000000  0.000000 -0.529843<br>2 -0.850476  0.000000  0.000000 -0.893813<br>3  0.812226  0.000000  0.614715  0.112509<br>4  0.074320  0.000000  1.145727  0.168718<br>5 -0.516371 -1.022050  0.774645  0.705847<br>6  0.617606  0.881843 -0.619870 -1.527961</p><p>#可以直接对数据框修改，也就是说可以直接改变源数据，不产生副本。</p><p>frame_1=pd.DataFrame(np.random.randn(7,4));frame_1.loc[:4,1]=np.nan;frame_1.loc[:2,2]=np.nan</p><p>frame_1<br>Out[107]:<br>          0         1         2         3<br>0 -0.748195       NaN       NaN -0.539246<br>1 -2.360077       NaN       NaN -0.061078<br>2 -1.743350       NaN       NaN -0.233060<br>3 -2.100371       NaN  0.187509  0.893321<br>4 -0.477253       NaN  1.876733  0.208389<br>5  0.770411 -2.262797  0.321646 -2.490215<br>6  1.265209 -0.453140  0.045817  0.951077</p><p>frame_1.fillna({1:pd.Series([2,3,7,9,0],index=[0,1,2,3,4]),2:pd.Series([1,9,8],index=[0,1,2])})<br>Out[108]:<br>          0         1         2         3<br>0 -0.748195  2.000000  1.000000 -0.539246<br>1 -2.360077  3.000000  9.000000 -0.061078<br>2 -1.743350  7.000000  8.000000 -0.233060<br>3 -2.100371  9.000000  0.187509  0.893321<br>4 -0.477253  0.000000  1.876733  0.208389<br>5  0.770411 -2.262797  0.321646 -2.490215<br>6  1.265209 -0.453140  0.045817  0.951077</p><p>层次化索引：</p><p>series_1=pd.Series(np.random.randn(12),index=[[‘r1’,’r1’,’r1’,’t1’,’t1’,’s1’,’s1’,’s1’,’s1’,’p1’,’q1’,’q1’],[9,8,7,6,5,4,3,2,1,0,12,11]])</p><p>series_1<br>Out[8]:<br>r1  9     1.536272<br>    8     0.378965<br>    7    -0.292986<br>t1  6    -0.254990<br>    5     0.765191<br>s1  4     2.204928<br>    3     0.662662<br>    2    -0.595029<br>    1    -1.905753<br>p1  0    -1.029524<br>q1  12   -1.038748<br>    11   -1.192589<br>dtype: float64</p><p>series_1.index<br>Out[9]:<br>MultiIndex(levels=[[‘p1’, ‘q1’, ‘r1’, ‘s1’, ‘t1’], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12]],<br>           labels=[[2, 2, 2, 4, 4, 3, 3, 3, 3, 0, 1, 1], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 11, 10]])</p><p>可以直接索引外层标签，也就是第一层标签。<br>series_1[‘s1’]<br>Out[6]:<br>4   -0.012306<br>3    0.800679<br>2   -0.862986<br>1    0.048458<br>dtype: float64</p><p>也可以做切片。但是外层标签必须是<br>1.经过排序的，必须！<br>2.每个外层标签的第一个字母不能不一致，要大写，全大写，要小写全小写。</p><p>Series_123=pd.Series(np.random.randint(10),index=[[‘apple’,’apple’,’apple’,’apricot’,’apricot’,’apricot’,’banana’,’banana’,’blackberry’,’cherry’],[3,2,5,6,0,4,9,11,21,17]])</p><p>Series_123[‘apple’]<br>Out[4]:<br>3    9<br>2    9<br>5    9<br>dtype: int64</p><p>Series_123[‘apple’:’banana’]<br>Out[64]:<br>apple    3     5<br>         2     5<br>         5     5<br>apricot  6     5<br>         0     5<br>         4     5<br>banana   9     5<br>         11    5<br>dtype: int64</p><p>Series_123[‘apple’:’apricot’]<br>Out[65]:<br>apple    3    5<br>         2    5<br>         5    5<br>apricot  6    5<br>         0    5<br>         4    5<br>dtype: int64</p><p>Series_123[‘apple’:’blackberry’]<br>Out[67]:<br>apple       3     5<br>            2     5<br>            5     5<br>apricot     6     5<br>            0     5<br>            4     5<br>banana      9     5<br>            11    5<br>blackberry  21    5<br>dtype: int64</p><p>Series_67=pd.Series(np.random.randint(10),index=[[‘apple’,’apple’,’apple’,’apricot’,’apricot’,’apricot’,’banana’,’banana’,’blackberry’,’cherry’],[3,2,5,6,5,4,9,5,21,17]])</p><p>Series_67<br>Out[7]:<br>apple       3     4<br>            2     4<br>            5     4<br>apricot     6     4<br>            5     4<br>            4     4<br>banana      9     4<br>            5     4<br>blackberry  21    4<br>cherry      17    4<br>dtype: int64</p><p>Series_67[:,5]<br>Out[8]:<br>apple      4<br>apricot    4<br>banana     4<br>dtype: int64</p><p>#对于Series，中括号的第一个位置是代表外层标签，第二位置代表内存标签</p><p>例子：</p><p>Series_67[‘apple’,5]<br>Out[10]: 4</p><p>带有层次化索引的Series可以立马转化为数据框，反之，数据框也可以转化为带有层次化索引的Series<br>Series_67.unstack()<br>Out[20]:<br>             2    3    4    5    6    9    17   21<br>apple       4.0  4.0  NaN  4.0  NaN  NaN  NaN  NaN<br>apricot     NaN  NaN  4.0  4.0  4.0  NaN  NaN  NaN<br>banana      NaN  NaN  NaN  4.0  NaN  4.0  NaN  NaN<br>blackberry  NaN  NaN  NaN  NaN  NaN  NaN  NaN  4.0<br>cherry      NaN  NaN  NaN  NaN  NaN  NaN  4.0  NaN</p><p>#Series的内层索引变化为列标签，外层索引转化为行标签,并且重复索引删除，索引保持唯一性。</p><p>Series_67.unstack(0)<br>Out[22]:<br>    apple  apricot  banana  blackberry  cherry<br>2     4.0      NaN     NaN         NaN     NaN<br>3     4.0      NaN     NaN         NaN     NaN<br>4     NaN      4.0     NaN         NaN     NaN<br>5     4.0      4.0     4.0         NaN     NaN<br>6     NaN      4.0     NaN         NaN     NaN<br>9     NaN      NaN     4.0         NaN     NaN<br>17    NaN      NaN     NaN         NaN     4.0<br>21    NaN      NaN     NaN         4.0     NaN</p><p>#axis=0时，Series的内层索引变化为行标签，外层索引转化为列标签</p><p>Series_67.unstack(1)<br>Out[24]:<br>             2    3    4    5    6    9    17   21<br>apple       4.0  4.0  NaN  4.0  NaN  NaN  NaN  NaN<br>apricot     NaN  NaN  4.0  4.0  4.0  NaN  NaN  NaN<br>banana      NaN  NaN  NaN  4.0  NaN  4.0  NaN  NaN<br>blackberry  NaN  NaN  NaN  NaN  NaN  NaN  NaN  4.0<br>cherry      NaN  NaN  NaN  NaN  NaN  NaN  4.0  NaN</p><p>Series_67.unstack().stack()<br>Out[29]:<br>apple       2     4.0<br>            3     4.0<br>            5     4.0<br>apricot     4     4.0<br>            5     4.0<br>            6     4.0<br>banana      5     4.0<br>            9     4.0<br>blackberry  21    4.0<br>cherry      17    4.0<br>dtype: float64</p><p>Gamedata=pd.DataFrame(np.array([[31,27,24,60],[26,28,13,29],[27,17,12,27],[29,9,5,18],[31,12,4,70],[45,11,12,12]]),index=[[‘Morning’,’Morning’,’Morning’,’Afternoon’,’Afternoon’,’Afternoon’],[1,2,3,1,2,3]],columns=[[‘Junior’,’Junior’,’Youth’,’Youth’],[‘Zhang’,’Wang’,’Li’,’Zhao’]])</p><p>Gamedata<br>Out[35]:<br>            Junior      Youth<br>             Zhang Wang    Li Zhao<br>Morning   1     31   27    24   60<br>          2     26   28    13   29<br>          3     27   17    12   27<br>Afternoon 1     29    9     5   18<br>          2     31   12     4   70<br>          3     45   11    12   12</p><p>Gamedata=pd.DataFrame(np.array([[31,27,24,60],[26,28,13,29],[27,17,12,27],[29,9,5,18],[31,12,4,70],[45,11,12,12]]),index=[[‘A_Morning’,’A_Morning’,’A_Morning’,’B_Afternoon’,’B_Afternoon’,’B_Afternoon’],[1,2,3,1,2,3]],columns=[[‘Junior’,’Junior’,’Youth’,’Youth’],[‘Zhang’,’Wang’,’Li’,’Zhao’]])</p><p>Gamedata.index.names=[‘time’,’sequence’]</p><p>#因为行有双层索引，因此需要两个名字</p><p>#列也是如此，也是两个名字</p><p>Gamedata.columns.names=[‘age’,’name’]</p><p>Gamedata<br>Out[50]:<br>age                  Junior      Youth<br>name                  Zhang Wang    Li Zhao<br>time        sequence<br>A_Morning   1            31   27    24   60<br>            2            26   28    13   29<br>            3            27   17    12   27<br>B_Afternoon 1            29    9     5   18<br>            2            31   12     4   70<br>            3            45   11    12   12</p><p>Gamedata[‘Junior’]<br>Out[51]:<br>name                  Zhang  Wang<br>time        sequence<br>A_Morning   1            31    27<br>            2            26    28<br>            3            27    17<br>B_Afternoon 1            29     9<br>            2            31    12<br>            3            45    11</p><p>Gamedata.loc[‘Morning’]<br>Out[31]:<br>Age       Junior      Youth<br>Name       Zhang Wang    Li Zhao<br>series_nr<br>1             31   27    24   60<br>2             26   28    13   29<br>3             27   17    12   27</p><p>Gamedata.loc[‘Morning’,2]<br>Out[32]:<br>Age     Name<br>Junior  Zhang    26<br>        Wang     28<br>Youth   Li       13<br>        Zhao     29<br>Name: (Morning, 2), dtype: int32</p><p>多重标签的顺序互换：</p><p>Gamedata.swaplevel(‘sequence’,’time’)<br>Out[52]:<br>age                  Junior      Youth<br>name                  Zhang Wang    Li Zhao<br>sequence time<br>1        A_Morning       31   27    24   60<br>2        A_Morning       26   28    13   29<br>3        A_Morning       27   17    12   27<br>1        B_Afternoon     29    9     5   18<br>2        B_Afternoon     31   12     4   70<br>3        B_Afternoon     45   11    12   12</p><p>Gamedata.swaplevel(‘age’,’name’,axis=1)<br>Out[60]:<br>name                  Zhang   Wang    Li  Zhao<br>age                  Junior Junior Youth Youth<br>time        sequence<br>A_Morning   1            31     27    24    60<br>            2            26     28    13    29<br>            3            27     17    12    27<br>B_Afternoon 1            29      9     5    18<br>            2            31     12     4    70<br>            3            45     11    12    12</p><p>Gamedata.sortlevel(1)<br>C:\Users\dongfeng\Anaconda3\lib\site-packages\ipykernel_launcher.py:1: FutureWarning: sortlevel is deprecated, use sort_index(level= …)<br>  “””Entry point for launching an IPython kernel.<br>Out[55]:<br>age                  Junior      Youth<br>name                  Zhang Wang    Li Zhao<br>time        sequence<br>A_Morning   1            31   27    24   60<br>B_Afternoon 1            29    9     5   18<br>A_Morning   2            26   28    13   29<br>B_Afternoon 2            31   12     4   70<br>A_Morning   3            27   17    12   27<br>B_Afternoon 3            45   11    12   12</p><p>#sortlevel则根据单个级别的值进行排序，上例根据sequence列数据。</p><p>Gamedata.swaplevel(‘age’,’name’,axis=1).sortlevel(0)<br>C:\Users\dongfeng\Anaconda3\lib\site-packages\ipykernel_launcher.py:1: FutureWarning: sortlevel is deprecated, use sort_index(level= …)<br>  “””Entry point for launching an IPython kernel.<br>Out[61]:<br>name                  Zhang   Wang    Li  Zhao<br>age                  Junior Junior Youth Youth<br>time        sequence<br>A_Morning   1            31     27    24    60<br>            2            26     28    13    29<br>            3            27     17    12    27<br>B_Afternoon 1            29      9     5    18<br>            2            31     12     4    70<br>            3            45     11    12    12</p><p>#交换两层列标签，然后对第二行列标签排序<br>Gamedata<br>Out[62]:<br>age                  Junior      Youth<br>name                  Zhang Wang    Li Zhao<br>time        sequence<br>A_Morning   1            31   27    24   60<br>            2            26   28    13   29<br>            3            27   17    12   27<br>B_Afternoon 1            29    9     5   18<br>            2            31   12     4   70<br>            3            45   11    12   12</p><p>Gamedata.swaplevel(‘age’,’name’,axis=1).sortlevel(1)<br>C:\Users\dongfeng\Anaconda3\lib\site-packages\ipykernel_launcher.py:1: FutureWarning: sortlevel is deprecated, use sort_index(level= …)<br>  “””Entry point for launching an IPython kernel.<br>Out[63]:<br>name                  Zhang   Wang    Li  Zhao<br>age                  Junior Junior Youth Youth<br>time        sequence<br>A_Morning   1            31     27    24    60<br>B_Afternoon 1            29      9     5    18<br>A_Morning   2            26     28    13    29<br>B_Afternoon 2            31     12     4    70<br>A_Morning   3            27     17    12    27<br>B_Afternoon 3            45     11    12    12</p><p>#交换两层行标签，然后对第二列行标签排序</p><p>根据级别计算：</p><p>Gamedata<br>Out[62]:<br>age                  Junior      Youth<br>name                  Zhang Wang    Li Zhao<br>time        sequence<br>A_Morning   1            31   27    24   60<br>            2            26   28    13   29<br>            3            27   17    12   27<br>B_Afternoon 1            29    9     5   18<br>            2            31   12     4   70<br>            3            45   11    12   12</p><p>Gamedata.sum(level=’sequence’)<br>Out[64]:<br>age      Junior      Youth<br>name      Zhang Wang    Li Zhao<br>sequence<br>1            60   36    29   78<br>2            57   40    17   99<br>3            72   28    24   39</p><p>#每个级别包含两个元素，（因为此级别标签分别重复两次。）<br>Gamedata.sum(level=’name’,axis=1)<br>Out[68]:<br>name                  Li  Wang  Zhang  Zhao<br>time        sequence<br>A_Morning   1         24    27     31    60<br>            2         13    28     26    29<br>            3         12    17     27    27<br>B_Afternoon 1          5     9     29    18<br>            2          4    12     31    70<br>            3         12    11     45    12</p><p>每个级别只包含一个元素，因此无法相加，只能排序。</p><p>Gamedata.sum(level=’age’,axis=1)<br>Out[69]:<br>age                   Junior  Youth<br>time        sequence<br>A_Morning   1             58     84<br>            2             54     42<br>            3             44     39<br>B_Afternoon 1             38     23<br>            2             43     74<br>            3             56     24</p><p>#每个级别包含两个元素，分别两两相加。</p><p>Gamedata.sum(level=’time’)<br>Out[71]:<br>age         Junior      Youth<br>name         Zhang Wang    Li Zhao<br>time<br>A_Morning       84   72    49  116<br>B_Afternoon    105   32    21  100</p><p>每个级别包含三个元素，分别相加即可</p><p>把数据框的列转化为行索引：</p><p>frame_1123=pd.DataFrame({‘a’:range(4),’b’:range(4,0,-1),’c’:[‘one’,’one’,’two’,’two’],’d’:[0,1,2,3]})</p><p>frame_1123<br>Out[73]:<br>   a  b    c  d<br>0  0  4  one  0<br>1  1  3  one  1<br>2  2  2  two  2<br>3  3  1  two  3</p><p>frame_1224=frame_1123.set_index([‘c’,’d’])</p><p>frame_1224<br>Out[76]:<br>       a  b<br>c   d<br>one 0  0  4<br>    1  1  3<br>two 2  2  2<br>    3  3  1</p><p>#我们发现列从数据框中消失，变成了双重行索引。</p><p>然而而这些列也可以不消失。</p><p>frame_1123.set_index([‘c’,’d’],drop=False)<br>Out[79]:<br>       a  b    c  d<br>c   d<br>one 0  0  4  one  0<br>    1  1  3  one  1<br>two 2  2  2  two  2<br>3  3  1  two  3</p><p>我们可以把双重索引再转化到数据框的数据区域。</p><p>frame_1123.reset_index()<br>Out[82]:<br>   index  a  b    c  d<br>0      0  0  4  one  0<br>1      1  1  3  one  1<br>2      2  2  2  two  2<br>3      3  3  1  two  3</p><p>面板数据：</p><p>Panel实质上是一个三维的数据框，3维说明其有三个轴，每个轴的含义如下：</p><p>items: 0轴， 每个项目对应其中的一个DataFrame<br><strong>major_axis（主轴）: </strong> 1轴，它是每个DataFrame的index<br><strong>minor_axis（副轴）: </strong> 2轴，它是每个DataFrame的column<br>创建panel：<br>A.数组创建,三维数组<br>   Dataframe_3 = pd.Panel(np.random.randn(2,5,4),items=[‘Item1’,’Item2’],major_axis=pd.date_range(‘2000-01-01’,’2000-01-05’),minor_axis=[‘A’,’B’,’C’,’D’])</p><p>Dataframe_4=pd.Panel(np.array([[[1,4,67,45],[34,56,2,0],[78,90,3,4],[4,23,67,5],[34,89,67,1]],[[67,90,64,7],[789,345,6,2],[33,89,467,8],[43,93,2,8],[33,74,89,6]]]),items=[‘Item1’,’Item2’],major_axis=pd.date_range(‘2000-01-01’,’2000-01-05’),minor_axis=[‘A’,’B’,’C’,’D’])</p><p>Dataframe_3<br>Out[107]: </p><p><class 'pandas.core.panel.panel'><br>Dimensions: 2 (items) x 5 (major_axis) x 4 (minor_axis)<br>Items axis: Item1 to Item2<br>Major_axis axis: 2000-01-01 00:00:00 to 2000-01-05 00:00:00<br>Minor_axis axis: A to D</class></p><p>Dataframe_4<br>Out[108]: </p><p><class 'pandas.core.panel.panel'><br>Dimensions: 2 (items) x 5 (major_axis) x 4 (minor_axis)<br>Items axis: Item1 to Item2<br>Major_axis axis: 2000-01-01 00:00:00 to 2000-01-05 00:00:00<br>Minor_axis axis: A to D</class></p><p>B.通过字典创建<br>data = {‘Item1’ : pd.DataFrame(np.random.randn(4, 3),index=pd.date_range(‘2017-09-05’,’2017-09-08’),columns=[‘X’,’D’,’F’]),’Item2’ : pd.DataFrame(np.random.randn(4, 2),index=pd.date_range(‘2017-09-05’,’2017-09-08’),columns=[‘X’,’D’])}</p><p>panel_1=pd.Panel(data)</p><p>panel_1<br>Out[115]: </p><p><class 'pandas.core.panel.panel'><br>Dimensions: 2 (items) x 4 (major_axis) x 3 (minor_axis)<br>Items axis: Item1 to Item2<br>Major_axis axis: 2017-09-05 00:00:00 to 2017-09-08 00:00:00<br>Minor_axis axis: D to X</class></p><p>C.通过数据框创建</p><p>midx = pd.MultiIndex(levels=[[‘one’, ‘two’], [‘x’,’y’]], labels=[[1,1,0,0],[1,0,1,0]])<br>midx<br>Out[117]:<br>MultiIndex(levels=[[‘one’, ‘two’], [‘x’, ‘y’]],<br>           labels=[[1, 1, 0, 0], [1, 0, 1, 0]])</p><p>第一层行标是[‘one’, ‘two’]，labels[1, 1, 0, 0]；第二层行标是 [‘x’,’y’]，labels[1, 0, 1, 0]，注意’one’对应‘0’，’two’对应‘1’</p><p>df = pd.DataFrame({‘A’:[1,2,3,4],’B’:[5,6,7,8]},index=midx)</p><p>df<br>Out[119]:<br>       A  B<br>two y  1  5<br>    x  2  6<br>one y  3  7<br>    x  4  8<br>df.to_panel()</p><p>面板操作<br>A.选取<br>Dataframe_3[‘Item1’]<br>Out[124]: Dataframe_3<br>                   A         B         C         D<br>2000-01-01  0.836830 -1.856472  0.345340  0.576771<br>2000-01-02 -1.529758 -1.646630  0.635996 -0.337408<br>2000-01-03  0.451765  0.156648 -1.225328 -0.177641<br>2000-01-04  1.123645  0.364549  0.684536  1.558884<br>2000-01-05 -0.082263  1.472391 -0.379373  2.410845</p><p>Dataframe_3.major_axis<br>Out[128]:<br>DatetimeIndex([‘2000-01-01’, ‘2000-01-02’, ‘2000-01-03’, ‘2000-01-04’,<br>               ‘2000-01-05’],<br>              dtype=’datetime64[ns]’, freq=’D’)</p><p>Dataframe_3[‘Item1’]<br>Out[131]:<br>                   A         B         C         D<br>2000-01-01  0.836830 -1.856472  0.345340  0.576771<br>2000-01-02 -1.529758 -1.646630  0.635996 -0.337408<br>2000-01-03  0.451765  0.156648 -1.225328 -0.177641<br>2000-01-04  1.123645  0.364549  0.684536  1.558884<br>2000-01-05 -0.082263  1.472391 -0.379373  2.410845</p><p>Dataframe_3.major_xs(Dataframe_3.major_axis[2])</p><p>Dataframe_3.minor_axis<br>Out[134]: Index([‘A’, ‘B’, ‘C’, ‘D’], dtype=’object’)</p><p>Dataframe_3.minor_xs(Dataframe_3.minor_axis[3])<br>Out[137]:<br>               Item1     Item2<br>2000-01-01  0.576771  1.387176<br>2000-01-02 -0.337408 -0.159394<br>2000-01-03 -0.177641 -1.622084<br>2000-01-04  1.558884  0.393800<br>2000-01-05  2.410845 -0.249931</p><p>转置：</p><p>Dataframe_3=pd.Panel(np.random.randn(2,5,4),items=[‘Item1’,’Item2’],major_axis=pd.date_range(‘2000-01-01’,’2000-01-05’),minor_axis=[‘A’,’B’,’C’,’D’])</p><p>Dataframe_3<br>Out[5]: </p><p><class 'pandas.core.panel.panel'><br>Dimensions: 2 (items) x 5 (major_axis) x 4 (minor_axis)<br>Items axis: Item1 to Item2<br>Major_axis axis: 2000-01-01 00:00:00 to 2000-01-05 00:00:00<br>Minor_axis axis: A to D</class></p><p>Dataframe_3[‘Item1’,’2000-01-03’,’B’]<br>Out[9]: 2.3125077493899666</p><p>#转置前的元素定位查询<br>Dataframe_3.transpose(0,2,1)<br>Out[10]: </p><p><class 'pandas.core.panel.panel'><br>Dimensions: 2 (items) x 4 (major_axis) x 5 (minor_axis)<br>Items axis: Item1 to Item2<br>Major_axis axis: A to D<br>Minor_axis axis: 2000-01-01 00:00:00 to 2000-01-05 00:00:00</class></p><p>Data_transpose=Dataframe_3.transpose(0,2,1)</p><p>Data_transpose[‘Item1’,’B’,’2000-01-03’]<br>Out[12]: 2.3125077493899666</p><p>#转置后的同一元素查询，两者查询结果相同，说明转置成功。</p><p>面板转化为分层索引数据框<br>Dataframe_3.to_frame()<br>Out[16]:<br>                     Item1     Item2<br>major      minor<br>2000-01-01 A      1.345174 -1.719012<br>           B     -1.075240  1.258681<br>           C      0.366470 -0.004046<br>           D     -0.149155 -0.405295<br>2000-01-02 A      0.005256  0.204166<br>           B     -0.032269 -0.667655<br>           C      1.825649  1.050139<br>           D     -1.505179  0.534874<br>2000-01-03 A      0.876495 -0.414982<br>           B      2.312508 -0.731893<br>           C     -0.129701 -1.470191<br>           D     -0.637856 -0.083188<br>2000-01-04 A     -0.287276  0.633456<br>           B     -0.623472 -0.229308<br>           C      0.530747 -0.896306<br>           D      0.229674  0.288064<br>2000-01-05 A      0.163915 -1.836235<br>           B      0.618230  1.353955<br>           C      0.260995  0.808007<br>           D      1.673127 -0.275785<br>切片：</p><p>Dataframe_3[‘Item2’,:,’B’]<br>Out[18]:<br>2000-01-01    1.258681<br>2000-01-02   -0.667655<br>2000-01-03   -0.731893<br>2000-01-04   -0.229308<br>2000-01-05    1.353955<br>Freq: D, Name: B, dtype: float64</p><p>Dataframe_3[‘Item2’,’2000-01-02’:’2000-01-04’,’B’]<br>Out[19]:<br>2000-01-02   -0.667655<br>2000-01-03   -0.731893<br>2000-01-04   -0.229308<br>Freq: D, Name: B, dtype: float64</p><p>Dataframe_3[‘Item2’,’2000-01-02’]<br>Out[20]:<br>A    0.204166<br>B   -0.667655<br>C    1.050139<br>D    0.534874<br>Name: 2000-01-02 00:00:00, dtype: float64</p><p>Dataframe_3[‘Item2’,’2000-01-02’:’2000-01-04’]<br>Out[21]:<br>                   A         B         C         D<br>2000-01-02  0.204166 -0.667655  1.050139  0.534874<br>2000-01-03 -0.414982 -0.731893 -1.470191 -0.083188<br>2000-01-04  0.633456 -0.229308 -0.896306  0.288064</p><p>Dataframe_3[‘Item1’:’Item2’,’2000-01-02’:’2000-01-04’,’C’]<br>Out[22]:<br>               Item1     Item2<br>2000-01-02  1.825649  1.050139<br>2000-01-03 -0.129701 -1.470191<br>2000-01-04  0.530747 -0.896306</p><p>Dataframe_3[:,’2000-01-02’:’2000-01-04’,’C’:’D’]<br>Out[28]: </p><p><class 'pandas.core.panel.panel'><br>Dimensions: 2 (items) x 3 (major_axis) x 2 (minor_axis)<br>Items axis: Item1 to Item2<br>Major_axis axis: 2000-01-02 00:00:00 to 2000-01-04 00:00:00<br>Minor_axis axis: C to D</class></p><p>#切出新面板。</p><p>数据加载，存储，清理，转换，合并与重塑</p><p>数据的加载与存储<br>Python在文本文件的加载与存储方面极其方便，这是它成为深受大家喜爱语言的原因之一。</p><p>Pandas 提供了一些直接将表格文件读取为DataFrame对象的函数<br>下面我们一一讲解：<br>A, read_csv<br>import pandas as pd<br>!type example_1.txt<br>系统找不到指定的文件。我们做一下简单修改<br>!type Desktop\example_1.txt<br>Liu,Zhang,Wang,Li,Class<br>23,34,78,32,’primary’<br>77,32,89,66,’intermediate’<br>99,34,78,66,’senior’<br>66,34,6,33,’intermediate’<br>也可以直接读取‘CSV’文件<br>!type Desktop\example_1.csv<br>Liu,Zhang,Wang,Li,Class<br>23,34,78,32,’primary’<br>77,32,89,66,’intermediate’<br>99,34,78,66,’senior’<br>66,34,6,33,’intermediate’<br>直接读取的数据相当于源数据，即没有转化为数据框的数据。</p><p>下面我们直接把CSV文件读成数据框：<br>frame_1=pd.read_csv(‘Desktop\example_1.csv’)</p><p>frame_1<br>Out[10]:<br>   Liu  Zhang  Wang  Li           Class<br>0   23     34    78  32       ‘primary’<br>1   77     32    89  66  ‘intermediate’<br>2   99     34    78  66        ‘senior’<br>3   66     34     6  33  ‘intermediate’</p><p>#我们发现我们得到一个完美的数据框<br>下面我们尝试用‘read_table’<br>frame_1=pd.read_table(‘Desktop\example_1.csv’)</p><p>frame_1<br>Out[15]:<br>      Liu,Zhang,Wang,Li,Class<br>0       23,34,78,32,’primary’<br>1  77,32,89,66,’intermediate’<br>2        99,34,78,66,’senior’<br>3   66,34,6,33,’intermediate’</p><p>我们发现被读成的DataFrame排列很混乱，下面我们加上分割符号‘，’再运行一次。<br>frame_1=pd.read_table(‘Desktop\example_1.csv’,sep=’,’)</p><p>frame_1<br>Out[13]:<br>   Liu  Zhang  Wang  Li           Class<br>0   23     34    78  32       ‘primary’<br>1   77     32    89  66  ‘intermediate’<br>2   99     34    78  66        ‘senior’<br>3   66     34     6  33  ‘intermediate’</p><p>总结：用read_table一定要加分割符号。<br>上面的例子中的csv数据我们都加了列名，如果没有列名会怎么样呢?<br>frame_2=pd.read_table(‘Desktop\example_2.csv’,sep=’,’)</p><p>frame_2<br>Out[19]:<br>   23  34  78  32       ‘primary’<br>0  77  32  89  66  ‘intermediate’<br>1  99  34  78  66        ‘senior’<br>2  66  34   6  33  ‘intermediate’</p><p>我们发现计算机自动把第一行数据当做列名，这样的话我们的源数据就遭到破坏。</p><p>为了避免这种错误，我们加入‘header’属性。让计算机自动加列名或者自己显性指定：</p><p>frame_3=pd.read_csv(‘Desktop\example_2.csv’,header=None)</p><p>frame_3<br>Out[21]:<br>    0   1   2   3               4<br>0  23  34  78  32       ‘primary’<br>1  77  32  89  66  ‘intermediate’<br>2  99  34  78  66        ‘senior’<br>3  66  34   6  33  ‘intermediate’</p><p>frame_3=pd.read_csv(‘Desktop\example_2.csv’,names=[‘a’,’b’,’c’,’d’,’class’])</p><p>frame_3<br>Out[23]:<br>    a   b   c   d           class<br>0  23  34  78  32       ‘primary’<br>1  77  32  89  66  ‘intermediate’<br>2  99  34  78  66        ‘senior’<br>3  66  34   6  33  ‘intermediate’<br>源文件中去掉双引号，这里双引号也会消失！<br>我们可以把最右边的列直接转化成行索引列。</p><p>frame_3=pd.read_csv(‘Desktop\example_2.csv’,names=[‘a’,’b’,’c’,’d’,’class’],index_col=’class’)</p><p>frame_3<br>Out[28]:<br>                 a   b   c   d<br>class<br>‘primary’       23  34  78  32<br>‘intermediate’  77  32  89  66<br>‘senior’        99  34  78  66<br>‘intermediate’  66  34   6  33</p><p>除了可以读取为普通的数据框，还可以读取为带有重索引的数据框：</p><p>pd.read_csv(‘Desktop\example_5.csv’,index_col=[‘group’,’games’])<br>Out[45]:<br>             a  b  c  a.1  b.1  c.1  a.2  b.2  c.2<br>group games<br>one   Att    4  3  4    2    4    3    4    2    1<br>      Cgt    4  3  4    2    4    3    4    2    1<br>      Aer    4  3  4    2    4    3    4    2    1<br>two   Att    4  3  4    2    4    3    4    2    1<br>      Cgt    4  3  4    2    4    3    4    2    1<br>      Aer    4  3  4    2    4    3    4    2    1</p><p>对于那些用数量不等空格或者字符串隔开的数据，我们可以通过正则操作符一步处理到位，把数据处理整齐：</p><p>!type Desktop\exampel_6.csv<br>         A     B     C’<br>aaa     -3.45  2.36   8.90’<br>bbb   0.334  0.457      -4.5’<br>ccc     0.76  -7.34  -8.99’<br>ddd      0.37  -7.8   -4.45’</p><p>pd.read_csv(‘Desktop\exampel_6.csv’,sep=’\s+’)<br>Out[63]:<br>         A      B      C’<br>aaa -3.450  2.360   8.90’<br>bbb  0.334  0.457   -4.5’<br>ccc  0.760 -7.340  -8.99’<br>ddd  0.370 -7.800  -4.45’</p><p>如果这里的源数据没有引号的话，这里引号也会自动消失。<br>利用skiprows语句可以跳过任意无意义行信息。<br>!type Desktop\example_9.csv<br>title:Good Boy<br>Little Robert asked his mother for two cents. “What did you do with the money I gave you yesterday?”<br>a,b,c,d,name<br>“I gave it to a poor old woman,” he answered.<br>“You’re a good boy,” said the mother proudly. “Here are two cents more. But why are you so interested in the old woman?”<br>group1,12,2,2,3,robert<br>group2,10,19,18,17,linz<br>“She is the one who sells the candy.”<br>group3,29,28,27,27,hans<br>group4,34,35,35,36,manfried</p><p>整理后数据</p><p>pd.read_csv(‘Desktop\example_9.csv’,skiprows=[0,1,3,4,7])<br>Out[69]:<br>         a   b   c   d      name<br>group1  12   2   2   3    robert<br>group2  10  19  18  17      linz<br>group3  29  28  27  27      hans<br>group4  34  35  35  36  manfried</p><p>缺失数据要么没有，要么用某个标记值表示。请看下面两个例子：</p><p>!type Desktop\example_10.csv<br>Liu,Zhang,Wang,Li,Class<br>23,34,78,32,NA<br>77,32,,66,’intermediate’<br>99,34,78,66,’senior’<br>66,34,6,33,’intermediate’</p><p>pd.read_csv(‘Desktop\example_10.csv’)<br>Out[83]:<br>   Liu  Zhang  Wang  Li           Class<br>0   23     34  78.0  32             NaN<br>1   77     32   NaN  66  ‘intermediate’<br>2   99     34  78.0  66        ‘senior’<br>3   66     34   6.0  33  ‘intermediate’</p><p>#上面例子产生NAN值，（直接在数字处空一位，就会产生NaN，比如数据1,2,4对应列标签，A,B,C,D）</p><p>!type Desktop\example_11.csv<br>23,34,78,32,’ ‘<br>77,32,89,66,’intermediate’<br>99,34, ,66,’senior’<br>66,34,6,33,’intermediate’</p><p>pd.read_csv(‘Desktop\example_11.csv’)<br>Out[86]:<br>   23  34  78  32             ‘ ‘<br>0  77  32  89  66  ‘intermediate’<br>1  99  34      66        ‘senior’<br>2  66  34   6  33  ‘intermediate’</p><p>#上面的例子什么都不显示（只有空字符串和空格）<br>通过na_values python可以用字符串标识NAN值。但要注意源数据中字符串上不能有引号。</p><p>!type Desktop\example_12.csv<br>A,B,C,D<br>1,2,3,4<br>5,me,7,8<br>8,10,11,me<br>12,13,14,16</p><p>pd.read_table(‘Desktop\example_12.csv’,na_values=[‘me’],sep=’,’)<br>Out[14]:<br>    A     B   C     D<br>0   1   2.0   3   4.0<br>1   5   NaN   7   8.0<br>2   8  10.0  11   NaN<br>3  12  13.0  14  16.0</p><p>可以用字符串字典的形式标识多空值数据框<br>!type Desktop\example_13.csv<br>A,B,C,D<br>1,2,3,4<br>too,to,56,33<br>45,dee,78,69<br>12,21,34,43</p><p>pd.read_table(‘Desktop\example_13.csv’,na_values={‘A’:’too’,’B’:[‘to’,’dee’]},sep=’,’)<br>Out[18]:<br>      A     B   C   D<br>0   1.0   2.0   3   4<br>1   NaN   NaN  56  33<br>2  45.0   NaN  78  69<br>3  12.0  21.0  34  43</p><p>爬虫数据例子：<br>df=pd.read_csv(‘Desktop\pachong.csv’,encoding=’gbk’,sep=’,’,header=None, skiprows=[14,47,49,50,51,59,68,83,104,125,127,128,136,150,173,184])<br>用这个指令可以处理中文数据</p><p>Pd.read_csv读取excel数据：</p><p>import pandas as pd</p><p>pd.read_excel(r’Desktop\1.xls’ ,sheetname=[0,1])<br>Out[2]:<br>OrderedDict([(0,      1   2   3   4<br>              0    2   3   4   5<br>              1    3   4   5   6<br>              2    4   5   6   7<br>              3    5   6   7   8<br>              4    6   7   8   9<br>              5    7   8   9  10<br>              6    8   9  10  11<br>              7    9  10  11  12<br>              8   10  11  12  13<br>              9   11  12  13  14<br>              10  12  13  14  15<br>              11  13  14  15  16<br>              12  14  15  16  17<br>              13  15  16  17  18<br>              14  16  17  18  19<br>              15  17  18  19  20<br>              16  18  19  20  21<br>              17  19  20  21  22<br>              18  20  21  22  23<br>              19  21  22  23  24), (1,     23  22  34  55  67<br>              0   24  23  35  56  68<br>              1   25  24  36  57  69<br>              2   26  25  37  58  70<br>              3   27  26  38  59  71<br>              4   28  27  39  60  72<br>              5   29  28  40  61  73<br>              6   30  29  41  62  74<br>              7   31  30  42  63  75<br>              8   32  31  43  64  76<br>              9   33  32  44  65  77<br>              10  34  33  45  66  78<br>              11  35  34  46  67  79<br>              12  36  35  47  68  80<br>              13  37  36  48  69  81<br>              14  38  37  49  70  82<br>              15  39  38  50  71  83<br>              16  40  39  51  72  84<br>              17  41  40  52  73  85<br>              18  42  41  53  74  86<br>              19  43  42  54  75  87<br>              20  44  43  55  76  88<br>              21  45  44  56  77  89<br>              22  46  45  57  78  90)])</p><p>#sheetname=表格时，返回多个指定的在一个workbook里面的表格，sheetname=none，将返回一个workbook里的所有表格。sheetname=int时，int指的是表格索引号，sheetname=’sheet1‘返回指定表格。</p><p>pd.read_excel(r’Desktop\1.xls’ ,sheetname=None)<br>Out[4]:<br>OrderedDict([(‘Sheet1’,      1   2   3   4<br>              0    2   3   4   5<br>              1    3   4   5   6<br>              2    4   5   6   7<br>              3    5   6   7   8<br>              4    6   7   8   9<br>              5    7   8   9  10<br>              6    8   9  10  11<br>              7    9  10  11  12<br>              8   10  11  12  13<br>              9   11  12  13  14<br>              10  12  13  14  15<br>              11  13  14  15  16<br>              12  14  15  16  17<br>              13  15  16  17  18<br>              14  16  17  18  19<br>              15  17  18  19  20<br>              16  18  19  20  21<br>              17  19  20  21  22<br>              18  20  21  22  23<br>              19  21  22  23  24), (‘Sheet2’,     23  22  34  55  67<br>              0   24  23  35  56  68<br>              1   25  24  36  57  69<br>              2   26  25  37  58  70<br>              3   27  26  38  59  71<br>              4   28  27  39  60  72<br>              5   29  28  40  61  73<br>              6   30  29  41  62  74<br>              7   31  30  42  63  75<br>              8   32  31  43  64  76<br>              9   33  32  44  65  77<br>              10  34  33  45  66  78<br>              11  35  34  46  67  79<br>              12  36  35  47  68  80<br>              13  37  36  48  69  81<br>              14  38  37  49  70  82<br>              15  39  38  50  71  83<br>              16  40  39  51  72  84<br>              17  41  40  52  73  85<br>              18  42  41  53  74  86<br>              19  43  42  54  75  87<br>              20  44  43  55  76  88<br>              21  45  44  56  77  89<br>              22  46  45  57  78  90), (‘Sheet3’,     234  22   44   78    990<br>              0   235   23   45   79   991<br>              1   236   24   46   80   992<br>              2   237   25   47   81   993<br>              3   238   26   48   82   994<br>              4   239   27   49   83   995<br>              5   240   28   50   84   996<br>              6   241   29   51   85   997<br>              7   242   30   52   86   998<br>              8   243   31   53   87   999<br>              9   244   32   54   88  1000<br>              10  245   33   55   89  1001<br>              11  246   34   56   90  1002<br>              12  247   35   57   91  1003<br>              13  248   36   58   92  1004<br>              14  249   37   59   93  1005<br>              15  250   38   60   94  1006<br>              16  251   39   61   95  1007<br>              17  252   40   62   96  1008<br>              18  253   41   63   97  1009<br>              19  254   42   64   98  1010<br>              20  255   43   65   99  1011)])</p><p>pd.read_excel(r’Desktop\1.xls’ ,sheetname=2)<br>Out[5]:<br>    234  22   44   78    990<br>0   235   23   45   79   991<br>1   236   24   46   80   992<br>2   237   25   47   81   993<br>3   238   26   48   82   994<br>4   239   27   49   83   995<br>5   240   28   50   84   996<br>6   241   29   51   85   997<br>7   242   30   52   86   998<br>8   243   31   53   87   999<br>9   244   32   54   88  1000<br>10  245   33   55   89  1001<br>11  246   34   56   90  1002<br>12  247   35   57   91  1003<br>13  248   36   58   92  1004<br>14  249   37   59   93  1005<br>15  250   38   60   94  1006<br>16  251   39   61   95  1007<br>17  252   40   62   96  1008<br>18  253   41   63   97  1009<br>19  254   42   64   98  1010<br>20  255   43   65   99  1011</p><p>pd.read_excel(r’Desktop\1.xls’ ,sheetname=0)<br>Out[6]:<br>     1   2   3   4<br>0    2   3   4   5<br>1    3   4   5   6<br>2    4   5   6   7<br>3    5   6   7   8<br>4    6   7   8   9<br>5    7   8   9  10<br>6    8   9  10  11<br>7    9  10  11  12<br>8   10  11  12  13<br>9   11  12  13  14<br>10  12  13  14  15<br>11  13  14  15  16<br>12  14  15  16  17<br>13  15  16  17  18<br>14  16  17  18  19<br>15  17  18  19  20<br>16  18  19  20  21<br>17  19  20  21  22<br>18  20  21  22  23<br>19  21  22  23  24</p><p>#sheetname=整数时，整数表示表格编号，编号从0开始。</p><p>pd.read_excel(r’Desktop\1.xls’ ,sheetname=’Sheet3’)<br>Out[9]:<br>    234  22   44   78    990<br>0   235   23   45   79   991<br>1   236   24   46   80   992<br>2   237   25   47   81   993<br>3   238   26   48   82   994<br>4   239   27   49   83   995<br>5   240   28   50   84   996<br>6   241   29   51   85   997<br>7   242   30   52   86   998<br>8   243   31   53   87   999<br>9   244   32   54   88  1000<br>10  245   33   55   89  1001<br>11  246   34   56   90  1002<br>12  247   35   57   91  1003<br>13  248   36   58   92  1004<br>14  249   37   59   93  1005<br>15  250   38   60   94  1006<br>16  251   39   61   95  1007<br>17  252   40   62   96  1008<br>18  253   41   63   97  1009<br>19  254   42   64   98  1010<br>20  255   43   65   99  1011</p><p>#上面是用字符串‘Sheet3’来调用表格三数据</p><p>#header : int, list of ints, default 0 指定列索引行，默认0，即取第一行，即数据第一行被自动读取为列索引，这一点我们并不希望，因为会丢失掉第一行数据，因此通常设定 header = None，这种情况下，计算机自动为整个数据添加新的列索引。</p><p>pd.read_excel(r’Desktop\1.xls’ ,sheetname=’Sheet3’,header=None)<br>Out[10]:<br>      0   1   2   3     4<br>0   234  22  44  78   990<br>1   235  23  45  79   991<br>2   236  24  46  80   992<br>3   237  25  47  81   993<br>4   238  26  48  82   994<br>5   239  27  49  83   995<br>6   240  28  50  84   996<br>7   241  29  51  85   997<br>8   242  30  52  86   998<br>9   243  31  53  87   999<br>10  244  32  54  88  1000<br>11  245  33  55  89  1001<br>12  246  34  56  90  1002<br>13  247  35  57  91  1003<br>14  248  36  58  92  1004<br>15  249  37  59  93  1005<br>16  250  38  60  94  1006<br>17  251  39  61  95  1007<br>18  252  40  62  96  1008<br>19  253  41  63  97  1009<br>20  254  42  64  98  1010<br>21  255  43  65  99  1011</p><p>#上例中我们发现计算机没有破坏原数据，额外为我们添加了一行列索引。</p><p>#skiprows : list-like，跳过指定行数的数据<br>pd.read_excel(r’Desktop\1.xls’ ,sheetname=’Sheet3’,header=None,skiprows=[1,5,19,10])<br>Out[11]:<br>      0   1   2   3     4<br>0   234  22  44  78   990<br>1   236  24  46  80   992<br>2   237  25  47  81   993<br>3   238  26  48  82   994<br>4   240  28  50  84   996<br>5   241  29  51  85   997<br>6   242  30  52  86   998<br>7   243  31  53  87   999<br>8   245  33  55  89  1001<br>9   246  34  56  90  1002<br>10  247  35  57  91  1003<br>11  248  36  58  92  1004<br>12  249  37  59  93  1005<br>13  250  38  60  94  1006<br>14  251  39  61  95  1007<br>15  252  40  62  96  1008<br>16  254  42  64  98  1010<br>17  255  43  65  99  1011</p><p>#我们发现数据少了4行，原因是我们分别跳过了4行不同行</p><p>#skip_footer : int,default 0, 省略从尾部数的整数行数据 </p><p>pd.read_excel(r’Desktop\1.xls’ ,sheetname=’Sheet3’,header=None,skip_footer=8)<br>Out[13]:<br>      0   1   2   3     4<br>0   234  22  44  78   990<br>1   235  23  45  79   991<br>2   236  24  46  80   992<br>3   237  25  47  81   993<br>4   238  26  48  82   994<br>5   239  27  49  83   995<br>6   240  28  50  84   996<br>7   241  29  51  85   997<br>8   242  30  52  86   998<br>9   243  31  53  87   999<br>10  244  32  54  88  1000<br>11  245  33  55  89  1001<br>12  246  34  56  90  1002<br>13  247  35  57  91  1003</p><p>#从下向上数8行，然后跳过这8行</p><p>#index_col : int, list of ints, default None指定某列为索引列<br>pd.read_excel(r’Desktop\1.xls’ ,sheetname=’Sheet3’,header=None,index_col=4)<br>Out[15]:<br>        0   1   2   3<br>4<br>990   234  22  44  78<br>991   235  23  45  79<br>992   236  24  46  80<br>993   237  25  47  81<br>994   238  26  48  82<br>995   239  27  49  83<br>996   240  28  50  84<br>997   241  29  51  85<br>998   242  30  52  86<br>999   243  31  53  87<br>1000  244  32  54  88<br>1001  245  33  55  89<br>1002  246  34  56  90<br>1003  247  35  57  91<br>1004  248  36  58  92<br>1005  249  37  59  93<br>1006  250  38  60  94<br>1007  251  39  61  95<br>1008  252  40  62  96<br>1009  253  41  63  97<br>1010  254  42  64  98<br>1011  255  43  65  99</p><p>#上面指定第四列为索引列</p><p>#names : array-like, default None, 给所有列索引重新命名。</p><p>pd.read_excel(r’Desktop\1.xls’ ,sheetname=’Sheet3’,names=[‘col_1’,’col_2’,’col_3’,’col_4’,’col_5’])<br>Out[17]:<br>    col_1  col_2  col_3  col_4  col_5<br>0     235     23     45     79    991<br>1     236     24     46     80    992<br>2     237     25     47     81    993<br>3     238     26     48     82    994<br>4     239     27     49     83    995<br>5     240     28     50     84    996<br>6     241     29     51     85    997<br>7     242     30     52     86    998<br>8     243     31     53     87    999<br>9     244     32     54     88   1000<br>10    245     33     55     89   1001<br>11    246     34     56     90   1002<br>12    247     35     57     91   1003<br>13    248     36     58     92   1004<br>14    249     37     59     93   1005<br>15    250     38     60     94   1006<br>16    251     39     61     95   1007<br>17    252     40     62     96   1008<br>18    253     41     63     97   1009<br>19    254     42     64     98   1010<br>20    255     43     65     99   1011</p><p>#上面的列索引都被更换。</p><p>文本文件的块读取</p><p>如果只想读取数据一部分，或者数据过大，我们想逐步读取，我们可以通过附加属性函数来实现。</p><p>通过nrows属性函数可以选择所需要的行数<br>!type Desktop\example_14.csv<br>one,two,three,four<br>0,1,2,3<br>4,5,6,7<br>8,9,10,11<br>12,13,14,15<br>16,17,18,19<br>20,21,22,23<br>12,13,14,15<br>16,17,18,19<br>20,21,22,23<br>12,13,14,15<br>16,17,18,19<br>20,21,22,23<br>12,13,14,15<br>16,17,18,19<br>20,21,22,23<br>0,1,2,3<br>4,5,6,7<br>8,9,10,11<br>12,13,14,15<br>16,17,18,19<br>20,21,22,23<br>12,13,14,15<br>16,17,18,19</p><p>pd.read_table(‘Desktop\example_14.csv’,sep=’,’,nrows=8)<br>Out[21]:<br>   one  two  three  four<br>0    0    1      2     3<br>1    4    5      6     7<br>2    8    9     10    11<br>3   12   13     14    15<br>4   16   17     18    19<br>5   20   21     22    23<br>6   12   13     14    15<br>7   16   17     18    19</p><p>实验项目：数据的分块读取：</p><p>原始数据的部分截取：</p><p>block_2=pd.read_csv(‘Desktop\lockreading.csv’,chunksize=59)<br>key_quantity=pd.Series([])</p><p>#block_2是对整个数据分块后的返回值，可看做一个三维数据框，key_quantity是一个存储行编号数量的series</p><p>for block_var in block_2:<br>key_quantity=key_quantity.add(block_var[‘Key’].value_counts(),fill_value=0)</p><p>{千万注意：这里fill_value很重要，因为在循环过程中，由于相加的两个Seires的行标签不可能每一次都完全匹配，行标签不完全匹配的两个Series相加如果会产生空值，这种情况下会影响下次循环series的相加，因为空值+实数会继续产生空值，从而计数错误。为了消除这种现象的产生，最好的办法是每一次相加前的空值立马填充为‘0’值，这样杜绝空值产生，不会影响下一步两个series的相加。<br>看下面例子：<br>import pandas<br>import pandas as pd<br>serie_1=pd.Series([1,2,3],index=list(‘abc’))<br>serie_2=pd.Series([4,5,8],index=list(‘abd’))<br>serie_3=serie_1+serie_2<br>serie_3<br>Out[6]:<br>a    5.0<br>b    7.0<br>c    NaN<br>d    NaN<br>dtype: float64</p><p>#假如我们添加’fill_value=0‘<br>serie_1.add(serie_2,fill_value=0)<br>Out[8]:<br>a    5.0<br>b    7.0<br>c    3.0<br>d    8.0<br>dtype: float64       }</p><p>接下来我们继续我们的项目：<br>key_quantity=key_quantity.sort_values(ascending=False)<br>key_quantity</p><p>Out[16]:<br>Nr.36    10.0<br>Nr.30    10.0<br>Nr.32    10.0<br>Nr.33    10.0<br>Nr.34    10.0<br>Nr.35    10.0<br>Nr.37    10.0<br>Nr.38    10.0<br>Nr.39    10.0<br>Nr.29    10.0<br>Nr.40    10.0<br>Nr.41    10.0<br>Nr.28    10.0<br>Nr.27    10.0<br>Nr.26    10.0<br>Nr.25    10.0<br>Nr.24    10.0<br>Nr.23    10.0<br>Nr.31    10.0<br>Nr.42     9.0<br>Nr.21     7.0<br>Nr.20     7.0<br>Nr.2      7.0<br>Nr.19     7.0<br>Nr.18     7.0<br>Nr.17     7.0<br>Nr.22     7.0<br>Nr.15     7.0<br>Nr.14     7.0<br>Nr.3      7.0<br>Nr.13     7.0<br>Nr.12     7.0<br>Nr.11     7.0<br>Nr.10     7.0<br>Nr.16     7.0<br>Nr.9      7.0<br>Nr.8      7.0<br>Nr.52     7.0<br>Nr.7      7.0<br>Nr.6      7.0<br>Nr.59     7.0<br>Nr.58     7.0<br>Nr.57     7.0<br>Nr.56     7.0<br>Nr.55     7.0<br>Nr.54     7.0<br>Nr.53     7.0<br>Nr.51     7.0<br>Nr.4      7.0<br>Nr.50     7.0<br>Nr.5      7.0<br>Nr.49     7.0<br>Nr.48     7.0<br>Nr.47     7.0<br>Nr.46     7.0<br>Nr.45     7.0<br>Nr.44     7.0<br>Nr.43     7.0<br>Nr.1      7.0<br>dtype: float64</p><p>#上面这个Series左边是行编号，（注意不是行索引，行编号是key列中的值，它是每一行的编号），右边是每个编号在整个数据里出现的次数。</p><p>通过一个小函数我们能够瞬间遍查每个数据块寻找任何一个给定的行编号。</p><p>def search_rowindizies(str_test):<br>    list_1=[]<br>    for block_var in block_2:<br>        boll=block_var[‘Key’]==str_test<br>        st=block_var.loc[boll,:’A24’].values<br>        lst=st.astype(np.float32)</p><pre><code>    #alst=list(lst)    list_1.append(lst)return list_1</code></pre><p>block_2=pd.read_csv(‘Desktop\lockreading.csv’,chunksize=59)</p><p>search_rowindizies(‘Nr.42’)<br>Out[19]:<br>[array([[  4.57160000e+04,   2.33750000e+04,   2.23410000e+04,<br>           1.60100000e+03,   6.03000000e+02,   9.98000000e+02,<br>           2.27580000e+04,   1.01930000e+04,   1.25650000e+04,<br>           1.37070000e+04,   7.65300000e+03,   6.05400000e+03,<br>           4.13700000e+03,   2.58400000e+03,   1.55300000e+03,<br>           2.97900000e+03,   2.01500000e+03,   9.64000000e+02,<br>           5.19000000e+02,   3.16000000e+02,   2.03000000e+02,<br>           1.50000000e+01,   1.10000000e+01,   4.00000000e+00]], dtype=float32),<br> array([[  4.57160000e+04,   2.33750000e+04,   2.23410000e+04,<br>           1.60100000e+03,   6.03000000e+02,   9.98000000e+02,<br>           2.27580000e+04,   1.01930000e+04,   1.25650000e+04,<br>           1.37070000e+04,   7.65300000e+03,   6.05400000e+03,<br>           4.13700000e+03,   2.58400000e+03,   1.55300000e+03,<br>           2.97900000e+03,   2.01500000e+03,   9.64000000e+02,<br>           5.19000000e+02,   3.16000000e+02,   2.03000000e+02,<br>           1.50000000e+01,   1.10000000e+01,   4.00000000e+00]], dtype=float32),<br> array([[  4.57160000e+04,   2.33750000e+04,   2.23410000e+04,<br>           1.60100000e+03,   6.03000000e+02,   9.98000000e+02,<br>           2.27580000e+04,   1.01930000e+04,   1.25650000e+04,<br>           1.37070000e+04,   7.65300000e+03,   6.05400000e+03,<br>           4.13700000e+03,   2.58400000e+03,   1.55300000e+03,<br>           2.97900000e+03,   2.01500000e+03,   9.64000000e+02,<br>           5.19000000e+02,   3.16000000e+02,   2.03000000e+02,<br>           1.50000000e+01,   1.10000000e+01,   4.00000000e+00]], dtype=float32),<br> array([[  4.57160000e+04,   2.33750000e+04,   2.23410000e+04,<br>           1.60100000e+03,   6.03000000e+02,   9.98000000e+02,<br>           2.27580000e+04,   1.01930000e+04,   1.25650000e+04,<br>           1.37070000e+04,   7.65300000e+03,   6.05400000e+03,<br>           4.13700000e+03,   2.58400000e+03,   1.55300000e+03,<br>           2.97900000e+03,   2.01500000e+03,   9.64000000e+02,<br>           5.19000000e+02,   3.16000000e+02,   2.03000000e+02,<br>           1.50000000e+01,   1.10000000e+01,   4.00000000e+00]], dtype=float32),<br> array([[  4.57160000e+04,   2.33750000e+04,   2.23410000e+04,<br>           1.60100000e+03,   6.03000000e+02,   9.98000000e+02,<br>           2.27580000e+04,   1.01930000e+04,   1.25650000e+04,<br>           1.37070000e+04,   7.65300000e+03,   6.05400000e+03,<br>           4.13700000e+03,   2.58400000e+03,   1.55300000e+03,<br>           2.97900000e+03,   2.01500000e+03,   9.64000000e+02,<br>           5.19000000e+02,   3.16000000e+02,   2.03000000e+02,<br>           1.50000000e+01,   1.10000000e+01,   4.00000000e+00]], dtype=float32),<br> array([[  4.57160000e+04,   2.33750000e+04,   2.23410000e+04,<br>           1.60100000e+03,   6.03000000e+02,   9.98000000e+02,<br>           2.27580000e+04,   1.01930000e+04,   1.25650000e+04,<br>           1.37070000e+04,   7.65300000e+03,   6.05400000e+03,<br>           4.13700000e+03,   2.58400000e+03,   1.55300000e+03,<br>           2.97900000e+03,   2.01500000e+03,   9.64000000e+02,<br>           5.19000000e+02,   3.16000000e+02,   2.03000000e+02,<br>           1.50000000e+01,   1.10000000e+01,   4.00000000e+00]], dtype=float32),<br> array([[  4.57160000e+04,   2.33750000e+04,   2.23410000e+04,<br>           1.60100000e+03,   6.03000000e+02,   9.98000000e+02,<br>           2.27580000e+04,   1.01930000e+04,   1.25650000e+04,<br>           1.37070000e+04,   7.65300000e+03,   6.05400000e+03,<br>           4.13700000e+03,   2.58400000e+03,   1.55300000e+03,<br>           2.97900000e+03,   2.01500000e+03,   9.64000000e+02,<br>           5.19000000e+02,   3.16000000e+02,   2.03000000e+02,<br>           1.50000000e+01,   1.10000000e+01,   4.00000000e+00]], dtype=float32),<br> array([[  4.57160000e+04,   2.33750000e+04,   2.23410000e+04,<br>           1.60100000e+03,   6.03000000e+02,   9.98000000e+02,<br>           2.27580000e+04,   1.01930000e+04,   1.25650000e+04,<br>           1.37070000e+04,   7.65300000e+03,   6.05400000e+03,<br>           4.13700000e+03,   2.58400000e+03,   1.55300000e+03,<br>           2.97900000e+03,   2.01500000e+03,   9.64000000e+02,<br>           5.19000000e+02,   3.16000000e+02,   2.03000000e+02,<br>           1.50000000e+01,   1.10000000e+01,   4.00000000e+00],<br>        [  4.57160000e+04,   2.33750000e+04,   2.23410000e+04,<br>           1.60100000e+03,   6.03000000e+02,   9.98000000e+02,<br>           2.27580000e+04,   1.01930000e+04,   1.25650000e+04,<br>           1.37070000e+04,   7.65300000e+03,   6.05400000e+03,<br>           4.13700000e+03,   2.58400000e+03,   1.55300000e+03,<br>           2.97900000e+03,   2.01500000e+03,   9.64000000e+02,<br>           5.19000000e+02,   3.16000000e+02,   2.03000000e+02,<br>           1.50000000e+01,   1.10000000e+01,   4.00000000e+00]], dtype=float32)]</p><p>#每次执行函数都要调用一次block_2,因为数据用完一次后自动与源数据断开，Block_2自动清零消失<br>到此为止，我们的项目结束！！</p><p>把数据下载到csv 文件<br>DataFrame_1=pd.DataFrame(np.arange(16).reshape(4,4),index=list(‘asdt’),columns=list(‘sgdt’))</p><p>DataFrame_1<br>Out[5]:<br>    s   g   d   t<br>a   0   1   2   3<br>s   4   5   6   7<br>d   8   9  10  11<br>t  12  13  14  15</p><p>DataFrame_1.to_csv(‘Desktop\DataFrame_1.csv’)</p><p>#数据储存到桌面，文件名是DataFrame_1。默认情况下，To_csv方法只会把数据存为用逗号隔开的csv数据。我们可以通过!type函数直接调用这个已存到桌面上的文件，就会发现它的确如此，如下：</p><p>!type Desktop\DataFrame_1.csv<br>,s,g,d,t<br>a,0,1,2,3<br>s,4,5,6,7<br>d,8,9,10,11<br>t,12,13,14,15</p><p>#上面是没有转化为数据框的源数据格式，也就是csv文件的直接调取。<br>当然，我们也可以直接将数据直接存其它分割方式，例如下面的例子</p><p>DataFrame_1.to_csv(‘Desktop\DataFrame_2.csv’,sep=’#’)</p><p>!type Desktop\DataFrame_2.csv</p><p>#s#g#d#t<br>a#0#1#2#3<br>s#4#5#6#7<br>d#8#9#10#11<br>t#12#13#14#15</p><p>DataFrame_2=DataFrame_1.copy()</p><p>DataFrame_2.loc[‘a’,’s’]=np.nan</p><p>DataFrame_2<br>Out[32]:<br>      s   g   d   t<br>a   NaN   1   2   3<br>s   4.0   5   6   7<br>d   8.0   9  10  11<br>t  12.0  13  14  15</p><p>DataFrame_2.to_csv(‘Desktop\DataFrame_3.csv’)</p><p>!type Desktop\DataFrame_3.csv<br>,s,g,d,t<br>a,,1,2,3<br>s,4.0,5,6,7<br>d,8.0,9,10,11<br>t,12.0,13,14,15</p><p>#再重新通过！type指令调回已存储的文件后，发现数据框原有的NaN值变成空位置，然而，空位置在csv文件中并不好辨认，因此我们需要把含有nan值的数据框存储为nan值被指定的容易辨认的符号替代的csv文件。</p><p>DataFrame_2<br>Out[50]:<br>      s   g   d   t<br>a   NaN   1   2   3<br>s   4.0   5   6   7<br>d   8.0   9  10  11<br>t  12.0  13  14  15</p><p>DataFrame_2.to_csv(‘Desktop\DataFrame_4.csv’,na_rep=’Cat’)<br>!type Desktop\DataFrame_4.csv<br>,s,g,d,t<br>a,Cat,1,2,3<br>s,4.0,5,6,7<br>d,8.0,9,10,11<br>t,12.0,13,14,15</p><p>#用!type调用储存在桌面的文件DataFrame_4.csv，我们会发现原来在数据框的NaN值在存储后被‘Cat’替代</p><p>这里我们要注意空位置与空字符串不一样<br>试比较：</p><p>pd.read_csv(‘Desktop\example_16.csv’)<br>Out[42]:<br>     a    b    c   d<br>0  ‘ ‘  123  456  89<br>1   22   65  ‘ ‘  12<br>2  345   89    0   6<br>3   23  ‘ ‘   33  66</p><p>!type Desktop\example_16.csv<br>a,b,c,d<br>‘ ‘,123,456,89<br>22,65,’ ‘,12<br>345,89,0,6<br>23,’ ‘,33,66</p><p>上面是空字符串</p><p>pd.read_csv(‘Desktop\example_17.csv’)<br>Out[44]:<br>       a      b      c   d<br>0    NaN  123.0  456.0  89<br>1   22.0   65.0    NaN  12<br>2  345.0   89.0    0.0   6<br>3   23.0    NaN   33.0  66</p><p>!type Desktop\example_17.csv<br>a,b,c,d<br>,123,456,89<br>22,65,,12<br>345,89,0,6<br>23,,33,66</p><p>上面是空位置，空位置再读取成数据框时会产生NaN值。</p><p>如果没有特殊指定，数据框行和列的标签会随数据一起存储为csv文件，当然我们也可以不这样。如下：</p><p>DataFrame_1<br>Out[51]:<br>    s   g   d   t<br>a   0   1   2   3<br>s   4   5   6   7<br>d   8   9  10  11<br>t  12  13  14  15</p><p>DataFrame_1.to_csv(‘Desktop\Dataframe_12.csv’,index=False,header=False)</p><p>!type Desktop\Dataframe_12.csv<br>0,1,2,3<br>4,5,6,7<br>8,9,10,11<br>12,13,14,15</p><p>我们发现行标签和列标签都不见了。</p><p>我们还可以只存储数据框的部分列，并指定顺序：</p><p>DataFrame_1.to_csv(‘Desktop\Dataframe_13.csv’,index=False,columns=[‘s’,’t’,’d’])</p><p>调用存储文件，测试！！</p><p>!type Desktop\Dataframe_13.csv<br>s,t,d<br>0,3,2<br>4,7,6<br>8,11,10<br>12,15,14</p><p>我们发现只有部分列被存储，且列的顺序按照指定。</p><p>Series 也可以通过to_csv来存储信息到桌面。<br>dates_1=pd.date_range(‘01/06/2017’,periods=14)</p><p>dates_1<br>Out[60]:<br>DatetimeIndex([‘2017-01-06’, ‘2017-01-07’, ‘2017-01-08’, ‘2017-01-09’,<br>               ‘2017-01-10’, ‘2017-01-11’, ‘2017-01-12’, ‘2017-01-13’,<br>               ‘2017-01-14’, ‘2017-01-15’, ‘2017-01-16’, ‘2017-01-17’,<br>               ‘2017-01-18’, ‘2017-01-19’],<br>              dtype=’datetime64[ns]’, freq=’D’)<br>series_12=pd.Series(np.arange(14),index=dates_1)<br>series_12.to_csv(‘Desktop\series_123.csv’)<br>!type Desktop\series_123.csv<br>2017-01-06,0<br>2017-01-07,1<br>2017-01-08,2<br>2017-01-09,3<br>2017-01-10,4<br>2017-01-11,5<br>2017-01-12,6<br>2017-01-13,7<br>2017-01-14,8<br>2017-01-15,9<br>2017-01-16,10<br>2017-01-17,11<br>2017-01-18,12<br>2017-01-19,13</p><p>csv文件也可以从桌面直接被读取成Series：<br>pd.Series.from_csv(‘Desktop\series_123.csv’)<br>Out[71]:<br>2017-01-06     0<br>2017-01-07     1<br>2017-01-08     2<br>2017-01-09     3<br>2017-01-10     4<br>2017-01-11     5<br>2017-01-12     6<br>2017-01-13     7<br>2017-01-14     8<br>2017-01-15     9<br>2017-01-16    10<br>2017-01-17    11<br>2017-01-18    12<br>2017-01-19    13<br>dtype: int64</p><p>注：<br>1.Read_csv可以读取文件，url，文件型对象，但被加载文件必须有分割符，默认的分割符为逗号。<br>2.Read_table可以读取文件，url，文件型对象，但被加载文件必须有分割符，默认的分割符为制表符‘\t’。这一点与read_csv不同，烦请再加载有逗号的数据时用seq属性注明，也即seq=‘，’！<br>3.Read_fwf读取（或称加载）没有分隔符数据，但是各数据之间间距要恒定。<br>4.Read_clipboard 通常用来读取网络数据,在使用前，必须把网页内容先复制到粘贴板上，例如：</p><p>pd.read_clipboard(sep=’\s+’)<br>Out[73]:<br>     北      京  220956  209468   11488  697.02  264.30  253555   44087  701.42<br>0    天      津   93162   90080    3082  330.68  126.98  106063   15983  340.10<br>1    河      北  209740  200012    9728  963.39  327.27  262396   62384  982.31<br>2    山      西  131802  114466   17336  628.55  192.27  214625  100159  669.39<br>3  内蒙古  71196   65627    5569  306.82  110.15  101829   36202  308.10<br>4    　      　       　       　       　       　       　       　       　NaN<br>5    辽      宁  211502  199611   11891  838.09  305.58  268741   69130  846.25</p><p>上面函数常用关键字列表</p><p>filepath_or_buffer:     文件系统位置，url，文件型对象的字符串<br>delimiter或sep    源文件各数据间分隔符或正则表达式<br>header    上载数据成数据框时，数据框的列名，默认为上载数据的第一行。即‘0’行。如果不需要列标签，那么使header=None<br>index_col    就是给行层次化索引命名，行层次索引一般有两列，内列和外列。<br>skiprows    需要忽略的行数，跳过无用行<br>na_values    实质就是把源数据中的指定字符串转化为空值。<br>converters    由列名或者说列号或者说列标签和函数组成字典，例如{‘A’:f}说明f函数应用到’A’列中的每一个数据。<br>nrows    需要读取的数据行数<br>skip_footer    需要忽略的行数，注意从源数据最后一行向上数<br>encoding    用于指明unicode文本文件的文本编码格式<br>Squeeze    如果数据仅有一列，自动返回series<br>thousands    千分位分隔符，如’.’或’,’</p><p>converters的应用：</p><p>1.数据框的元素作为字符穿处理<br>In [1]: import pandas as pd</p><p>In [2]: import numpy as np</p><p>In [3]: Data_1=pd.DataFrame([[1,2,1],[3,4,2],[3,5,4]],columns=[‘A’,’B’,’C’],index=[‘r1’,’r2’,’r3’])</p><p>In [4]: Data_1<br>Out[4]:<br>A B C<br>r1 1 2 1<br>r2 3 4 2<br>r3 3 5 4</p><p>In [7]: Data_1.to_csv(r’Desktop\dong1234.csv’,sep=’,’)</p><p>In [8]: pd.read_csv(‘Desktop\dong1234.csv’,delimiter=’,’,usecols=[‘A’,’B’,’C’])<br>Out[8]:<br>A B C<br>0 1 2 1<br>1 3 4 2<br>2 3 5 4</p><p>In [10]: pd.read_csv(‘Desktop\dong123.csv’,delimiter=’,’,usecols=[‘A’,’B’,’C’],converters={‘B’:lambda x:x*2})<br>Out[10]:<br>A B C<br>0 1 22 1<br>1 3 44 2<br>2 3 55 4</p><p>In [11]: pd.read_csv(‘Desktop\dong123.csv’,delimiter=’,’,usecols=[‘A’,’B’,’C’],converters={‘B’:lambda x:x*2+’1’})<br>Out[11]:<br>A B C<br>0 1 221 1<br>1 3 441 2<br>2 3 551 4</p><p>In [12]: pd.read_csv(‘Desktop\dong123.csv’,delimiter=’,’,usecols=[‘A’,’B’,’C’],converters={‘B’:lambda x:x<em>2</em>3+’1’})<br>    …:<br>Out[12]:<br>A B C<br>0 1 2222221 1<br>1 3 4444441 2<br>2 3 5555551 4<br>2.数据框的元素作为数据处理</p><p>In [14]: pd.read_csv(‘Desktop\dong123.csv’,delimiter=’,’,usecols=[‘A’,’B’,’C’],converters={‘B’:lambda x:float(x)*<em>3+2</em>float(x)})<br>Out[14]:<br>A B C<br>0 1 12.0 1<br>1 3 72.0 2<br>2 3 135.0 4</p><p>In [15]: import math<br>In [21]: converters_1={i: lambda x:float(x)*<em>3+math.sin((np.pi/6)</em>float(x)) for i in range(3)}</p><p>In [22]: converters_1<br>Out[22]:<br>{0: &lt;function <strong>main</strong>.<dictcomp>.<lambda>&gt;,<br>1: &lt;function <strong>main</strong>.<dictcomp>.<lambda>&gt;,<br>2: &lt;function <strong>main</strong>.<dictcomp>.<lambda>&gt;}</lambda></dictcomp></lambda></dictcomp></lambda></dictcomp></p><p>In [23]: pd.read_csv(‘Desktop\dong123.csv’,delimiter=’,’,usecols=[‘A’,’B’,’C’],converters=converters_1)<br>Out[23]:<br>A B C<br>0 1.5 8.866025 1<br>1 28.0 64.866025 2<br>2 28.0 125.500000 4</p><p>分隔符格式的手工处理<br>通常用read_table或者read_csv直接加载csv文件或者TXT文件都是没有问题的，但有时csv文件十分混乱，以致无法加载，也是十分常见的，这就要求我们在加载前要对原始csv文件进行处理，使其能够被顺利加载。</p><p>我们先看一个单字符分隔符文件<br>import pandas as pd</p><p>import numpy as np</p><p>!type Desktop\example_20.csv<br>“f”,”g”,”h”,”d”<br>“1”,”1”,”4”,”5”<br>“7”,”9”,”0”,”4”<br>“2”,”8”,”11”,0<br>import csv<br>调用内置csv模块，将已打开文件直接传给csv.reader<br>f=open(‘Desktop\example_20.csv’)<br>getting_1=csv.reader(f)<br>getting_1<br>Out[25]: &lt;_csv.reader at 0x3077b74320&gt;</p><p>#我们无法看到getting_1的庐山真面目，怎么办？通过for循环，我们看到getting_1中的每个元素。这是一个十分好的方法，请大家务必注意：<br>for subgetting in getting_1:<br>    print(subgetting)</p><p>[‘f’, ‘g’, ‘h’, ‘d’]<br>[‘1’, ‘1’, ‘4’, ‘5’]<br>[‘7’, ‘9’, ‘0’, ‘4’]<br>[‘2’, ‘8’, ‘11’, ‘0’]<br>我下面再举一个具体的例子：</p><p>range(1,9,1)<br>Out[27]: range(1, 9)<br>for subrange in range(1,9,1):<br>    print(subrange)</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>当然这里我们还有一个终极解决方案，也就是通过list。<br>Gate_1=list(csv.reader(open(‘Desktop\example_20.csv’)))<br>Gate_1<br>Out[32]:<br>[[‘f’, ‘g’, ‘h’, ‘d’],<br> [‘1’, ‘1’, ‘4’, ‘5’],<br> [‘7’, ‘9’, ‘0’, ‘4’],<br> [‘2’, ‘8’, ‘11’, ‘0’]]</p><p>#直到这里我们终于看到了csv.reader()的庐山真面目。</p><p>header,values=Gate_1[0],Gate_1[1:]</p><p>dic_new_1={u:v for u,v in zip(header,zip(*values))}</p><p>dic_new_1<br>Out[36]:<br>{‘d’: (‘5’, ‘4’, ‘0’),<br> ‘f’: (‘1’, ‘7’, ‘2’),<br> ‘g’: (‘1’, ‘9’, ‘8’),<br> ‘h’: (‘4’, ‘0’, ‘11’)}</p><p>最终我们把相对杂乱无章的数据转化为规整的字典。</p><p>解释：zip（<em>2dim-Array）<br>这个操作相当于把嵌套列表每一行一一对应先组成元组，然后组成列表：<br>c=[[1,2,3],[4,7,0]]<br>zip(</em>c)<br>Out[40]: <zip at 0x3077b9ce08><br>list(zip(*c))<br>Out[41]: [(1, 4), (2, 7), (3, 0)]</zip></p><p>我们可以自定义csv文件的读取或写入格式：<br>Import csv<br>class mydialect(csv.Dialect):<br>    lineterminator = ‘\n’ #用于写操作时的行结束符，读操作时将忽略此项，也就是读操作时无需在文件数据行尾处加‘\n’<br>    delimiter = ‘#’ #可以读取用‘#’分割的字段（或者数据）<br>quotechar=’”‘ #用于带有特殊字符的字段（通常指的是带有单引号的字符串）的引用符号，例如源数据这样的字段’12#3’通过csv.reader函数读取到python程序页面后会变成”’12”,”3’”。<br>quoting=csv.QUOTE_ALL #读取所有字段（和数据）<br>skipinitialspace=True #或略分隔符后面的空格<br>doublequote=True #如果读取的字段含有引用符号，则整个字段加双引号。</p><p>下面是一个比较简单的例子：<br>Import csv<br>class mydialect(csv.Dialect):<br>    lineterminator = ‘\n’<br>    delimiter = ‘#’<br>    quotechar=’”‘<br>    quoting=csv.QUOTE_ALL<br>    skipinitialspace=True<br>    doublequote=True</p><p>myfile_1=open(‘Desktop\example_223.csv’)</p><p>content_11=csv.reader(myfile_1,dialect=mydialect)</p><p>for contents in content_11:</p><pre><code>print(contents)</code></pre><p>[‘At’, ‘bee’, ‘cotton’, ‘death’, “common’hero’tree”]<br>[‘1’, ‘2’, ‘3’, ‘4’]<br>[‘5’, ‘6’, ‘7’, ‘8’, ‘9’]<br>[‘9’, ‘10’, ‘11’, ‘12’, “‘12”, “3’”]</p><p>!type Desktop\example_223.csv<br>At#bee#cotton#  death#common’hero’tree<br>1#2#  3#4<br>5#6#7#8#9<br>9#10#11#12#’12#3’</p><p>我们上面一直在讨论通过定义csv.Dialect的一个子类来读取独有格式的csv，下面我们谈谈写入</p><p>class mydialect(csv.Dialect):<br>    lineterminator = ‘\n’<br>    delimiter = ‘#’<br>    quotechar=’”‘<br>    quoting=csv.QUOTE_ALL<br>    skipinitialspace=True<br>doublequote=True</p><p>with open(‘Desktop\example_25.csv’,’w’) as newsetting_1: #首先open()函数打开文件’Desktop\example_25.csv’，如果不存在这个文件，则创建它，返回文件对象newsetting_1。<br>     writer_object=csv.writer(newsetting_1,dialect=mydialect) #创建一个写对象’writer_object’，可理解成给打开文件添加独有编码风格“mydialect”。然后返回一个带有独有编码风格的新文件对象<br>     writer_object.writerow([“‘one’”,0,  8]) #可通过列表把内容一步步地写入到打开的文件<br>     writer_object.writerow([‘two’,62,43])<br>     mylist=[[‘three’,46,88],[‘four’,  3,12]]<br>     writer_object.writerows(mylist)</p><p>!type Desktop\example_25.csv<br>one’#”0”#”8”<br>two#”62”#”43”<br>three#”46”#”88”<br>four#”3”#”12”</p><p>JSON数据<br>JSON是一种数据格式，它是通过HTTP请求在web浏览器与其他应用程序之间数据传送格式之一。</p><p>例如：<br>Json_documents=”””<br>{“Name”:”Wes”,”places_lived”:[“United States”,”Spain”,”Germany”,”Japan”],”pet”:null,”siblings”:[{“name”:”Scott”,”age”:25,”pet”:”Zuko”,”weight”:56,”height”:172},{“name”:”Katie”,”age”:33,”pet”:”Cisco”,”weight”:89,”height”:189}]}<br>“””<br>这是一个Json数据格式字符串数据对象，可以通过python标准库中的json.loads函数即可将JSON字符串数据转化为python字符串数据。</p><p>import json</p><p>getting_1=json.loads(Json_documents)</p><p>getting_1<br>Out[36]:<br>{‘Name’: ‘Wes’,<br> ‘pet’: None,<br> ‘places_lived’: [‘United States’, ‘Spain’, ‘Germany’, ‘Japan’],<br> ‘siblings’: [{‘age’: 25,<br>   ‘height’: 172,<br>   ‘name’: ‘Scott’,<br>   ‘pet’: ‘Zuko’,<br>   ‘weight’: 56},<br>  {‘age’: 33, ‘height’: 189, ‘name’: ‘Katie’, ‘pet’: ‘Cisco’, ‘weight’: 89}]}</p><p>试比较这两种数据结构，我们会发现：<br>A.JSON格式的字符串数据对象的字符串没有排序，确切的说字典或者说JSON对象的键和其所对应的子字典内容都没有任何排序。而python格式的字典缺有严格工整的排序，无论键还是键所对应的字典都有严格排序。<br>B.所有字符串的双引号都变成单引号<br>C.JSON格式的字典最前面和最后面都有‘”””’（也可用“’”）标识，转化成Python格式后所有标识全部消失。<br>D.JSON的空值用null表达，Python用None表达。</p><p>有一点我们必须要注意，JSON格式的对象（JSON有对象（即字典）、数组、字符串、数字，bool值以及null等数据结构）的键必须是字符串。如果不是字符串将会在转换时出现错误提示:<br>Json_documents=”””<br>{23:”Wes”,”places_lived”:[“United States”,”Spain”,”Germany”,”Japan”],”pet”:null,”siblings”:[{“name”:”Scott”,”age”:25,”pet”:”Zuko”,”weight”:56,”height”:172},{“name”:”Katie”,”age”:33,”pet”:”Cisco”,”weight”:89,”height”:189}]}<br>“””</p><h2 id="getting-1-json-loads-Json-documents"><a href="#getting-1-json-loads-Json-documents" class="headerlink" title="getting_1=json.loads(Json_documents)"></a>getting_1=json.loads(Json_documents)</h2><p>JSONDecodeError                           Traceback (most recent call last)</p><p><ipython-input-38-66d19b29dad0> in <module>()<br>—-&gt; 1 getting_1=json.loads(Json_documents)</module></ipython-input-38-66d19b29dad0></p><p>~\Anaconda3\lib\json__init__.py in loads(s, encoding, cls, object_hook, parse_float, parse_int, parse_constant, object_pairs_hook, **kw)<br>    352             parse_int is None and parse_float is None and<br>.<br>.<br>.<br>    357             raise JSONDecodeError(“Expecting value”, s, err.value) from None</p><p>JSONDecodeError: Expecting property name enclosed in double quotes: line 2 column 2 (char 2)</p><p>我们当然也可以把python格式的数据对象转化为JSON格式，使用python的函数json.dumps可以实现这一愿望：<br>例子：</p><p>python_format_1={‘Name’: ‘Wes’,<br> ‘pet’: None,<br> ‘places_lived’: [‘United States’, ‘Spain’, ‘Germany’, ‘Japan’],<br> ‘siblings’: [{‘age’: 25,<br>   ‘height’: 172,<br>   ‘name’: ‘Scott’,<br>   ‘pet’: ‘Zuko’,<br>   ‘weight’: 56},<br>  {‘age’: 33, ‘height’: 189, ‘name’: ‘Katie’, ‘pet’: ‘Cisco’, ‘weight’: 89}]}</p><p> json_format_1=pd.json.dumps(python_format_1)</p><p>json_format_1<br>Out[6]:’{“Name”:”Wes”,”pet”:null,”places_lived”:[“United States”,”Spain”,”Germany”,”Japan”],”siblings”:[{“age”:25,”height”:172,”name”:”Scott”,”pet”:”Zuko”,”weight”:56},{“age”:33,”height”:189,”name”:”Katie”,”pet”:”Cisco”,”weight”:89}]}’</p><p>再把json格式数据转化为python数据格式后，我们需要把数据作进一步处理，以便我们更好的处理数据。最常用的做法是把数据继续转化为数据框：</p><p>newDataFrame=pd.DataFrame(python_format_1[‘siblings’])</p><p>newDataFrame<br>Out[8]:<br>   age  height   name    pet  weight<br>0   25     172  Scott   Zuko      56<br>1   33     189  Katie  Cisco      89<br>python_format_1[‘siblings’]表示的是一个由字典组成的列表，通过它可以直接生成一个数据框，这是一个很好的数据框创建方法。我们下面一起做一些用这种模式创建数据框的练习：</p><p>例子1：<br>dict_1={‘c1’:[1,2,3,4,5],’c2’:[21,65,32,90,0],’c3’:[90,67,5,6,3],’c4’:[1,2,1,2,0],’c5’:[9,0,8,7,0]}</p><p>dict_2={‘c1’:[1,3,3,4,5],’c2’:[21,5,32,90,3],’c3’:[90,7,5,6,3],’c4’:[1,2,155,2,0],’c5’:[9,450,8,7,0]}<br>newframe_0=pd.DataFrame(dict_1)</p><p>newframe_0<br>Out[19]:<br>   c1  c2  c3  c4  c5<br>0   1  21  90   1   9<br>1   2  65  67   2   0<br>2   3  32   5   1   8<br>3   4  90   6   2   7<br>4   5   0   3   0   0</p><p>例子2：<br>newframe_0=pd.DataFrame([dict_1])<br>newframe_0<br>Out[17]:<br>    c1            c2              c3             c4      \<br>0  [1, 2, 3, 4, 5]  [21, 65, 32, 90, 0]  [90, 67, 5, 6, 3]  [1, 2, 1, 2, 0]   </p><pre><code>c5  </code></pre><p>0  [9, 0, 8, 7, 0]  </p><p>例子3：<br>newframe_1=pd.DataFrame([dict_1,dict_2]):<br>newframe_1<br>Out[15]:<br>     c1             c2            c3                c4  \<br>0  [1, 2, 3, 4, 5]  [21, 65, 32, 90, 0]  [90, 67, 5, 6, 3]    [1, 2, 1, 2, 0]<br>1  [1, 3, 3, 4, 5]   [21, 5, 32, 90, 3]   [90, 7, 5, 6, 3]  [1, 2, 155, 2, 0]   </p><pre><code>c5  </code></pre><p>0    [9, 0, 8, 7, 0]<br>1  [9, 450, 8, 7, 0]<br>例子4<br>dic_3={‘c6’:[1,3,3,4,5],’c7’:[21,5,32,90,3],’c8’:[90,7,5,6,3],’c9’:[1,2,155,2,0],’c10’:[9,450,8,7,0]}<br>newFrame_4=pd.DataFrame([dict_1,dic_3])<br>newFrame_4<br>Out[22]:<br>      c1                    c10                 c2               c3       \<br>0  [1, 2, 3, 4, 5]              NaN               [21, 65, 32, 90, 0]  [90, 67, 5, 6, 3]<br>1      NaN               [9, 450, 8, 7, 0]             NaN            NaN   </p><pre><code>c4               c5                  c6                  c7       \</code></pre><p>0  [1, 2, 1, 2, 0]       [9, 0, 8, 7, 0]              NaN              NaN<br>1    NaN              NaN               [1, 3, 3, 4, 5]      [21, 5, 32, 90, 3]   </p><pre><code>c8             c9  </code></pre><p>0    NaN          NaN<br>1  [90, 7, 5, 6, 3]  [1, 2, 155, 2, 0]  </p><p>#数据框的列索引由字典的键确定，字典列表中的有多少字典键就有多少列，譬如字典列表的第一个字典（0位置字典）有5个键，第二个字典（1位置字典）有5个键，那么生成的数据框就有10个列。字典列表的长度代表了行的数量，就如例子中字典列表的长度是2，那么数据框就有两行，0行和1行。</p><p>通过columns我们可以指定需要显示的数据列：</p><p>newframe_5=pd.DataFrame([dict_1,dict_2],columns=[‘c2’,’c3’])</p><p>newframe_5<br>Out[24]:<br>     c2               c3<br>0  [21, 65, 32, 90, 0]  [90, 67, 5, 6, 3]<br>1   [21, 5, 32, 90, 3]   [90, 7, 5, 6, 3]</p><p>数据的二进制格式存储</p><p>定义：将对象转换为可通过网络传输或可以存储到本地磁盘的数据格式的过程称为序列化；反之，则称为反序列化。Python内置的pickle序列化用于实现Python数据类型与Python特定二进制格式之间的转换。<br>import pandas as pd<br>frame_1=pd.read_csv(‘Desktop\exampel_6.csv’)<br>frame_1=pd.read_csv(‘Desktop\exampel_6.csv’,sep=’\s+’)</p><p>frame_1<br>Out[6]:<br>         A      B      C’<br>aaa -3.450  2.360   8.90’<br>bbb  0.334  0.457   -4.5’<br>ccc  0.760 -7.340  -8.99’<br>ddd  0.370 -7.800  -4.45’</p><p>frame_1.to_pickle(‘Desktop\frame_pickle’)</p><p>#上面我们把frame_1存储成pickle格式<br>我们也可以把数据读回到python。</p><p>import pickle<br>load_file=open(‘Desktop\Frame_pickle’,’rb’)</p><p>pickle.load(load_file)<br>Out[17]:<br>         A      B      C’<br>aaa -3.450  2.360   8.90’<br>bbb  0.334  0.457   -4.5’<br>ccc  0.760 -7.340  -8.99’<br>ddd  0.370 -7.800  -4.45’</p><p>HDF5的存取</p><p>Hierarchical Data Format(HDF)是一种针对大量数据进行组织和存储的文件格式。它包含了数据模型，库，和文件格式标准。以其便捷有效，移植性强，灵活可扩展的特点受到了广泛的关注和应用。</p><p>对大数据的组织和存储得益于HDF文件的系统式节点结构，这样的结构不仅支持元数据，而且使多数据集存储成为现实。</p><p>Python中的HDF5库有两个接口Pytables和h5py。</p><p>我们先看一下h5py，h5py是python的一种工具包，它提供了一种直接而高级的HDF5 API访问接口。</p><p>import h5py<br>import numpy as np</p><p>#HDF5的写入<br>Intentity_12=np.ones((10,12,300,305))<br>data_h5py_1=h5py.File(‘Desktop\example_29-1.h5’,’w’)</p><p>#创建一个h5文件<br>data_h5py_1[‘data’]=Intentity_12</p><p>#把数据写入到data_h5py_1主键‘data’中<br>data_h5py_1[‘labels’]=range(120)</p><p>#把数据写入到data_h5py_1主键‘labels’中<br>data_h5py_1.close()</p><p>#HDF5的读取<br>data_h5py_2=h5py.File(‘Desktop\example_29-1.h5’,’r’)</p><p>#h5文件的读取<br>key_content=data_h5py_2.keys()</p><p>#所有键的查看<br>abc_123=data_h5py_2[‘data’][:]</p><p>#查看主键‘data’的内容<br>data_h5py_2[‘labels’][:]</p><p>#查看主键‘labels’的内容</p><p>我们再看另一种接口Pytables，Pytables也是python的一种工具包，它抽像了许多HDF5的细节以提供多种灵活数据容器，及实现表索引和查询功能。</p><p>import pandas as pd<br>store=pd.HDFStore(‘Desktop\example_30.h5’,’w’)</p><p>#通过HDFStore创建一个h5文件<br>getframe_1=pd.DataFrame(np.arange(16).reshape(4,4),index=[‘r1’,’r2’,’r3’,’r4’],columns=[‘c1’,’c2’,’c3’,’c4’])<br>store[‘layer_1’]=getframe_1<br>store[‘layer_1_1’]=getframe_1[‘c2’]<br>store<br>Out[50]: </p><p><class 'pandas.io.pytables.hdfstore'><br>File path: Desktop\example_30.h5<br>/layer_1              frame        (shape-&gt;[4,4])<br>/layer_1_1            series       (shape-&gt;[4])<br>store[‘layer_1’][‘c4’]<br>Out[51]:<br>r1     3<br>r2     7<br>r3    11<br>r4    15<br>Name: c4, dtype: int32</class></p><p>注意：<br>1.HDF5最好一次写入，不要多次写入,以免破坏文件<br>2.创建H5文件时，各种文件类型。<br>r：只能读<br>r+：可读可写，不会创建不存在的文件。如果直接写文件，则从顶部开始写，覆盖之前此位置的内容，如果先读后写，则会在文件最后追加内容。<br>w：只能写，覆盖整个文件，文件不存在则创建<br>a：只能写，从文件底部添加内容，文件不存在则创建</p><p>数据的合并<br>常用的数据合并函数有pandas.merge和pandas.contact以及combine_first。它们分别有着各自的应用条件。我们根据实际情况选取合适的函数来进行数据合并。</p><p>1.pandas.merge<br>通过merge函数可以实现数据框的合并，但这种合并要经过一个或多个键的衔接，这就要求我们必须在数据框中专门添加一个‘Key’列用于衔接。<br>例1：<br>Frame_1=pd.DataFrame({‘schluessel’:[‘Nr.1’,’Nr.2’,’Nr.3’,’Nr.4’,’Nr.5’],’values_1’:[1,2,2,8,9],’values_2’:[4,7,9,0,1]})</p><p>Frame_2=pd.DataFrame({‘schluessel’:[‘Nr.1’,’Nr.1’,’Nr.3’,’Nr.3’,’Nr.5’],’values_1’:[1,2,2,8,9],’values_2’:[4,7,9,0,1]})</p><p>Frame_1<br>Out[28]:<br>  schluessel  values_1  values_2<br>0       Nr.1         1         4<br>1       Nr.2         2         7<br>2       Nr.3         2         9<br>3       Nr.4         8         0<br>4       Nr.5         9         1</p><p>Frame_2<br>Out[29]:<br>  schluessel  values_1  values_2<br>0       Nr.1         1         4<br>1       Nr.1         2         7<br>2       Nr.3         2         9<br>3       Nr.3         8         0<br>4       Nr.5         9         1</p><p>pd.merge(Frame_2,Frame_1,on=’schluessel’)<br>Out[27]:<br>  schluessel  values_1_x  values_2_x  values_1_y  values_2_y<br>0       Nr.1           1           4           1           4<br>1       Nr.1           2           7           1           4<br>2       Nr.3           2           9           2           9<br>3       Nr.3           8           0           2           9<br>4       Nr.5           9           1           9           1</p><p>多对一（重复键列对不重复键列）内连接注意事项<br>每次合并前都要指定作为键的列，比如上面我们指定“schluessel”<br>作为键的列如有重复键要保留，不要去重，看另一个待合并数据框有没有这个键，如果有，把相同的键合并到一起。<br>如果某些键在各自数据框中都没有重复现象，但是两个数据框相比这些键相同，那么要把两个键合并到一起。<br>如果某些键在各自数据框中都没有重复现象，且两个数据框相比这些键也不相同，那么这些键将不出现在合并后的键列里</p><p>注意：默认是内连接</p><p>如果键名不同，我们可以通过关键字“left_on”和“right_on”分别安置：<br>frame_2=pd.DataFrame({‘rkey’:[‘a’,’c’,’d’],’data_2’:[3,2,1]})</p><p>frame_1=pd.DataFrame({‘lkey’:[‘a’,’a’,’c’,’a’,’b’,’c’,’d’,’b’],’data_1’:[2,6,9,3,2,1,0,5]})</p><p>pd.merge(frame_1,frame_2,left_on=’lkey’,right_on=’rkey’)<br>Out[5]:<br>   data_1 lkey  data_2 rkey<br>0       2    a       3    a<br>1       6    a       3    a<br>2       3    a       3    a<br>3       9    c       2    c<br>4       1    c       2    c<br>5       0    d       1    d</p><p>在默认的条件下，合并后的键是两个数据框的键的交集，例如上面的例子均是如此，这种键的合并方式被称作内连接，除了内连接还有左连接、右连接以及外连接。下满我们分别比较这几种方式：</p><p>frame_2=pd.DataFrame({‘sl’:[‘a’,’c’,’d’,’f’],’data_2’:[3,2,1,7]})<br>frame_1=pd.DataFrame({‘sl’:[‘a’,’a’,’c’,’a’,’b’,’c’,’d’,’b’],’data_1’:[2,6,9,3,2,1,0,5]})</p><p>pd.merge(frame_1,frame_2,on=’sl’,how=’inner’)<br>Out[16]:<br>   data_1 sl  data_2<br>0       2  a       3<br>1       6  a       3<br>2       3  a       3<br>3       9  c       2<br>4       1  c       2<br>5       0  d       1</p><p>#内连接是键的交集<br>pd.merge(frame_1,frame_2,on=’sl’,how=’left’)<br>Out[17]:<br>   data_1 sl  data_2<br>0       2  a     3.0<br>1       6  a     3.0<br>2       9  c     2.0<br>3       3  a     3.0<br>4       2  b     NaN<br>5       1  c     2.0<br>6       0  d     1.0<br>7       5  b     NaN</p><p>pd.merge(frame_2,frame_1,on=’sl’,how=’left’)<br>Out[6]:<br>   data_2 sl  data_1<br>0       3  a     2.0<br>1       3  a     6.0<br>2       3  a     3.0<br>3       2  c     9.0<br>4       2  c     1.0<br>5       1  d     0.0<br>6       7  f     NaN</p><p>#左连接以第一个数据框的键列为合并参考键列，观察参考键列中的键是否在两个待合并数据框中有重复，有则在合并时也要重复。<br>pd.merge(frame_1,frame_2,on=’sl’,how=’right’)<br>Out[18]:<br>   data_1 sl  data_2<br>0     2.0  a       3<br>1     6.0  a       3<br>2     3.0  a       3<br>3     9.0  c       2<br>4     1.0  c       2<br>5     0.0  d       1<br>6     NaN  f       7</p><p>#右连接以第二个数据框的键列为合并参考键列，观察参考键列中的键是否在两个待合并数据框中有重复，有则在合并时也要重复。</p><p>pd.merge(frame_1,frame_2,on=’sl’)<br>Out[19]:<br>   data_1 sl  data_2<br>0       2  a       3<br>1       6  a       3<br>2       3  a       3<br>3       9  c       2<br>4       1  c       2<br>5       0  d       1</p><p>我们可以看到，“how=’inner’”和how在缺失的状况下运行结果是一样的。</p><p>下面我们讨论多对多键的操作：</p><p>内连接<br>frame_2=pd.DataFrame({‘sl’:[‘a’,’c’,’a’,’d’,’f’],’data_2’:[3,2,1,7,6]})<br>frame_1=pd.DataFrame({‘sl’:[‘a’,’a’,’c’,’a’,’b’,’c’,’d’,’b’],’data_1’:[2,6,9,3,2,1,0,5]})</p><p>pd.merge(frame_2,frame_1,on=’sl’)<br>Out[9]:<br>   data_2 sl  data_1<br>0       3  a       2<br>1       3  a       6<br>2       3  a       3<br>3       1  a       2<br>4       1  a       6<br>5       1  a       3<br>6       2  c       9<br>7       2  c       1<br>8       7  d       0</p><p>多对多键合并注意事项（内连接）:</p><p>#指定合并键列</p><p>#作为键的列如有重复键要保留，不要去重，看另一个待合并数据框有没有这个键，如果有，把相同的键合并到一起并重复。如果在一个数据框重复的键在另一个数据框中也重复出现，那么合并后它重复的次数符合笛卡尔积。<br>如果某些键在各自数据框中都没有重复现象，但是两个数据框相比这些键相同，那么要把两个键合并到一起。<br>如果某些键在各自数据框中都没有重复现象，且两个数据框相比这些键也不相同，那么这些键将不出现在合并后的键列里</p><p>frame_2<br>Out[17]:<br>   data_2 sl<br>0       3  a<br>1       2  c<br>2       1  a<br>3       7  d<br>4       6  f</p><p>frame_1<br>Out[18]:<br>   data_1 sl<br>0       2  a<br>1       6  a<br>2       9  c<br>3       3  a<br>4       2  b<br>5       1  c<br>6       0  d<br>7       5  b</p><p>pd.merge(frame_2,frame_1,on=’sl’,how=’left’)<br>Out[16]:<br>   data_2 sl  data_1<br>0       3  a     2.0<br>1       3  a     6.0<br>2       3  a     3.0<br>3       2  c     9.0<br>4       2  c     1.0<br>5       1  a     2.0<br>6       1  a     6.0<br>7       1  a     3.0<br>8       7  d     0.0<br>9       6  f     NaN</p><p>#左连接以第一个数据框的键列为合并参考键列，观察参考键列中的键是否在两个待合并数据框中有重复，有则在合并时也要重复。<br>如果在一个数据框重复的键在另一个数据框中也重复出现，那么合并后它重复的次数符合笛卡尔积。<br>pd.merge(frame_2,frame_1,on=’sl’,how=’right’)<br>Out[19]:<br>    data_2 sl  data_1<br>0      3.0  a       2<br>1      1.0  a       2<br>2      3.0  a       6<br>3      1.0  a       6<br>4      3.0  a       3<br>5      1.0  a       3<br>6      2.0  c       9<br>7      2.0  c       1<br>8      7.0  d       0<br>9      NaN  b       2<br>10     NaN  b       5</p><p>#右连接以第二个数据框的键列为合并参考键列，观察参考键列中的键是否在两个待合并数据框中有重复，有则在合并时也要重复。<br>如果在一个数据框重复的键在另一个数据框中也重复出现，那么合并后它重复的次数符合笛卡尔积。</p><p>外连接组合了左连接和右连接的效果。<br>pd.merge(frame_2,frame_1,on=’sl’,how=’outer’)<br>Out[20]:<br>    data_2 sl  data_1<br>0      3.0  a     2.0<br>1      3.0  a     6.0<br>2      3.0  a     3.0<br>3      1.0  a     2.0<br>4      1.0  a     6.0<br>5      1.0  a     3.0<br>6      2.0  c     9.0<br>7      2.0  c     1.0<br>8      7.0  d     0.0<br>9      6.0  f     NaN<br>10     NaN  b     2.0<br>11     NaN  b     5.0</p><p>通过上面的一系列例子，我们发现，两个数据框的键列如果不完全一致，或者键不唯一，将是一件很麻烦的事，因此，我建议同学们除非万不得已还是应该给两个待合并的数据框设置带有唯一键的完全相同的键列。</p><p>frame_2=pd.DataFrame({‘sl’:[‘a’,’b’,’c’,’d’,’f’],’data_2’:[3,2,1,7,6]})<br>frame_1=pd.DataFrame({‘sl’:[‘a’,’b’,’c’,’d’,’f’],’data_1’:[2,6,9,3,2]})</p><p>pd.merge(frame_2,frame_1,on=’sl’)<br>Out[22]:<br>   data_2 sl  data_1<br>0       3  a       2<br>1       2  b       6<br>2       1  c       9<br>3       7  d       3<br>4       6  f       2</p><p>indirect_Data=pd.merge(frame_2,frame_1,on=’sl’)<br>indirect_Data.reindex(columns=[‘data_1’,’data_2’,’sl’])<br>Out[27]:<br>   data_1  data_2 sl<br>0       2       3  a<br>1       6       2  b<br>2       9       1  c<br>3       3       7  d<br>4       2       6  f</p><p>带有双关键字列的数据框的合并</p><p>frame_doppel_1=pd.DataFrame({‘key1’:list(‘wwerrt’),’key2’:list(‘onoodn’),’data1’:[1,9,76,9,5,6]})</p><p>frame_doppel_2=pd.DataFrame({‘key1’:list(‘wwt’),’key2’:list(‘onn’),’data1’:[1,9,76]})</p><p>frame_doppel_2<br>Out[31]:<br>   data1 key1 key2<br>0      1    w    o<br>1      9    w    n<br>2     76    t    n</p><p>frame_doppel_1<br>Out[32]:<br>   data1 key1 key2<br>0      1    w    o<br>1      9    w    n<br>2     76    e    o<br>3      9    r    o<br>4      5    r    d<br>5      6    t    n</p><p>pd.merge(frame_doppel_1,frame_doppel_2,on=[‘key1’,’key2’],how=’outer’)<br>Out[33]:<br>   data1_x key1 key2  data1_y<br>0        1    w    o      1.0<br>1        9    w    n      9.0<br>2       76    e    o      NaN<br>3        9    r    o      NaN<br>4        5    r    d      NaN<br>5        6    t    n     76.0</p><p>pd.merge(frame_doppel_1,frame_doppel_2,on=[‘key1’,’key2’],how=’left’)<br>Out[34]:<br>   data1_x key1 key2  data1_y<br>0        1    w    o      1.0<br>1        9    w    n      9.0<br>2       76    e    o      NaN<br>3        9    r    o      NaN<br>4        5    r    d      NaN<br>5        6    t    n     76.0</p><p>pd.merge(frame_doppel_1,frame_doppel_2,on=[‘key1’,’key2’],how=’right’)<br>Out[35]:<br>   data1_x key1 key2  data1_y<br>0        1    w    o        1<br>1        9    w    n        9<br>2        6    t    n       76</p><p>pd.merge(frame_doppel_1,frame_doppel_2,on=[‘key1’,’key2’])<br>Out[36]:<br>   data1_x key1 key2  data1_y<br>0        1    w    o        1<br>1        9    w    n        9<br>2        6    t    n       76</p><p>#对于有双从键列的数据框，我们先在各自的数据框内把两个键列组成一个元组序列键列，然后按单键列处理即可。（当然，真正的实际原理并非如此）。</p><p>frame_123=pd.DataFrame({‘data’:[1,2,8,9,0,98,6,56],’key1’:list(‘aacabbed’)})<br>frame_456=pd.DataFrame({‘data_1’:[2,67,1]},index=[‘a’,’b’,’e’])</p><p>frame_456<br>Out[39]:<br>   data_1<br>a       2<br>b      67<br>e       1</p><p>pd.merge(frame_123,frame_456,left_on=’key1’,right_index=True)<br>Out[40]:<br>   data key1  data_1<br>0     1    a       2<br>1     2    a       2<br>3     9    a       2<br>4     0    b      67<br>5    98    b      67<br>6     6    e       1</p><p>pd.merge(frame_123,frame_456,left_on=’key1’,right_index=True,how=’outer’)<br>Out[42]:<br>   data key1  data_1<br>0     1    a     2.0<br>1     2    a     2.0<br>3     9    a     2.0<br>2     8    c     NaN<br>4     0    b    67.0<br>5    98    b    67.0<br>6     6    e     1.0<br>7    56    d     NaN</p><p>firstar_1=pd.DataFrame({‘sl_1’:[‘doctor’,’doctor’,’doctor’,’patient’,’patient’],’sl_2’:[4,2,4,20,32],’data_1’:np.arange(5)})<br>secondar_1=pd.DataFrame(np.arange(12).reshape(4,3),index=[[‘doctor’,’doctor’,’patient’,’patient’],[4,4,20,20]],columns=[‘day’,’hour’,’second’])</p><p>secondar_1<br>Out[7]:<br>            day  hour  second<br>doctor  4     0     1       2<br>        4     3     4       5<br>patient 20    6     7       8<br>        20    9    10      11</p><p>firstar_1<br>Out[8]:<br>   data_1     sl_1  sl_2<br>0       0   doctor     4<br>1       1   doctor     2<br>2       2   doctor     4<br>3       3  patient    20<br>4       4  patient    32</p><p>combination_1=pd.merge(firstar_1,secondar_1,left_on=[‘sl_1’,’sl_2’],right_index=True)</p><p>combination_1<br>Out[11]:<br>   data_1     sl_1  sl_2  day  hour  second<br>0       0   doctor     4    0     1       2<br>0       0   doctor     4    3     4       5<br>2       2   doctor     4    0     1       2<br>2       2   doctor     4    3     4       5<br>3       3  patient    20    6     7       8<br>3       3  patient    20    9    10      11</p><p>对于带有重索引的数据框合并时，要先把重索引组成一个个元组对，然后与另一个数据框两个键列组成的元组队进行比较。上面的例子选出两个数据框元组对的交集。多对多相同时符合笛卡尔积</p><p>#下面是左连接效果<br>pd.merge(firstar_1,secondar_1,left_on=[‘sl_1’,’sl_2’],right_index=True,how=’left’)<br>Out[5]:<br>   data_1     sl_1  sl_2  day  hour  second<br>0       0   doctor     4  0.0   1.0     2.0<br>0       0   doctor     4  3.0   4.0     5.0<br>1       1   doctor     2  NaN   NaN     NaN<br>2       2   doctor     4  0.0   1.0     2.0<br>2       2   doctor     4  3.0   4.0     5.0<br>3       3  patient    20  6.0   7.0     8.0<br>3       3  patient    20  9.0  10.0    11.0<br>4       4  patient    32  NaN   NaN     NaN</p><p>#下面是左连接效果<br>pd.merge(firstar_1,secondar_1,left_on=[‘sl_1’,’sl_2’],right_index=True,how=’right’)<br>Out[6]:<br>   data_1     sl_1  sl_2  day  hour  second<br>0       0   doctor     4    0     1       2<br>2       2   doctor     4    0     1       2<br>0       0   doctor     4    3     4       5<br>2       2   doctor     4    3     4       5<br>3       3  patient    20    6     7       8<br>3       3  patient    20    9    10      11</p><p>#下面是外连接效果<br>pd.merge(firstar_1,secondar_1,left_on=[‘sl_1’,’sl_2’],right_index=True,how=’outer’)<br>Out[7]:<br>   data_1     sl_1  sl_2  day  hour  second<br>0       0   doctor     4  0.0   1.0     2.0<br>0       0   doctor     4  3.0   4.0     5.0<br>2       2   doctor     4  0.0   1.0     2.0<br>2       2   doctor     4  3.0   4.0     5.0<br>1       1   doctor     2  NaN   NaN     NaN<br>3       3  patient    20  6.0   7.0     8.0<br>3       3  patient    20  9.0  10.0    11.0<br>4       4  patient    32  NaN   NaN     NaN</p><p>同时使用双方索引直接合并也是没有问题的，我们看下例：</p><p>DataFrame_1=pd.DataFrame([[2,89,0],[7,9,34],[3.4,5.6,8.9]],index=[‘a’,’g’,’f’],columns=[‘c1’,’c2’,’c3’])</p><p>DataFrame_2=pd.DataFrame([[8,45,6,8],[4,5,3,23],[45,90,6.9,0.7],[4.5,6.8,9.2,7.6]],index=[‘g’,’g’,’a’,’f’],columns=[‘c3’,’c4’,’c5’,’c6’])<br>pd.merge(DataFrame_1,DataFrame_2,left_index=True,right_index=True,how=’outer’)<br>Out[12]:<br>    c1    c2  c3_x  c3_y    c4   c5    c6<br>a  2.0  89.0   0.0  45.0  90.0  6.9   0.7<br>f  3.4   5.6   8.9   4.5   6.8  9.2   7.6<br>g  7.0   9.0  34.0   8.0  45.0  6.0   8.0<br>g  7.0   9.0  34.0   4.0   5.0  3.0  23.0</p><p>下面我们用join函数来实现按索引的合并：<br>利用join按行索引合并时，两个待合并数据框的列索引不能有重复。<br>DataFrame_2_cor=pd.DataFrame([[8,45,6,8],[4,5,3,23],[45,90,6.9,0.7],[4.5,6.8,9.2,7.6]],index=[‘g’,’g’,’c’,’b’],columns=[‘c7’,’c4’,’c5’,’c6’])</p><p>DataFrame_2_cor<br>Out[22]:<br>     c7    c4   c5    c6<br>g   8.0  45.0  6.0   8.0<br>g   4.0   5.0  3.0  23.0<br>c  45.0  90.0  6.9   0.7<br>b   4.5   6.8  9.2   7.6</p><p>DataFrame_1<br>Out[23]:<br>    c1    c2    c3<br>a  2.0  89.0   0.0<br>g  7.0   9.0  34.0<br>f  3.4   5.6   8.9</p><p>DataFrame_2_cor.join(DataFrame_1)<br>Out[24]:<br>     c7    c4   c5    c6   c1   c2    c3<br>b   4.5   6.8  9.2   7.6  NaN  NaN   NaN<br>c  45.0  90.0  6.9   0.7  NaN  NaN   NaN<br>g   8.0  45.0  6.0   8.0  7.0  9.0  34.0<br>g   4.0   5.0  3.0  23.0  7.0  9.0  34.0</p><p>DataFrame_2_cor.join(DataFrame_1,how=’inner’)<br>Out[25]:<br>    c7    c4   c5    c6   c1   c2    c3<br>g  8.0  45.0  6.0   8.0  7.0  9.0  34.0<br>g  4.0   5.0  3.0  23.0  7.0  9.0  34.0</p><p>DataFrame_2_cor.join(DataFrame_1,how=’right’)<br>Out[26]:<br>    c7    c4   c5    c6   c1    c2    c3<br>a  NaN   NaN  NaN   NaN  2.0  89.0   0.0<br>f  NaN   NaN  NaN   NaN  3.4   5.6   8.9<br>g  8.0  45.0  6.0   8.0  7.0   9.0  34.0<br>g  4.0   5.0  3.0  23.0  7.0   9.0  34.0</p><p>DataFrame_2_cor.join(DataFrame_1,how=’outer’)<br>Out[28]:<br>     c7    c4   c5    c6   c1    c2    c3<br>a   NaN   NaN  NaN   NaN  2.0  89.0   0.0<br>b   4.5   6.8  9.2   7.6  NaN   NaN   NaN<br>c  45.0  90.0  6.9   0.7  NaN   NaN   NaN<br>f   NaN   NaN  NaN   NaN  3.4   5.6   8.9<br>g   8.0  45.0  6.0   8.0  7.0   9.0  34.0<br>g   4.0   5.0  3.0  23.0  7.0   9.0  34.0</p><p>#其运行结果完全按照merge.只不过默认是how=’left’。</p><p>轴向连接<br>在Numpy阶段我们讲过数组的合并，比如我们用concatenate连接两个数组：</p><p>arr=np.arange(12).reshape(3,4)</p><p>arr<br>Out[3]:<br>array([[ 0,  1,  2,  3],<br>       [ 4,  5,  6,  7],<br>       [ 8,  9, 10, 11]])</p><p>np.concatenate((arr,arr),axis=0)<br>Out[4]:<br>array([[ 0,  1,  2,  3],<br>       [ 4,  5,  6,  7],<br>       [ 8,  9, 10, 11],<br>       [ 0,  1,  2,  3],<br>       [ 4,  5,  6,  7],<br>       [ 8,  9, 10, 11]])</p><p>np.concatenate((arr,arr),axis=1)<br>Out[5]:<br>array([[ 0,  1,  2,  3,  0,  1,  2,  3],<br>       [ 4,  5,  6,  7,  4,  5,  6,  7],<br>       [ 8,  9, 10, 11,  8,  9, 10, 11]])</p><p>接下来我们看一下两个或两个以上的Series是如何合并的。<br>ps_1=pd.Series([0,1],index=[‘a’,’b’])</p><p>ps_2=pd.Series([6,2],index=[‘c’,’d’])</p><p>ps_3=pd.Series([7,0,8,6,0],index=[‘e’,’f’,’g’,’h’,’k’])</p><p>pd.concat((ps_1,ps_2,ps_3))<br>Out[10]:<br>a    0<br>b    1<br>c    6<br>d    2<br>e    7<br>f    0<br>g    8<br>h    6<br>k    0<br>dtype: int64<br>接下来我们使 ’axis=1’，看看结果如何（注意：通常情况下，对于Series的轴是不允许其为“1”的）：<br>pd.concat((ps_1,ps_2,ps_3),axis=1)<br>Out[11]:<br>     0    1    2<br>a  0.0  NaN  NaN<br>b  1.0  NaN  NaN<br>c  NaN  6.0  NaN<br>d  NaN  2.0  NaN<br>e  NaN  NaN  7.0<br>f  NaN  NaN  0.0<br>g  NaN  NaN  8.0<br>h  NaN  NaN  6.0<br>k  NaN  NaN  0.0</p><p>pd.concat((ps_2,ps_4))<br>Out[16]:<br>c    6<br>d    2<br>a    0<br>b    8<br>c    6<br>d    2<br>dtype: int64</p><p>pd.concat((ps_2,ps_4),axis=1)<br>Out[17]:<br>     0  1<br>a  NaN  0<br>b  NaN  8<br>c  6.0  6<br>d  2.0  2</p><p>pd.concat((ps_2,ps_4),axis=1,join=’inner’)<br>Out[18]:<br>   0  1<br>c  6  6<br>d  2  2</p><p>我们还可以给合并后的Series指定索引名：<br>pd.concat((ps_2,ps_4),axis=1,join_axes=[[‘a’,’b’,’u’,’v’]])<br>Out[19]:<br>    0    1<br>a NaN  0.0<br>b NaN  8.0<br>u NaN  NaN<br>v NaN  NaN</p><p>通过key参数可以实现把Series合并成层次化Series：<br>pd.concat((ps_1,ps_2*3,ps_3),keys=[‘ein’,’drei’,’fuenf’])<br>Out[6]:<br>ein    a     0<br>       b     1<br>drei   c    18<br>       d     6<br>fuenf  e     7<br>       f     0<br>       g     8<br>       h     6<br>       k     0<br>dtype: int64<br>这里如果我们添加axis=1，结果会如何呢？<br>  ein  drei  fuenf<br>a  0.0   NaN    NaN<br>b  1.0   NaN    NaN<br>c  NaN  18.0    NaN<br>d  NaN   6.0    NaN<br>e  NaN   NaN    7.0<br>f  NaN   NaN    0.0<br>g  NaN   NaN    8.0<br>h  NaN   NaN    6.0<br>k  NaN   NaN    0.0</p><p>我们发现此时原本Series的外层索引变成列索引。</p><p>对于有重复行索引的Series合并后结果会如何呢？</p><p>很不幸，无法运行！</p><p>到此，我们需要做一个用concat合并Series的总结：<br>总结：<br>待合并的每个series中不能出现重复的行标签<br>对于axis=0，Series合并后的效果是行标签的直接组合。<br>对于axis=1，要视合并模式而定，默认合并模式join=“outer”，按照单个的Seires，一列一列地排下去，join=“inner”模式意味着在outer模式的基础上只保留个Series共有部分，其他全删除。</p><p>下面我们把contact应用到数据框</p><p>import pandas as pd<br>import numpy as np<br>frame_1=pd.DataFrame([[1000,2000],[279,1123],[721,877]],index=[‘salary’,’expenditure’,’surplus’],columns=[‘mattias’,’jennifer’])<br>frame_2=pd.DataFrame(np.array([[1000,2000,3000],[279,1123,2000],[721,877,1000]])*12,index=[‘salary per annum’,’expenditure per annum’,’surplus per annum’],columns=[‘mattias’,’jennifer’,’jocker’])</p><p>pd.concat((frame_1,frame_2),axis=1,keys=[‘works’,’boss’])<br>Out[2]:<br>                        works              boss<br>                      mattias jennifer  mattias jennifer   jocker<br>expenditure             279.0   1123.0      NaN      NaN      NaN<br>expenditure per annum     NaN      NaN   3348.0  13476.0  24000.0<br>salary                 1000.0   2000.0      NaN      NaN      NaN<br>salary per annum          NaN      NaN  12000.0  24000.0  36000.0<br>surplus                 721.0    877.0      NaN      NaN      NaN<br>surplus per annum         NaN      NaN   8652.0  10524.0  12000.0</p><p>pd.concat((frame_1,frame_2),axis=0,keys=[‘works’,’boss’])<br>Out[3]:<br>                             jennifer   jocker  mattias<br>works salary                     2000      NaN     1000<br>      expenditure                1123      NaN      279<br>      surplus                     877      NaN      721<br>boss  salary per annum          24000  36000.0    12000<br>      expenditure per annum     13476  24000.0     3348<br>      surplus per annum         10524  12000.0     8652<br>视axis=1和 =0 而定，Keys可以给数据框的列或行加上重索引</p><p>Keys所实现的功能也可以通过字典来实现：</p><p>pd.concat({‘works’:frame_1,’boss’:frame_2},axis=1)<br>Out[6]:<br>                          boss                     works<br>                       mattias jennifer   jocker mattias jennifer<br>expenditure                NaN      NaN      NaN   279.0   1123.0<br>expenditure per annum   3348.0  13476.0  24000.0     NaN      NaN<br>salary                     NaN      NaN      NaN  1000.0   2000.0<br>salary per annum       12000.0  24000.0  36000.0     NaN      NaN<br>surplus                    NaN      NaN      NaN   721.0    877.0<br>surplus per annum       8652.0  10524.0  12000.0     NaN      NaN<br>通过names可以给重索引进行命名：<br>pd.concat({‘works’:frame_1,’boss’:frame_2},axis=1,names=[‘Identity’,’Names’])<br>Out[7]:<br>Identity                  boss                     works<br>Names                  mattias jennifer   jocker mattias jennifer<br>expenditure                NaN      NaN      NaN   279.0   1123.0<br>expenditure per annum   3348.0  13476.0  24000.0     NaN      NaN<br>salary                     NaN      NaN      NaN  1000.0   2000.0<br>salary per annum       12000.0  24000.0  36000.0     NaN      NaN<br>surplus                    NaN      NaN      NaN   721.0    877.0<br>surplus per annum       8652.0  10524.0  12000.0     NaN      NaN</p><p>通过Ignore_index=Ture可以把自行设置的行或列索引转变成python自动配置的行或列索引。<br>pd.concat((frame_1,frame_2),axis=0,ignore_index=True)<br>Out[11]:<br>   jennifer   jocker  mattias<br>0      2000      NaN     1000<br>1      1123      NaN      279<br>2       877      NaN      721<br>3     24000  36000.0    12000<br>4     13476  24000.0     3348<br>5     10524  12000.0     8652</p><p>pd.concat((frame_1,frame_2),axis=1,ignore_index=True)<br>Out[12]:<br>                            0       1        2        3        4<br>expenditure             279.0  1123.0      NaN      NaN      NaN<br>expenditure per annum     NaN     NaN   3348.0  13476.0  24000.0<br>salary                 1000.0  2000.0      NaN      NaN      NaN<br>salary per annum          NaN     NaN  12000.0  24000.0  36000.0<br>surplus                 721.0   877.0      NaN      NaN      NaN<br>surplus per annum         NaN     NaN   8652.0  10524.0  12000.0</p><p>如果axis=1，那么join是按0轴操作；同理，axis=1，那么join是按1轴操作。</p><p>pd.concat((frame_1,frame_2),axis=1,join=’outer’)<br>Out[16]:<br>                       mattias  jennifer  mattias  jennifer   jocker<br>expenditure              279.0    1123.0      NaN       NaN      NaN<br>expenditure per annum      NaN       NaN   3348.0   13476.0  24000.0<br>salary                  1000.0    2000.0      NaN       NaN      NaN<br>salary per annum           NaN       NaN  12000.0   24000.0  36000.0<br>surplus                  721.0     877.0      NaN       NaN      NaN<br>surplus per annum          NaN       NaN   8652.0   10524.0  12000.0</p><p>pd.concat((frame_1,frame_2),axis=0,join=’inner’)<br>Out[17]:<br>                       mattias  jennifer<br>salary                    1000      2000<br>expenditure                279      1123<br>surplus                    721       877<br>salary per annum         12000     24000<br>expenditure per annum     3348     13476<br>surplus per annum         8652     10524</p><p>ag_1=pd.DataFrame(np.floor(np.random.randn(4,4)),index=list(‘gfas’),columns=list(‘xcvb’))</p><p>ag_2=pd.DataFrame(np.floor(np.random.randint(2,8,12).reshape(4,3)),index=[‘xu’,’de’,’jiang’,’hu’],columns=list(‘xvb’))</p><p>pd.concat((ag_1,ag_2),keys=[‘Gr’,’A’],axis=1,join_axes=[ag_1.index])</p><p>Out[64]:<br>    Gr                  A<br>     x    c    v    b   x   v   b<br>g -2.0  0.0  0.0  1.0 NaN NaN NaN<br>f -2.0 -1.0  0.0 -1.0 NaN NaN NaN<br>a -2.0  0.0  0.0  2.0 NaN NaN NaN<br>s  0.0 -2.0 -1.0 -2.0 NaN NaN NaN</p><p>ag_1=pd.DataFrame(np.floor(np.random.randn(4,4)),index=list(‘gfas’),columns=list(‘xcvb’))</p><p>ag_2=pd.DataFrame(np.floor(np.random.randint(2,8,12).reshape(4,3)),index=[‘xu’,’de’,’jiang’,’hu’],columns=list(‘xvb’))</p><p>pd.concat((ag_1,ag_2),keys=[‘Gr’,’A’],axis=1,join_axes=[ag_2.index])</p><p>Out[65]:<br>       Gr                A<br>        x   c   v   b    x    v    b<br>xu    NaN NaN NaN NaN  3.0  3.0  4.0<br>de    NaN NaN NaN NaN  5.0  2.0  6.0<br>jiang NaN NaN NaN NaN  7.0  2.0  3.0<br>hu    NaN NaN NaN NaN  7.0  2.0  6.0</p><p>ag_1=pd.DataFrame(np.floor(np.random.randn(4,4)),index=list(‘gfas’),columns=list(‘xcvb’))</p><p>ag_2=pd.DataFrame(np.floor(np.random.randint(2,8,12).reshape(4,3)),index=[‘xu’,’de’,’jiang’,’hu’],columns=list(‘xvb’))</p><p>pd.concat((ag_1,ag_2),keys=[‘Gr’,’A’],axis=0,join_axes=[ag_2.columns])</p><p>Out[67]:<br>            x    v    b<br>Gr g     -1.0 -1.0  0.0<br>   f     -1.0 -1.0 -1.0<br>   a      1.0 -1.0  1.0<br>   s      0.0 -1.0 -1.0<br>A  xu     7.0  3.0  3.0<br>   de     6.0  6.0  3.0<br>   jiang  2.0  7.0  5.0<br>   hu     7.0  5.0  7.0</p><p>ag_1=pd.DataFrame(np.floor(np.random.randn(4,4)),index=list(‘gfas’),columns=list(‘xcvb’))</p><p>ag_2=pd.DataFrame(np.floor(np.random.randint(2,8,12).reshape(4,3)),index=[‘xu’,’de’,’jiang’,’hu’],columns=list(‘xvb’))</p><p>pd.concat((ag_1,ag_2),keys=[‘Gr’,’A’],axis=0,join_axes=[ag_1.columns])</p><p>Out[68]:<br>            x    c    v    b<br>Gr g      0.0  0.0 -1.0  2.0<br>   f      0.0 -1.0  0.0 -2.0<br>   a      0.0 -1.0 -2.0  0.0<br>   s     -1.0 -2.0  0.0 -1.0<br>A  xu     2.0  NaN  2.0  6.0<br>   de     6.0  NaN  4.0  2.0<br>   jiang  7.0  NaN  6.0  5.0<br>   hu     4.0  NaN  7.0  6.0</p><p>Concat的参数详解：<br>objs    参与连接的pandas对象的列表或者元组或者字典。是唯一必需的参数。<br>axis    指明按那个轴进行连接，默认为0<br>join    指明连接方式，“inner”或”outer”，默认“outer”。指明其他轴向上的索引是按交集（“inner”）还是并集(“outer”)进行合并。<br>keys    与连接对象有关的值，用于形成连接轴向上的层次化索引。可以是任意值的列表或数组、元组数组、数组列表等。<br>join_axes    指定根据那个数据框的索引来对齐数据，这个索引不参与并\交运算<br>Names    给层索引每一层命名<br>Ignore_index    不保留连接轴上的索引，产生一组新索引</p><p>给数据打补丁：<br>尽管我们学习各种各种的数据合并与连接（merge、join、concatenation等）。然而他们都仅仅是对索引的直接处理。很难对Series或者数据框所包含的数据直接处理。<br>通过np.where,可以实现数值的补空合并。</p><p>ser_1=pd.Series([np.nan,45,np.nan,3.9,90,np.nan],index=list(‘abcdef’))<br>ser_2=pd.Series(np.arange(len(ser_1)),index=list(‘abcdef’))</p><p>ser_1<br>Out[73]:<br>a     NaN<br>b    45.0<br>c     NaN<br>d     3.9<br>e    90.0<br>f     NaN<br>dtype: float64</p><p>ser_2<br>Out[74]:<br>a    0<br>b    1<br>c    2<br>d    3<br>e    4<br>f    5<br>dtype: int32</p><p>pd.Series(np.where(pd.isnull(ser_1),ser_2,ser_1),index=list(‘abcdef’))<br>Out[79]:<br>a     0.0<br>b    45.0<br>c     2.0<br>d     3.9<br>e    90.0<br>f     5.0<br>dtype: float64</p><p>通过combine_first来实现相同功能：<br>ser_1.combine_first(ser_2)<br>Out[80]:<br>a     0.0<br>b    45.0<br>c     2.0<br>d     3.9<br>e    90.0<br>f     5.0<br>dtype: float64</p><p>#拿fra_2值补fra_1</p><p>fra_1=pd.DataFrame({‘a’:[1.,np.nan,5.,np.nan],’b’:[np.nan,2.,np.nan,6.],’c’:range(2,9,2)})</p><p>fra_2=pd.DataFrame({‘a’:[3,np.nan,6,3,8],’b’:[np.nan,np.nan,2,6,8]})</p><p>fra_1<br>Out[84]:<br>     a    b  c<br>0  1.0  NaN  2<br>1  NaN  2.0  4<br>2  5.0  NaN  6<br>3  NaN  6.0  8</p><p>fra_2<br>Out[85]:<br>     a    b<br>0  3.0  NaN<br>1  NaN  NaN<br>2  6.0  2.0<br>3  3.0  6.0<br>4  8.0  8.0</p><p>fra_1.combine_first(fra_2)<br>Out[86]:<br>     a    b    c<br>0  1.0  NaN  2.0<br>1  NaN  2.0  4.0<br>2  5.0  2.0  6.0<br>3  3.0  6.0  8.0<br>4  8.0  8.0  NaN</p><p>#拿fra_2值补fra_1<br>数据的重塑（仔细读注解额）<br>数据的重塑其本质就是对数据表格进行重排。所用到的函数通常被称为重塑函数或轴向旋转函数。</p><p>重塑层次化索引：</p><p>带有层次化索引数据框的重塑主要是通过以下函数来实现的：<br>Stack：将列索引旋转为行索引<br>Unstack：将行索引旋转为列索引<br>注意：以上只适合重索引数据框<br>我们先从一个简单的数据框开始。<br>data_1=pd.DataFrame(np.arange(6).reshape(2,3),index=pd.Index([‘XDL_1’,’XDL_2’],name=’education_group’),columns=pd.Index([‘one’,’three’,’two’],name=’nr.’))</p><p>data_1<br>Out[4]:<br>nr.              one  three  two<br>education_group<br>XDL_1              0      1    2<br>XDL_2              3      4    5</p><p>data_1.stack()<br>Out[5]:<br>education_group  nr.<br>XDL_1            one      0<br>                 three    1<br>                 two      2<br>XDL_2            one      3<br>                 three    4<br>                 two      5<br>dtype: int32</p><p>#对于没有重索引的数据框，用stack方法会实现列索引成为内层行索引<br>data_1.unstack()<br>Out[14]:<br>nr.    education_group<br>one    XDL_1              0<br>       XDL_2              3<br>three  XDL_1              1<br>       XDL_2              4<br>two    XDL_1              2<br>       XDL_2              5<br>dtype: int32</p><p>#对于没有重索引的数据框，用unstack方法会实现列索引成为外层行索引<br>data_double_ser=data_1.stack()</p><p>#生成重索引series<br>data_double_ser<br>Out[21]:<br>education_group  nr.<br>XDL_1            one      0<br>                 three    1<br>                 two      2<br>XDL_2            one      3<br>                 three    4<br>                 two      5<br>dtype: int32<br>data_double_ser.unstack()<br>Out[6]:<br>nr.              one  three  two<br>education_group<br>XDL_1              0      1    2<br>XDL_2              3      4    5</p><p>#通过unstack把内层行索引旋转到列索引，默认旋转内层级行索引到列索引。<br>data_1.stack().unstack(0)<br>Out[10]:<br>education_group  XDL_1  XDL_2<br>nr.<br>one                  0      3<br>three                1      4<br>two                  2      5</p><p>#默认按内层索引操作，我们可以指定操作级别。这里的‘0’代表外层级别。也可以用外层索引名来代替‘0’<br>data_1.stack().unstack(‘education_group’)<br>Out[13]:<br>education_group  XDL_1  XDL_2<br>nr.<br>one                  0      3<br>three                1      4<br>two                  2      5</p><p>#指定重索引行外层级，并通过unstack把外层行索引旋转到列索引</p><p>s1=pd.Series([0,3,4,-3],index=list(‘abcd’))</p><p>s2=pd.Series([6,2,9],index=list(‘bca’))</p><p>data_ser_double=pd.concat((s1,s2),keys=[‘one’,’two’])</p><p>data_ser_double<br>Out[25]:<br>one  a    0<br>     b    3<br>     c    4<br>     d   -3<br>two  b    6<br>     c    2<br>     a    9<br>dtype: int64</p><p>data_ser_double.unstack()<br>Out[26]:<br>       a    b    c    d<br>one  0.0  3.0  4.0 -3.0<br>two  9.0  6.0  2.0  NaN</p><p>#如果S1和S2的索引数目不等或者数目相等但索引内容不同都会产生空值，因此我们要求S1和S2的索引必须完全一致，才能在运算中不产生空值！！</p><p>#产生空值的情况下，如果我们设置dropna=True（默认）那么上面的运算可逆。如果我们设置dropna=False的情况下，上面的运算时不可逆的。</p><p>data_ser_double.unstack().stack()<br>Out[28]:<br>one  a    0.0<br>     b    3.0<br>     c    4.0<br>     d   -3.0<br>two  a    9.0<br>     b    6.0<br>     c    2.0<br>dtype: float64</p><p>data_ser_double.unstack().stack(dropna=False)<br>Out[29]:<br>one  a    0.0<br>     b    3.0<br>     c    4.0<br>     d   -3.0<br>two  a    9.0<br>     b    6.0<br>     c    2.0<br>     d    NaN<br>dtype: float64</p><p>移除重复数据<br>data=pd.DataFrame({‘k1’:[‘one’]<em>3+[‘two’]</em>4,’k2’:[1,2,3,4,5,6,7]})</p><p>data<br>Out[8]:<br>    k1  k2<br>0  one   1<br>1  one   2<br>2  one   3<br>3  two   4<br>4  two   5<br>5  two   6<br>6  two   7</p><p>利用duplicated可以判断重复行</p><p>#默认k1和k2列必须都重复才算重复行<br>data.duplicated()<br>Out[5]:<br>0    False<br>1    False<br>2    False<br>3    False<br>4    False<br>5    False<br>6    False<br>dtype: bool</p><p>data=pd.DataFrame({‘k1’:[‘one’]<em>3+[‘two’]</em>4,’k2’:[2,3,2,3,6,6,6]})</p><p>data<br>Out[8]:<br>    k1  k2<br>0  one   2<br>1  one   3<br>2  one   2<br>3  two   3<br>4  two   6<br>5  two   6<br>6  two   6</p><p>data.duplicated()<br>Out[9]:<br>0    False<br>1    False<br>2     True<br>3    False<br>4    False<br>5     True<br>6     True<br>dtype: bool</p><p>#注意，原项不会判断为True，只有真正的重复项才会，如上例子，红色不会判断为True，蓝色才会判断为True。</p><p>#通过drop_duplicates方法，可以移除重复行，返回一个没有重复行的DataFrame。<br>data.drop_duplicates()<br>Out[11]:<br>    k1  k2<br>0  one   2<br>1  one   3<br>3  two   3<br>4  two   6</p><p>#可以指定某一列或几列中行重复就算重复行<br>data[‘k3’],data[‘k4’],data[‘k5’]=[0,0,0,0,3,6,7],[4,8,6,7,6,7,7],[2,2,4,4,6,6,8]<br>data<br>Out[20]:<br>    k1  k2  k3  k4  k5<br>0  one   2   0   4   2<br>1  one   3   0   8   2<br>2  one   2   0   6   4<br>3  two   3   0   7   4<br>4  two   6   3   6   6<br>5  two   6   6   7   6<br>6  two   6   7   7   8</p><p>data.drop_duplicates([‘k1’])<br>Out[22]:<br>    k1  k2  k3  k4  k5<br>0  one   2   0   4   2<br>3  two   3   0   7   4</p><p>data.drop_duplicates([‘k1’,’k2’])<br>Out[24]:<br>    k1  k2  k3  k4  k5<br>0  one   2   0   4   2<br>1  one   3   0   8   2<br>3  two   3   0   7   4<br>4  two   6   3   6   6</p><p>data<br>Out[27]:<br>    k1  k2  k3  k4  k5<br>0  one   2   0   4   2<br>1  one   3   0   8   2<br>2  one   2   0   6   4<br>3  two   3   0   7   4<br>4  two   6   3   6   6<br>5  two   6   6   7   6<br>6  two   6   7   7   8</p><p>data.drop_duplicates([‘k1’],keep=’last’)<br>Out[29]:<br>    k1  k2  k3  k4  k5<br>2  one   2   0   6   4<br>6  two   6   7   7   8</p><p>data.duplicated([‘k1’],keep=’last’)<br>Out[34]:<br>0     True<br>1     True<br>2    False<br>3     True<br>4     True<br>5     True<br>6    False<br>dtype: bool</p><p>#默认保留重复行的第一行，也可以设置保留最后一个，keep=’last’,删除其他所有重复行。</p><p>利用字典映射对数据进行操作：</p><p>data_1=pd.DataFrame({‘food’:[‘bacon火腿’,’sausage红肠’,’pulled pork手撕肉’,’sirloin牛里脊肉’,’beef jerky牛肉干’,’mutton shashlik烤羊肉串’,’Chicken salad鸡肉’,’Minced chicken鸡肉泥’,’dried squids鱿鱼干’,’dried fish鱼干’,’sausage红肠’,’bacon火腿’,’sausage红肠’,’bacon火腿’,’Chicken salad鸡肉’,’dried squids鱿鱼干’,’dried fish鱼干’,’mutton shashlik烤羊肉串’,’beef jerky牛肉干’,’Minced chicken鸡肉泥’,’pulled pork手撕肉’,’sirloin牛里脊肉’,’mutton shashlik烤羊肉串’,’Chicken salad鸡肉’,’Minced chicken鸡肉泥’,’bacon火腿’,’sausage红肠’,’pulled pork手撕肉’,’sirloin牛里脊肉’,’beef jerky牛肉干’,’mutton shashlik烤羊肉串’,’Chicken salad鸡肉’,’Minced chicken鸡肉泥’,’dried squids鱿鱼干’,’dried fish鱼干’,’sausage红肠’,’bacon火腿’,’sausage红肠’,’bacon火腿’,’Chicken salad鸡肉’,’dried squids鱿鱼干’,’dried fish鱼干’,’mutton shashlik烤羊肉串’,’beef jerky牛肉干’,’sirloin牛里脊肉’,’mutton shashlik烤羊肉串’,’Chicken salad鸡肉’,’Minced chicken鸡肉泥’],’weight(g)’:abs((np.random.normal(0,1,size=48)*24+10)).astype(np.int32)})</p><p>data_1<br>Out[4]:<br>                   food       weight(g)<br>0               bacon火腿         27<br>1             sausage红肠         41<br>2        pulled pork手撕肉         16<br>3           sirloin牛里脊肉         12<br>4         beef jerky牛肉干          0<br>5   mutton shashlik烤羊肉串          7<br>6       Chicken salad鸡肉         31<br>7     Minced chicken鸡肉泥         14<br>8       dried squids鱿鱼干          3<br>9          dried fish鱼干         38<br>10            sausage红肠         34<br>11              bacon火腿         12<br>12            sausage红肠          9<br>13              bacon火腿         23<br>14      Chicken salad鸡肉         34<br>15      dried squids鱿鱼干          1<br>16         dried fish鱼干         19<br>17  mutton shashlik烤羊肉串          6<br>18        beef jerky牛肉干          0<br>19    Minced chicken鸡肉泥          3<br>20       pulled pork手撕肉         22<br>21          sirloin牛里脊肉          9<br>22  mutton shashlik烤羊肉串         14<br>23      Chicken salad鸡肉         34<br>24    Minced chicken鸡肉泥         37<br>25              bacon火腿         27<br>26            sausage红肠          0<br>27       pulled pork手撕肉         32<br>28          sirloin牛里脊肉          0<br>29        beef jerky牛肉干         38<br>30  mutton shashlik烤羊肉串         16<br>31      Chicken salad鸡肉         35<br>32    Minced chicken鸡肉泥          4<br>33      dried squids鱿鱼干          5<br>34         dried fish鱼干          3<br>35            sausage红肠         26<br>36              bacon火腿         12<br>37            sausage红肠          2<br>38              bacon火腿          5<br>39      Chicken salad鸡肉         11<br>40      dried squids鱿鱼干          6<br>41         dried fish鱼干         24<br>42  mutton shashlik烤羊肉串         26<br>43        beef jerky牛肉干         56<br>44          sirloin牛里脊肉          2<br>45  mutton shashlik烤羊肉串          5<br>46      Chicken salad鸡肉         12<br>47    Minced chicken鸡肉泥         13</p><p>我们发现数据框‘food’列中有很多重复。如果我们给数据假如新列，并要求新列与food存在某种逻辑关系。例如给‘food’标记食材来源。<br>通过map函数可以很轻松实现上面的要求。</p><p>meat_source={‘bacon火腿’:’猪’,’sausage红肠’:’猪’,’pulled pork手撕肉’:’猪’,’sirloin牛里脊肉’:’牛’,’beef jerky牛肉干’:’牛’,’mutton shashlik烤羊肉串’:’羊’,’chicken salad鸡肉’:’鸡’,’minced chicken鸡肉泥’:’鸡’,’dried squids鱿鱼干’:’鱿鱼’,’dried fish鱼干’:’鱼’}<br>data_1[‘animal’]=data_1[‘food’].map(meat_source)<br>data_1<br>Out[25]:<br>                   food  weight(g)       animal<br>0               bacon火腿         17      猪<br>1             sausage红肠         38      猪<br>2        pulled pork手撕肉          3      猪<br>3           sirloin牛里脊肉         12      牛<br>4         beef jerky牛肉干         31      牛<br>5   mutton shashlik烤羊肉串         16      羊<br>6       Chicken salad鸡肉         17    NaN<br>7     Minced chicken鸡肉泥         14    NaN<br>8       dried squids鱿鱼干         12     鱿鱼<br>9          dried fish鱼干          7      鱼<br>10            sausage红肠         25      猪<br>11              bacon火腿         30      猪<br>12            sausage红肠         12      猪<br>13              bacon火腿         32      猪<br>14      Chicken salad鸡肉         10    NaN<br>15      dried squids鱿鱼干         42     鱿鱼<br>16         dried fish鱼干          8      鱼<br>17  mutton shashlik烤羊肉串         13      羊<br>18        beef jerky牛肉干         34      牛<br>19    Minced chicken鸡肉泥         44    NaN<br>20       pulled pork手撕肉          3      猪<br>21          sirloin牛里脊肉         25      牛<br>22  mutton shashlik烤羊肉串          4      羊<br>23      Chicken salad鸡肉         39    NaN<br>24    Minced chicken鸡肉泥         20    NaN<br>25              bacon火腿          5      猪<br>26            sausage红肠         38      猪<br>27       pulled pork手撕肉         28      猪<br>28          sirloin牛里脊肉         12      牛<br>29        beef jerky牛肉干         21      牛<br>30  mutton shashlik烤羊肉串         13      羊<br>31      Chicken salad鸡肉         13    NaN<br>32    Minced chicken鸡肉泥         26    NaN<br>33      dried squids鱿鱼干         43     鱿鱼<br>34         dried fish鱼干         14      鱼<br>35            sausage红肠         25      猪<br>36              bacon火腿         19      猪<br>37            sausage红肠         24      猪<br>38              bacon火腿         57      猪<br>39      Chicken salad鸡肉         25    NaN<br>40      dried squids鱿鱼干         38     鱿鱼<br>41         dried fish鱼干         18      鱼<br>42  mutton shashlik烤羊肉串         54      羊<br>43        beef jerky牛肉干         24      牛<br>44          sirloin牛里脊肉         15      牛<br>45  mutton shashlik烤羊肉串         17      羊<br>46      Chicken salad鸡肉         61    NaN<br>47    Minced chicken鸡肉泥         29    NaN</p><p>#map的实质是把一种映射法则应用到所制定的列上，比如这里的‘food’列。这种映射法则通常通过字典与函数来体现。</p><p>#map把与meat_source字典的键相对应food值一个个投影到字典建对应的值然后把投影结果赋值给data_1[‘animal’]</p><p>#我们发现‘animal’列有空值。原因是meat_source中的键与‘food’列值不完全一致。</p><p>#通过map(str.lower)把food列中的值的第一个字母转变成小写，这样meat_source中的键与‘food’列值完全一致，这样Nan会自动消失。</p><p>data_1[‘animal’]=data_1[‘food’].map(lambda x:meat_source[x.lower()])<br>或<br>data_1[‘animal’]=data_1[‘food’].map(str.lower).map(meat_source)</p><p>data_1<br>Out[23]:<br>                   food  weight(g)        animal<br>0               bacon火腿         17      猪<br>1             sausage红肠         38      猪<br>2        pulled pork手撕肉          3      猪<br>3           sirloin牛里脊肉         12      牛<br>4         beef jerky牛肉干         31      牛<br>5   mutton shashlik烤羊肉串         16      羊<br>6       Chicken salad鸡肉         17      鸡<br>7     Minced chicken鸡肉泥         14      鸡<br>8       dried squids鱿鱼干         12     鱿鱼<br>9          dried fish鱼干          7      鱼<br>10            sausage红肠         25      猪<br>11              bacon火腿         30      猪<br>12            sausage红肠         12      猪<br>13              bacon火腿         32      猪<br>14      Chicken salad鸡肉         10      鸡<br>15      dried squids鱿鱼干         42     鱿鱼<br>16         dried fish鱼干          8      鱼<br>17  mutton shashlik烤羊肉串         13      羊<br>18        beef jerky牛肉干         34      牛<br>19    Minced chicken鸡肉泥         44      鸡<br>20       pulled pork手撕肉          3      猪<br>21          sirloin牛里脊肉         25      牛<br>22  mutton shashlik烤羊肉串          4      羊<br>23      Chicken salad鸡肉         39      鸡<br>24    Minced chicken鸡肉泥         20      鸡<br>25              bacon火腿          5      猪<br>26            sausage红肠         38      猪<br>27       pulled pork手撕肉         28      猪<br>28          sirloin牛里脊肉         12      牛<br>29        beef jerky牛肉干         21      牛<br>30  mutton shashlik烤羊肉串         13      羊<br>31      Chicken salad鸡肉         13      鸡<br>32    Minced chicken鸡肉泥         26      鸡<br>33      dried squids鱿鱼干         43     鱿鱼<br>34         dried fish鱼干         14      鱼<br>35            sausage红肠         25      猪<br>36              bacon火腿         19      猪<br>37            sausage红肠         24      猪<br>38              bacon火腿         57      猪<br>39      Chicken salad鸡肉         25      鸡<br>40      dried squids鱿鱼干         38     鱿鱼<br>41         dried fish鱼干         18      鱼<br>42  mutton shashlik烤羊肉串         54      羊<br>43        beef jerky牛肉干         24      牛<br>44          sirloin牛里脊肉         15      牛<br>45  mutton shashlik烤羊肉串         17      羊<br>46      Chicken salad鸡肉         61      鸡<br>47    Minced chicken鸡肉泥         29      鸡</p><p>添加amount=weight<em>price项<br>product=[‘bacon火腿’,’sausage红肠’,’pulled pork手撕肉’,’sirloin牛里脊肉’,’beef jerky牛肉干’,’mutton shashlik烤羊肉串’,’Chicken salad鸡肉’,’Minced chicken鸡肉泥’,’dried squids鱿鱼干’,’dried fish鱼干’]<br>price=[1,1.5,2,2.3,2.6,3.6,2,2.6,8,9.9]<br>get_Data={k:p</em>i for i,k in zip(list(data_1[‘weight(g)’].values),range(len(data_1[‘weight(g)’]))) for m,p in zip(product,price) if m==data_1[‘food’][k]}<br>data_1[‘key’]=np.arange(48)<br>data_1[‘anount’]=data_1[‘key’].map(get_Data)<br>data_1.reindex(columns=[‘food’,’weight(g)’, ‘animal’,  ‘anount’,’key’  ])<br>Out[108]:<br>                   food        weight(g) animal  anount  key<br>0               bacon火腿         17      猪    17.0    0<br>1             sausage红肠         38      猪    57.0    1<br>2        pulled pork手撕肉          3      猪     6.0    2<br>3           sirloin牛里脊肉         12      牛    27.6    3<br>4         beef jerky牛肉干         31      牛    80.6    4<br>5   mutton shashlik烤羊肉串         16      羊    57.6    5<br>6       Chicken salad鸡肉         17      鸡    34.0    6<br>7     Minced chicken鸡肉泥         14      鸡    36.4    7<br>8       dried squids鱿鱼干         12     鱿鱼    96.0    8<br>9          dried fish鱼干          7      鱼    69.3    9<br>10            sausage红肠         25      猪    37.5   10<br>11              bacon火腿         30      猪    30.0   11<br>12            sausage红肠         12      猪    18.0   12<br>13              bacon火腿         32      猪    32.0   13<br>14      Chicken salad鸡肉         10      鸡    20.0   14<br>15      dried squids鱿鱼干         42     鱿鱼   336.0   15<br>16         dried fish鱼干          8      鱼    79.2   16<br>17  mutton shashlik烤羊肉串         13      羊    46.8   17<br>18        beef jerky牛肉干         34      牛    88.4   18<br>19    Minced chicken鸡肉泥         44      鸡   114.4   19<br>20       pulled pork手撕肉          3      猪     6.0   20<br>21          sirloin牛里脊肉         25      牛    57.5   21<br>22  mutton shashlik烤羊肉串          4      羊    14.4   22<br>23      Chicken salad鸡肉         39      鸡    78.0   23<br>24    Minced chicken鸡肉泥         20      鸡    52.0   24<br>25              bacon火腿          5      猪     5.0   25<br>26            sausage红肠         38      猪    57.0   26<br>27       pulled pork手撕肉         28      猪    56.0   27<br>28          sirloin牛里脊肉         12      牛    27.6   28<br>29        beef jerky牛肉干         21      牛    54.6   29<br>30  mutton shashlik烤羊肉串         13      羊    46.8   30<br>31      Chicken salad鸡肉         13      鸡    26.0   31<br>32    Minced chicken鸡肉泥         26      鸡    67.6   32<br>33      dried squids鱿鱼干         43     鱿鱼   344.0   33<br>34         dried fish鱼干         14      鱼   138.6   34<br>35            sausage红肠         25      猪    37.5   35<br>36              bacon火腿         19      猪    19.0   36<br>37            sausage红肠         24      猪    36.0   37<br>38              bacon火腿         57      猪    57.0   38<br>39      Chicken salad鸡肉         25      鸡    50.0   39<br>40      dried squids鱿鱼干         38     鱿鱼   304.0   40<br>41         dried fish鱼干         18      鱼   178.2   41<br>42  mutton shashlik烤羊肉串         54      羊   194.4   42<br>43        beef jerky牛肉干         24      牛    62.4   43<br>44          sirloin牛里脊肉         15      牛    34.5   44<br>45  mutton shashlik烤羊肉串         17      羊    61.2   45<br>46      Chicken salad鸡肉         61      鸡   122.0   46<br>47    Minced chicken鸡肉泥         29      鸡    75.4   47</p><p>灵活的替换值方法：<br>前面我们讲过fillna替换空值，还有notnull也可以实现空值替换。这里我们继续推荐一种另外的替换方法-replace法。这种方法不仅简单而且还十分灵活。</p><p>#把那些标记为空值的数据替换成pandas能够理解的Na值</p><p>data=pd.Series([1.,-999.,2.,999.,-1000.,3.])</p><p>data<br>Out[115]:<br>0       1.0<br>1    -999.0<br>2       2.0<br>3     999.0<br>4   -1000.0<br>5       3.0<br>dtype: float64</p><p>#假如-999是空值标记</p><p>data.replace(-999,np.nan)<br>Out[117]:<br>0       1.0<br>1       NaN<br>2       2.0<br>3     999.0<br>4   -1000.0<br>5       3.0<br>dtype: float64</p><p>#也可以一次替换多值</p><p>data.replace([-999,-1000],np.nan)<br>Out[119]:<br>0      1.0<br>1      NaN<br>2      2.0<br>3    999.0<br>4      NaN<br>5      3.0<br>dtype: float64<br>data_1=[23,’invalue’,34]<br>data_1=pd.Series(data_1)<br>data_1<br>Out[124]:<br>0         23<br>1    invalue<br>2         34<br>dtype: object<br>data_1.replace(‘invalue’,2)<br>Out[122]:<br>0    23<br>1     2<br>2    34<br>dtype: int64<br>data_1=pd.Series([1.,-999.,2.,-999.,-1000.,3.])</p><p>data_1<br>Out[129]:<br>0       1.0<br>1    -999.0<br>2       2.0<br>3    -999.0<br>4   -1000.0<br>5       3.0<br>dtype: float64<br>data_1.replace([-999,-1000],[np.nan,0])<br>Out[126]:<br>0    1.0<br>1    NaN<br>2    2.0<br>3    NaN<br>4    0.0<br>5    3.0<br>dtype: float64</p><p>#也可以表示成字典形式</p><p>data_1.replace({-999:np.nan,-1000:0})<br>Out[130]:<br>0    1.0<br>1    NaN<br>2    2.0<br>3    NaN<br>4    0.0<br>5    3.0<br>dtype: float64</p><p>重命名轴索引<br>data=pd.DataFrame(np.arange(12).reshape(3,4),index=[‘a’,’b’,’c’],columns=[‘c1’,’c2’,’c3’,’c4’])</p><p>#Map可以通过字典把要处理的列（键值）映射到对应的值，也可以通过函数把相应的列映射到对应的值</p><p>#通过str.upper函数map把行索引列映射到大写行索引列。</p><p>data.index=data.index.map(str.upper)</p><p>data<br>Out[137]:<br>   c1  c2  c3  c4<br>A   0   1   2   3<br>B   4   5   6   7<br>C   8   9  10  11</p><p>#可以用rename对轴索引进行修改<br>data.rename(index=str.title,columns=str.upper)<br>Out[5]:<br>   C1  C2  C3  C4<br>A   0   1   2   3<br>B   4   5   6   7<br>C   8   9  10  11</p><p>#rename通过字典的帮助可实现对部分标签的更新</p><p>data.rename(index={‘a’:’Sun’,’b’:’Zhang’,’c’:’Wang’},columns={‘c2’:’CNr.’})</p><p>data.rename(index={‘b’:’Zhang’,’c’:’Wang’},inplace=True)</p><p>data<br>Out[11]:<br>       c1  c2  c3  c4<br>a       0   1   2   3<br>Zhang   4   5   6   7<br>Wang    8   9  10  11</p><p>#通过inplace=True，可以改变原数据</p><p>数据的离散和面元划分<br>有些时候我们需要把连续数据离散化或拆分成面元。面元指的是一段按组拆分后的数据。面元化就是把数据进行分组。<br>例： ages=[20,22,25,27,26,31,78,45,20,19,67,34,56,66,59,43]</p><p>#面元化的实现</p><p>bin_nr=[min(ages),35,46,57,63,max(ages)]<br>bin_nr<br>Out[15]: [19, 35, 46, 57, 63, 78]<br>cut_1=pd.cut(ages,bin_nr)<br>cut_1<br>Out[17]:<br>[(19, 35], (19, 35], (19, 35], (19, 35], (19, 35], …, (19, 35], (46, 57], (63, 78], (57, 63], (35, 46]]<br>Length: 16<br>Categories (5, interval[int64]): [(19, 35] &lt; (35, 46] &lt; (46, 57] &lt; (57, 63] &lt; (63, 78]]</p><p>#对数据分组后的编号是：<br>ages<br>Out[28]: [20, 22, 25, 27, 26, 31, 78, 45, 20, 19, 67, 34, 56, 66, 59, 43]<br>cut_1.codes<br>Out[24]: array([ 0,  0,  0,  0,  0,  0,  4,  1,  0, -1,  4,  0,  2,  4,  3,  1], dtype=int8)<br>我们发现分组编号中有-1值，这是‘19’这个值造成的，因为我们的分组组限不包括‘19’这个值。解决办法有两个：<br>改变bin_nr<br>bin_nr=[18,min(ages),35,46,57,63,max(ages)]<br>cut_1=pd.cut(ages,bin_nr)<br>cut_1<br>Out[35]:<br>[(19, 35], (19, 35], (19, 35], (19, 35], (19, 35], …, (19, 35], (46, 57], (63, 78], (57, 63], (35, 46]]<br>Length: 16<br>Categories (6, interval[int64]): [(18, 19] &lt; (19, 35] &lt; (35, 46] &lt; (46, 57] &lt; (57, 63] &lt; (63, 78]]<br>cut_1.codes<br>Out[38]: array([1, 1, 1, 1, 1, 1, 5, 2, 1, 0, 5, 1, 3, 5, 4, 2], dtype=int8)<br>修改参数：<br>bin_nr=[min(ages),35,46,57,63,max(ages)]<br>pd.cut(ages,bin_nr,include_lowest=True)<br>Out[41]:<br>[(18.999, 35.0], (18.999, 35.0], (18.999, 35.0], (18.999, 35.0], (18.999, 35.0], …, (18.999, 35.0], (46.0, 57.0], (63.0, 78.0], (57.0, 63.0], (35.0, 46.0]]<br>Length: 16<br>Categories (5, interval[float64]): [(18.999, 35.0] &lt; (35.0, 46.0] &lt; (46.0, 57.0] &lt; (57.0, 63.0] &lt; (63.0, 78.0]]<br>cut2=pd.cut(ages,bin_nr,include_lowest=True)<br>cut2.codes<br>Out[43]: array([0, 0, 0, 0, 0, 0, 4, 1, 0, 0, 4, 0, 2, 4, 3, 1], dtype=int8)<br>ages<br>Out[45]: [20, 22, 25, 27, 26, 31, 78, 45, 20, 19, 67, 34, 56, 66, 59, 43]</p><p>#显示分组组限：<br>cut_1.categories<br>Out[31]:<br>IntervalIndex([(19, 35], (35, 46], (46, 57], (57, 63], (63, 78]]<br>              closed=’right’,<br>              dtype=’interval[int64]’)</p><p>#统计各组频数<br>pd.value_counts(cut2)<br>Out[55]:<br>(18.999, 35.0]    9<br>(63.0, 78.0]      3<br>(35.0, 46.0]      2<br>(57.0, 63.0]      1<br>(46.0, 57.0]      1<br>dtype: int64</p><p>#right=False可改变组限区间闭区间的位置；<br>bin_nr=[min(ages),35,46,57,63,max(ages),79]<br>pd.cut(ages,bin_nr,right=False)<br>Out[50]:<br>[[19, 35), [19, 35), [19, 35), [19, 35), [19, 35), …, [19, 35), [46, 57), [63, 78), [57, 63), [35, 46)]<br>Length: 16<br>Categories (6, interval[int64]): [[19, 35) &lt; [35, 46) &lt; [46, 57) &lt; [57, 63) &lt; [63, 78) &lt; [78, 79)]<br>cut4=pd.cut(ages,bin_nr,right=False)<br>cut4.codes<br>Out[52]: array([0, 0, 0, 0, 0, 0, 5, 1, 0, 0, 4, 0, 2, 4, 3, 1], dtype=int8)</p><p>#通过labels给面元设置名称<br>bin_nr=[min(ages),35,46,57,63,max(ages)]<br>pd.cut(ages,bin_nr,include_lowest=True)<br>cut2=pd.cut(ages,bin_nr,include_lowest=True,labels=Name_group)<br>cut2<br>Out[62]:<br>[青年, 青年, 青年, 青年, 青年, …, 青年, 中年, 少老年, 老中年, 壮年]<br>Length: 16<br>Categories (5, object): [青年 &lt; 壮年 &lt; 中年 &lt; 老中年 &lt; 少老年]</p><p>#如果给bins参数赋整数值，意味着传入的数值是面元数量，计算机会根据整个数据最大值和最小值计算等长面元。<br>bin_nr=[min(ages),35,46,57,63,max(ages)]<br>pd.cut(ages,bin_nr,include_lowest=True)<br>cut2=pd.cut(ages,6,include_lowest=True)<br>cut2<br>Out[64]:<br>[(18.94, 28.833], (18.94, 28.833], (18.94, 28.833], (18.94, 28.833], (18.94, 28.833], …, (28.833, 38.667], (48.5, 58.333], (58.333, 68.167], (58.333, 68.167], (38.667, 48.5]]<br>Length: 16<br>Categories (6, interval[float64]): [(18.94, 28.833] &lt; (28.833, 38.667] &lt; (38.667, 48.5] &lt; (48.5, 58.333] &lt; (58.333, 68.167] &lt; (68.167, 78.0]]<br>pd.value_counts(cut2)<br>Out[68]:<br>(18.94, 28.833]     7<br>(58.333, 68.167]    3<br>(38.667, 48.5]      2<br>(28.833, 38.667]    2<br>(68.167, 78.0]      1<br>(48.5, 58.333]      1<br>dtype: int64</p><p>#等数据点面元化</p><p>data_random=np.random.randn(1000)</p><p>cut_12=pd.qcut(data_random,8)</p><p>cut_12<br>Out[71]:<br>[(-1.193, -0.735], (-0.043, 0.297], (0.297, 0.628], (-1.193, -0.735], (-0.365, -0.043], …, (-3.453, -1.193], (-0.365, -0.043], (0.628, 1.122], (-0.735, -0.365], (1.122, 2.735]]<br>Length: 1000<br>Categories (8, interval[float64]): [(-3.453, -1.193] &lt; (-1.193, -0.735] &lt; (-0.735, -0.365] &lt; (-0.365, -0.043] &lt; (-0.043, 0.297] &lt; (0.297, 0.628] &lt; (0.628, 1.122] &lt; (1.122, 2.735]]<br>pd.value_counts(cut_12)<br>Out[72]:<br>(1.122, 2.735]      125<br>(0.628, 1.122]      125<br>(0.297, 0.628]      125<br>(-0.043, 0.297]     125<br>(-0.365, -0.043]    125<br>(-0.735, -0.365]    125<br>(-1.193, -0.735]    125<br>(-3.453, -1.193]    125<br>dtype: int64</p><p>#自定义分位数（必须是0-1之间的分位数，包括端点，因为这里是按百分比分位）<br>cut_12=pd.qcut(data_random,[0,0.3,0.6,0.85,1])<br>cut_12<br>Out[80]:<br>[(-3.453, -0.573], (-0.573, 0.218], (0.218, 0.987], (-3.453, -0.573], (-0.573, 0.218], …, (-3.453, -0.573], (-0.573, 0.218], (0.218, 0.987], (-3.453, -0.573], (0.987, 2.735]]<br>Length: 1000<br>Categories (4, interval[float64]): [(-3.453, -0.573] &lt; (-0.573, 0.218] &lt; (0.218, 0.987] &lt; (0.987, 2.735]]<br>pd.value_counts(cut_12)<br>Out[81]:<br>(-0.573, 0.218]     300(0-0.3)<br>(-3.453, -0.573]    300(0.3-0.6)<br>(0.218, 0.987]      250(0.6-0.85)<br>(0.987, 2.735]      150(0.85-1)<br>dtype: int64</p><p>检测和过滤异常值<br>Outlier（out来了）异常值。如何检测那些值是异常值呢？我们来看一个例子：<br>import pandas as pd</p><p>import numpy as np</p><p>np.random.seed(12876)</p><p>data=pd.DataFrame(np.random.randn(1000,4))</p><p>data.describe()<br>Out[5]:<br>                 0            1            2            3<br>count  1000.000000  1000.000000  1000.000000  1000.000000<br>mean     -0.032748     0.017600     0.005716     0.052615<br>std       1.029352     1.013877     0.974347     0.990795<br>min      -3.558590    -3.399723    -3.714028    -3.113867<br>25%      -0.731609    -0.654785    -0.703925    -0.604366<br>50%      -0.079017     0.001919     0.020646     0.041902<br>75%       0.686783     0.688564     0.685262     0.703313<br>max       3.040923     2.809213     2.827195     3.389950</p><p>#根据各列的最大值和最小值对各列数值进行过滤<br>c_1=data[2]<br>c_1[np.abs(c_1)&gt;3]<br>Out[8]:<br>382   -3.002094<br>466   -3.714028<br>Name: 2, dtype: float64</p><p>#对整个数据框中所有&gt;3的值进行过滤<br>Step1:<br>np.abs(data)&gt;3<br>Out[43]:<br>         0      1      2      3<br>0    False  False  False  False<br>1    False  False  False  False<br>2    False  False  False  False<br>3    False  False  False  False<br>4    False  False  False  False<br>5    False  False  False  False<br>6    False  False  False  False<br>7    False  False  False  False<br>8    False  False  False  False<br>9    False  False  False  False<br>10   False  False  False  False<br>11   False  False  False  False<br>12   False  False  False  False<br>13   False  False  False  False<br>14   False  False  False  False<br>15   False  False  False  False<br>16   False  False  False  False<br>17   False  False  False  False<br>18   False  False  False  False<br>19   False  False  False  False<br>20   False  False  False  False<br>21   False  False  False  False<br>22   False  False  False  False<br>23   False  False  False  False<br>24   False  False  False  False<br>25   False  False  False  False<br>26   False  False  False  False<br>27   False  False  False  False<br>28   False  False  False  False<br>29   False  False  False  False<br>..     …    …    …    …<br>970  False  False  False  False<br>971  False  False  False  False<br>972  False  False  False  False<br>973  False  False  False  False<br>974  False  False  False  False<br>975  False  False  False  False<br>976  False  False  False  False<br>977  False  False  False  False<br>978  False  False  False  False<br>979  False  False  False  False<br>980  False  False  False  False<br>981  False  False  False  False<br>982  False  False  False  False<br>983  False  False  False  False<br>984  False  False  False  False<br>985  False  False  False  False<br>986  False  False  False  False<br>987  False  False  False  False<br>988  False  False  False  False<br>989  False  False  False  False<br>990  False  False  False  False<br>991  False  False  False  False<br>992  False  False  False  False<br>993  False  False  False  False<br>994  False  False  False  False<br>995  False  False  False  False<br>996  False  False  False  False<br>997  False  False  False  False<br>998  False  False  False  False<br>999  False  False  False  False</p><p>[1000 rows x 4 columns]<br>Step2:</p><p>#逐列按行，把含有true值的每一行转化成true，把不含的行转成false，返回series</p><p>(np.abs(data)&gt;3).any(1)<br>Out[46]:<br>0      False<br>1      False<br>2      False<br>3      False<br>4      False<br>5      False<br>6      False<br>7      False<br>8      False<br>9      False<br>10     False<br>11     False<br>12     False<br>13     False<br>14     False<br>15     False<br>16     False<br>17     False<br>18     False<br>19     False<br>20     False<br>21     False<br>22     False<br>23     False<br>24     False<br>25     False<br>26     False<br>27     False<br>28     False<br>29     False</p><p>970    False<br>971    False<br>972    False<br>973    False<br>974    False<br>975    False<br>976    False<br>977    False<br>978    False<br>979    False<br>980    False<br>981    False<br>982    False<br>983    False<br>984    False<br>985    False<br>986    False<br>987    False<br>988    False<br>989    False<br>990    False<br>991    False<br>992    False<br>993    False<br>994    False<br>995    False<br>996    False<br>997    False<br>998    False<br>999    False<br>Length: 1000, dtype: bool<br>Step3:</p><p>#放到索引位置直接索引行<br>data[(np.abs(data)&gt;3).any(1)]<br>Out[16]:<br>            0         1         2         3<br>82  -1.535879 -1.077352  1.293144  3.058112<br>270 -1.131598 -0.273447 -0.979915 -3.113867<br>281  0.022546 -0.526429  0.361507  3.021792<br>283 -0.469536  0.122044 -1.188901  3.389950<br>327 -0.676235  0.155461 -0.706008  3.026979<br>340  3.040923  1.046905 -0.375365 -0.572458<br>358 -3.558590 -1.343718  1.411491  1.001404<br>382 -1.947519  0.556118 -3.002094  0.701169<br>466 -1.817789 -0.187283 -3.714028 -0.049148<br>859  0.906164 -3.399723 -0.360720  0.245022<br>注意：<br>1.参数bool_only意味着只接受布尔值，如果是空值的话，计算机会检验数据，然后仅仅接收是布尔值的数据。如果是False，非布尔值数据参与比较，且自动被设置为True值参与比较。例如：<br>TM_1=TM.astype(object)</p><p>TM_1.loc[0]=3</p><p>TM_1<br>Out[60]:<br>         0      1      2      3<br>0        3      3      3      3<br>1    False  False  False  False<br>2    False  False  False  False<br>3    False  False  False  False<br>4    False  False  False  False<br>5    False  False  False  False<br>6    False  False  False  False<br>7    False  False  False  False<br>8    False  False  False  False<br>9    False  False  False  False<br>10   False  False  False  False<br>11   False  False  False  False<br>12   False  False  False  False<br>13   False  False  False  False<br>14   False  False  False  False<br>15   False  False  False  False<br>16   False  False  False  False<br>17   False  False  False  False<br>18   False  False  False  False<br>19   False  False  False  False<br>20   False  False  False  False<br>21   False  False  False  False<br>22   False  False  False  False<br>23   False  False  False  False<br>24   False  False  False  False<br>25   False  False  False  False<br>26   False  False  False  False<br>27   False  False  False  False<br>28   False  False  False  False<br>29   False  False  False  False<br>..     …    …    …    …<br>970  False  False  False  False<br>971  False  False  False  False<br>972  False  False  False  False<br>973  False  False  False  False<br>974  False  False  False  False<br>975  False  False  False  False<br>976  False  False  False  False<br>977  False  False  False  False<br>978  False  False  False  False<br>979  False  False  False  False<br>980  False  False  False  False<br>981  False  False  False  False<br>982  False  False  False  False<br>983  False  False  False  False<br>984  False  False  False  False<br>985  False  False  False  False<br>986  False  False  False  False<br>987  False  False  False  False<br>988  False  False  False  False<br>989  False  False  False  False<br>990  False  False  False  False<br>991  False  False  False  False<br>992  False  False  False  False<br>993  False  False  False  False<br>994  False  False  False  False<br>995  False  False  False  False<br>996  False  False  False  False<br>997  False  False  False  False<br>998  False  False  False  False<br>999  False  False  False  False</p><p>[1000 rows x 4 columns]</p><p>TM_1.any(1,bool_only=True)<br>Out[61]:<br>0      False<br>1      False<br>2      False<br>3      False<br>4      False<br>5      False<br>6      False<br>7      False<br>8      False<br>9      False<br>10     False<br>11     False<br>12     False<br>13     False<br>14     False<br>15     False<br>16     False<br>17     False<br>18     False<br>19     False<br>20     False<br>21     False<br>22     False<br>23     False<br>24     False<br>25     False<br>26     False<br>27     False<br>28     False<br>29     False</p><p>970    False<br>971    False<br>972    False<br>973    False<br>974    False<br>975    False<br>976    False<br>977    False<br>978    False<br>979    False<br>980    False<br>981    False<br>982    False<br>983    False<br>984    False<br>985    False<br>986    False<br>987    False<br>988    False<br>989    False<br>990    False<br>991    False<br>992    False<br>993    False<br>994    False<br>995    False<br>996    False<br>997    False<br>998    False<br>999    False<br>Length: 1000, dtype: bool</p><p>TM_1.any(1,bool_only=False)<br>Out[62]:<br>0       True<br>1      False<br>2      False<br>3      False<br>4      False<br>5      False<br>6      False<br>7      False<br>8      False<br>9      False<br>10     False<br>11     False<br>12     False<br>13     False<br>14     False<br>15     False<br>16     False<br>17     False<br>18     False<br>19     False<br>20     False<br>21     False<br>22     False<br>23     False<br>24     False<br>25     False<br>26     False<br>27     False<br>28     False<br>29     False</p><p>970    False<br>971    False<br>972    False<br>973    False<br>974    False<br>975    False<br>976    False<br>977    False<br>978    False<br>979    False<br>980    False<br>981    False<br>982    False<br>983    False<br>984    False<br>985    False<br>986    False<br>987    False<br>988    False<br>989    False<br>990    False<br>991    False<br>992    False<br>993    False<br>994    False<br>995    False<br>996    False<br>997    False<br>998    False<br>999    False<br>Length: 1000, dtype: bool</p><p>2.如果我们这里使用any（0），将会发生错误，原因是返回值仅仅是一个下面的series，把它放到索引位。肯定无法进行索引</p><p>(np.abs(data)&gt;3).any(0)<br>Out[36]:<br>0    True<br>1    True<br>2    True<br>3    True<br>dtype: bool<br>data[(np.abs(data)&gt;3).any(0)]<br>C:\Users\dongfeng\Anaconda3\lib\site-packages\ipykernel_launcher.py:1: UserWarning: Boolean Series key will be reindexed to match DataFrame index.</p><h2 id="“””Entry-point-for-launching-an-IPython-kernel"><a href="#“””Entry-point-for-launching-an-IPython-kernel" class="headerlink" title="  “””Entry point for launching an IPython kernel."></a>  “””Entry point for launching an IPython kernel.</h2><p>IndexingError                             Traceback (most recent call last)</p><p><ipython-input-37-ebe2c62f7641> in <module>()<br>—-&gt; 1 data[(np.abs(data)&gt;3).any(0)]</module></ipython-input-37-ebe2c62f7641></p><p>~\Anaconda3\lib\site-packages\pandas\core\frame.py in <strong>getitem</strong>(self, key)<br>   1956         if isinstance(key, (Series, np.ndarray, Index, list)):<br>   1957             # either boolean or fancy integer index<br>-&gt; 1958             return self._getitem_array(key)<br>   1959         elif isinstance(key, DataFrame):<br>   1960             return self._getitem_frame(key)</p><p>~\Anaconda3\lib\site-packages\pandas\core\frame.py in _getitem_array(self, key)<br>   1996             # check_bool_indexer will throw exception if Series key cannot<br>   1997             # be reindexed to match DataFrame rows<br>-&gt; 1998             key = check_bool_indexer(self.index, key)<br>   1999             indexer = key.nonzero()[0]<br>   2000             return self.take(indexer, axis=0, convert=False)</p><p>~\Anaconda3\lib\site-packages\pandas\core\indexing.py in check_bool_indexer(ax, key)<br>   1937         mask = isnull(result._values)<br>   1938         if mask.any():<br>-&gt; 1939             raise IndexingError(‘Unalignable boolean Series provided as ‘<br>   1940                                 ‘indexer (index of the boolean Series and of ‘<br>   1941                                 ‘the indexed object do not match’)</p><p>IndexingError: Unalignable boolean Series provided as indexer (index of the boolean Series and of the indexed object do not match</p><p>当然我们可以修改，把其放在列位，但这样的话等于什么也没有做，仅仅选取所有列<br>data.loc[:,(np.abs(data)&gt;3).any(0)]<br>Out[40]:<br>            0         1         2         3<br>0   -0.567046 -0.491171 -0.827547 -0.680408<br>1    0.206551 -1.456287  0.629825  0.148732<br>2   -1.130370 -0.056857  1.431013  1.475764<br>3   -2.125800  0.108440 -1.350079  0.523728<br>4   -0.736537 -0.846202  0.543960 -1.230080<br>5   -0.152478  0.087115 -0.304004  0.050398<br>6   -0.479466 -1.990843 -0.361344  1.096610<br>7   -0.246875  0.595030  1.469306 -0.438550<br>8    0.989888  0.174695  0.241461 -0.550926<br>9   -0.781855  1.660456  1.041865  0.264480<br>10   1.661492  0.356601 -0.699093  0.869719<br>11   0.163815  0.246831 -0.250914 -0.694415<br>12  -1.584598 -1.279383 -1.274184 -0.008277<br>13  -0.266142  1.401936  0.397230 -0.087856<br>14   0.016147  0.710451  1.548756  0.292436<br>15  -0.885661 -0.126581  0.927745 -0.194748<br>16  -0.018011  0.384556  0.545346  0.447323<br>17  -1.785552  0.372100  0.014757 -2.023199<br>18   0.764790  0.900823 -1.039617  1.111810<br>19  -0.603835  0.951399 -1.166977  2.091614<br>20   0.227416  0.606907 -0.533333  0.524420<br>21   0.728552 -0.138527 -1.922079 -2.683756<br>22  -1.777072 -0.610157 -1.141227 -0.527488<br>23  -0.393001  1.573780 -0.270537 -0.552588<br>24   0.142684 -0.237119 -2.089615  0.982052<br>25   0.048209 -0.858588  1.238078  0.605156<br>26  -0.736681  0.402256 -0.247741 -0.549385<br>27  -0.183541 -0.654161  0.539174 -0.597491<br>28   0.641096 -1.708915  0.660372  0.510122<br>29  -0.174187 -0.809638  0.032858 -1.431953<br>..        …       …       …       …<br>970 -0.868857  2.001313  0.852164  0.589976<br>971 -0.557336  0.318217 -0.546586  1.061976<br>972 -0.884070 -0.641405 -0.210885  0.049715<br>973  0.785917  0.212696  1.193491  1.007289<br>974  0.921965 -0.478275 -1.417855  0.911799<br>975  0.131626  0.050366  0.637130  0.267212<br>976 -1.425079  0.923022 -0.208123 -0.697405<br>977  1.723595 -0.022576 -0.954601 -0.374849<br>978 -2.049331  1.803200 -0.894918  0.955312<br>979  0.082268  2.073896  0.072605  0.912109<br>980 -0.166275 -0.463344  1.510438 -0.478526<br>981  0.438580  0.540105  1.023839  0.441328<br>982 -0.260641  1.145658  0.062698  1.655832<br>983 -0.176418 -0.032755  0.906118  2.012923<br>984 -0.870494  0.038007 -0.371591 -0.262396<br>985 -0.683679 -0.182418  0.683105 -0.852608<br>986 -0.641252  1.387388  1.770705 -1.003002<br>987 -2.111872 -0.438135  0.669196 -0.642335<br>988  1.279690 -0.179545 -1.728947  0.837643<br>989 -0.378165  0.507085 -0.106542  0.511993<br>990  0.741188 -0.681142 -0.192551 -0.712643<br>991  1.045758  0.238560 -0.713991 -0.463895<br>992 -1.052059 -0.942410 -0.062352  0.267082<br>993 -0.184833  1.474266  2.345032  1.189559<br>994 -0.245563 -0.513430 -0.998651 -0.858027<br>995  0.745093  0.478441  1.731140  0.848215<br>996 -0.445829 -0.022585 -0.621001 -1.348158<br>997 -1.479772  0.688092 -1.209812 -1.247304<br>998 -0.260688  0.373783 -0.384794  1.073226<br>999 -0.395423  0.955142  0.525140  1.178641</p><p>#把所有数据限制到-3到3的范围内。<br>data[np.abs(data)&gt;3]=np.sign(data)*3#左边实现绝对值大于3的值的选取，即设置了x&gt;3或x&lt;-3的选区。右边是符号与左边选区数值对应，绝对值数值为3的数据。通过=赋值到选区的相应位置。<br>count_frame=pd.DataFrame([pd.value_counts(np.abs(data[0])&gt;3),pd.value_counts(np.abs(data[1])&gt;3),pd.value_counts(np.abs(data[2])&gt;3),pd.value_counts(np.abs(data[3])&gt;3)])</p><p>count_frame<br>Out[77]:<br>   False<br>0   1000<br>1   1000<br>2   1000<br>3   1000</p><p>排列与随机采样</p><p>通过permutation函数可以实现对数据框或者Series的随机排列。<br>asr=np.random.randint(-6,6,15).reshape(5,3)<br>asr_fra=pd.DataFrame(asr)<br>asr_fra<br>Out[17]:<br>   0  1  2<br>0 -2  1  0<br>1 -2  4  3<br>2 -5  1  4<br>3  0  4  1<br>4  4  4 -1<br>np.random.permutation(asr_fra)<br>Out[18]:<br>array([[-5,  1,  4],<br>       [-2,  4,  3],<br>       [ 4,  4, -1],<br>       [ 0,  4,  1],<br>       [-2,  1,  0]])</p><p>#其实质仅仅是对第一列数据进行排列，其他列随着第一列移动</p><p>#下面对Series进行随机排列<br>ser1=pd.Series([3,2,7,9,0,2,1,9,2,2,3,12,17])<br>np.random.permutation(ser1)<br>Out[22]: array([ 9,  7,  3,  0,  2,  3, 17,  2, 12,  2,  1,  9,  2], dtype=int64)</p><p>#我们也可以通过产生一个随机排列数组，对数组进行排列</p><p>as_frame=pd.DataFrame(np.random.randint(-12,20,42).reshape(7,6))</p><p>as_frame<br>Out[26]:<br>    0   1   2   3   4   5<br>0  -5  13  10  14  -2   5<br>1 -10  13  -9  10  -4  -7<br>2   6  11   0  -2  -8   9<br>3   0 -11  -8  -2 -12  16<br>4   3 -12  -5  18   8   3<br>5   0   3   4   4   5  10<br>6   7   0   6  -7   3 -10</p><p>pattern=np.random.permutation(6)<br>pattern<br>Out[29]: array([5, 4, 3, 0, 1, 2])<br>as_frame.take(pattern,0)<br>Out[28]:<br>    0   1   2   3   4   5<br>5   0   3   4   4   5  10<br>4   3 -12  -5  18   8   3<br>3   0 -11  -8  -2 -12  16<br>0  -5  13  10  14  -2   5<br>1 -10  13  -9  10  -4  -7<br>2   6  11   0  -2  -8   9<br>注意这里返回的结果是as_frame的一个子数据框，这是因为pattern的结果是从从0到5的一个排列，数据框的行索引是按照这个pattern的这个结果进行排列。<br>这里也可以按列索引进行排列<br>as_frame.take(pattern,1)<br>Out[31]:<br>    5   4   3   0   1   2<br>0   5  -2  14  -5  13  10<br>1  -7  -4  10 -10  13  -9<br>2   9  -8  -2   6  11   0<br>3  16 -12  -2   0 -11  -8<br>4   3   8  18   3 -12  -5<br>5  10   5   4   0   3   4<br>6 -10   3  -7   7   0   6<br>as_frame.take(np.random.permutation([4,3,0,1]),1)#可以按照索引子集的排列进行列的重排<br>Out[33]:<br>    3   4   0   1<br>0  14  -2  -5  13<br>1  10  -4 -10  13<br>2  -2  -8   6  11<br>3  -2 -12   0 -11<br>4  18   8   3 -12<br>5   4   5   0   3<br>6  -7   3   7   0<br>as_frame.take(np.random.permutation(as_frame.shape[1])[:4],1)<br>Out[37]:<br>    0   2   4   5<br>0  -5  10  -2   5<br>1 -10  -9  -4  -7<br>2   6   0  -8   9<br>3   0  -8 -12  16<br>4   3  -5   8   3<br>5   0   4   5  10<br>6   7   6   3 -10</p><p>通过random.randint和take函数就行随机抽样</p><p>五，绘图和可视化<br>Matplotlib入门，pandas下的绘图函数，画布，画布分割等等<br>Matplotlib入门<br>调用Matplotlib API 程序包</p><p>1，创建画布<br>import matplotlib as plt</p><p>import matplotlib.pyplot as plt</p><p>figure_1=plt.figure()<br>(或者详细定义画布<br>figure_1=plt.figure(1,(4,6),dpi=400,facecolor=’green’,edgecolor=’yellow’,frameon=True)）<br>figure_1<br>Out[43]: &lt;matplotlib.figure.Figure at 0x8ea7987320&gt;</p><p>2，分割画布</p><p>aapic_1=figure_1.add_subplot(2,2,1)</p><p>aapic_2=figure_1.add_subplot(2,2,2)</p><p>aapic_3=figure_1.add_subplot(2,2,3)</p><p>aapic_4=figure_1.add_subplot(2,2,4)</p><p>3，show 出你的画布</p><p>plt.show()</p><p>import matplotlib.pyplot as plt</p><p>import numpy as np</p><p>figure_1=plt.figure()</p><p>aapic_1=figure_1.add_subplot(2,2,1)</p><p>aapic_2=figure_1.add_subplot(2,2,2)</p><p>aapic_3=figure_1.add_subplot(2,2,3)</p><p>plt.plot(np.random.randn(50).cumsum(),’k–’)<br>Out[7]: [&lt;matplotlib.lines.Line2D at 0xdd16defd0&gt;]</p><p>#直接用“plot”绘图，k–代表黑色虚线图</p><p>aapic_2.hist(np.random.randn(100),bins=20,color=’k’,alpha=0.3)<br>Out[9]:<br>(array([  1.,   1.,   1.,   5.,   3.,   7.,   8.,  14.,  11.,   6.,  11.,<br>          6.,  13.,   5.,   2.,   3.,   0.,   1.,   0.,   2.]),<br> array([-2.64526298, -2.37172471, -2.09818644, -1.82464817, -1.5511099 ,<br>        -1.27757163, -1.00403336, -0.73049509, -0.45695681, -0.18341854,<br>         0.09011973,  0.363658  ,  0.63719627,  0.91073454,  1.18427281,<br>         1.45781108,  1.73134935,  2.00488762,  2.27842589,  2.55196416,<br>         2.82550243]),<br> <a 20 list of patch objects>)</a></p><p>aapic_1.scatter(np.arange(30),np.arange(30)+3*np.random.randn(30))<br>Out[10]: &lt;matplotlib.collections.PathCollection at 0xdd172c390&gt;</p><p>#alpha代表透明度，bins代表柱状体个数</p><p>plt.show<br>Out[12]: <function matplotlib.pyplot.show></function></p><p>plt.show()</p><p>这里还有一个简单且更为方便的画图方法；它可以创建一个新的figure（画布）并返回一个含有以创建的subplot对象的numpy数组。<br>pic,axes=plt.subplots(2,3)<br>plt.show(0)</p><p>饼图：<br>import numpy as np<br>import matplotlib.pyplot as plt<br>Asx,sd=plt.subplots(1,1)<br>sd.pie(np.arange(4,9),explode=[0.2,0.1,0.3,0.4,0.3],labels=[‘zhang’,’wang’,’li’,’zhao’,’liu’],colors=[‘m’,’r’,’g’,’c’,’b’],autopct=’%.2f%%’,pctdistance=1,shadow=True,labeldistance=1.6,startangle=30,radius=1,frame=True,rotatelabels=True)<br>Plt.show()</p><p> Asx,sd=plt.subplots(1,1)<br>sd.pie(np.arange(4,9),explode=[0,0,0,0,0],labels=[‘zhang’,’wang’,’li’,’zhao’,’liu’],colors=[‘m’,’r’,’g’,’c’,’b’],autopct=’%.2f%%’,pctdistance=1,shadow=True,labeldistance=0.5,startangle=30,radius=1,frame=True,rotatelabels=True)<br>plt.show()</p><p>#labeldistance&lt;1,图例将会在饼图内</p><p>#通过figsize=（6,6）把饼图设置成圆的，然后通过textprops设置字体，通过labeldistance设置标签离圆心距离。通过autopct设置每个部分总总体的百分数，通过pctdistance设置百分数例圆心距离，通过explode设置一个部分的强调。<br>Asx,sd=plt.subplots(1,1,figsize=(6,6))<br>sd.pie(np.arange(4,9),explode=[0,0.1,0,0,0],labels=[‘zhang’,’wang’,’li’,’zhao’,’liu’],colors=[‘m’,’r’,’g’,’c’,’b’],autopct=’%.2f%%’,pctdistance=0.4,shadow=True,labeldistance=0.5,wedgeprops=None,textprops={‘fontsize’:14},startangle=0,radius=1,frame=True,rotatelabels=None)<br>plt.show()</p><p>调整Subplot周围的间距：</p><p>默认情况下，子图外围是有一定边距的，并且各子图之间上下左右都有一定间距。</p><p>间距与子图大小有关，子图像宽，则横向间距小，图像高，则纵向间距小。</p><p>除了默认，我们可以选择自己确定间距：</p><p>plt.subplots_adjust(left=None,bottom=None,right=None,top=None,wspace=None,hspace=None)</p><p>#wspace和hspace用于控制宽度和高度的百分比，通过调整这两个参数，我们的子图间的上下左右间距会发生变化</p><p>例子：</p><p>import numpy as np<br>fig, axes=plt.subplots(2, 2, sharex=True, sharey=True)<br>for i in range(2):<br>    for j in range(2):<br>        axes[i,j].hist(np.random.randn(500),color=’k’,alpha=0.5)<br>plt.subplots_adjust(wspace=2,hspace=1)</p><p>plt.show(0)</p><p>&lt;matplotlib.figure.Figure at 0x17becd9908&gt;</p><p>&lt;matplotlib.figure.Figure at 0x17befbfda0&gt;</p><p>#shareX 和sharey是共X轴和Y轴。调整wspace 盒hspace可以得到不同的子图间距。<br>for i in range(2):<br>    for j in range(2):<br>        axes[i,j].hist(np.random.randn(500),color=’k’,alpha=0.5)<br>plt.subplots_adjust(wspace=0.2,hspace=0.1)</p><p>plt.show(0)</p><p>&lt;matplotlib.figure.Figure at 0x17becd9908&gt;</p><p>&lt;matplotlib.figure.Figure at 0x17befbfda0&gt;</p><p>问：上面图像的X轴和Y轴分别指的是什么？？？？</p><p>颜色和线型以及标记<br>指定图形函数线的颜色，我们可以通过一个指令实现，例：<br>Pic_11.plot(X,Y,’g–’) 等价于 ax.plot(x,y,linestyle=’–’,color=’g’)</p><p>更多颜色可使用指定其RGB值的形式。对于线性图，我们可以给数据点加上标记(marker)，使人更容易发现那些是数据点。</p><p>线型和marker表格：<br>‘-‘ solid line style<br>‘–’ dashed line style<br> ‘-.’ dash-dot line style<br>‘:’ dotted line style<br>‘.’ point marker<br>‘,’ pixel marker<br>‘o’ circle marker<br>‘v’ triangle_down marker<br>‘^’ triangle_up marker<br> ‘&lt;’ triangle_left marker<br>‘&gt;’ triangle_right marker<br>‘1’ tri_down marker<br>‘2’ tri_up marker<br>‘3’ tri_left marker<br>‘4’ tri_right marker<br> ‘s’ square marker<br>‘p’ pentagon marker<br>‘*’ star marker<br>‘h’ hexagon1 marker<br>‘H’ hexagon2 marker<br>‘+’ plus marker<br>‘x’ x marker<br>‘D’ diamond marker<br> ‘d’ thin_diamond marker<br>‘|’ vline marker<br>‘_’ hline marker<br>颜色表格：<br>‘b’ blue<br>‘g’ green<br>‘r’ red<br>‘c’ cyan<br>‘m’ magenta<br>‘y’ yellow<br>‘k’ black<br>‘w’ white</p><p>美丽温馨的例子：<br>marker_1=[‘.’, ‘,’, ‘o’, ‘v’, ‘^’, ‘&lt;’, ‘&gt;’, ‘1’, ‘2’, ‘3’, ‘4’,’s’,’p’,’<em>‘,’h’,’H’,’+’,’x’,’D’,’d’,’|’, ‘_’]<br>asd,fid_1=plt.subplots(len(marker_1),dpi=180,figsize=(6,6</em>len(marker_1)))<br>for i in range(len(marker_1)):<br>    N = 50 # 点的个数<br>    x = np.random.rand(N) <em> 2 # 随机产生50个0~2之间的x坐标<br>    y = np.random.rand(N) </em> 2 # 随机产生50个0~2之间的y坐标<br>    colors = np.random.rand(N) # 随机产生50个0~1之间的颜色值<br>    area = np.pi <em> (15 </em> np.random.rand(N))**2  # 点的半径范围:0~15 </p><pre><code># 画散点图fid_1[i].scatter(x, y, s=area, c=colors, alpha=0.5, marker=marker_1[i])fid_1[i].set_xlabel(marker_1[i])</code></pre><p>plt.show()</p><p>如果不涉及子图的话，无需先设置画布。可直接画出图形：<br>import numpy as np<br>import matplotlib.pyplot as plt<br>plt.plot(np.random.randn(30).cumsum(),’g*–’)<br>Out[3]: [&lt;matplotlib.lines.Line2D at 0xb407f4dd30&gt;]<br>plt.show()</p><p>plt.plot(np.random.randn(30).cumsum(),’g<em>–’) 等价于<br>Plt.plot(np.random.randn(30).cumsum(),color=’g’,linestyle=’dashed’,marker=’</em>’)</p><p>在线性图中，那些非数据点都是根据两个数据点连线插值的，我们可以修改这种插值方式，这里用到drawstyle选项修改：</p><p>data=np.array([1,2,3.2,2.3,4.6,7.5,2,3,6.5,7.8,9],dtype=float)<br>np.unique(data)<br>Out[9]: array([ 1. ,  2. ,  2.3,  3. ,  3.2,  4.6,  6.5,  7.5,  7.8,  9. ])<br>data<br>Out[10]: array([ 1. ,  2. ,  3.2,  2.3,  4.6,  7.5,  2. ,  3. ,  6.5,  7.8,  9. ])<br>data_uique=np.unique(data)<br>plt.plot(data_uique,’o-.’,label=’line_point’)<br>Out[28]: [&lt;matplotlib.lines.Line2D at 0xb40947c908&gt;]<br>plt.plot(data_uique,’r-‘,drawstyle=’steps-post’,label=’line’)<br>Out[29]: [&lt;matplotlib.lines.Line2D at 0xb40947cf98&gt;]<br> plt.legend(loc=’best’)<br>Out[30]: &lt;matplotlib.legend.Legend at 0xb4083ca358&gt;<br>plt.show()</p><p>legend函数介绍：<br>在画一些曲线图时，常常会出现多条曲线同时画在一张图上面，这时候就需要对不同的曲线进行不同的标注，以使读者能够清晰地知道每条曲线代表的含义。当你画很少的几条曲线时，这时画图命令中自动产生的legend能够基本满足你的需要，此时，你不需要做什么；但当你将很多个曲线画在一张图上时，自动产生的legend矩形框往往会覆盖住已经画出来的曲线，很不美观，这时你就需要写专门的代码对legend的位置进行精确的控制，而不能再依靠系统帮你自动控制了。</p><p>比如：<br>plt.legend(loc=’upper center’, bbox_to_anchor=(0.6,0.95),ncol=3,fancybox=True,shadow=True)<br>Ncol=表示我们的图例（legend）里的线的标识可以排成三列<br>Loc=标识图例的位置<br>bbox_to_anchor=图例的精确位置，上面bbox_to_anchor被赋予的二元组中，第一个数值用于控制legend的左右移动，值越大越向右边移动，第二个数值用于控制legend的上下移动，值越大，越向上移动。</p><p>刻度与标签<br>图像的刻度与标签都是通过一些方法来实现的，这里有几个方法大家在绘图中经常用到：</p><p>Xlim（X值范围）、xticks（X轴刻度值）和xticklabels（X轴刻度标签）</p><p>其使用方式有以下两种:<br>1.调用不带参数值，返回当前参数值，即是现在正用的参数值。<br>2.调用时带参数值，使用该参数值。</p><p>例：</p><p>table_1=plt.figure()</p><p>ax=table_1.add_subplot(1,1,1)</p><p>ax.plot(np.random.randn(1000).cumsum())<br>Out[36]: [&lt;matplotlib.lines.Line2D at 0xb409514550&gt;]</p><p>ax.plot(np.random.randn(100000).cumsum())<br>Out[37]: [&lt;matplotlib.lines.Line2D at 0xb40948f780&gt;]</p><p>ticks_1=ax.set_xticks([0,25000,50000,75000,100000])</p><p>scale_name=ax.set_xticklabels([‘step1’,’step2’,’step3’,’step4’,’step5’],rotation=45,fontsize=12)</p><p>ax.set_title(‘Python-03 Practice’)<br>Out[40]: Text(0.5,1,’Python-03 Practice’)</p><p>ax.set_xlabel(‘Steps’)<br>Out[41]: Text(0.5,0,’Steps’)</p><p>#下面我们添加图例<br>ax.plot(np.random.randn(100000).cumsum(),color=’m’,linestyle=’-‘,label=’solid’)<br>Out[44]: [&lt;matplotlib.lines.Line2D at 0xb409852748&gt;]</p><p>ax.plot(np.random.randn(100000).cumsum(),color=’c’,linestyle=’:’,label=’dotted’)<br>Out[45]: [&lt;matplotlib.lines.Line2D at 0xb4094f52b0&gt;]</p><p>ax.legend(loc=’best’)#plt.legend也是可以的<br>Out[46]: &lt;matplotlib.legend.Legend at 0xb409852ac8&gt;<br>plt.show()</p><p>加注解<br>用text、arrow和annotate等函数进行添加注解，text可以将文本加到图标的指定坐标。</p><p> fig,subpic=plt.subplots(1,1)</p><p>subpic.plot([2,77,90,2.3,4,5,6,45,34,67,35,66,34,23,76],[34,32,35,43,34,23,45,56,44,57,56,33,55,66,54],’b*-‘)<br>Out[7]: [&lt;matplotlib.lines.Line2D at 0x2eae706be0&gt;]<br>ticks_1=subpic.set_xticks([0,25,50,75,100])</p><p>scale_name=subpic.set_xticklabels([‘jenuary’,’february’,’march’,’april’,’may’],rotation=40,fontsize=12)</p><p>subpic.set_title(‘Python-03 Practice_1’,fontsize=16)<br>Out[11]: Text(0.5,1,’Python-03 Practice_1’)<br>subpic.set_xlabel(‘Weight’)<br>Out[13]: Text(0.5,0,’Weight’)<br>subpic.text(90,35,’key point one’,fontsize=10)<br>Out[15]: Text(90,35,’key point one’)</p><p>keymenge=[(67,57,’key point two’),(23,66,’key point two’)]</p><p>for x,y,label in keymenge:<br>    subpic.text(x,y,label,fontsize=12)</p><p>subpic.set_xlim([0,100])<br>Out[21]: (0, 100)</p><p>subpic.set_ylim([0,100])<br>Out[22]: (0, 100)<br>subpic.annotate(‘beautyful point’,xy=(5,23),xytext=(5,23))<br>Out[18]: Text(5,23,’beautyful point’)<br>plt.savefig(‘Desktop\python_01.svg’)<br>plt.savefig(‘Desktop\python_01.png’,dpi=400,bbox_inches=’tight’)</p><p>plt.show()</p><p>Matplotlib.pyplot的画图方式与R语言十分类似，繁琐是他们共同的特点。与Matplotlib.pyplot不同，pandas在作图上不仅方法简单，而且可以完成各种各样的作图工作。</p><p>图像的保存<br>在上一章，我们已经使用了savefig这个函数来存储图像。事实上，Savefig还可以作为对象figure的方法存储画布上的图像，例如：</p><p>import matplotlib.pyplot as plt<br>pic=plt.figure()<br>pic_1=pic.add_subplot(1,1,1)<br>import numpy as np<br>pic_1.plot(np.random.randn(50).cumsum(),’k–’)<br>Out[6]: [&lt;matplotlib.lines.Line2D at 0xa22b23f0b8&gt;]<br>pic.savefig(‘Desktop\dong_123.pdf’,dpi=300,bbox_inches=’tight’)</p><p>Savefig的主要参数如下：<br>fname: 表示绝对或者相对文件路径的字符串，文件具体格式由后缀来决定，譬如.pdf,.png格式等。<br>dpi: 图像分辨率，默认100，（每英寸点数）<br>Facecolor,edgecolor: 背景色，默认为“w”白色<br>Format: 显示设置文件格式，png，jpeg，pdf等等，但不要与fname里的文件格式发生冲突。<br>Bbox_inches，常用值是tight，可剪除图表周围的空白部分。</p><p>Pandas作图</p><p>线性图</p><p>Series 和 DataFrame 都有一个用于生成各类图表的plot方法，默认状态。他只生成线性图。<br>Series生成线性图，索引（index）直接被绘制成X轴。当然我们也可以关闭使用index绘制X轴。Use_index=False</p><p>X轴的刻度和界限可以用xsticks和xlim选项来进行调节，ysticks和ylim可以调节Y轴</p><p>例子<br>ser=pd.Series(np.random.randn(10).cumsum(),index=np.arange(0,100,10))</p><p>ser.plot()<br>Out[18]: &lt;matplotlib.axes._subplots.AxesSubplot at 0xf3e54e0240&gt;</p><p>plt.show()</p><p>DataFrame的plot方法会在一个子图中为各列数据绘制一条线。自动创建的图例的标签与列索引相同。</p><p>例：<br>import numpy as np</p><p>import pandas as pd<br>import matplotlib.pyplot as plt</p><p>Frame_01=pd.DataFrame([[2,4,8,16,32,64],[3,6,12,24,48,96],[5,10,15,20,25,30],[1,3,5,7,9,11],[16,8,4,2,1,0.5]],index=range(0,100,20),columns=[‘A’,’B’,’C’,’D’,’E’,’F’])</p><p>pic_2,subplot_object=plt.subplots(1,1)</p><p>Frame_01.plot(kind=’line’,ax=subplot_object,subplots=False,layout=False,logx=True,xlim=[0,100])<br>C:\Users\dongfeng\Anaconda3\lib\site-packages\matplotlib\axes_base.py:2923: UserWarning: Attempted to set non-positive xlimits for log-scale axis; invalid limits will be ignored.<br>  ‘Attempted to set non-positive xlimits for log-scale axis; ‘<br>Out[3]: &lt;matplotlib.axes._subplots.AxesSubplot at 0x5441e71cf8&gt;<br>plt.show()<br>Frame_01<br>Out[5]:<br>     A   B   C   D   E     F<br>0    2   4   8  16  32  64.0<br>20   3   6  12  24  48  96.0<br>40   5  10  15  20  25  30.0<br>60   1   3   5   7   9  11.0<br>80  16   8   4   2   1   0.5</p><p>Series.plot 方法的常用参数汇总：<br>label    用于设置图例的标签<br>ax<br>    确定要被绘制的matplotlib subplot对象。如果没有设置，则使用当前matplotlib subplot<br>style    设置传给matplotlib的风格字符串（’g*–’）<br>alpha    图表的填充不透明度（数值为0到1之间的数）<br>kind    各种图形样式line, bar, barh, kde, density, scatter<br>logy    在Y轴上使用对数标尺<br>use_index    将对象（Series and DataFrame）的索引用作刻度标签<br>rot    旋转度数（0到360）<br>xticks    用作X轴刻度的值<br>yticks    用作y轴刻度的值<br>xlim    x的值域<br>ylim    y的值域<br>grid    设置是否显示轴网格线</p><p>专用于DataFrame的plot的参数</p><p>Subplots    将依据数据框中的每个列绘制的图分别放置到单个的subplot（子画框）里<br>sharex    Subplots=true时，设定是否共享X的刻度和值域<br>sharey    Subplots=true时，设定是否共享y的刻度和值域<br>figsize    元组，用来表示图像大小（宽，高）<br>title    设置图像标题<br>Legend    设定是否添加一个subplot图例<br>sort_columns    设定是否以字母表中字母先后排列顺序绘制各列。</p><p>柱状图<br>柱状图分为水平柱状图和垂直柱状图。当kind=’bar’生成垂直柱状图；kind=’barh’生成水平柱状图。</p><p>A.Series生成柱状图<br> import numpy as np<br>import pandas as pd<br>import matplotlib.pyplot as plt<br>figure_1,get_information_of_pict=plt.subplots(2,1)<br>datas=pd.Series(np.random.rand(20),index=list(‘qwertyuiopasdfghjklz’))<br>datas.plot(kind=’barh’,ax=get_information_of_pict[0],figsize=(8,12),color=’g’)<br>Out[4]: &lt;matplotlib.axes._subplots.AxesSubplot at 0x5be13ea6d8&gt;<br>datas.plot(kind=’bar’,ax=get_information_of_pict[1],figsize=(8,12),color=’r’)<br>Out[5]: &lt;matplotlib.axes._subplots.AxesSubplot at 0x5be18c41d0&gt;<br>plt.show()</p><p>B.数据框生成柱状图<br>import numpy as np<br>import pandas as pd<br>Framedata_1=pd.DataFrame(np.arange(16).reshape(4,4)<strong>(1/2)+np.arange(16).reshape(4,4)*3+6,index=[‘spring’,’sommer’,’autumn’,’winter’],columns=[‘Benz’,’BMW’,’Porsche’,’VW’])<br>Out[11]:<br>    Benz    BMW    Porsche    VW<br>spring    6.000000    10.000000    13.414214    16.732051<br>sommer    20.000000    23.236068    26.449490    29.645751<br>autumn    32.828427    36.000000    39.162278    42.316625<br>winter    45.464102    48.605551    51.741657    54.872983<br>import numpy as np<br>import pandas as pd<br>plt.rcParams[‘font.sans-serif’]=[‘SimHei’]<br>plt.rcParams[‘axes.unicode_minus’] = False<br>Framedata_1=pd.DataFrame(np.arange(16).reshape(4,4)</strong>(1/2)+np.arange(16).reshape(4,4)*3+6,index=[‘spring’,’sommer’,’autumn’,’winter’],columns=[‘Benz’,’BMW’,’Porsche’,’VW’])<br>import matplotlib.pyplot as plt<br>picrange,pic_inf=plt.subplots(2,1)<br>Framedata_1.plot(kind=’bar’,ax=pic_inf[0],title=’2018年德系车销售额’,rot=50,figsize=(8,12))<br>Framedata_1.plot(kind=’barh’,ax=pic_inf[1],title=’2018年德系车销售额’,rot=130,figsize=(8,12))<br>plt.show()</p><p>​import numpy as np<br>import pandas as pd<br>import matplotlib.pyplot as plt<br>plt.rcParams[‘font.sans-serif’]=[‘SimHei’]<br>plt.rcParams[‘axes.unicode_minus’] = False<br>Framedata_1=pd.DataFrame(np.arange(16).reshape(4,4)*<em>(1/2)+np.arange(16).reshape(4,4)</em>3+6,index=[‘spring’,’sommer’,’autumn’,’winter’],columns=[‘Benz’,’BMW’,’Porsche’,’VW’])<br>import matplotlib.pyplot as plt<br>picrange,pic_inf=plt.subplots(2,1)<br>Framedata_1.plot(kind=’barh’,ax=pic_inf[1],stacked=True,title=’2018年德系车销售额’,rot=130,figsize=(8,12))<br>Framedata_1.plot(kind=’bar’,ax=pic_inf[0],stacked=True,title=’2018年德系车销售额’,rot=50,figsize=(8,12))<br>plt.show()</p><p>serie_1=pd.Series([3,4.5,5,3,6,9,4.7,4.7,4.7,4.7,4.5,4.5,6,6,3,7,7,7,7])</p><p>serie_1.value_counts().plot(kind=’bar’)<br>plt.show()</p><p>#应用serie_1.value.counts()在series中寻找数据重复的次数并作为纵坐标，Series中的数据作为横坐标。</p><p>直方图与密度图：</p><p>首先我们要区分直方图与柱状图。</p><p>柱状图：<br>柱状图的某一个轴（X或Y轴）可以没有严格的刻度，并且柱的宽度随图形大小，柱的数量等因素的变化而变化，并没有严格的公式来保证，因此没有实际意义，仅仅用来区分类别。通常柱状图是用条形的长度表示各类别对应的实际数据（譬如频数）的大小。<br>柱状图是分开排列<br>主要用于展示分类数据</p><p>直方图：<br>直方图通常是用面积表示各组数据大小（例如频数），矩形的高度表示每一组的频数或频率或其他匹配数据，宽度则表示各组的组距，因此其高度与宽度均有意义。<br>由于分组数据具有连续性，直方图的各矩形通常是连续排列。<br>直方图主要用于展示数据型数据。</p><p>plt.hist(np.array([1,2,3,4,5,1.2,1.34,1.78,2.1,2.4,2.8,2.9,3.1,3.5,3.7,4.2,4.9,5.6,5.3,5.8,5.9,5,3,6,7,8.5,6.4,7.3,7.8,7.2,5.6,6.6,6.45,6.99,3.45,2.36,5.67,8.13]),bins=5,normed=False,range=(2,8),color=’yellow’)</p><p>plt.hist(np.array([1,2,3,4,5,1.2,1.34,1.78,2.1,2.4,2.8,2.9,3.1,3.5,3.7,4.2,4.9,5.6,5.3,5.8,5.9,5,3,6,7,8.5,6.4,7.3,7.8,7.2,5.6,6.6,6.45,6.99,3.45,2.36,5.67,8.13]),bins=5,normed=True,range=(2,8),color=’yellow’)</p><p>plt.hist(np.array([1,2,3,4,5,1.2,1.34,1.78,2.1,2.4,2.8,2.9,3.1,3.5,3.7,4.2,4.9,5.6,5.3,5.8,5.9,5,3,6,7,8.5,6.4,7.3,7.8,7.2,5.6,6.6,6.45,6.99,3.45,2.36,5.67,8.13]),bins=5,normed=True,range=(2,8),color=’yellow’)</p><p>关于Normed（数据标准化）算法的解释：</p><p>sf,axes=plt.subplots()<br>data= np.array([1,1,2,3,3,3,3,3,4,5.1])<br>counts= axes.hist(data, normed= True)<br>counts</p><p>Out[9]:<br>(array([ 0.48780488,  0.        ,  0.24390244,  0.        ,  1.2195122 ,</p><pre><code>0.        ,  0.        ,  0.24390244,  0.        ,  0.24390244]),</code></pre><p> array([ 1.  ,  1.41,  1.82,  2.23,  2.64,  3.05,  3.46,  3.87,  4.28,<br>         4.69,  5.1 ]),<br> <a 10 list of patch objects>)</a></p><p>np.diff(counts[1])<br>Out[10]: array([ 0.41,  0.41,  0.41,  0.41,  0.41,  0.41,  0.41,  0.41,  0.41,  0.41])</p><p>#组距的计算<br>(counts[0]*np.diff(counts[1])).sum()<br>Out[13]: 1.0</p><p>#可以看到标准化后的结果和组距相乘然后求和等于1，这才是标准化的实际意义，而不是看标准化的结果是否都必须小于1。</p><p>#下面我们确定Python标准化的算法：<br>sf,axes=plt.subplots()<br>data= np.array([1,1,2,3,3,3,3,3,4,5.1])<br>counts_1= axes.hist(data, normed= False)<br>counts_1</p><p>Out[14]:<br>(array([ 2.,  0.,  1.,  0.,  5.,  0.,  0.,  1.,  0.,  1.]),<br> array([ 1.  ,  1.41,  1.82,  2.23,  2.64,  3.05,  3.46,  3.87,  4.28,<br>         4.69,  5.1 ]),<br> <a 10 list of patch objects>)</a></p><p>probality_1=counts_1[0]/np.sum(counts_1[0]*np.diff(counts_1[1]))</p><p>probality_1<br>Out[16]:<br>array([ 0.48780488,  0.        ,  0.24390244,  0.        ,  1.2195122 ,</p><pre><code>0.        ,  0.        ,  0.24390244,  0.        ,  0.24390244])</code></pre><p>最终我们得出算法公式为：<br>频数矩阵/Sum(频数矩阵*组距矩阵)<br>验证算法：<br>plt.hist(np.array([1,2,3,4,5,1.2,1.34,1.78,2.1,2.4,2.8,2.9,3.1,3.5,3.7,4.2,4.9,5.6,5.3,5.8,5.9,5,3,6,7,8.5,6.4,7.3,7.8,7.2,5.6,6.6,6.45,6.99,3.45,2.36,5.67,8.13]),bins=5,normed=True,range=(2,8),color=’yellow’)<br>Out[17]:<br>(array([ 0.234375  ,  0.13020833,  0.10416667,  0.234375  ,  0.13020833]),<br> array([ 2. ,  3.2,  4.4,  5.6,  6.8,  8. ]),<br> <a 5 list of patch objects>)</a></p><p>pro1=plt.hist(np.array([1,2,3,4,5,1.2,1.34,1.78,2.1,2.4,2.8,2.9,3.1,3.5,3.7,4.2,4.9,5.6,5.3,5.8,5.9,5,3,6,7,8.5,6.4,7.3,7.8,7.2,5.6,6.6,6.45,6.99,3.45,2.36,5.67,8.13]),bins=5,range=(2,8),color=’yellow’)</p><p>pro1[0]<br>Out[19]: array([ 9.,  5.,  4.,  9.,  5.])</p><p>pro_12=pro1[0]/np.sum(pro1[0]*np.diff(pro1[1]))</p><p>pro_12<br>Out[21]: array([ 0.234375  ,  0.13020833,  0.10416667,  0.234375  ,  0.13020833])</p><p>密度图通过kind的KDE关键字来实现的，这里的密度指的是概率密度。它是通过计算观测数据可能产生的概率密度分布而产生的<br>ser_1=np.random.normal(0,1,200)</p><p>ser_2=np.random.normal(16,1,200)<br>pis_1,sdr_1=plt.subplots()<br>A=np.concatenate((ser_1,ser_2))<br>ser_1=np.random.normal(0,1,200)</p><p>ser_2=np.random.normal(12,1,200)<br>value_1=pd.Series(A)<br>value_1.hist(bins=75,color=’m’,normed=True)<br>value_1.plot(kind=’kde’,style=’g–’)<br>plt.show()</p><p>散布图<br>散布图必须通过两个数据序列才能绘制而成。</p><p>也可以通过一个数据框绘制成散布矩阵,我们先绘制一个复杂的散布矩阵<br>import pandas as pd</p><p>import numpy as np</p><p>import matplotlib.pyplot as plt</p><p>X2=np.random.normal(3,1,1001)</p><p>X1=np.arange(1,1002,1)</p><p>X3=np.random.randn(1001)</p><p>X4=np.random.rand(1001)</p><p>X4=np.random.rand(1001)</p><p>X5=np.random.beta(2,1,1001)</p><p>test_data=np.column_stack((np.column_stack((np.column_stack((np.column_stack((X1,X2)),X3)),X4)),X5))</p><p>test_frame=pd.DataFrame(test_data)</p><p>pd.scatter_matrix(test_frame,diagonal=’kde’,color=’g’,figsize=(10,10))<br>C:\Users\dongfeng\Anaconda3\lib\site-packages\ipykernel_launcher.py:1: FutureWarning: pandas.scatter_matrix is deprecated. Use pandas.plotting.scatter_matrix instead<br>  “””Entry point for launching an IPython kernel.<br>Out[7]:<br>array([[&lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000342B2D89E8&gt;,<br>        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000003422A85240&gt;,<br>        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000003422A9E2B0&gt;,<br>        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000342AA85860&gt;,<br>        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000342AAD87F0&gt;],<br>       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000342AAD8828&gt;,<br>        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000342B33FFD0&gt;,<br>        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000342B3860F0&gt;,<br>        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000342B39BDA0&gt;,<br>        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000342B419518&gt;],<br>       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000342B452898&gt;,<br>        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000342B489828&gt;,<br>        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000342B4C3828&gt;,<br>        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000342B4D4F98&gt;,<br>        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000342B522F98&gt;],<br>       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000342B5684A8&gt;,<br>        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000342B5A23C8&gt;,<br>        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000342B53A7F0&gt;,<br>        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000342B603A58&gt;,<br>        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000342B63AF28&gt;],<br>       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000342B67D4A8&gt;,<br>        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000342B6A32B0&gt;,<br>        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000342C6B2518&gt;,<br>        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000342C6EA908&gt;,<br>        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000342C722828&gt;]], dtype=object)</p><p>plt.show()</p><p>散布矩阵数据索引图如下：<br>X1X1密度图    X2X1    X3X1    X4X1    X5X1<br>X1X2    X2X2密度图    X3X2    X4X2    X5X2<br>X1X3    X2X3    X3X3密度图    X4X3    X5X3<br>X1X4    X2X4    X3X4    X4X4密度图    X5X4<br>X1X5    X2X5    X3X5    X4X5    X5X5密度图</p><p>接下来我们通过简单的散布图来验证我们的散布矩阵图：<br>X1X1密度图：</p><p>X3X1 和 X1X3：<br>fig_123,axec=plt.subplots(1,2,dpi=140)</p><p>for j in range(1):<br>    axec[j].scatter(test_frame[2],test_frame[0],color=’m’,marker=’.’)<br>    axec[j].set_xlabel(‘X3’)<br>    axec[j+1].scatter(test_frame[0],test_frame[2],color=’m’,marker=’.’)<br>    axec[j+1].set_xlabel(‘X1’)<br>plt.show()</p><p>数据地图（basemap）<br>from mpl_toolkits.basemap import Basemap<br>   …: import matplotlib.pyplot as plt<br>   …: import pandas as pd<br>   …: import numpy as np<br>   …: from matplotlib import cm</p><h1 id="绘制基础地图，选择绘制的区域，因为是绘制中国地图，故选取如下经纬度，lat-0和lon-0是地图中心的维度和经度。"><a href="#绘制基础地图，选择绘制的区域，因为是绘制中国地图，故选取如下经纬度，lat-0和lon-0是地图中心的维度和经度。" class="headerlink" title="绘制基础地图，选择绘制的区域，因为是绘制中国地图，故选取如下经纬度，lat_0和lon_0是地图中心的维度和经度。"></a>绘制基础地图，选择绘制的区域，因为是绘制中国地图，故选取如下经纬度，lat_0和lon_0是地图中心的维度和经度。</h1><p>china_map=Basemap(projection=’stere’,lat_0=34,lon_0=115,llcrnrlat=28 ,urcrnrlat=42,llcrnrlon=105,urcrnrlon=129,rsphere=(2000,2000),resolution=’l’,area_thresh=350)</p><p>#参数解释：</p><p>#Projection- 地图投影方式，常用的有’ortho’、’merc’、’stere’和’cyl’,’cass’、’lcc’等。 </p><p>#llcrnrlat- 所需地图域左下角的纬度（度）。 </p><p>#urcrnrlat- 所需地图域的右上角的纬度（度）。 </p><p>#llcrnrlon- 所需地图域左下角的经度（度）。 </p><p>#urcrnrlon- 所需地图域的右上角的经度（度）。</p><p>china_map.drawmapboundary(color=’g’,zorder=0)   # 绘制边界<br>china_map.fillcontinents(color=’y’,lake_color=’b’,zorder=2)   # 填充大陆，发现填充之后无法显示散点图，应该是被覆盖了,因此取消<br>china_map.drawstates(color=’m’,zorder=3)        # 绘制省<br>china_map.drawcoastlines(color=’r’,zorder=3)    # 绘制海岸线，必须绘制，即使是不靠海也需绘制<br>china_map.drawcountries(color=’r’,zorder=3)</p><p>#linewidth 设置线宽</p><p>#linestyle 设置线形。默认为 solid，可以是 dash，也可以是 matplotlib 其它选项。</p><p>#color 设置颜色。默认为 black(k)。</p><p>#antialiased 抗锯齿选项。默认为 True.<br>china_map.drawrivers(linewidth=0.5, linestyle=’solid’, color=’#1E90FF’,zorder=3)</p><p>#zorder 设置图层位置。默认情况下由 Basemap 设置.<br>china_map.drawlsmask(land_color=’0 ‘,ocean_color=’#1E90FF’,zorder=1)</p><p>#china_map.drawcountries(color=’y’)     # 绘制国家，不太适合此例子，但需保留</p><p>#china_map.bluemarble()<br>parallels = np.arange(28.,42.,2.)<br>china_map.drawparallels(parallels,labels=[1,0,0,0],fontsize=10,zorder=4) # 绘制纬线</p><p>meridians = np.arange(105.,129.,3.)<br>china_map.drawmeridians(meridians,labels=[0,0,0,1],fontsize=10,zorder=4) # 绘制经线<br>data_1=pd.read_csv(r’Desktop\dizhenshuju.csv’,header=None,delimiter=’,’).values<br>lat=data_1[:,2];lon=data_1[:,1];Seismic_grade=data_1[:,3]<br>Seismic_grade_float=np.array(Seismic_grade,dtype=np.float64)<br>class_1=(Seismic_grade_float/np.max(Seismic_grade_float))*5<br>x,y = china_map(lon,lat)#地图上的精度维度匹配参数x，y<br>china_map.scatter(x,y,s=class_1,cmap=cm.hsv,c=’#8A2BE2’,zorder=5) # 使用matplotlib的散点图绘制函数<br>plt.savefig(‘Desktop\dong_1217.pdf’,dpi=300,bbox_inches=’tight’)<br>plt.show()</p><p>画布的复杂分割：<br>Subplot2grid</p><p>在网格中创建一个子图。网格是由shape指定的，位于loc指定的位置，横跨各个方向上的rowspan个，colspan个单元格。 loc的索引是基于0的。<br>matplotlib.pyplot.subplot2grid(shape, loc, rowspan=1, colspan=1, **kwargs)</p><p>例子：<br>def subpicnr_invisible(fig):<br>    for i, ax in enumerate(fig.axes): #利用list(enumerate(plt.gcf().axes))枚举函数生成元组列表[(画框编号,画框对象)(),…]<br>        ax.text(0.5, 0.5, “ax%d” % (i+1))</p><p>plt.figure(0,dpi=150)<br>pic_1=plt.subplot2grid((3,3),(0,0),colspan=3)</p><p>#画框pic_1位于（0,0），这里的0意味着0行和0列，colspan=3意味着横跨三列，默认的rowspan=1意味着横跨一行</p><p>#ax2 = plt.subplot2grid((3, 3), (1, 0), colspan=2)<br>pic_2 = plt.subplot2grid((3, 3), (1, 0), colspan=2)</p><p>#画框pic_2位于（1,0），这里的0意味着1行和0列,（‘1’这一行有0和1两列），colspan=2意味着横跨两列，默认的rowspan=1意味着横跨一行。<br>pic_3 = plt.subplot2grid((3,3), (1, 2), rowspan=2)<br>pic_4 = plt.subplot2grid((3,3), (2, 0))<br>pic_5 = plt.subplot2grid((3,3), (2, 1))<br>plt.subplots_adjust(wspace=0.25,hspace=0.4)<br>plt.suptitle(“python_practice_08”)<br>subpicnr_invisible(plt.gcf())#plt.gcf返回所有画布信息,<br>plt.show()</p><p>例子2<br>def subpicnr_invisible(fig):<br>    for i, ax in enumerate(fig.axes): #利用list(enumerate(plt.gcf().axes))枚举函数生成元组列表[(画框编号,画框对象)(),…]<br>        ax.text(0.5, 0.5, “ax%d” % (i+1))</p><p>plt.figure(0,dpi=150)<br>pic_1=plt.subplot2grid((3,3),(0,0),colspan=2)</p><p>#画框pic_1位于（0,0），这里的0意味着0行和0列，colspan=3意味着横跨三列，默认的rowspan=1意味着横跨一行<br>pic_2 = plt.subplot2grid((3, 3), (0, 2), colspan=1)</p><p>#pic_2 = plt.subplot2grid((3, 3), (1, 0), colspan=2)</p><p>#画框pic_2位于（1,0），这里的0意味着1行和0列,（‘1’这一行有0和1两列），colspan=2意味着横跨两列，默认的rowspan=1意味着横跨一行。<br>pic_3 = plt.subplot2grid((3,3), (1, 0),rowspan=2,colspan=2)<br>pic_4 = plt.subplot2grid((3,3), (1, 2))<br>pic_5 = plt.subplot2grid((3,3), (2, 2))<br>plt.subplots_adjust(wspace=0.25,hspace=0.4)<br>plt.suptitle(“python_practice_08”)<br>subpicnr_invisible(plt.gcf())#plt.gcf返回所有画布信息,<br>plt.show()</p><p>GridSpec：<br>例子1：<br>def subpicnr_invisible(fig):<br>    for i, ax in enumerate(fig.axes): #利用list(enumerate(plt.gcf().axes))枚举函数生成元组列表[(画框编号,画框对象)(),…]<br>        ax.text(0.5, 0.5, “ax%d” % (i+1))</p><p>import matplotlib.gridspec as gridspec<br>plt.figure(0,dpi=150)<br>gs = gridspec.GridSpec(3, 3)<br>pic_1=plt.subplot(gs[0,:])#按照数组索引理解即可<br>pic_2 = plt.subplot(gs[1,:2])<br>pic_3 = plt.subplot(gs[1:,-1])<br>pic_4 = plt.subplot(gs[2,0])<br>pic_5 = plt.subplot(gs[2,1])<br>plt.subplots_adjust(wspace=0.25,hspace=0.4)<br>plt.suptitle(“python_practice_08”)<br>subpicnr_invisible(plt.gcf())#plt.gcf返回所有画布信息,<br>plt.show()</p><p>例子2：<br>def subpicnr_invisible(fig):<br>    for i, ax in enumerate(fig.axes): #利用list(enumerate(plt.gcf().axes))枚举函数生成元组列表[(画框编号,画框对象)(),…]<br>        ax.text(0.5, 0.5, “ax%d” % (i+1))</p><p>import matplotlib.gridspec as gridspec<br>plt.figure(0,dpi=150)<br>gs = gridspec.GridSpec(3, 3)<br>pic_1=plt.subplot(gs[0,:2])#按照数组索引理解即可<br>pic_2 = plt.subplot(gs[0,-1])<br>pic_3 = plt.subplot(gs[1:,:-1])<br>pic_4 = plt.subplot(gs[1,-1])<br>pic_5 = plt.subplot(gs[2,-1])<br>plt.subplots_adjust(wspace=0.25,hspace=0.4)<br>plt.suptitle(“python_practice_08”)<br>subpicnr_invisible(plt.gcf())#plt.gcf返回所有画布信息,<br>plt.show()</p><p>例子：</p><p>plt.figure(dpi=100,figsize=(10,10))<br>gs = gridspec.GridSpec(3, 3)<br>pic_1=plt.subplot(gs[0,:2])#按照数组索引理解即可<br>pic_2 = plt.subplot(gs[0,-1])<br>pic_3 = plt.subplot(gs[1:,:-1])<br>pic_4 = plt.subplot(gs[1,-1])<br>pic_5 = plt.subplot(gs[2,-1])<br>plt.subplots_adjust(wspace=0.25,hspace=0.4)<br>plt.suptitle(“python_practice_08”,fontsize=’20’)<br>n = 730<br>X = np.linspace(-2<em>np.pi,2</em>np.pi,n)<br>Y = np.sin(2<em>X)</em>X+np.pi<br>Y_1=np.sin(2<em>X)</em>X-np.pi<br>pic_1.plot(X,Y,linestyle=’-‘,color=’#FFB6C1’,alpha=1.00)<br>pic_1.plot(X,Y_1,linestyle=’-.’,color=’#1E90FF’,alpha=1.00)<br>n_1=1000<br>X_2 = np.random.normal(0,1,n_1)<br>Y_2= np.random.normal(0,1,n_1)<br>pic_2.scatter(X_2,Y_2,c=np.linspace(0,1,1000),cmap=’coolwarm’)<br>n_2=10<br>X_3 = np.arange(n_2); Y_3 = (1-X_3/np.float(n_2)) <em> np.random.uniform(0,0.5,n_2); Y_3_1 = -(1-X_3/np.float(n_2)) </em> np.random.uniform(0,0.5,n_2)<br>pic_3.bar(X_3,Y_3,facecolor=’#FFB6C1’,width=0.6,align=’center’)<br>pic_3.bar(X_3,Y_3_1,facecolor=’#87CEFA’,width=0.6,align=’center’)<br>for x,y in zip(X_3,Y_3):<br>    pic_3.text(x, y+0.03,’%.2f’ % y,ha=’center’)<br>for x,y in zip(X_3,Y_3_1):<br>    pic_3.text(x, y-0.03,’%.2f’ % y,ha=’center’)<br>f=lambda x,y: (1-x/2+x<strong>5+y</strong>3)*np.exp(-x<strong>2-y</strong>2)<br>x_4 = np.linspace(-3,3,1000)<br>y_4 = np.linspace(-3,3,1000)<br>X_4,Y_4 = np.meshgrid(x_4,y_4)<br>pic_4.contourf(X_4, Y_4, f(X_4,Y_4), 8, alpha=.75, cmap=’coolwarm’)<br>pic_4.contour(X_4, Y_4, f(X_4,Y_4), 8, colors=’black’)<br>t=np.linspace(-np.pi,np.pi,20)<br>u,v=np.array([np.cos(theta) for theta in t]),np.array([np.sin(theta) for theta in t])<br>X_5,Y_5= np.mgrid[0:10,0:10]#晶格化<br>pic_5.quiver(X_5,Y_5,u,v,np.random.randn(10))<br>plt.show()</p><p>绘制立体图<br>曲面图：<br>plot_surface<br>plot_surface(X, Y, Z, <em>args, **kwargs)<br>默认情况下，它将以纯色着色，但它也通过提供</em> cmap *参数来支持颜色映射。</p><p>‘rstride<code>和</code>cstride` kwargs设置了用于对输入数据进行采样以生成图形的步幅。如果传入1k个1k数组，则步幅的默认值将导致绘制100x100的网格。 默认为10。 如果同时提供了stride和count kwargs（rcount、ccount），则引发ValueError。</p><p><code>rcount</code>和<code>ccount</code> kwargs取代<code>rstride</code>和<code>cstride</code>作为表面绘图的默认采样方法。这些参数将决定从输入数据中最多取多少个均匀间隔的样本来生成图。 这是默认的采样方法，除非使用“经典”风格。 如果同时指定了步幅和数量（stride and count），将会引发ValueError。</p><p>参数：</p><ul><li>X <em>，</em> Y <em>，</em> Z *  数据值为二维数组      </li><li>rstride *    数组行步幅（步长）      </li><li>cstride *    数组列步幅（步长）      </li><li>rcount *    最多使用行，默认为50      </li><li>ccount <em>    最多使用列，默认为50      </em>颜色*       曲面片的颜色      </li><li>cmap *     曲面片调色板。      </li><li>facecolors * 单个曲面片的表面色      </li><li>norm *     一个标准化实例，用于将值映射到颜色      </li><li>vmin *     映射的最小值      </li><li>vmax <em>    映射的最大值      </em>shade*     是否遮蔽表面色</li></ul><p>例子：参数化坐标轴下的三维球<br>from mpl_toolkits.mplot3d import Axes3D<br>import numpy as np<br>import matplotlib.pyplot as plt<br>u = np.linspace(0,2<em>np.pi,1000)<br>v = np.linspace(0,np.pi,1000)<br>x=10</em>np.outer(np.sin(v),np.cos(u))<br>y=10<em>np.outer(np.sin(v),np.sin(u))<br>z=10</em>np.outer(np.cos(v),np.ones(len(np.cos(v))))</p><p>#创建二维数据集X,Y和Z，注意他们的值必须在各矩阵相同位置处一一对应。<br>fig=plt.figure(0,figsize=(8,8),dpi=120)<br>ax=fig.add_subplot(1,1,1,projection=’3d’)</p><p>#ax.plot_surface(x,y,z,rcount=1000,ccount=1000,cmap=’coolwarm’)#太浪费时间了，用下面替换语句<br>ax.plot_surface(x,y,z,cmap=’hot’)<br>plt.show()</p><p>例子：非参数化坐标轴下曲面图<br>import numpy as np<br>from mpl_toolkits.mplot3d import Axes3D<br>import matplotlib.pyplot as plt<br>import random<br>def fun(x, y):<br>  return np.sqrt(x<strong>2 + y</strong>2)<br>fig = plt.figure(0,dpi=120,figsize=(6,6))<br>ax = fig.add_subplot(111, projection=’3d’)<br>x = y = np.linspace(-5.0, 5.0, 100)<br>X, Y = np.meshgrid(x, y)<br>zs = np.array([fun(x,y) for x,y in zip(np.ravel(X), np.ravel(Y))])<br>Z = zs.reshape(Y.shape)<br>ax.plot_surface(X, Y, Z,cmap=’jet’)<br>ax.set_xlabel(‘X Label’)<br>ax.set_ylabel(‘Y Label’)<br>ax.set_zlabel(‘Z Label’)</p><p>#(np.ravel(X)).shape<br>plt.show()</p><p>import numpy as np<br>from mpl_toolkits.mplot3d import Axes3D<br>import matplotlib.pyplot as plt<br>import random</p><p>def fun(x, y):<br>  return np.cos(np.sqrt(x<strong>2 + y</strong>2))</p><p>fig = plt.figure(0,dpi=120,figsize=(6,6))<br>ax = fig.add_subplot(111, projection=’3d’)<br>x = y = np.linspace(-5.0, 5.0, 100)<br>X, Y = np.meshgrid(x, y)<br>zs = np.array([fun(x,y) for x,y in zip(np.ravel(X), np.ravel(Y))])<br>Z = zs.reshape(Y.shape)</p><p>ax.plot_surface(X, Y, Z,cmap=’jet’)</p><p>ax.set_xlabel(‘X Label’)<br>ax.set_ylabel(‘Y Label’)<br>ax.set_zlabel(‘Z Label’)</p><p>#(np.ravel(X)).shape<br>plt.show()</p><p>例子，带色度条的三维图<br>import numpy as np<br>from mpl_toolkits.mplot3d import Axes3D<br>import matplotlib.pyplot as plt<br>import random</p><p>f=lambda x,y: (1-x/2+x<strong>5+y</strong>3)*np.exp(-x<strong>2-y</strong>2)<br>fig = plt.figure(0,dpi=160,figsize=(10,10))<br>ax = fig.add_subplot(111, projection=’3d’)<br>x = y = np.linspace(-5.0, 5.0, 100)<br>X, Y = np.meshgrid(x, y)<br>zs = np.array([f(x,y) for x,y in zip(np.ravel(X), np.ravel(Y))])<br>Z = zs.reshape(Y.shape)</p><p>pic_3dim=ax.plot_surface(X, Y, Z,cmap=’Spectral_r’)<br>plt.colorbar(pic_3dim)  #画出色度条<br>ax.set_xlabel(‘X Label’)<br>ax.set_ylabel(‘Y Label’)<br>ax.set_zlabel(‘Z Label’)</p><p>#(np.ravel(X)).shape<br>plt.show()</p><p>另外的一种表面图绘制方法：<br>例如：<br>import matplotlib.pyplot as plt<br>from mpl_toolkits.mplot3d import Axes3D #绘制3D坐标的函数<br>import numpy as np  </p><p>def fun(x,y):<br>    return np.power(x,2)+np.sin(np.power(y,2))*x  </p><p>fig1=plt.figure(0,dpi=160,figsize=(8,8))<br>ax=Axes3D(fig1)#三维化画布并产生三维画框<br>X=np.arange(-3,3,0.05)<br>Y=np.arange(-3,3,0.05)<br>X,Y=np.meshgrid(X,Y)#生成坐标点<br>Z=fun(X,Y)<br>plt.title(‘python-08’)<br>ax.plot_surface(X, Y, Z,cmap=’coolwarm’)<br>ax.set_xlabel(‘x label’, color=’r’)<br>ax.set_ylabel(‘y label’, color=’g’)<br>ax.set_zlabel(‘z label’, color=’b’)<br>plt.show()</p><p>曲线图<br>例子：我的葫芦<br>from mpl_toolkits.mplot3d import Axes3D</p><p>fig = plt.figure(0,dpi=100,figsize=(6,6))<br>ax = fig.add_subplot(1,1,1, projection=’3d’)<br>theta = np.linspace(-20 <em> np.pi, 20 </em> np.pi, 1000)<br>z = np.linspace(0,10,1000);phi=np.linspace(0,2<em>np.pi,1000)<br>r=z</em>np.sin(phi)<br>x = r <em> np.sin(theta)<br>y = r </em> np.cos(theta)<br>ax.plot(x, y, z, label=’curve’)<br>ax.legend()<br>plt.show()</p><p>散点图（见LDA）<br>线框图<br>例子：<br>import numpy as np  </p><p>def fun(x,y):<br>    return np.power(x,2)+np.sin(np.power(y,2))*x  </p><p>fig1=plt.figure(0,dpi=160,figsize=(8,8))<br>ax=Axes3D(fig1)#三维化画布并产生三维画框<br>X=np.arange(-3,3,0.05)<br>Y=np.arange(-3,3,0.05)<br>X,Y=np.meshgrid(X,Y)#生成坐标点<br>Z=fun(X,Y)<br>plt.title(‘python-08’)<br>ax.plot_wireframe(X, Y, Z, rstride=3, cstride=3)#一定要调节成大的扫描步长才有效果<br>ax.set_xlabel(‘x label’, color=’r’)<br>ax.set_ylabel(‘y label’, color=’g’)<br>ax.set_zlabel(‘z label’, color=’b’)<br>plt.show()</p><p>等高线图<br>contour和contourf都是画三维等高线图的，不同点在于contourf会对等高线间的区域进行填充。<br>参数：</p><p><em>X</em>, <em>Y</em>, <em>Z</em>     数组型数据<br><em>extend3d</em>      是否在3D中扩展等高线图（默认值：False）<br><em>stride</em>         <em>步幅</em>，用于扩展等高线图的步幅（步长）<br><em>zdir</em>           等高线图产生方向: x, y 或 z (default)<br><em>offset</em>         如果赋值，绘制等高线投影到垂直于zdir并且通过偏移量确定位置的平面</p><p>例子：<br>import numpy as np  </p><p>def fun(x,y):<br>    return (1/(2<em>np.pi))</em>np.exp(-0.5*(x<strong>2+y</strong>2))  </p><p>fig1=plt.figure(0,dpi=160,figsize=(8,8))<br>ax=Axes3D(fig1)#三维化画布并产生三维画框<br>X=np.arange(-3,3,0.05)<br>Y=np.arange(-3,3,0.05)<br>X,Y=np.meshgrid(X,Y)#生成坐标点<br>Z=fun(X,Y)<br>plt.title(‘python-08’)<br>ax.plot_surface(X, Y, Z, rstride=3, cstride=3,cmap=’jet’)<br>ax.contour(X, Y, Z, zdir=’z’,offset=0.16,cmap=’coolwarm’)<br>cset = ax.contour(X, Y, Z, zdir=’x’, offset=-3, cmap=’coolwarm’)<br>cset = ax.contour(X, Y, Z, zdir=’y’, offset=3, cmap=’coolwarm’)<br>ax.set_xlabel(‘x label’, color=’r’)<br>ax.set_ylabel(‘y label’, color=’g’)<br>ax.set_zlabel(‘z label’, color=’b’)<br>plt.show()</p><p>动态图<br>运动中的布朗运动<br>from matplotlib import pyplot as plt</p><p>from matplotlib import animation<br>import numpy as np<br>%matplotlib qt5<br>def randn_point():</p><pre><code># 产生随机散点图的x和y数据x=np.random.randn(100)y=np.random.randn(100)return x,y</code></pre><p>fig,ax1=plt.subplots(1,1,dpi=130,figsize=(8,6))</p><h1 id="先绘制初始图形"><a href="#先绘制初始图形" class="headerlink" title="先绘制初始图形"></a>先绘制初始图形</h1><p>x1,y1=randn_point()<br>sca1 = ax1.scatter(x1,y1)   # 散点图<br>def init():</p><pre><code># 构造开始帧函数init# 改变散点图数据x1, y1 = randn_point()data1 = [[x,y] for x,y in zip(x1,y1)]sca1.set_offsets(data1)  # 散点图label = &apos;timestep {0}&apos;.format(0)ax1.set_xlabel(label)return sca1,ax1  # 注意返回值，我们要更新的就是这些数据</code></pre><p>def animate(i):</p><pre><code># 接着，构造自定义动画函数animate，用来更新每一帧上各个x对应的y坐标值，参数表示第i帧x1, y1 = randn_point()x2, y2 = randn_point()data1 = [[x,y] for x,y in zip(x1,y1)]sca1.set_offsets(data1)  # 散点图label = &apos;timestep {0}&apos;.format(i)ax1.set_xlabel(label)return sca1,ax1</code></pre><h1 id="接下来，我们调用FuncAnimation函数生成动画。参数说明："><a href="#接下来，我们调用FuncAnimation函数生成动画。参数说明：" class="headerlink" title="接下来，我们调用FuncAnimation函数生成动画。参数说明："></a>接下来，我们调用FuncAnimation函数生成动画。参数说明：</h1><h1 id="fig-进行动画绘制的figure"><a href="#fig-进行动画绘制的figure" class="headerlink" title="fig 进行动画绘制的figure"></a>fig 进行动画绘制的figure</h1><h1 id="func-自定义动画函数，即传入刚定义的函数animate"><a href="#func-自定义动画函数，即传入刚定义的函数animate" class="headerlink" title="func 自定义动画函数，即传入刚定义的函数animate"></a>func 自定义动画函数，即传入刚定义的函数animate</h1><h1 id="frames-动画长度，一次循环包含的帧数"><a href="#frames-动画长度，一次循环包含的帧数" class="headerlink" title="frames 动画长度，一次循环包含的帧数"></a>frames 动画长度，一次循环包含的帧数</h1><h1 id="init-func-自定义开始帧，即传入刚定义的函数init"><a href="#init-func-自定义开始帧，即传入刚定义的函数init" class="headerlink" title="init_func 自定义开始帧，即传入刚定义的函数init"></a>init_func 自定义开始帧，即传入刚定义的函数init</h1><h1 id="interval-更新频率，以ms计"><a href="#interval-更新频率，以ms计" class="headerlink" title="interval 更新频率，以ms计"></a>interval 更新频率，以ms计</h1><h1 id="blit-选择更新所有点，还是仅更新产生变化的点。应选择True，但mac用户请选择False，否则无法显示动画"><a href="#blit-选择更新所有点，还是仅更新产生变化的点。应选择True，但mac用户请选择False，否则无法显示动画" class="headerlink" title="blit 选择更新所有点，还是仅更新产生变化的点。应选择True，但mac用户请选择False，否则无法显示动画"></a>blit 选择更新所有点，还是仅更新产生变化的点。应选择True，但mac用户请选择False，否则无法显示动画</h1><p>ani = animation.FuncAnimation(fig=fig,func=animate,frames=1000,init_func=init,interval=100,blit=False)<br>plt.show()</p><p>布朗运动过程模拟：</p><p>from matplotlib import pyplot as plt</p><p>from matplotlib import animation<br>import numpy as np<br>%matplotlib qt5<br>def randn_point(t):<br>    Data=np.random.randn(100,10001)<br>    brown_moving=Data.T[0]<em>t+sum([Data_x</em>((np.sqrt(2)<em>np.sin(i</em>np.pi<em>t))/(i</em>np.pi)) for Data_x,i in list(zip(Data.T[1:],range(1,10001)))])<br>angel=np.random.randn(100)<em>360<br>return brown_moving</em>np.cos(angel),brown_moving*np.sin(angel)<br>fig,ax1=plt.subplots(1,1,dpi=130,figsize=(8,6))</p><h1 id="先绘制初始图形-1"><a href="#先绘制初始图形-1" class="headerlink" title="先绘制初始图形"></a>先绘制初始图形</h1><p>plt.xlim([-100,100])</p><p>#plt.ylim([-50,50])</p><p>x1,y1=randn_point(np.random.randint(100))<br>sca1 = ax1.scatter(x1,y1)<br>def init():</p><pre><code># 构造开始帧函数init# 改变散点图数据x1, y1 = randn_point(np.random.randint(100))data1 = [[x,y] for x,y in zip(x1,y1)]sca1.set_offsets(data1)  # 散点图label = &apos;timestep {0}&apos;.format(0)ax1.set_xlabel(label)return sca1,ax1  # 注意返回值，我们要更新的就是这些数据</code></pre><p>def animate(i):</p><pre><code># 接着，构造自定义动画函数animate，用来更新每一帧上各个x对应的y坐标值，参数表示第i帧x1, y1 = randn_point(i)x2, y2 = randn_point(i)data1 = [[x,y] for x,y in zip(x1,y1)]sca1.set_offsets(data1)  # 散点图label = &apos;timestep {0}&apos;.format(i)ax1.set_xlabel(label)return sca1,ax1</code></pre><p>ani = animation.FuncAnimation(fig=fig,func=animate,frames=100,init_func=init,interval=1,blit=False)<br>plt.show()</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora常用语法</title>
      <link href="/2019/06/05/Typora%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/06/05/Typora%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="标题的使用格式"><a href="#标题的使用格式" class="headerlink" title="标题的使用格式"></a>标题的使用格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\# 一阶标题 或者快捷键Ctrl+1</span><br><span class="line">\##二阶标题 或者快捷键Ctrl+2</span><br><span class="line">\###三阶标题 或者快捷键Ctrl+3</span><br><span class="line">\####四阶标题 或者快捷键Ctrl+4</span><br><span class="line">\#####五阶标题 或者快捷键Ctrl+5</span><br></pre></td></tr></table></figure><h3 id="文本居中使用格式"><a href="#文本居中使用格式" class="headerlink" title="文本居中使用格式"></a>文本居中使用格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\&lt;center\&gt;这是要居中的文本内容\&lt;/center\&gt;1</span><br></pre></td></tr></table></figure><h3 id="下划线使用格式"><a href="#下划线使用格式" class="headerlink" title="下划线使用格式"></a>下划线使用格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\下划线的内容\&lt;\u&gt; 或者快捷键 Ctrl+U 或者格式里面的下划线</span><br></pre></td></tr></table></figure><h3 id="删除线使用格式"><a href="#删除线使用格式" class="headerlink" title="删除线使用格式"></a>删除线使用格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\~\~删除线的内容\~\~  或者格式里面的删除线</span><br></pre></td></tr></table></figure><h3 id="字体加粗使用格式"><a href="#字体加粗使用格式" class="headerlink" title="字体加粗使用格式"></a>字体加粗使用格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**加粗字体** 或者快捷键Ctrl+B 或者格式里面加粗</span><br></pre></td></tr></table></figure><h3 id="字体倾斜使用格式"><a href="#字体倾斜使用格式" class="headerlink" title="字体倾斜使用格式"></a>字体倾斜使用格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*字体倾斜了* 或者快捷键Ctrl+I</span><br></pre></td></tr></table></figure><h2 id="图片的插入"><a href="#图片的插入" class="headerlink" title="图片的插入"></a>图片的插入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以直接拖进去,或者插入里面选择图像</span><br></pre></td></tr></table></figure><h3 id="超链接使用格式"><a href="#超链接使用格式" class="headerlink" title="超链接使用格式"></a>超链接使用格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">快捷键Ctrl+K 或者格式里面的超链接</span><br></pre></td></tr></table></figure><h2 id="代码区域"><a href="#代码区域" class="headerlink" title="代码区域"></a>代码区域</h2><p>Typora支持对多种语言的代码区域进行<strong>语法高亮</strong>。这些语言可以说是<strong>涵盖了绝大部分经常使用的编程语言</strong>，包括C++，Python，MATLAB，甚至包含spreadsheet（也就是Excel电子表格）。用Typora记编程笔记，看起来一清二楚。如果设置代码语言为flow，那么可以直接画出一个流程图；还可以使用相应的方法画出时序图等图表。</p><h3 id="代码区域的使用格式"><a href="#代码区域的使用格式" class="headerlink" title="代码区域的使用格式"></a>代码区域的使用格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">​```内容```python</span><br></pre></td></tr></table></figure><h3 id="任务列表使用格式"><a href="#任务列表使用格式" class="headerlink" title="任务列表使用格式"></a>任务列表使用格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- [ ] 文字 （注：注意用空格隔开）</span><br></pre></td></tr></table></figure><h3 id="任务列表在typora中的显示形式"><a href="#任务列表在typora中的显示形式" class="headerlink" title="任务列表在typora中的显示形式"></a>任务列表在typora中的显示形式</h3><ul><li style="list-style: none"><input type="checkbox"> JAVA</li><li style="list-style: none"><input type="checkbox"> C</li><li style="list-style: none"><input type="checkbox"> C++</li><li style="list-style: none"><input type="checkbox" checked> Python</li></ul><h3 id="列表的使用格式"><a href="#列表的使用格式" class="headerlink" title="列表的使用格式"></a>列表的使用格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\+ 、- 、* 创建无序列，任意数字开始+空格创建有序列表</span><br></pre></td></tr></table></figure><ul><li>Python</li></ul><h2 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h2><p>Typora支持加入用LaTeX写成的数学公式，并且在软件界面下用MathJax直接渲染。<br>数学公式分为两种：<br>一种是行内公式(inline math)，可以在偏好设置中单独打开，由一个美元符号$将公式围起来；<br>一种是行外公式，直接按<strong>Ctrl+Shift+M</strong>；<br>注：上标和下标可以使用数学表达式来获取</p><h3 id="水平分割线的使用格式"><a href="#水平分割线的使用格式" class="headerlink" title="水平分割线的使用格式"></a>水平分割线的使用格式</h3><p>***或者- - -</p><h3 id="水平分割线在typora中显示形式"><a href="#水平分割线在typora中显示形式" class="headerlink" title="水平分割线在typora中显示形式"></a>水平分割线在typora中显示形式</h3><hr><h3 id="引用的使用格式"><a href="#引用的使用格式" class="headerlink" title="引用的使用格式"></a>引用的使用格式</h3><p>>+空格</p><blockquote><p>与天奋斗，其乐无穷！与地奋斗，其乐无穷！与人奋斗，其乐无穷！</p></blockquote><h3 id="注释的使用格式"><a href="#注释的使用格式" class="headerlink" title="注释的使用格式"></a>注释的使用格式</h3><p>要添加注释的文字[1](<a href="https://log.csdn.net/mollen/article/details/84110708#fn:" target="_blank" rel="noopener">https://log.csdn.net/mollen/article/details/84110708#fn:</a>)</p><h5 id="注释在typora中显示形式"><a href="#注释在typora中显示形式" class="headerlink" title="注释在typora中显示形式"></a>注释在typora中显示形式</h5><p>中国<a href="https://blog.csdn.net/mollen/article/details/84110708#fn:" target="_blank" rel="noopener">2</a></p><h3 id="表情的使用格式"><a href="#表情的使用格式" class="headerlink" title="表情的使用格式"></a>表情的使用格式</h3><p>:单词</p><h5 id="表情在typora中的显示形式"><a href="#表情在typora中的显示形式" class="headerlink" title="表情在typora中的显示形式"></a>表情在typora中的显示形式</h5><p>:smiley: </p><h2 id="Typora快捷键"><a href="#Typora快捷键" class="headerlink" title="Typora快捷键"></a>Typora快捷键</h2><table><thead><tr><th>快捷键</th><th>作用</th><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>Ctrl+1</td><td>一阶标题</td><td>Ctrl+B</td><td>字体加粗</td></tr><tr><td>Ctrl+2</td><td>二阶标题</td><td>Ctrl+I</td><td>字体倾斜</td></tr><tr><td>Ctrl+3</td><td>三阶标题</td><td>Ctrl+U</td><td>下划线</td></tr><tr><td>Ctrl+4</td><td>四阶标题</td><td>Ctrl+Home</td><td>返回Typora顶部</td></tr><tr><td>Ctrl+5</td><td>五阶标题</td><td>Ctrl+End</td><td>返回Typora底部</td></tr><tr><td>Ctrl+6</td><td>六阶标题</td><td>Ctrl+T</td><td>创建表格</td></tr><tr><td>Ctrl+L</td><td>选中某句话</td><td>Ctrl+K</td><td>创建超链接</td></tr><tr><td>Ctrl+D</td><td>选中某个单词</td><td>Ctrl+F</td><td>搜索</td></tr><tr><td>Ctrl+E</td><td>选中相同格式的文字</td><td>Ctrl+H</td><td>搜索并替换</td></tr><tr><td>Alt+Shift+5</td><td>删除线</td><td>Ctrl+Shift+I</td><td>插入图片</td></tr></tbody></table><h4 id="颜色代码块"><a href="#颜色代码块" class="headerlink" title="颜色代码块"></a>颜色代码块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">$\textcolor&#123;GreenYellow&#125;&#123;GreenYellow&#125; $</span><br><span class="line">$\textcolor&#123;Yellow&#125;&#123;Yellow&#125;$</span><br><span class="line">$\textcolor&#123;Goldenrod&#125;&#123;Goldenrod&#125; $</span><br><span class="line">$\textcolor&#123;Dandelion&#125;&#123;Dandelion&#125;$</span><br><span class="line">$\textcolor&#123;Apricot&#125;&#123;Apricot&#125; $</span><br><span class="line">$\textcolor&#123;Peach&#125;&#123;Peach&#125;$</span><br><span class="line">$\textcolor&#123;Melon&#125;&#123;Melon&#125; $</span><br><span class="line">$\textcolor&#123;YellowOrange&#125;&#123;YellowOrange&#125;$</span><br><span class="line">$\textcolor&#123;Orange&#125;&#123;Orange&#125; $</span><br><span class="line">$\textcolor&#123;BurntOrange&#125;&#123;BurntOrange&#125;$</span><br><span class="line">$\textcolor&#123;Bittersweet&#125;&#123;Bittersweet&#125;$</span><br><span class="line">$\textcolor&#123;RedOrange&#125;&#123;RedOrange&#125; $</span><br><span class="line">$\textcolor&#123;Mahogany&#125;&#123;Mahogany&#125;$</span><br><span class="line">$\textcolor&#123;Maroon&#125;&#123;Maroon&#125; $</span><br><span class="line">$\textcolor&#123;BrickRed&#125;&#123;BrickRed&#125;$</span><br><span class="line">$\textcolor&#123;Red&#125;&#123;Red&#125; $</span><br><span class="line">$\textcolor&#123;OrangeRed&#125;&#123;OrangeRed&#125;$</span><br><span class="line">$\textcolor&#123;RubineRed&#125;&#123;RubineRed&#125;$</span><br><span class="line">$\textcolor&#123;WildStrawberry&#125;&#123;WildStrawberry&#125;$</span><br><span class="line">$\textcolor&#123;Salmon&#125;&#123;Salmon&#125;$</span><br><span class="line">$\textcolor&#123;CarnationPink&#125;&#123;CarnationPink&#125;$</span><br><span class="line">$\textcolor&#123;Magenta&#125;&#123;Magenta&#125; $</span><br><span class="line">$\textcolor&#123;VioletRed&#125;&#123;VioletRed&#125;$</span><br><span class="line">$\textcolor&#123;Rhodamine&#125;&#123;Rhodamine&#125; $</span><br><span class="line">$\textcolor&#123;Mulberry&#125;&#123;Mulberry&#125;$</span><br><span class="line">$\textcolor&#123;RedViolet&#125;&#123;RedViolet&#125; $</span><br><span class="line">$\textcolor&#123;Fuchsia&#125;&#123;Fuchsia&#125;$</span><br><span class="line">$\textcolor&#123;Lavender&#125;&#123;Lavender&#125; $</span><br><span class="line">$\textcolor&#123;Thistle&#125;&#123;Thistle&#125;$</span><br><span class="line">$\textcolor&#123;Orchid&#125;&#123;Orchid&#125; $</span><br><span class="line">$\textcolor&#123;DarkOrchid&#125;&#123;DarkOrchid&#125;$</span><br><span class="line">$\textcolor&#123;Purple&#125;&#123;Purple&#125; $</span><br><span class="line">$\textcolor&#123;Plum&#125;&#123;Plum&#125;$</span><br><span class="line">$\textcolor&#123;Violet&#125;&#123;Violet&#125; $</span><br><span class="line">$\textcolor&#123;RoyalPurple&#125;&#123;RoyalPurple&#125;$</span><br><span class="line">$\textcolor&#123;BlueViolet&#125;&#123;BlueViolet&#125;$</span><br><span class="line">$\textcolor&#123;Periwinkle&#125;&#123;Periwinkle&#125;$</span><br><span class="line">$\textcolor&#123;CadetBlue&#125;&#123;CadetBlue&#125;$</span><br><span class="line">$\textcolor&#123;CornflowerBlue&#125;&#123;CornflowerBlue&#125;$</span><br><span class="line">$\textcolor&#123;MidnightBlue&#125;&#123;MidnightBlue&#125;$</span><br><span class="line">$\textcolor&#123;NavyBlue&#125;&#123;NavyBlue&#125; $</span><br><span class="line">$\textcolor&#123;RoyalBlue&#125;&#123;RoyalBlue&#125;$</span><br><span class="line">$\textcolor&#123;Blue&#125;&#123;Blue&#125; $</span><br><span class="line">$\textcolor&#123;Cerulean&#125;&#123;Cerulean&#125;$</span><br><span class="line">$\textcolor&#123;Cyan&#125;&#123;Cyan&#125; $</span><br><span class="line">$\textcolor&#123;ProcessBlue&#125;&#123;ProcessBlue&#125;$</span><br><span class="line">$\textcolor&#123;SkyBlue&#125;&#123;SkyBlue&#125; $</span><br><span class="line">$\textcolor&#123;Turquoise&#125;&#123;Turquoise&#125;$</span><br><span class="line">$\textcolor&#123;TealBlue&#125;&#123;TealBlue&#125; $</span><br><span class="line">$\textcolor&#123;Aquamarine&#125;&#123;Aquamarine&#125;$</span><br><span class="line">$\textcolor&#123;BlueGreen&#125;&#123;BlueGreen&#125; $</span><br><span class="line">$\textcolor&#123;Emerald&#125;&#123;Emerald&#125;$</span><br><span class="line">$\textcolor&#123;JungleGreen&#125;&#123;JungleGreen&#125;$</span><br><span class="line">$\textcolor&#123;SeaGreen&#125;&#123;SeaGreen&#125; $</span><br><span class="line">$\textcolor&#123;Green&#125;&#123;Green&#125;$</span><br><span class="line">$\textcolor&#123;ForestGreen&#125;&#123;ForestGreen&#125;$</span><br><span class="line">$\textcolor&#123;PineGreen&#125;&#123;PineGreen&#125; $</span><br><span class="line">$\textcolor&#123;LimeGreen&#125;&#123;LimeGreen&#125;$</span><br><span class="line">$\textcolor&#123;YellowGreen&#125;&#123;YellowGreen&#125;$</span><br><span class="line">$\textcolor&#123;SpringGreen&#125;&#123;SpringGreen&#125;$</span><br><span class="line">$\textcolor&#123;OliveGreen&#125;&#123;OliveGreen&#125;$</span><br><span class="line">$\textcolor&#123;RawSienna&#125;&#123;RawSienna&#125; $</span><br><span class="line">$\textcolor&#123;Sepia&#125;&#123;Sepia&#125;$</span><br><span class="line">$\textcolor&#123;Brown&#125;&#123;Brown&#125; $</span><br><span class="line">$\textcolor&#123;Tan&#125;&#123;Tan&#125;$</span><br><span class="line">$\textcolor&#123;Gray&#125;&#123;Gray&#125; $</span><br><span class="line">$\textcolor&#123;Black&#125;&#123;Black&#125;$</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python绘图</title>
      <link href="/2019/06/05/python%E7%BB%98%E5%9B%BE/"/>
      <url>/2019/06/05/python%E7%BB%98%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h3><p>import matplotlib.pyplot as plt<br>若无法显示图画记得要放在一起写不要分开写</p><p>######添加数值</p><p>for a,b in zip(ls1,ls2):<br>    plt.text(a, b,’%.0f’%b, ha = ‘center’,va = ‘bottom’,fontsize=10)</p><p>#####创建画布<br>方法1:创建简单画布<br>figure_1 = plt.figure()<br>方法2:创建复杂画布<br>figure_1 = plt.figure(1,(8,4),dpi=140,facecolor=’red’,edgecolor=’yellow’,frameon=True)<br>注释: 1代表画布编号,8,4表示宽高比,dpi表示像素,facecolor表示底色,edgecolor表示边角色frameon=Teue表示是绘制边框</p><p>#####创建画框<br>①分割画布创建画框<br>aapic_1 = figure_1.add_subplot(2,2,1) #表示分成2行2列,其中的编号1的画框,编号顺序从左到右从上到下<br>aapic_1 = figure_1.add_subplot(2,2,2)<br>aapic_1 = figure_1.add_subplot(2,2,3)<br>aapic_1 = figure_1.add_subplot(2,2,4)<br>plt.show()</p><h5 id="画线状图"><a href="#画线状图" class="headerlink" title="画线状图"></a>画线状图</h5><p>创建一个画布<br>figure_2 = plt.figure(1,(6,4),dpi=140,frameon=True)<br>创建一个画框<br>axes1 = figure_2.add_subplot(1,1,1)<br>形成线图<br>axes1.plot(np.arange(0,10),np.random.normal(3,1.6,10,’b -‘)<br>b表示线颜色为蓝色, 表示点为 ,-表示线为实线</p><h5 id="画直方图"><a href="#画直方图" class="headerlink" title="画直方图"></a>画直方图</h5><p>fgs = np.random.randn(1000)<br>创建一个画布<br>figure_2 = plt.figure(1,(6,4),dpi=140,frameon=True)<br>创建一个画框<br>axes1 = figure_2.add_subplot(1,1,1)<br>创建直方图<br>axes1.hist(fgs,bins=20) #bins表示分成多少组</p><h5 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h5><p>x = np.linspace(-3,3,100)<br>一步创建画框画布<br>sfg,axes = plt.subplots(1,1,dpi=140,figsize(6,4))<br>绘制散点图<br>axes1.scatter(x,np.cos(x),c=’b’,marker=’ ‘) #x表示x轴,np.cos(x)表示纵轴,c=’b’表示颜色为蓝色,,marker=’ ‘表示外形为 .</p><h5 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h5><p>Asx,sd=plt.subplots(1,1)  #一行一列遵循数组编号<br>sd.pie(np.arange(4,9),explode=[0.2,0.1,0.3,0.4,0.3],labels=[‘1’,’2’,’3’,’4,’5’],colors=[‘m’,’r’,’g’,’c’,’b’],autopct=’%.2f%%’,pctdistance=1,shadow=True,labeldistance=1.6,startangle=30,radius=1,frame=True,rotatelabels=True)<br>np.arange(4,9)用来分块分成5块,explode表示爆炸系数,labels表示标签名,colors表示各个标签对应图的颜色,shadow表示阴影,radius圆半径,autopct指定数值的显示方式,labeldistance每一项的名称label和距离圆心的半径,pctdistance每一项的比例autopct和距离圆心的半径,frame表的轴框架,rotatelabels旋转每个label到指定的角度,startanglex轴逆时针旋转饼图的开始角度.</p><p>如果不涉及子图的话，无需先设置画布。可直接画出图形：<br>plt.plot(np.random.randn(30).cumsum(),’g –’)<br>等价于Plt.plot(np.random.randn(30).cumsum(),color=’g’,linestyle=’dashed’,marker=’ ’)<br>plt.plot(data_uique,’r-‘,drawstyle=’steps-post’,label=’line’)====label=’line’标识线型<br>plt.legend(loc=’best’)  线标签的位置放在最好的地方 plt.legend也可以</p><h5 id="刻度和标签"><a href="#刻度和标签" class="headerlink" title="刻度和标签"></a>刻度和标签</h5><p>Xlim（X值范围）、xticks（X轴刻度值）和xticklabels（X轴刻度标签）<br>ticks_1=ax.set_xticks([0,25000,50000,75000,100000])” 分组的组距<br>scale_name=ax.set_xticklabels([‘step1’,’step2’,’step3’,’step4’,’step5’],rotation=45,fontsize=12) 分组对应的标签名<br>ax.set_title(‘Python-03 Practice’)  设置画框标题 ,使用画布加标题不需要set<br>ax.set_xlabel(‘Steps’)  设置x轴标签<br>ax.set_ylabel(‘Values’) 设置y轴标签<br>subpic.text(90,35,’key point one’,fontsize=10)  位置定坐标位置添加注解<br>keymenge=[(67,57,’key point two’),(23,66,’key point two’)] 添加多个注解可以通过循环列表实现<br>subpic.annotate(‘beautyful point’,xy=(5,23),xytext=(5,23)) 宁一种加注解方式<br>plt.savefig(‘Desktop python_01.png’,dpi=400,bbox_inches=’tight’) 保存图片</p><h4 id="线型和marker表格："><a href="#线型和marker表格：" class="headerlink" title="线型和marker表格："></a>线型和marker表格：</h4><p>‘-‘ solid line style<br>‘–’ dashed line style<br>‘-.’ dash-dot line style<br>‘:’ dotted line style<br>‘.’ point marker<br>‘,’ pixel marker<br>‘o’ circle marker<br>‘v’ triangle_down marker<br>‘^’ triangle_up marker<br>‘&lt;’ triangle_left marker<br>‘&gt;’ triangle_right marker<br>‘1’ tri_down marker<br>‘2’ tri_up marker<br>‘3’ tri_left marker<br>‘4’ tri_right marker<br>‘s’ square marker<br>‘p’ pentagon marker<br>‘ ‘ star marker<br>‘h’ hexagon1 marker<br>‘H’ hexagon2 marker<br>‘+’ plus marker<br>‘x’ x marker<br>‘D’ diamond marker<br>‘d’ thin_diamond marker<br>‘|’ vline marker<br>‘_’ hline marker<br>颜色表格：<br>‘b’ blue<br>‘g’ green<br>‘r’ red<br>‘c’ cyan<br>‘m’ magenta<br>‘y’ yellow<br>‘k’ black<br>‘w’ white</p><h3 id="Pandas作图"><a href="#Pandas作图" class="headerlink" title="Pandas作图"></a>Pandas作图</h3><h5 id="线性图"><a href="#线性图" class="headerlink" title="线性图"></a>线性图</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">ser=pd.Series(np.random.randn(10).cumsum(),index=np.arange(0,100,10))</span><br><span class="line">ser.plot()</span><br></pre></td></tr></table></figure><p><img src="/2019/06/05/python绘图/series线形图.png" alt="eries线形"><br>Series.plot 方法的常用参数汇总：<br>| label     | 用于设置图例的标签                                           |<br>| ——— | ———————————————————— |<br>| ax        | 确定要被绘制的matplotlib subplot对象。如果没有设置，则使用当前matplotlib subplot |<br>| style     | 设置传给matplotlib的风格字符串（’g*–’）                     |<br>| alpha     | 图表的填充不透明度（数值为0到1之间的数）                     |<br>| kind      | 各种图形样式line, bar, barh, kde, density, scatter           |<br>| logy      | 在Y轴上使用对数标尺                                          |<br>| use_index | 将对象（Series and DataFrame）的索引用作<strong>刻度标签</strong>         |<br>| rot       | 旋转度数（0到360）                                           |<br>| xticks    | 用作X轴刻度的值                                              |<br>| yticks    | 用作y轴刻度的值                                              |<br>| xlim      | x的值域                                                      |<br>| ylim      | y的值域                                                      |<br>| grid      | 设置是否显示轴网格线                                         |<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">Frame_01=pd.DataFrame([[2,4,8,16,32,64],[3,6,12,24,48,96],[5,10,15,20,25,30],[1,3,5,7,9,11],[16,8,4,2,1,0.5]],index=range(0,100,20),columns=[&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;])</span><br><span class="line">pic_2,subplot_object=plt.subplots(1,1)</span><br><span class="line">Frame_01.plot(kind=&apos;line&apos;,ax=subplot_object,subplots=False,layout=False,logx=True,xlim=[0,100])</span><br></pre></td></tr></table></figure></p><p><img src="/2019/06/05/python绘图/dataframe线形图.png" alt="ataframe线形"><br>DataFrame的plot的参数<br>| Subplots     | 将依据数据框中的每个列绘制的图分别放置到单个的subplot（子画框）里 |<br>| ———— | ———————————————————— |<br>| sharex       | Subplots=true时，设定是否共享X的刻度和值域                   |<br>| sharey       | Subplots=true时，设定是否共享y的刻度和值域                   |<br>| figsize      | 元组，用来表示图像大小（宽，高）                             |<br>| title        | 设置图像标题                                                 |<br>| Legend       | 设定是否添加一个subplot图例                                  |<br>| sort_columns | 设定是否以字母表中字母先后排列顺序绘制各列。                 |</p><h5 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Series生成柱状图</span><br><span class="line"> import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">figure_1,get_information_of_pict=plt.subplots(2,1)</span><br><span class="line">datas=pd.Series(np.random.rand(20),index=list(&apos;qwertyuiopasdfghjklz&apos;))</span><br><span class="line">datas.plot(kind=&apos;barh&apos;,ax=get_information_of_pict[0],figsize=(8,12),color=&apos;g&apos;)</span><br><span class="line">Out[4]: &lt;matplotlib.axes._subplots.AxesSubplot at 0x5be13ea6d8&gt;</span><br><span class="line">datas.plot(kind=&apos;bar&apos;,ax=get_information_of_pict[1],figsize=(8,12),color=&apos;r&apos;)</span><br><span class="line">Out[5]: &lt;matplotlib.axes._subplots.AxesSubplot at 0x5be18c41d0&gt;</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2019/06/05/python绘图/series柱状图.png" alt="eries柱状"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">数据框生成柱状图</span><br><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">plt.rcParams[&apos;font.sans-serif&apos;]=[&apos;SimHei&apos;] </span><br><span class="line">plt.rcParams[&apos;axes.unicode_minus&apos;] = False</span><br><span class="line">Framedata_1=pd.DataFrame(np.arange(16).reshape(4,4)**(1/2)+np.arange(16).reshape(4,4)*3+6,index=[&apos;spring&apos;,&apos;sommer&apos;,&apos;autumn&apos;,&apos;winter&apos;],columns=[&apos;Benz&apos;,&apos;BMW&apos;,&apos;Porsche&apos;,&apos;VW&apos;])</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">picrange,pic_inf=plt.subplots(2,1)</span><br><span class="line">Framedata_1.plot(kind=&apos;bar&apos;,ax=pic_inf[0],title=&apos;2018年德系车销售额&apos;,rot=50,figsize=(8,12))</span><br><span class="line">Framedata_1.plot(kind=&apos;barh&apos;,ax=pic_inf[1],title=&apos;2018年德系车销售额&apos;,rot=130,figsize=(8,12))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2019/06/05/python绘图/dataframe柱状图.png" alt="ataframe柱状"></p><h3 id="绘制立体图"><a href="#绘制立体图" class="headerlink" title="绘制立体图"></a>绘制立体图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">参数：</span><br><span class="line">  X ， Y ， Z  数据值为二维数组   </span><br><span class="line">  rstride   数组行步幅（步长）   </span><br><span class="line">  cstride   数组列步幅（步长）   </span><br><span class="line">  rcount   最多使用行，默认为50   </span><br><span class="line">  ccount   最多使用列，默认为50   </span><br><span class="line"> 颜色    曲面片的颜色   </span><br><span class="line">  cmap    曲面片调色板。   </span><br><span class="line">  facecolors  单个曲面片的表面色   </span><br><span class="line">  norm    一个标准化实例，用于将值映射到颜色   </span><br><span class="line">  vmin    映射的最小值   </span><br><span class="line">  vmax   映射的最大值   </span><br><span class="line"> shade   是否遮蔽表面色</span><br></pre></td></tr></table></figure><h5 id="曲面图"><a href="#曲面图" class="headerlink" title="曲面图"></a>曲面图</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">例子：非参数化坐标轴下曲面图</span><br><span class="line">import numpy as np</span><br><span class="line">from mpl_toolkits.mplot3d import Axes3D</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import random</span><br><span class="line">def fun(x, y):</span><br><span class="line">  return np.sqrt(x**2 + y**2)</span><br><span class="line">fig = plt.figure(0,dpi=120,figsize=(6,6))</span><br><span class="line">ax = fig.add_subplot(111, projection=&apos;3d&apos;)</span><br><span class="line">x = y = np.linspace(-5.0, 5.0, 100)</span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br><span class="line">zs = np.array([fun(x,y) for x,y in zip(np.ravel(X), np.ravel(Y))])</span><br><span class="line">Z = zs.reshape(Y.shape)</span><br><span class="line">ax.plot_surface(X, Y, Z,cmap=&apos;jet&apos;)</span><br><span class="line">ax.set_xlabel(&apos;X Label&apos;)</span><br><span class="line">ax.set_ylabel(&apos;Y Label&apos;)</span><br><span class="line">ax.set_zlabel(&apos;Z Label&apos;)</span><br><span class="line">#(np.ravel(X)).shape</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2019/06/05/python绘图/曲面图.png" alt="面"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">例子：参数化坐标轴下的三维球</span><br><span class="line">from mpl_toolkits.mplot3d import Axes3D</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">u = np.linspace(0,2*np.pi,1000)</span><br><span class="line">v = np.linspace(0,np.pi,1000)</span><br><span class="line">x=10*np.outer(np.sin(v),np.cos(u))</span><br><span class="line">y=10*np.outer(np.sin(v),np.sin(u))</span><br><span class="line">z=10*np.outer(np.cos(v),np.ones(len(np.cos(v))))</span><br><span class="line">#创建二维数据集X,Y和Z，注意他们的值必须在各矩阵相同位置处一一对应。</span><br><span class="line">fig=plt.figure(0,figsize=(8,8),dpi=120)</span><br><span class="line">ax=fig.add_subplot(1,1,1,projection=&apos;3d&apos;)</span><br><span class="line">#ax.plot_surface(x,y,z,rcount=1000,ccount=1000,cmap=&apos;coolwarm&apos;)#太浪费时间了，用下面替换语句</span><br><span class="line">ax.plot_surface(x,y,z,cmap=&apos;hot&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2019/06/05/python绘图/球形图.png" alt="形"></p><h5 id="曲线图"><a href="#曲线图" class="headerlink" title="曲线图"></a>曲线图</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">例子：我的葫芦</span><br><span class="line">from mpl_toolkits.mplot3d import Axes3D</span><br><span class="line"></span><br><span class="line">fig = plt.figure(0,dpi=100,figsize=(6,6))</span><br><span class="line">ax = fig.add_subplot(1,1,1, projection=&apos;3d&apos;)</span><br><span class="line">theta = np.linspace(-20 * np.pi, 20 * np.pi, 1000)</span><br><span class="line">z = np.linspace(0,10,1000);phi=np.linspace(0,2*np.pi,1000)</span><br><span class="line">r=z*np.sin(phi)</span><br><span class="line">x = r * np.sin(theta)</span><br><span class="line">y = r * np.cos(theta)</span><br><span class="line">ax.plot(x, y, z, label=&apos;curve&apos;)</span><br><span class="line">ax.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2019/06/05/python绘图/曲线图.png" alt="线"></p><h5 id="边框图"><a href="#边框图" class="headerlink" title="边框图"></a>边框图</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">线框图</span><br><span class="line">例子：</span><br><span class="line">import numpy as np  </span><br><span class="line">def fun(x,y):  </span><br><span class="line">    return np.power(x,2)+np.sin(np.power(y,2))*x  </span><br><span class="line">  </span><br><span class="line">fig1=plt.figure(0,dpi=160,figsize=(8,8))  </span><br><span class="line">ax=Axes3D(fig1)#三维化画布并产生三维画框</span><br><span class="line">X=np.arange(-3,3,0.05)  </span><br><span class="line">Y=np.arange(-3,3,0.05)</span><br><span class="line">X,Y=np.meshgrid(X,Y)#生成坐标点  </span><br><span class="line">Z=fun(X,Y) </span><br><span class="line">plt.title(&apos;python-08&apos;)</span><br><span class="line">ax.plot_wireframe(X, Y, Z, rstride=3, cstride=3)#一定要调节成大的扫描步长才有效果</span><br><span class="line">ax.set_xlabel(&apos;x label&apos;, color=&apos;r&apos;)  </span><br><span class="line">ax.set_ylabel(&apos;y label&apos;, color=&apos;g&apos;)  </span><br><span class="line">ax.set_zlabel(&apos;z label&apos;, color=&apos;b&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2019/06/05/python绘图/网格图.png" alt="格"></p><p>#####等高线图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">*X*, *Y*, *Z*     数组型数据</span><br><span class="line">*extend3d*      是否在3D中扩展等高线图（默认值：False）</span><br><span class="line">*stride*         *步幅*，用于扩展等高线图的步幅（步长）</span><br><span class="line">*zdir*           等高线图产生方向: x, y 或 z (default)</span><br><span class="line">*offset*         如果赋值，绘制等高线投影到垂直于zdir并且通过偏移量确定位置的平面</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">import numpy as np  </span><br><span class="line">  </span><br><span class="line">def fun(x,y):  </span><br><span class="line">    return (1/(2*np.pi))*np.exp(-0.5*(x**2+y**2))  </span><br><span class="line">fig1=plt.figure(0,dpi=160,figsize=(8,8))  </span><br><span class="line">ax=Axes3D(fig1)#三维化画布并产生三维画框</span><br><span class="line">X=np.arange(-3,3,0.05)  </span><br><span class="line">Y=np.arange(-3,3,0.05)</span><br><span class="line">X,Y=np.meshgrid(X,Y)#生成坐标点  </span><br><span class="line">Z=fun(X,Y) </span><br><span class="line">plt.title(&apos;python-08&apos;)</span><br><span class="line">ax.plot_surface(X, Y, Z, rstride=3, cstride=3,cmap=&apos;jet&apos;)</span><br><span class="line">ax.contour(X, Y, Z, zdir=&apos;z&apos;,offset=0.16,cmap=&apos;coolwarm&apos;) </span><br><span class="line">cset = ax.contour(X, Y, Z, zdir=&apos;x&apos;, offset=-3, cmap=&apos;coolwarm&apos;) </span><br><span class="line">cset = ax.contour(X, Y, Z, zdir=&apos;y&apos;, offset=3, cmap=&apos;coolwarm&apos;)</span><br><span class="line">ax.set_xlabel(&apos;x label&apos;, color=&apos;r&apos;)  </span><br><span class="line">ax.set_ylabel(&apos;y label&apos;, color=&apos;g&apos;)  </span><br><span class="line">ax.set_zlabel(&apos;z label&apos;, color=&apos;b&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2019/06/05/python绘图/等势线图.png" alt="势线"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas</title>
      <link href="/2019/06/05/Pandas/"/>
      <url>/2019/06/05/Pandas/</url>
      
        <content type="html"><![CDATA[<h1 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h1><h3 id="Series-适用于一维的"><a href="#Series-适用于一维的" class="headerlink" title="Series(适用于一维的)"></a>Series(适用于一维的)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Series数据的建立</span><br><span class="line">pddata_1=pd.Series([1,2,3]) </span><br><span class="line">对应数据格式:</span><br><span class="line">0 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">pddata_1=pd.Series([[1,2],[3,4]])</span><br><span class="line">对应数据格式:</span><br><span class="line">0    [1, 2]</span><br><span class="line">1    [3, 4]</span><br><span class="line">pddata_1=pd.Series([[1,2],[3,4]],index=[&apos;345&apos;,&apos;2342&apos;])</span><br><span class="line">对应数据格式:</span><br><span class="line">345     [1, 2]</span><br><span class="line">2342    [3, 4]</span><br><span class="line">pddata_1=pd.Series(((1,2),(3,4)),index=[&apos;345&apos;,&apos;2342&apos;])</span><br><span class="line">对应数据格式:</span><br><span class="line">345     (1, 2)</span><br><span class="line">2342    (3, 4)</span><br><span class="line">pddata_1=pd.Series([np.random.randint(1,100,6),np.random.randint(1,100,6)])</span><br><span class="line">对应数据格式:</span><br><span class="line">0    [15, 24, 43, 57, 97, 36]</span><br><span class="line">1     [67, 12, 69, 61, 9, 18]</span><br><span class="line">pddata_1=pd.Series(&#123;1:&apos;foo&apos;,3:&apos;drt&apos;,8:&apos;tyue&apos;&#125;)  =====不需要加索引index否则会使得数据的值变成nan,冲突了</span><br><span class="line">对应数据格式:</span><br><span class="line">1     foo</span><br><span class="line">3     drt</span><br><span class="line">8    tyue</span><br><span class="line">pddata_1=pd.Series(list(zip(np.array(list1),np.array(list2)))</span><br><span class="line">对应数据格式:</span><br><span class="line">0    (1, 3)</span><br><span class="line">1    (2, 4)</span><br><span class="line">2    (3, 5)</span><br><span class="line">3    (4, 6)</span><br></pre></td></tr></table></figure><h4 id="Series常用的方法"><a href="#Series常用的方法" class="headerlink" title="Series常用的方法"></a>Series常用的方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1.values  以数组形式查看所有值</span><br><span class="line">s1.index  查看所有索引</span><br><span class="line">通过索引取值 s1[&apos;索引名&apos;]</span><br><span class="line">Series过滤 s1[s1&gt;2]  返回索引以及对应的数据</span><br><span class="line">(numpy过滤的实现通过布尔数组实现)</span><br></pre></td></tr></table></figure><h6 id="Series更新"><a href="#Series更新" class="headerlink" title="Series更新"></a>Series更新</h6><p>s1.update(pd.Series([12,23],index = [3,4]))</p><h6 id="Series追加"><a href="#Series追加" class="headerlink" title="Series追加"></a>Series追加</h6><p>s1.append(pd.Series([-123,-234,-56],ignore_index=True))   ignore_index=True表示形成默认的索引,不写表示使用原来数据自带的索引</p><h6 id="Series是否包含某个数据"><a href="#Series是否包含某个数据" class="headerlink" title="Series是否包含某个数据"></a>Series是否包含某个数据</h6><p>‘want’ in datas_pys   返回布尔值.判断want是否为datas_pys的索引,数据框dataframe同样适用index和columns都可以判断</p><h6 id="检测数据是否丢失"><a href="#检测数据是否丢失" class="headerlink" title="检测数据是否丢失"></a>检测数据是否丢失</h6><p>pd.isnull(serie_123)    serie_123.isnull()   是空值的返回对应的True<br>pd.notnull(serie_123)  serie_123.notnull()   不是空值对应的布尔值为True<br>补充:numpy判断是否为空,np.isnan(i) == True,没有i == np.nan这种用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed() 随机种子,使得随机组成的数组不会改变,重新运行还是之前的三个数据</span><br><span class="line">a1 = np.random.randint(1,13,6)</span><br><span class="line">np.random.seed()</span><br><span class="line">a1</span><br></pre></td></tr></table></figure><h6 id="修改Series的索引"><a href="#修改Series的索引" class="headerlink" title="修改Series的索引"></a>修改Series的索引</h6><p>s1.index = [新的值]<br>serie_123.index=[‘lin’, ‘tan’, ‘shan’, ‘zhang’]</p><h5 id="Series索引重建"><a href="#Series索引重建" class="headerlink" title="Series索引重建"></a>Series索引重建</h5><p>sr1.reindex([1,2,3,4,’e’,’r’,’t’])  新形成的索引若原来的sr1中有对应的索引则数据不变,对于sr1中没有的则显示为NaN</p><p>sr1.reindex([1,2,3,4,’e’,’r’,’t’],fill_value = -1)   没有的全部填成-1,具体填什么看要求可以为0等等</p><h5 id="缺失值填充"><a href="#缺失值填充" class="headerlink" title="缺失值填充"></a>缺失值填充</h5><p>s2=s1.reindex(range(11),method=’ffill’)   向前填充(6对应5的数据)</p><p>s2=s1.reindex(range(11),method=’bfill’)   向后填充(6对应7的数据</p><h6 id="选区"><a href="#选区" class="headerlink" title="选区"></a>选区</h6><p>Series的切片选区不仅可以通过自定义的索引去获取还能通过默认的数字去获取(即使已经自定义了同样可以使用) <strong>注意</strong>右边可以取到是闭区间(仅适用自定义的索引)</p><h6 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h6><p>sr1[sr1&gt;5]  =====返回符合条件的数据以及对应的行索引</p><h6 id="Series赋值"><a href="#Series赋值" class="headerlink" title="Series赋值"></a>Series赋值</h6><p>sr1[2:4] = [2,3]   ======自定义的索引也可以使用切片操作</p><h5 id="value-counts"><a href="#value-counts" class="headerlink" title="value_counts()"></a>value_counts()</h5><p>对Series中值进行计数  返回的为值以及对应的数量<br>pd.value_counts(series_3.values)  当成函数同样可以使用,当成函数可以用在任何序列和数组,一般不用于数据框</p><h6 id="isin"><a href="#isin" class="headerlink" title="isin()"></a>isin()</h6><p>判断数据是否在容器内返回布尔数组<br>s1.isin([‘a’,’c’])  每个数据都进行判断,可以当做布尔索引使用返回true的索引和值</p><h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a><strong>DataFrame</strong></h3><h5 id="创建数据框"><a href="#创建数据框" class="headerlink" title="创建数据框"></a>创建数据框</h5><h6 id="方式一"><a href="#方式一" class="headerlink" title="方式一:"></a>方式一:</h6><p>df1 = pd.DataFrame(np.random.randint(1,100,(3,3)),index=[‘a’,’b’,’c’],columns=[‘d’,’e’,’f’])  不使用index和columns时会使用默认的0,1,2…之类的</p><h6 id="方式二"><a href="#方式二" class="headerlink" title="方式二:"></a>方式二:</h6><p>list1 = [1,3,4,5,6]<br>list2 = [5,6,7,8,9]<br>dict1 = {‘a’:list1,’b’:list2}<br>df1 = pd.DataFrame(dict1) =====行索引使用的是默认的数字,列索引使用的是字典的键</p><h5 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h5><h6 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h6><p>df1.loc[行索引名,列索引名]  ix很少使用,基本用到行索引都要用loc</p><p>loc不能直接获取某一列可以通过df1.loc[:,列索引名] ,列索引名可以为列表任意选取指定的列,行同样可以</p><h5 id="但是行索引可以通过切片获取-如df1-‘t’-’t’-可以获取指定的行和多行"><a href="#但是行索引可以通过切片获取-如df1-‘t’-’t’-可以获取指定的行和多行" class="headerlink" title="但是行索引可以通过切片获取 如df1[‘t’:’t’]可以获取指定的行和多行"></a>但是行索引可以通过切片获取 如df1[‘t’:’t’]可以获取指定的行和多行</h5><h6 id="列数据索引"><a href="#列数据索引" class="headerlink" title="列数据索引"></a>列数据索引</h6><p>df1[‘列索引名’]   =====返回对应的那一列以及对应的行索引</p><h6 id="行数据索引"><a href="#行数据索引" class="headerlink" title="行数据索引"></a>行数据索引</h6><p>df1.loc[行索引名]  或者 df1.ix[行索引名] (快要不能使用了少用)</p><h6 id="索引的更改"><a href="#索引的更改" class="headerlink" title="索引的更改"></a>索引的更改</h6><p>df1.index = [新值]  df1.columns= [新值]</p><h6 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h6><p>df1.transpose()  或者 df1.T</p><h6 id="删除列索引以及对应列"><a href="#删除列索引以及对应列" class="headerlink" title="删除列索引以及对应列"></a>删除列索引以及对应列</h6><p>del df1[‘e’]   ======该方法无法删除行索引添加loc也不行</p><h6 id="删除行索引以及对应行-也可以用来删除列"><a href="#删除行索引以及对应行-也可以用来删除列" class="headerlink" title="删除行索引以及对应行(也可以用来删除列)"></a>删除行索引以及对应行(也可以用来删除列)</h6><p>df1.drop(行索引名)   默认0轴表示行,1表示列========删除相关的0,1跟记得不太一样逐行按列和按列逐行相反注意差别</p><h6 id="数据框名字的添加-列索引行索引的统称-跟二维数组那种类似"><a href="#数据框名字的添加-列索引行索引的统称-跟二维数组那种类似" class="headerlink" title="数据框名字的添加(列索引行索引的统称,跟二维数组那种类似)"></a>数据框名字的添加(列索引行索引的统称,跟二维数组那种类似)</h6><p>df1.index.name = ‘名字’<br>df1.columns.name = ‘名字</p><h6 id="替换数据"><a href="#替换数据" class="headerlink" title="替换数据"></a>替换数据</h6><p>a1.replace([np.nan, 5, 7], [10, 100, 100])</p><h6 id="查看数据框的索引"><a href="#查看数据框的索引" class="headerlink" title="查看数据框的索引"></a>查看数据框的索引</h6><p>df1.index  </p><h6 id="产看数据框的值"><a href="#产看数据框的值" class="headerlink" title="产看数据框的值"></a>产看数据框的值</h6><p>df1.values  ====返回的是数组</p><h5 id="缺失值填充-1"><a href="#缺失值填充-1" class="headerlink" title="缺失值填充"></a>缺失值填充</h5><p>同Series相同  df1.reindex([1,’t’,’tr’,’e’]) 有的写下来没有的全为NaN</p><h6 id="修改索引"><a href="#修改索引" class="headerlink" title="修改索引"></a>修改索引</h6><p>修改行索引(默认为行索引)  df1.reindex(index = [1,’t’,’tr’,’e’])</p><p>修改列索引  frame2.reindex(columns=[‘four’,’three’])</p><p>同时修改列和行索引  df1.reindex([‘row1’,’row2’,’row3’,’row4’],columns=[‘five’,’three’,’six’])</p><h6 id="布尔索引-1"><a href="#布尔索引-1" class="headerlink" title="布尔索引"></a>布尔索引</h6><p>df1[df1[列索引名]&gt;60]  =====返回对应True的行</p><p>df1.loc[df1[列索引名]&gt;60,:]  与上面的等价</p><p>df1[df1&gt;60]   只返回True对应的值False的值为NaN</p><h6 id="行列索引有重复值"><a href="#行列索引有重复值" class="headerlink" title="行列索引有重复值"></a>行列索引有重复值</h6><p>通过行列索引获取会将多个都获取到df1.loc[‘r1’]  df1[‘d2’]</p><h6 id="is-unique"><a href="#is-unique" class="headerlink" title="is_unique()"></a>is_unique()</h6><p>判断是否存在重复值索引 df.index.is_unique()  df.columns.is_unique</p><p>series 使用s1.is_unique()即可</p><h6 id="Get-value"><a href="#Get-value" class="headerlink" title="Get_value"></a>Get_value</h6><p>方法得到数据框内单个值==效果同loc但是不常用</p><p>Data.get_value(‘three’,’ihr’)</p><h4 id="简单的算数运算和数据对齐"><a href="#简单的算数运算和数据对齐" class="headerlink" title="简单的算数运算和数据对齐"></a>简单的算数运算和数据对齐</h4><p>Series按照对应的索引相加减乘除如果没有对应的返回NaN,推荐使用默认索引</p><p>DataFrame也要按照行列索引相同相加减乘除,否则会产生NaN</p><h6 id="消除空值的方法"><a href="#消除空值的方法" class="headerlink" title="消除空值的方法"></a>消除空值的方法</h6><p>df1.add(df2,fill_value=0)</p><h6 id="DataFrame-和-Series之间运算-索引要一一对应"><a href="#DataFrame-和-Series之间运算-索引要一一对应" class="headerlink" title="DataFrame 和 Series之间运算(索引要一一对应)"></a>DataFrame 和 Series之间运算(索引要一一对应)</h6><p>df1-sr1   =====匹配列索引,数据框一行行被Series减去(广播)</p><p>一列列相减没意义,实现需要通过方法如f1.sub(s1,axis=0)</p><h6 id="min-max"><a href="#min-max" class="headerlink" title="min()\max()"></a>min()\max()</h6><p>默认按列计算==df1.min(0)  按行算改成1即可</p><h6 id="sum"><a href="#sum" class="headerlink" title="sum()"></a>sum()</h6><p>df1.sum() 按列求和 df1.sum(0)<br>df1.sum(1) 按行求和<br>df1.sum(axis=1,skipna=False)  不跳过空值,有空值则结果为NaN</p><h6 id="idxmax-idxmin"><a href="#idxmax-idxmin" class="headerlink" title="idxmax()\idxmin()"></a>idxmax()\idxmin()</h6><p>df1.idxmax()  按列求最大值所在的行索引 == df1.idxmax(0)<br>df1.idxmax(1)   按行球最大值所在的列索引  返回列索引以及对应的行索引<br>df1.idxmin()  方法同上面的max<br>df1.idxmin(axis=1,skipna=False) 遇到了nan则对应为NaN</p><h6 id="cumsum"><a href="#cumsum" class="headerlink" title="cumsum()"></a>cumsum()</h6><p>求累加和,默认按列,默认忽略空值<br>df1.cumsum() 同 df1.cumsum(0)<br>df1.cumsum(1)  按行求累加和</p><h5 id="describe"><a href="#describe" class="headerlink" title="describe()"></a>describe()</h5><p>df1.describe()查看df1列的众多属性</p><h5 id="fillna"><a href="#fillna" class="headerlink" title="fillna()"></a>fillna()</h5><p>df1.fillna(0) 将所有的空值填为0,其中np.nan和None都能产生空值的效果<br>df1.fillna({1:5,2:4}) 通过字典补值 将列索引1和2那列所有空值填成5和4<br>df1.fillna({1:pd.Series([2,3,7],index=[0,1,2]),2:pd.Series([1,9],index=[0,1])}) 通过观察原数据的空值,确定行号,然后根据空缺值所在的位置创建Series对对应数据进行补值(常用语经验补值和业务补值)</p><h5 id="dropna"><a href="#dropna" class="headerlink" title="dropna()"></a>dropna()</h5><p>过滤空值数据<br>s1.dropna() 删除空值及其对应的索引<br>df1.dropna(0,how=’any’)  按行删除,将行中有空值的全删除<br>df1.dropna(1,how=’all’)  按列删除,将列中全为空值的删除否则不删</p><h4 id="apply和applymap-通过函数对数据处理"><a href="#apply和applymap-通过函数对数据处理" class="headerlink" title="apply和applymap(通过函数对数据处理)"></a>apply和applymap(通过函数对数据处理)</h4><p>df1.apply(func,axis=1)  根据func是矢量还是标量决定是否对元素操作(这里的矢量指函数含有min,max等方法)  当为标量的时候是对每一个元素处理,当为矢量决定是对行还是列处理</p><p>df1.applymap(func)  对每一个数据处理</p><h5 id="DataFrame-的格式化-非常有用"><a href="#DataFrame-的格式化-非常有用" class="headerlink" title="DataFrame 的格式化(非常有用)"></a>DataFrame 的格式化(非常有用)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">frame11=pd.DataFrame(np.random.randn(3,4),index=[&apos;r1&apos;,&apos;r2&apos;,&apos;r3&apos;],columns=[&apos;c1&apos;,&apos;c2&apos;,&apos;c3&apos;,&apos;c4&apos;])</span><br><span class="line">formatierung=lambda x:&apos;%.2f&apos; % x</span><br><span class="line">frame11.applymap(formatierung)</span><br></pre></td></tr></table></figure><h5 id="排序和排名"><a href="#排序和排名" class="headerlink" title="排序和排名"></a>排序和排名</h5><h6 id="索引排序"><a href="#索引排序" class="headerlink" title="索引排序"></a>索引排序</h6><p>df1.sort_index(0)  逐行<strong>按列</strong> </p><p>df1.sort_index(1)  逐列<strong>按行</strong></p><h6 id="值排序"><a href="#值排序" class="headerlink" title="值排序"></a>值排序</h6><p>df1.sort_values(by=某个列字段,axis=0)  按列排</p><p>df1.sort_values(by=某个行字段,axis=1)  按行排</p><p>===================================================</p><h3 id="Series排名"><a href="#Series排名" class="headerlink" title="Series排名"></a>Series排名</h3><h6 id="方法1-Series-1-rank-method-’average’-ascending-True"><a href="#方法1-Series-1-rank-method-’average’-ascending-True" class="headerlink" title="方法1:Series_1.rank(method=’average’,ascending=True)"></a>方法1:Series_1.rank(method=’average’,ascending=True)</h6><h6 id="方法2-Series-1-rank-method-’min’"><a href="#方法2-Series-1-rank-method-’min’" class="headerlink" title="方法2:Series_1.rank(method=’min’)"></a>方法2:Series_1.rank(method=’min’)</h6><h6 id="方法3-Series-1-rank-method-’max’"><a href="#方法3-Series-1-rank-method-’max’" class="headerlink" title="方法3:Series_1.rank(method=’max’)"></a>方法3:Series_1.rank(method=’max’)</h6><h6 id="方法4-Series-1-rank-method-’first’"><a href="#方法4-Series-1-rank-method-’first’" class="headerlink" title="方法4:Series_1.rank(method=’first’)"></a>方法4:Series_1.rank(method=’first’)</h6><h6 id="DataFrame的排名-默认是按列排的按行排加上axis-1"><a href="#DataFrame的排名-默认是按列排的按行排加上axis-1" class="headerlink" title="DataFrame的排名(默认是按列排的按行排加上axis=1)"></a>DataFrame的排名(默认是按列排的按行排加上axis=1)</h6><h6 id="方法1-Frame-1-rank-method-’average’-ascending-True"><a href="#方法1-Frame-1-rank-method-’average’-ascending-True" class="headerlink" title="方法1:Frame_1.rank(method=’average’,ascending=True)"></a>方法1:Frame_1.rank(method=’average’,ascending=True)</h6><h6 id="方法2-Frame-1-rank-method-’min’"><a href="#方法2-Frame-1-rank-method-’min’" class="headerlink" title="方法2:Frame_1.rank(method=’min’)"></a>方法2:Frame_1.rank(method=’min’)</h6><h6 id="方法3-Frame-1-rank-method-’max’"><a href="#方法3-Frame-1-rank-method-’max’" class="headerlink" title="方法3:Frame_1.rank(method=’max’)"></a>方法3:Frame_1.rank(method=’max’)</h6><h6 id="方法4-Frame-1-rank-method-’first’"><a href="#方法4-Frame-1-rank-method-’first’" class="headerlink" title="方法4:Frame_1.rank(method=’first’)"></a>方法4:Frame_1.rank(method=’first’)</h6><h3 id="花式索引随机赋空值-块赋值"><a href="#花式索引随机赋空值-块赋值" class="headerlink" title="花式索引随机赋空值(块赋值)"></a>花式索引随机赋空值(块赋值)</h3><p>fr567.loc[np.unique(np.random.randint(3,8,5).tolist()),np.unique(np.random.randint(2,7,5).tolist())]=np.nan</p><h3 id="层次化索引"><a href="#层次化索引" class="headerlink" title="层次化索引"></a>层次化索引</h3><p>pd.Series(np.random.randn(4),index=[[‘r1’,’r1’,’t1’,’t1’],[2,3,5,7]])</p><p>最里层索引一定唯一</p><h3 id="散点知识点"><a href="#散点知识点" class="headerlink" title="散点知识点"></a>散点知识点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">in判断索引是否在Series或者DataFrame里而不是数据是否在里面</span><br><span class="line">#时间加减操作</span><br><span class="line">from dateutil.relativedelta import relativedelta</span><br><span class="line">from datetime import  datetime</span><br><span class="line">datetime.now() - relativedelta(days=1)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>布尔数组、数组排序、数组去重</title>
      <link href="/2019/06/03/%E5%B8%83%E5%B0%94%E6%95%B0%E7%BB%84%E3%80%81%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E3%80%81%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
      <url>/2019/06/03/%E5%B8%83%E5%B0%94%E6%95%B0%E7%BB%84%E3%80%81%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E3%80%81%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p><strong>离散数据</strong>:名目数据(名字、目录,能直接描述的事物)或者是顺序数据(称为带顺序的名目数据)</p><p><strong>连续数据</strong>:区间数据(等距数据)和等比数据(连续性的数据),区间数据没有自然0点,其0值点是人为规定的,等比数据有自然0点.<br>温度和时间为区间数据<br>大部分都是等比数据如身高、年龄等等</p><h2 id="布尔数组（可用来判断空值、满足条件个数、以及是否满足条件等）"><a href="#布尔数组（可用来判断空值、满足条件个数、以及是否满足条件等）" class="headerlink" title="布尔数组（可用来判断空值、满足条件个数、以及是否满足条件等）"></a>布尔数组（可用来判断空值、满足条件个数、以及是否满足条件等）</h2><p>bool_1.sum()   统计true值的个数  list(bool_1).count(True)也可以实现计数<br>bool_1.sum(1） 按列计算（不同其他）<br>bool_1.sum(0） 按行计算<br>bool_1.any()  判断是否有True<br>bool_1.all() 判断是否全是True<br>对于大混合数据（包含各种类型）需要使用dtype去声明为object类型否则会产生各种问题 如spirit_ar=np.array(daten1,dtype=object</p><p>对数据进行操作的时候尽量使用新变量和copy进行原数据的保护</p><h2 id="数据的删除"><a href="#数据的删除" class="headerlink" title="数据的删除"></a>数据的删除</h2><p>np.delete(a1,j,0)  a1表示待操作的数组，j表示待操作的行索引或者列索引，0代表对行操作，1代表对列操作</p><h4 id="多行-多列删除"><a href="#多行-多列删除" class="headerlink" title="多行\多列删除"></a><strong>多行\多列删除</strong></h4><p>np.delete(a1,[2,3,4,5,6]，0)    当使用遍历数据并且进行删除的时候需要倒着删否则因为索引变化导致删除数据出现错误<br>np.where(条件)  只有条件返回的为一个元组，两个数据分别存放着行和列数组<br>np.arange(1,9) = np.array(range(1,9))</p><h2 id="数组的排序"><a href="#数组的排序" class="headerlink" title="数组的排序"></a>数组的排序</h2><p>a1.sort()   默认按行排序===但是会破环数据结构<br>a1.sort(0)  按列进行排序（小到大，里面有参数可以改为从大到小排）<br>a1.sort(1)  按行进行排序<br>np.sort(a1,轴参数)  ==================与sort属性方法相比，函数是一次性排序而属性方法是永久排序，破环了原来的数据</p><h3 id="数组的拼接"><a href="#数组的拼接" class="headerlink" title="数组的拼接"></a>数组的拼接</h3><p>np.vstack((a1,a2))  垂直拼接，将数组按行拼接（列数必须相同）<br>np.hstack((a1,a2))  水平拼接，像数据按列拼接（行数必须相等）<br>np.column_stack(a1,a2)  水平拼接，数据按列拼接<br>注意：对于大数据都是分块读取的然后拼接而不是一下子读取全部</p><h3 id="数组的去重"><a href="#数组的去重" class="headerlink" title="数组的去重"></a>数组的去重</h3><p>删除重复行：np.unique(a1,axis=0)    0表示删除重复行，并对第一列进行排序<br>删除重复列：np.unique(a1,axis=1)    1表示删除重复列，并对第一行进行排序<br>（注意对于数据的删除操作对应的0，1不是常见的逐行按列和逐列按行）</p><p><strong>np.in1d()</strong>  一维数组的批量查询<br>np.in1d(a1,[查询目标1，查询目标2…..])======返回的为布尔数组，找到的对应为True,没找到的为False,对每一个数据比较,满足任意一个即为True<br>a1查询对象可以为列表，可以为数组（注意数据类型）也可以通过布尔值使用布尔值索引去找对应的数据</p><p><strong>数组当作集合操作</strong></p><p>np.intersect1d(a1,a2)  两个集合的交集  返回的为公共的数据<br>np.union1d(a1,a2) 集合的并集 【常用于一维数组】<br>np.setdiff1d(a1,a2)  a1对a2的差集<br>np.setxor1d(a1,a2)   交集的补集（并集去掉交集）</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy基本统计函数</title>
      <link href="/2019/05/31/numpy%E5%9F%BA%E6%9C%AC%E7%BB%9F%E8%AE%A1%E5%87%BD%E6%95%B0/"/>
      <url>/2019/05/31/numpy%E5%9F%BA%E6%9C%AC%E7%BB%9F%E8%AE%A1%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="基本统计概念"><a href="#基本统计概念" class="headerlink" title="基本统计概念"></a>基本统计概念</h2><h3 id="方差（var"><a href="#方差（var" class="headerlink" title="方差（var)"></a>方差（var)</h3><h5 id="理论公式"><a href="#理论公式" class="headerlink" title="理论公式:"></a>理论公式:</h5><p><img src="/2019/05/31/numpy基本统计函数/1.png" alt="1"></p><h5 id="总体方差"><a href="#总体方差" class="headerlink" title="总体方差"></a>总体方差</h5><p><img src="/2019/05/31/numpy基本统计函数/fd88164275e2a8dae94129482d71b7c46fc84927.svg" alt="d88164275e2a8dae94129482d71b7c46fc8492"></p><h5 id="样本方差"><a href="#样本方差" class="headerlink" title="样本方差"></a>样本方差</h5><p><img src="/2019/05/31/numpy基本统计函数/54782f27f6b9157389e2c57b627b3bcaf08c4b34.svg" alt="4782f27f6b9157389e2c57b627b3bcaf08c4b3"><br>样本方差是总体方差的无偏估计<br>样本方差的定义中，分母的值为n-1而非n，一个重要原因即是这样定义的样本方差是总体方差的无偏估计。这被称为贝塞尔修正。</p><h5 id="标准差-std"><a href="#标准差-std" class="headerlink" title="标准差(std)"></a>标准差(std)</h5><p>方差的算术平方根</p><p><img src="/2019/05/31/numpy基本统计函数/d439b6003af33a87111e5010c65c10385343b54d.png" alt="439b6003af33a87111e5010c65c10385343b54"></p><h5 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h5><p>每次出现的概率乘以结果的总和,公式在方差处</p><h2 id="基本统计函数"><a href="#基本统计函数" class="headerlink" title="基本统计函数"></a>基本统计函数</h2><p>Sum,mean,min,max,argmax,argmin,cumsum,cumprod等函数</p><h5 id="sum"><a href="#sum" class="headerlink" title="sum()"></a>sum()</h5><p>sum(a1) 默认按列求和<br>a1.sum()  np.sum(a1)  整个数组从头加到尾<br>a1.sum(1) np.sum(a1,1) 对每行求和<br>a1.sum(0) np.sum(a1,0) 每列求和</p><h5 id="mean"><a href="#mean" class="headerlink" title="mean()"></a>mean()</h5><p>没有mean(a1)用法<br>a1.mean() np.mean(a1) 从头到尾求均值<br>a1.mean(0)  np.mean(a1,0)按列求均值<br>a1.mean(1)  np.mean(a1,1) 按行求均值</p><h5 id="min"><a href="#min" class="headerlink" title="min()"></a>min()</h5><p>没有min(a1)用法 ====针对a1为数组<br>a1.min() np.min(a1)整个数组中的最小值<br>a1.min(0) np.min(a1,0) 每列中最小值<br>a1.min(1)  np.min(a1,1) 每行中最小值</p><h5 id="max"><a href="#max" class="headerlink" title="max()"></a>max()</h5><p>max(a1)用法 ====针对a1为数组<br>a1.max() np.max(a1)整个数组中的最小值<br>a1.max(0) np.max(a1,0) 每列中最小值<br>a1.max(1)  np.max(a1,1) 每行中最小值</p><h5 id="argmin-argmax"><a href="#argmin-argmax" class="headerlink" title="argmin(),argmax()"></a>argmin(),argmax()</h5><p>a1.ravel()可将数组伸展为一维数组与reshape相反<br>a1.argmin()  np.argmin(a1)  将数组伸展为一维,然后返回最小值所在的索引<br>等价于  np.where(a1.ravel()==np.min(a1))[0][0]<br>a1.argmax()  np.argmax(a1)  将数组伸展为一维,然后返回最大值所在的索引<br>等价于  np.where(a1.ravel()==np.max(a1))[0][0]<br>np.argmax(a1,0)  a1.argmax(0) 返回每列中最大值行索引np.argmin(a1,0)  a1.argmin(0)  返回每列中最小值行索引<br>np.argmax(a1,1) a1.argmax(1) 返回每行中最大值列索引<br>np.argmin(a1,1) a1.argmin(1)  返回每行中最小值列索引</p><h5 id="cumsum（所有元素的累积和）cumprod（所有元素的累积积）"><a href="#cumsum（所有元素的累积和）cumprod（所有元素的累积积）" class="headerlink" title="cumsum（所有元素的累积和）cumprod（所有元素的累积积）"></a>cumsum（所有元素的累积和）cumprod（所有元素的累积积）</h5><p>a1.cumsum()  返回一维数组,每个数据为前面数据的累加<br>a1.cumsum(0) np.cumsum(a1,0) 按列求累加和<br>a1.cumsum(1) np.cumsum(a1,1)按行求累加和<br>a1.cumprod(0)  np.cumprod(a1,0)按列求累积积<br>a1.cumprod(1)   np.cumprod(a1,1)按行求累积积</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>势图和数据的快速挑选</title>
      <link href="/2019/05/30/%E5%8A%BF%E5%9B%BE%E5%92%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E5%BF%AB%E9%80%9F%E6%8C%91%E9%80%89/"/>
      <url>/2019/05/30/%E5%8A%BF%E5%9B%BE%E5%92%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E5%BF%AB%E9%80%9F%E6%8C%91%E9%80%89/</url>
      
        <content type="html"><![CDATA[<h1 id="势图"><a href="#势图" class="headerlink" title="势图"></a>势图</h1><p>实例:<br><img src="/2019/05/30/势图和数据的快速挑选/图片2.png" alt="片"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(x, y)</span>:</span>    </span><br><span class="line"><span class="keyword">return</span> x*np.exp((-x**<span class="number">2</span>)-(y**<span class="number">2</span>))</span><br><span class="line"><span class="comment">#创建一个画布 0表示编号,dpi表示像素,figsize表示画布大小</span></span><br><span class="line">fig = plt.figure(<span class="number">0</span>,dpi=<span class="number">140</span>,figsize=(<span class="number">8</span>,<span class="number">8</span>)) </span><br><span class="line"><span class="comment">#linspace将区间等分为500份</span></span><br><span class="line">x = y = np.linspace(<span class="number">-2.0</span>, <span class="number">2.0</span>, <span class="number">500</span>)</span><br><span class="line"><span class="comment">#meshgrid网格化处理(笛卡尔乘积),没有的话会导致数据过少(只有经过原点角平分线上的点)</span></span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br><span class="line"><span class="comment">#形成z坐标(x,y,z)构成了立体图形,为一个漏斗图</span></span><br><span class="line">Z=fun(X,Y)</span><br><span class="line"><span class="comment">#创建一个画布形成两行两列的画框,像素150,figsize表示画布总大小被4个平分,画框形成的为数组通过索引获取</span></span><br><span class="line">fig,axes1=plt.subplots(<span class="number">2</span>,<span class="number">2</span>,dpi=<span class="number">150</span>,figsize=(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line"><span class="comment">#[0,0]表示第一行第一个画框</span></span><br><span class="line">axes1[<span class="number">0</span>,<span class="number">0</span>].imshow(Z)</span><br><span class="line">axes1[<span class="number">0</span>,<span class="number">1</span>].imshow(Z,cmap = plt.cm.gray)</span><br><span class="line">axes1[<span class="number">1</span>,<span class="number">0</span>].imshow(Z,cmap=plt.cm.cool)</span><br><span class="line">axes1[<span class="number">1</span>,<span class="number">1</span>].imshow(Z,cmap=plt.cm.hot)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p>势图主要由很多的等势线构成,形成的三维立体与平面相切,形成的圈投影到二维平面形成等势线,众多的等势线构成了势图</p><h1 id="np-where"><a href="#np-where" class="headerlink" title="np.where"></a>np.where</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">np.where(condition,[x,y])快速找到想要的数据 如果条件为真返回x,为假返回y,如果条件加了[]会导致形成的数组维度增加</span><br><span class="line">一.条件为单布尔值</span><br><span class="line">a=<span class="number">23</span></span><br><span class="line">np.where([type(a)==int],<span class="string">'整数'</span>,<span class="string">'小数'</span>)[<span class="number">0</span>]  返回的为数组通过索引取出来</span><br><span class="line">二.条件为布尔矩阵</span><br><span class="line">实例<span class="number">1</span>:</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">word_combination_games</span><span class="params">(positive_nr)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">    <span class="keyword">import</span> random</span><br><span class="line">    <span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">    list1=[<span class="string">'我'</span>,<span class="string">'你'</span>,<span class="string">'他'</span>,<span class="string">'她'</span>,<span class="string">'我们'</span>,<span class="string">'你们'</span>,<span class="string">'他们'</span>,<span class="string">'她们'</span>]</span><br><span class="line">    random.shuffle(list1)</span><br><span class="line">    list2=[<span class="string">'学习'</span>,<span class="string">'研究'</span>,<span class="string">'喜欢'</span>,<span class="string">'厌恶'</span>,<span class="string">'专研'</span>,<span class="string">'抛弃'</span>,<span class="string">'讨厌'</span>,<span class="string">'练习'</span>]</span><br><span class="line">    random.shuffle(list2)</span><br><span class="line">    list3=[<span class="string">'女人'</span>,<span class="string">'美酒'</span>,<span class="string">'香烟'</span>,<span class="string">'金钱'</span>,<span class="string">'Python'</span>,<span class="string">'豪车'</span>,<span class="string">'别墅'</span>,<span class="string">'奢侈品'</span>]</span><br><span class="line">    random.shuffle(list3)</span><br><span class="line">    <span class="comment">#创建信息列表并随机打乱</span></span><br><span class="line">inf_ar1=inf_ar=np.column_stack((np.column_stack((np.array(list1),np.array(list2))),np.array(list3)))<span class="comment">#把各列表信息以列的形式合并成二维数组</span></span><br><span class="line">    np.random.shuffle(inf_ar1)<span class="comment">#随机打乱合并后二维数组</span></span><br><span class="line">    random_ar=[[<span class="literal">True</span> <span class="keyword">if</span> np.random.rand()&gt;=<span class="number">0.5</span> <span class="keyword">else</span> <span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">8</span>)]</span><br><span class="line">     <span class="comment">#随机生成用作np.where条件的布尔矩阵。</span></span><br><span class="line">    a1=np.where(np.array(random_ar),inf_ar,inf_ar1)</span><br><span class="line">    <span class="comment">#print(a1)</span></span><br><span class="line">    <span class="keyword">if</span> positive_nr<span class="number">-1</span>&gt;<span class="number">7</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'数字太大，超出信息列表长度'</span></span><br><span class="line">    <span class="keyword">else</span>:   </span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y:x+y,a1[positive_nr<span class="number">-1</span>])</span><br><span class="line">实例<span class="number">2</span>:</span><br><span class="line">np.where([[<span class="literal">True</span>, <span class="literal">False</span>], [<span class="literal">True</span>, <span class="literal">True</span>]],[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]],[[<span class="number">9</span>, <span class="number">8</span>], [<span class="number">7</span>, <span class="number">6</span>]])</span><br><span class="line">Out[<span class="number">15</span>]: </span><br><span class="line">array([[<span class="number">1</span>, <span class="number">8</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">例<span class="number">3</span>:</span><br><span class="line">array([[<span class="number">17</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">       [<span class="number">17</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">16</span>],</span><br><span class="line">       [<span class="number">20</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">18</span>],</span><br><span class="line">       [<span class="number">15</span>, <span class="number">16</span>, <span class="number">19</span>, <span class="number">16</span>]])</span><br><span class="line">np.where(ar122&gt;<span class="number">17</span>) </span><br><span class="line">Out[<span class="number">20</span>]: (array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=int64), array([<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>], dtype=int64))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> numpy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>向量和矩阵的各种积</title>
      <link href="/2019/05/30/%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B5%E7%9A%84%E5%90%84%E7%A7%8D%E7%A7%AF/"/>
      <url>/2019/05/30/%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B5%E7%9A%84%E5%90%84%E7%A7%8D%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="內积-内乘"><a href="#內积-内乘" class="headerlink" title="內积(内乘)"></a>內积(内乘)</h2><p>内乘（interior product，或译内积）是光滑流形上的微分形式外代数上一个次数为 −1 导子，定义为微分形式与一个向量场的缩并。</p><h2 id="外积"><a href="#外积" class="headerlink" title="外积"></a>外积</h2><p>外积（英语：Outer product），在线性代数中一般指两个向量的张量积，其结果为一矩阵；与外积相对，两向量的内积结果为标量.外积可视作是矩阵的克罗内克积的一种特例,向量的外积是矩阵的克罗内克积的特殊情况</p><h2 id="点积-点乘"><a href="#点积-点乘" class="headerlink" title="点积(点乘)"></a>点积(点乘)</h2><p>点积的名称源自表示点乘运算的点号，标量积的叫法则是在强调其运算结果为标量而非向量。向量的另一种乘法是叉乘（a×b），其结果为向量，称为叉积或向量积。点积是<strong>内积</strong>的一种特殊形式</p><h2 id="叉积-叉乘"><a href="#叉积-叉乘" class="headerlink" title="叉积(叉乘)"></a>叉积(叉乘)</h2><p>叉积（英语：Cross product）又称向量积（英语：Vector product），是对三维空间中的两个向量的二元运算，使用符号 axb。与点积不同，它的运算结果是向量</p><h2 id="针对向量"><a href="#针对向量" class="headerlink" title="针对向量"></a>针对向量</h2><p><strong>向量叉积(叉乘)</strong>:</p><p><img src="/2019/05/30/向量和矩阵的各种积/8435e5dde71190efeb164f46cb1b9d16fcfa60be.png" alt="435e5dde71190efeb164f46cb1b9d16fcfa60b"></p><p><strong>向量点积(点乘):</strong></p><p><img src="/2019/05/30/向量和矩阵的各种积/d7de7b9aa6a9bbc6f6435c24173c0597464c8420.svg" alt="7de7b9aa6a9bbc6f6435c24173c0597464c842"></p><p><img src="/2019/05/30/向量和矩阵的各种积/cc5bdd19a0812e351fb5bd137bc5851a53a6e04d.svg" alt="c5bdd19a0812e351fb5bd137bc5851a53a6e04"></p><h3 id="针对矩阵"><a href="#针对矩阵" class="headerlink" title="针对矩阵"></a>针对矩阵</h3><p><strong>矩阵乘积</strong>:A为 mxn矩阵，B为nxp矩阵，则他们的乘积AB(有时记做A · B）会是一个 mxp矩阵.(通过行向量和列向量的內积实现)</p><p><img src="/2019/05/30/向量和矩阵的各种积/a88a3a575025f8be866be951df7c18d614ebb14d.svg" alt="88a3a575025f8be866be951df7c18d614ebb14"></p><p><strong>阿达马乘积</strong>:或称做分素乘积AoB。两个m×n矩阵A、B的阿达马乘积标记为 AoB</p><p><img src="/2019/05/30/向量和矩阵的各种积/1f01749e2c7188ed1e9116b599d7463fc05efc76.svg" alt="f01749e2c7188ed1e9116b599d7463fc05efc7"></p><p><strong>矩阵外积</strong>:(克罗内克乘积)</p><p>两个矩阵 A和B，我们可以得到两个矩阵的直积，或称为克罗内克乘积 </p><p><img src="/2019/05/30/向量和矩阵的各种积/81e72b94c6379860d10c1995bf8f6ee61d577d77.svg" alt="1e72b94c6379860d10c1995bf8f6ee61d577d7"></p><p><strong>矩阵內积</strong>: 矩阵具有弗罗比尼乌斯内积，可以类比于向量的内积</p><p><img src="/2019/05/30/向量和矩阵的各种积/8b49c10f54ebdeab1153dd6e81ce4d1d2999c451.svg" alt="b49c10f54ebdeab1153dd6e81ce4d1d2999c45"></p><p>要求:AB矩阵必须具有相同的外形,因为求trace迹(方阵对角线之和)的时候必须为方阵</p><p><strong>矩阵点积</strong>: matlab中表现为对应位数的相乘,要求矩阵外形一样</p><p><strong>矩阵叉积</strong>: matlab中表现为矩阵的行列相乘,等同于矩阵的乘积</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy</title>
      <link href="/2019/05/28/numpy/"/>
      <url>/2019/05/28/numpy/</url>
      
        <content type="html"><![CDATA[<h1 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h1><p>概念<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numPy(Numerical Python) 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库</span><br></pre></td></tr></table></figure></p><p>###手动创建数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#anaconada自带print一般不要写某些地方要写</span><br><span class="line">import numpy as np</span><br><span class="line">创建几维数组就是嵌套几层(手动创建除了列表元组同样可以创建)除了array\asarray同样可以创建效果一样</span><br><span class="line">创建一维数组</span><br><span class="line">np.array([0.243,0.246,0.32,0.345,0.231])#可以用创建一维数组</span><br><span class="line">创建二维数组</span><br><span class="line">np.array([[1,2,3],[2,3,4]])</span><br><span class="line">创建三维数组</span><br><span class="line">np.array([[[1,2,3],[3,4,5]],[[2,3,4],[4,5,6]]])</span><br></pre></td></tr></table></figure></p><p>###基本指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">创建一个一维数组并且设置数据类型为浮点型</span><br><span class="line">a1 = np.array([1,2,3],dtype=np.float64)</span><br><span class="line">查看数组内数据类型</span><br><span class="line">a1.dtype  </span><br><span class="line">查看数组的数据类型</span><br><span class="line">type(a1)    ndarray格式</span><br><span class="line">数组内数据的加减乘除取商取余</span><br><span class="line">a1*2\a1+2\a1*a1\a1**2等等都是对应的数据相乘相加等</span><br><span class="line">数据类型修改</span><br><span class="line">一方面在定义的时候直接定义数据类型</span><br><span class="line">宁一方面在定以后直接强制修改</span><br><span class="line">a1.astype(np.int32)</span><br><span class="line">查看数组的外形</span><br><span class="line">a1.shape  </span><br><span class="line">一维数组:返回的是元素的个数如(4,)表示元素的个数为4个 效果等同于函数len()</span><br><span class="line">二维数组:返回的为数组的行数和列数(2,3) 2代表行数3代表列数</span><br><span class="line">三维数组:返回的是各个维度的个数(3,2,3) 表示三维数组含有3个二维数组,每个二维数组含有2行3列</span><br><span class="line">同理四维数组(2,5,2,10)#2个三维数组,每个三维数组含有5个二维数组,每个二维数组2行10列</span><br><span class="line">返回一个内存对象</span><br><span class="line">a1.data ====可以通过tolist转换为列表格式a1.data.tolist</span><br></pre></td></tr></table></figure></p><p>###创建特殊数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">创建零数组</span><br><span class="line">np.zeros((5,5))#输入行数和列数=====5行5列0数组</span><br><span class="line">np.zeros_like(a1) 表示生成的零数组的行数列数同数组a1一样</span><br><span class="line">创建全为1数组</span><br><span class="line">np.ones((3,4))创建一个3行4列的数据</span><br><span class="line">np.ones_like(a1) 创建一个数组行数和列数同a1一样</span><br><span class="line">创建单位数组</span><br><span class="line">np.identity(6) 创建一个6行6列的单位矩阵(对角线全为1)</span><br><span class="line">创建空数组</span><br><span class="line">np.empty((5,5)) 创建一个5行5列的空数组(会自动填值====占位)</span><br></pre></td></tr></table></figure></p><p>###自己动生成数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">np.random.randint(1,100,(10,3)) 表示生成一个10行3列的矩阵,矩阵内的数据为1到100间的随机数</span><br><span class="line">np.random.randint(1,100,10) 表示1到100件随机生成10个数可以通过reshape转换为数组格式</span><br><span class="line">np.random.random(6) 表示随机生成6个0到1之间的小数</span><br><span class="line">np.random.random((3,3)) 表示生成一个3行3列的数组,数据为0到1间的随机数</span><br><span class="line">np.random.normal(4,1.2,(3,5)) 服从高斯分布(正态分布) 4表示</span><br><span class="line">loc,1.2表示scale范围,(3,5)表示3行5列的矩阵</span><br><span class="line">np.arange(1,13).reshape(3,4)  arange先生成12个数然后在转化为3行4列的数组(记住数据要对齐)</span><br></pre></td></tr></table></figure></p><p>###数组的索引和切片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">一维数组的索引和切片</span><br><span class="line">一维数组的索引和切片同列表的索引和切片一样,存在开始、结束和步长</span><br><span class="line">test_array_1[5]   test_array_1[1:5]  test_array_1[-1:5:-1] test_array_1[::-1]</span><br><span class="line">一维数组选区的赋值：</span><br><span class="line">第一种：通过列表赋值  test_array_1[1:5]=[-1,-2,-3,-1]</span><br><span class="line">第二种：选区单元赋值  test_array_1[-1:3:-1]=0  全部赋为某个值</span><br><span class="line">第三种：通过数组赋值  test_array_1[2:6]=np.array([0,3,6,7])</span><br><span class="line">第四种：通过元组对选区进行赋值 test_array_1[-6::-1]=(2,6,8,0,1) 或者直接去掉括号</span><br><span class="line">【注意：列表切片赋值原列表不变而数组切片赋值原数组会发生变化 </span><br><span class="line">b = a1[2:5]  b[:] = [33,45,34]====原数组会发生变化，注意[:]不能少，若加上.copy()深复制就不会改变原数组,.view()为浅复制,公用一套值.数组中切片使用时一般都要加上copy保护原数组】</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">二维数组的切片和索引</span><br><span class="line">array_12[0]  表示取数组的0索引对应的行</span><br><span class="line">array_12[:2] 选取0行和1行</span><br><span class="line">array_12[1,2] 取索引为1那行列索引为2的数据 arry1[行索引,列索引]</span><br><span class="line">array_12[1][2] 也表示取某个数据</span><br><span class="line">ary1[:,1] 取全部行的列索引为1的数据</span><br><span class="line">二维数组的选区和赋值(首选列表和元组,数组次之)</span><br><span class="line">arr123[1:3,1:3]=[[-2,-4],[-8,-1]] 注意这里必须是嵌套列表</span><br><span class="line">arr123[1:3,1:3]=((0,0),(-1,-1))</span><br><span class="line">arr123[1:3,1:3]=np.array([[-2,-2],[-8,-8]])</span><br><span class="line">arr123[1:3,1:3]=0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">三维数组的索引和切片</span><br><span class="line">a[2][3,2] 或者 a[2,3,2]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">布尔值数组索引(可以选取任意行任意列)</span><br><span class="line">一维布尔值数组索引</span><br><span class="line">bool_matrix_col=np.array([True,True,False,True,False])</span><br><span class="line">rm_1[bool_matrix_row]   只返回数组中对应True的那一行</span><br><span class="line">rm_1[bool_matrix_row,2:] 返回True那一行并且对列进行限定</span><br><span class="line">rm_1[:,bool_matrix_row]  返回所有行,只返回对应True的那些列</span><br><span class="line">二维布尔值数组索引</span><br><span class="line">(array_231&lt;=7)&amp;(array_231&gt;=2) 返回数组的布尔值,符合条件的数据为True,否则为false(与符号:&amp; 或符号:| )</span><br><span class="line">array_231[(array_231&lt;=7)&amp;(array_231&gt;=2)]=0 将所有符合条件的选出来并且全部赋值为指定数据</span><br><span class="line">array_231[(array_231&lt;=7)] 会将所有符合条件的数据取出按照一维数组格式</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">花式索引</span><br><span class="line">第一种：</span><br><span class="line">ast[[0,5,15,17,19,3]]  选取中括号内的行，并且按照0-5-15-17-19-3的顺序排列</span><br><span class="line">第二种</span><br><span class="line">ar_32[[1,3,0],[2,1,2]] 返回三个数据分别为行索引为1列索引为2的数据,行索引为3列索引为1数据,行索引为0列索引为2的数据</span><br><span class="line">第三种</span><br><span class="line">oparray_1[[1,3,5,7]][:,[0,2,3,1]]  先取数组的1,3,5,7行形成新的数组,然后取所有行,以及对应的列,列的顺序按照给定的格式0,2,3,1顺序排</span><br><span class="line">亦可以用一个函数写ix_</span><br><span class="line">oparray_1[np.ix_([1,3,5,7],[0,2,3,1])] 效果一样</span><br><span class="line">第四种</span><br><span class="line">oparray_1[:,[0,2,3,1]]  取所有行以及按照对应顺序的列</span><br></pre></td></tr></table></figure><p>###数组的转置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">实质:数组或者矩阵的转置实质就是行列转换</span><br><span class="line">二维数组的转置</span><br><span class="line">ar12.T</span><br><span class="line">高维数组的转置(3维以及以上)当然二维也可以用transpose</span><br><span class="line">arr2 = arr1.transpose((1,0,2))  0,1,2表示维度三个表示三维,默认0,1,2(叫做轴构成对应维度空间的基础)顺序,形成的新的会按照轴的顺序进行排列</span><br><span class="line">注意:可以根据轴的顺序判断数据的变化以及位置,同时也可以根据数据的变化规律推导出轴顺序.</span><br></pre></td></tr></table></figure></p><p>###数组的函数计算(注意与矢量化计算的区别)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">常用的得一元函数</span><br><span class="line">np.sqrt(arr)  对数组的每一个数据都开方</span><br><span class="line">np.exp(arr)  以e为底对应的幂指数</span><br><span class="line">np.abs(arr)  数组中每个数据的绝对值</span><br><span class="line">np.floor(ar_12) 向下取整(小的)注意复数取整向小的而不是向近的</span><br><span class="line">np.ceil(ar_12)  向下取整</span><br><span class="line">np.sign(ar_12) 返回数组中每个数据的符号(1和-1表示)</span><br><span class="line">常用的二元函数</span><br><span class="line">np.maximum(ar_13,ar_14) 两个矩阵比较形成的新矩阵数据为两个矩阵中各自为数中大的值</span><br><span class="line">add,subtract,multiply,divide函数  加减乘除</span><br><span class="line">np.power(ar_13,ar_14) ar_13是底，ar_14是幂 ,ar_14除了是数组也可以是一个实数</span><br></pre></td></tr></table></figure></p><p>小知识：Python的八大基本数据类型<br>1.Number（数字）<br>2.String（字符串）<br>3.List（列表）<br>4.Tuple（元组）<br>5.Sets（集合）<br>6.Dictionary（字典）<br>7.None（空类型）<br>8.Object（对象类型）</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据分析高级基础概念</title>
      <link href="/2019/05/27/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E9%AB%98%E7%BA%A7%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/05/27/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E9%AB%98%E7%BA%A7%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="数据分析的步骤"><a href="#数据分析的步骤" class="headerlink" title="数据分析的步骤"></a>数据分析的步骤</h3><h4 id="1-明确分析目的"><a href="#1-明确分析目的" class="headerlink" title="1.明确分析目的"></a>1.明确分析目的</h4><p>分析的目的可分为三类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对现状进行描述性分析，给决策者提供未来发展方向的依据</span><br><span class="line">原因分析，弄清造成某种结果的原因</span><br><span class="line">为事物将来的发展趋势做出预测</span><br></pre></td></tr></table></figure></p><p>通常在明确分析目的后，还有一个十分重要的环节，尽管它没有出现在分析流程图中，然而却异常重要。即数据分析详细流程图，它通常是“数据分析一般步骤”中“数据处理”和“数据分析”这两个步骤的详细操作和分析流程。</p><h4 id="2-数据采集"><a href="#2-数据采集" class="headerlink" title="2.数据采集"></a>2.数据采集</h4><p>数据采集方法多种多样，这里简要的说几种：公司内部数据、互联网爬取、报刊书籍、问卷调查、购买数据等等目前来看，整个的数据采集方式发展趋于网络采集。</p><h4 id="3-数据处理"><a href="#3-数据处理" class="headerlink" title="3.数据处理"></a>3.数据处理</h4><p>数据处理常用的方法有三种：数据清洗，数据加工，数据计算</p><h4 id="4-数据分析"><a href="#4-数据分析" class="headerlink" title="4.数据分析"></a>4.数据分析</h4><p>数据分析方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">分类：</span><br><span class="line">通常我们按照分析的目的或者按照分析的作用进行分类：</span><br><span class="line">现状分析:对比、平均、综合评定（常用）……</span><br><span class="line">原因分析:分组、结构、交叉、杜邦分析、漏斗图、聚类……</span><br><span class="line">预测分析:回归、判别式分析、神经网络、决策树……</span><br></pre></td></tr></table></figure></p><h5 id="比较分析法"><a href="#比较分析法" class="headerlink" title="比较分析法"></a>比较分析法</h5><p>分类：静态与动态比较静态比较：同一时间，相同指标在不同总体间的比较，也叫横向比较，简称横比</p><p>动态比较：同一总体，相同指标在不同时期间的比较。也叫纵向比较，简称纵比</p><h5 id="分组分析法"><a href="#分组分析法" class="headerlink" title="分组分析法"></a>分组分析法</h5><p>定义：</p><p>根据数据特征，按照一定的指标，把数据划分为不同的群组进行研究，以求揭示各群组间的内在联系和规律。</p><p>分组时必须遵循两个原则：穷尽原则和互斥原则。穷尽原则：总体中的每一个单位都应有组可归，或者说各分组的空间足以容纳总体所有的单位。互斥原则：在分组指标的限制下，总体中的任何一个单位只能归属与某一个组，而不能同时或可能归属与几个组。</p><p>重要的分组参数：</p><p>组限：各分组间的分界处被称为组限，一个组的最大值称为组上限，一个组的最小值称为组下限。</p><p>组距：组上限与组下限的差叫组距</p><p>组数：分组个数</p><p>分组的步骤：</p><ol><li>组数确定这个完全依赖于数据分析师自己的经验了。有经验的数据分析师会根据数据本身特点给数据划分合理组数。<br> . 确定组距一组数据中的最大值与最小值的差除以组数。即：               （最大值-最小值）/组数</li><li>根据组距划分数据，使其各就各位。</li></ol><h5 id="结构分析法"><a href="#结构分析法" class="headerlink" title="结构分析法"></a>结构分析法</h5><p>被分析总体内的各部分与总体进行对比的分析方法，即部分数量除以总体数量，换句话说，部分占总体的比例，属于相对指标</p><h5 id="平均分析法"><a href="#平均分析法" class="headerlink" title="平均分析法"></a>平均分析法</h5><p>通过计算平均数来反映总体在一定时间、地点条件下某一数量特征的一般水平。但由于其忽略了个体间可能存在的巨大差异，有时候并不一定反映出某一指标的一般水平。因此，很多时候平均分析法是不可取的。</p><h5 id="交叉分析法"><a href="#交叉分析法" class="headerlink" title="交叉分析法"></a>交叉分析法</h5><p>交叉分析法又称立体分析法，是在纵向分析法和横向分析法的基础上，从交叉、立体的角度出发，由浅入深、由低级到高级的一种分析方法</p><h5 id="综合评价法"><a href="#综合评价法" class="headerlink" title="综合评价法"></a>综合评价法</h5><p>随着数据分析的广泛和深入的使用，我们遇到的问题越来越复杂，单靠对单一指标的分析越来越不能解决多指标问题。</p><p>人们通过实践总结，逐步形成了一系列运用多个指标对多个参评单位进行评价的方法，称之为综合评价法。综合评价法的本质是把多指标转化为一个能够反映综合情况的量（比如评分，通常不再是统计指标）来进行分析</p><p>步骤：</p><ol><li>确定综合评价指标体系，即用哪些指标来评价一个对象。</li><li>收集数据，若有必要，进行标准化处理，比如归一化，以求消除量纲。</li><li>确定指标体系中各指标权重，以保证评价的科学性与公平性。</li><li>对各个指标的评价数值进行汇总计算，得出综合评价分值。</li><li>凭借分值排名并得出结论。</li></ol><p>综合评价法的注意事项：</p><ol><li>综合指标体系里面的各个指标不是让我们一个接个去评定，而是要同时完成。这种要求是为了消除互为相关的指标带来的错误评价结果</li></ol><ol start="2"><li>重要指标不要忘记加权。</li><li>结果不再是统计指标，仅仅是对评价对象的评分或排名。</li><li>对各指标下的数据要根据实际情况采取数据标准化。</li></ol><p>归一化：</p><p>作用1：消除量纲，在多指标评价体系中，由于各评价指标的性质不同，通常具有不同的量纲和数量级。当各指标间的水平相差很大时，如果直接用原始指标值进行分析，就会突出数值较高的指标在综合分析中的作用，相对削弱数值水平较低指标的作用。因此，为了保证结果的可靠性，需要对原始指标数据进行标准化处理。</p><p>作用2：提升模型的收敛速度狭长的标量场经过标准化后变得比较圆，这样会大大提升计算的收敛速度。</p><p>权重: </p><p>1.要确定权重，首先要确定指标体系，这也就是综合评价的第一个步骤</p><p>2.通过以上指标体系收集数据，数据的收集是通过多个人力资源的专家填写下面表格实现的。</p><p>3.建立目标优化矩阵，进行权重确定</p><p>4.通过加权平均对表格进行综合计算</p><h5 id="杜邦分析法"><a href="#杜邦分析法" class="headerlink" title="杜邦分析法"></a>杜邦分析法</h5><p>金字塔结构层层分析法，各层存在明确的因果关系，更多时候是严格的函数关系。</p><h5 id="漏斗图分析法"><a href="#漏斗图分析法" class="headerlink" title="漏斗图分析法"></a>漏斗图分析法</h5><p>漏斗图适用于业务流程比较规范、周期长、环节多的流程分析，通过漏斗各环节业务数据的比较，能够直观地发现和说明问题所在</p><h4 id="几个常见的统计学概念"><a href="#几个常见的统计学概念" class="headerlink" title="几个常见的统计学概念"></a>几个常见的统计学概念</h4><p>相对数与绝对数:</p><p>绝对数描述客观事物总体在一定时间和地点条件下的总规模，总水平的指标。相对数是指两个相关事物的比值</p><p>百分数和百分点:</p><p>百分数表示个体占总体的程度。百分点表示相同事物不同时期的增幅。</p><p>频数频率：</p><p>频数是绝对数，频率是相对数。频数指某种事物或现象在其所在总体出里出现的次数,频率,个体出现的总次数与总体出现的总次数的比值</p><p>比例和比率:</p><p>比例是个体数值在总体数值中的占比 </p><p>比率是总体中各个体数值之间的对比</p><p>倍数与番数：</p><p>倍数是一个数除以另一个数所得的商。比如3是1.5的二倍</p><p>番数指的是某种事物总数的二的n次方倍</p><p>同比与环比：</p><p>同比是指与历史同时期进行比较得到的数值</p><p>环比是指与前一个统计期比较所得到的数值</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scrapy</title>
      <link href="/2019/05/24/scrapy/"/>
      <url>/2019/05/24/scrapy/</url>
      
        <content type="html"><![CDATA[<h1 id="scrapy"><a href="#scrapy" class="headerlink" title="scrapy"></a>scrapy</h1><p>创建一个scrapy工程   scrapy startproject  工程名</p><p>生成一个爬虫程序   scrapy   genspider  爬虫名  爬虫域名</p><p>执行爬虫   scrapy  crawl  爬虫名</p><p>scrapy 调试平台  scrapy  shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Windows 装 scrapy</span><br><span class="line">一.pycharm直接装,装不了用第二种</span><br><span class="line">二. 1&gt;pip install wheel</span><br><span class="line">    2&gt;pip install pywin32路径</span><br><span class="line">    3&gt;pip install Twisted路径</span><br><span class="line">    4&gt;pip install scrapy</span><br><span class="line">linux 和 macOS 安装 pip install scrapy</span><br></pre></td></tr></table></figure></p><h3 id="scrapy-架构图"><a href="#scrapy-架构图" class="headerlink" title="scrapy 架构图"></a>scrapy 架构图</h3><p><img src="/2019/05/24/scrapy/767eb02dff6d06533a17cc1e85e0727c.png" alt="67eb02dff6d06533a17cc1e85e0727"></p><p>散点知识:<br>schedular封装的Request包含url和方法,默认方法为parse,具体写的通过callback调用,通过yield返回给schedular<br>parse包含参数self和response<br>response只有body和text,没有content<br>使用xpath匹配直接response.xpath(‘  ‘)<br>选择器通过extract()获取data里面的数据,形成一个列表,若只有一个通过extract()[0]或者extract_first()<br>scrapy拼接url: response.urljoin(‘不完善的url’) 不同于urllib无需基础的url<br>scrapy框架中的item和pipline,item是一种简单的容器,保存了爬取到的数据(类似于字典)   pipline:主要是对收到的item进行处理[实现存储\清洗….]<br>yield 返回item则将item里面的数据传给piplines进行后续处理 ,返回request则给schedular处理(封装了request和url)<br>scrapy在response中间传递数据主要用到response.meta,存储的位置叫response.meta(存储的形式为字典的格式) yield 过后就会传递过去<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">response.meta[&apos;chapter&apos;] = 1</span><br><span class="line">req = scrapy.Request(url=next_page, callback=self.parse)</span><br><span class="line">req.meta[&apos;chapter&apos;] = response.meta[&apos;chapter&apos;]</span><br><span class="line">yield req</span><br></pre></td></tr></table></figure></p><h3 id="scrapy-数据流"><a href="#scrapy-数据流" class="headerlink" title="scrapy 数据流"></a>scrapy 数据流</h3><ol><li>start_urls 或 start_requests, 通过上面两个内容可以生成 Request(url 函数),<br>这些 Request 被发送到 Engine 中.</li><li>Engine 会将 Request 放入 Scheduler 保存, 等待下载器空闲</li><li>在下载器空闲的时候, Engine 会从 Scheduler 中获取 Request, 传递给 Downloader</li><li>传递 Request 到 Downloader 的过程中, 会经过 Downloader Middleware(process_request)</li><li>执行下载后, 会生成 Response, 返回给 Engine, 过程中会经过 Downloader Middleware<br>(process_response)</li><li>Engine 会将获取到的 Response 返回给 Spiders, 这之中会经过 Spider Middleware<br>(process_spider_input)</li><li>Spiders 会将 Response 获取具体的信息, 生成新的 Request 或者是 Item,<br>Spiders 会将 Request/Item, 返回给 Engine. 这之中会经过 Spider Middleware<br>(process_spider_output)</li><li>Engine 会判断 Request 或者是 Item, 如果内容是 Request, 存储到 Scheduler 中,<br>如果是 Item, 发送到 Item Pipeline 中继续处理</li><li>循环第三步</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程进程协程</title>
      <link href="/2019/05/24/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B/"/>
      <url>/2019/05/24/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">进程: 进程是资源分配和调度单位 </span><br><span class="line">线程: 线程是执行的单位</span><br><span class="line">进程池: 当我们的任务非常多时,按照以前的方法,需要创建很多的进程,进程创建过多会发生很多问题,系统会因为频繁切换进程,导致性能下降,进程池能够限制进程生成数量</span><br><span class="line">线程的三种基本状态:阻塞,执行,就绪</span><br><span class="line">进程的五种基本状态:派生,阻塞,激活,调度,结束</span><br><span class="line">    多线程的存在并不是为了提高运行速度,而是为了提高程序的使用率.(同一个进程如果执行路径多,更容易抢到CPU的执行权)</span><br><span class="line">僵尸进程:当进程退出父进程没有读取到子进程退出的返回代码就会产生僵尸进程==&gt;父进程的问题,杀死了,僵尸会变孤儿</span><br><span class="line">孤儿进程:一个父进程退出,而他的一个或多个子进程还在运行,这些子进程称为孤儿进程(会被init进程收养)</span><br><span class="line">僵尸进程与孤儿进程的区别:</span><br><span class="line">    孤儿进程是子进程还在运行,而父进程挂了,子进程被init进程收养,僵尸进程是父进程还在运行但是子进程挂了,但是父进程没有清理子进程的进程信息,导致资源浪费,而孤儿不会</span><br><span class="line">    </span><br><span class="line">进程间通信:</span><br><span class="line">    queue</span><br><span class="line">    半双工\全双工(pipe)</span><br><span class="line">    共享内存</span><br><span class="line">    manager().dict()等 </span><br><span class="line">    </span><br><span class="line">多进程(multiprocessing)\多线程(threading)\协程(asyncio)</span><br><span class="line">多线程是交替执行的,一次只有一个线程执行.当某个线程进入等待(io操作),则执行其他线程(相当于一个进程,用到cpu就执行这个任务,当这个任务用不到cpu就切换其他任务)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">并发和并行</span><br><span class="line">并行:</span><br><span class="line">    并行指同一时刻发生的两个或多个事件</span><br><span class="line">    并行是在不同实体上的多个事件</span><br><span class="line">并发:</span><br><span class="line">    并发性是指同一时间间隔内发生两个或多个事件</span><br><span class="line">    并发是在同一实体上的多个事件</span><br><span class="line">因此并行针对进程,并发针对线程</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">线程和进程的的关系:</span><br><span class="line"><span class="number">1.</span>进程内部包含所有的程序需要执行的资源</span><br><span class="line"><span class="number">2.</span>线程几乎不包括任何资源信息</span><br><span class="line"><span class="number">3.</span>线程是cpu执行的最小单位</span><br><span class="line"><span class="number">4.</span>进程中最少有一个线程(进程是包含进程的,可以有多个线程)</span><br><span class="line">推论:</span><br><span class="line"><span class="number">1.</span>进程和进程的资源是不共享的</span><br><span class="line"><span class="number">2.</span>同一进程的线程之间资源是共享的</span><br><span class="line"><span class="number">3.</span>多进程的程序挂掉一个,其他进程不会受影响</span><br><span class="line"><span class="number">4.</span>同一个进程内的多个线程,如果进程挂了,则线程都不存在了</span><br><span class="line">对编程的推论:</span><br><span class="line"><span class="number">1.</span>如果两个任务之间不共享任何资源(很少),最好用多进程</span><br><span class="line"><span class="number">2.</span>如果两个任务共享资源较多,最好用多进程</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">进程和线程创建步骤</span><br><span class="line"><span class="number">1.</span>新建进程\线程类</span><br><span class="line"><span class="number">2.</span>启动线程进程</span><br><span class="line"><span class="number">3.</span>等待进程\线程</span><br><span class="line">多进程:</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line">P1 = Process(target = 函数名,args = (参数))</span><br><span class="line">P1.start()</span><br><span class="line">P1.join()</span><br><span class="line">多线程:</span><br><span class="line"><span class="keyword">from</span> Threading <span class="keyword">import</span> thread</span><br><span class="line">P1 = Thread(target= , args(,))</span><br><span class="line">P1.start()</span><br><span class="line">P1.join()</span><br><span class="line">进程池的代码步骤:</span><br><span class="line"><span class="number">1.</span>创建进程池的类</span><br><span class="line"><span class="number">2.</span>将任务放进进程池</span><br><span class="line"><span class="number">3.</span>关闭进程池等待进程结束</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'你好啊&#123;&#125;'</span>.format(name))</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">'我很好呢!!'</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#创建进程池,参数表示最大支持的进程数量</span></span><br><span class="line">    pool = Pool(<span class="number">3</span>)</span><br><span class="line">    <span class="comment">#任务放入进程池</span></span><br><span class="line">    name_list = [<span class="string">'你'</span>,<span class="string">'我'</span>,<span class="string">'他'</span>]</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> name_list:</span><br><span class="line">        pool.apply_async(func=hello,args=(name,))</span><br><span class="line">    <span class="comment">#关闭进程池并等待进程池结束</span></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">协程的用处:</span><br><span class="line"><span class="number">1.</span>线程尽可能多的占用cpu</span><br><span class="line"><span class="number">2.</span>减少cpu切换线程,提高cpu的使用效果</span><br><span class="line">协程代码:</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line">g1 = gevent.spawn(函数名,参数)</span><br><span class="line">gevent.joinall([g1,g2,g3])</span><br><span class="line">猴子补丁:<span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line">monkey.patch_all()</span><br><span class="line">猴子补丁的作用:将time.sleep()变成gevent.sleep()从而使效果更直观,除此之外还有很多其他效果</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">多进程若共享资源需要导包:   </span><br><span class="line">    </span><br><span class="line">    原理:队列,需要取出以后再放入</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager</span><br><span class="line">queue = Manager.Queue()</span><br><span class="line">queue只有get和put两种操作</span><br><span class="line">eg:(queue,url) = queue.get(timeout=<span class="number">5</span>)</span><br><span class="line">queue.put((func,url))</span><br><span class="line">多进程添加代理需要注意的问题:</span><br><span class="line"><span class="number">1</span>&gt;共享资源问题</span><br><span class="line"><span class="number">2</span>&gt;更新问题,针对response的status的处理</span><br><span class="line"><span class="number">3</span>&gt;会添加代理</span><br><span class="line"><span class="number">4</span>&gt;会创建获取proxy和更新proxy的类</span><br><span class="line">pipe管道</span><br><span class="line">conn1,conn2 = Pipe() <span class="comment">#生成管道的两边,分别传给两个进程,一个是管道这头,一个是管道宁一端</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Pipe</span><br><span class="line"><span class="comment"># 导入进程，管道模块</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(conn)</span>:</span></span><br><span class="line">    conn.send([<span class="number">1</span>,<span class="string">'test'</span>,<span class="literal">None</span>])</span><br><span class="line">    conn.send([<span class="number">2</span>,<span class="string">'test'</span>,<span class="literal">None</span>])</span><br><span class="line">    print(conn.recv())</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    parent_conn,child_conn = Pipe(<span class="literal">True</span>) <span class="comment">#产生两个返回对象，一个是管道这一头，一个是另一头,True为全双工,False为半双工(第一个对象只能接收,第二个只能发送)</span></span><br><span class="line">    p = Process(target=f,args=(child_conn,))</span><br><span class="line">    p.start()</span><br><span class="line">    print(parent_conn.recv())</span><br><span class="line">    print(parent_conn.recv())</span><br><span class="line">    parent_conn.send(<span class="string">'father test'</span>)</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><p>1、如果是windows系统， multiprocessing.Process需在if <strong>name</strong> ==  ‘<strong>main</strong>‘:下使用</p><p>2、args后面的参数必须是tuple类型，在这里可以认为是为整数参数20000000添加了小括号和逗号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">并发和并行:(通俗的解释并行指的是多个事件同时进行,并发指的是两个或多个事件在同一时间间隔发生)</span><br><span class="line">(一)多线程程序在一个核CPU上的运行,就是并发</span><br><span class="line">(二)多线程程序在多个核的CPU上运行,就是并行</span><br><span class="line"></span><br><span class="line">并发在任意时刻只有一个在工作,并行是都在工作</span><br><span class="line">协程:独立的栈空间,共享堆空间,调度由用户自己控制,本质上有点类型于用户级线程,这些用户级线程的调度也是自己实现的.</span><br><span class="line">线程:一个线程可以跑多个协程,协程是轻量级线程</span><br></pre></td></tr></table></figure><p>多线程和多进程的使用场景</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">io操作不占用cpu(从硬盘,网络,内存读取数据都算io)</span><br><span class="line">计算占用cpu(如1+1计算)</span><br><span class="line">Python中的线程是假线程,不同线程之间的切换是需要消耗资源的,因为需要存储线程的上线文,不断的切换就会消耗资源.</span><br><span class="line">Python多线程适合io操作密集型的任务(如socket server网络并发这一类的)</span><br><span class="line">python多线程不适合cpu密集操作型的任务,主要使用cpu来计算,如大量的数学计算,CPU密集型的任务可以使用多进程来操作</span><br><span class="line">进程可以起多个,但是8核cpu只能对8个任务进行操作</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time,threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_run</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (threading.get_ident()) <span class="comment">#get_ident获取当前线程id</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(name)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'heelo'</span>,name)</span><br><span class="line">    t = threading.Thread(target=thread_run,)    <span class="comment">#在每个进程中又起了1个线程</span></span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):     <span class="comment">#起了10个进程</span></span><br><span class="line">        p = multiprocessing.Process(target=run,args=(<span class="string">'bob%s'</span> %i,))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure><p>默认进程之间数据是不共享的,如果一定要实现互访可以通过QUEUE实现,这个queue和线程中的queue使用方法一样,不过线程中的queue只能在线程之间使用</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">并发指的是多个线程被一个cpu轮流切换着执行(理解为在做一件事空闲的时候同时做宁外一件事)===&gt;理解为交替执行</span><br><span class="line">并行指的是被多个CPU执行 ====&gt;同时执行</span><br></pre></td></tr></table></figure><h5 id="PiPe-两个进程间的通信-两个进程分别位于管道的两端"><a href="#PiPe-两个进程间的通信-两个进程分别位于管道的两端" class="headerlink" title="PiPe(两个进程间的通信,两个进程分别位于管道的两端)"></a>PiPe(两个进程间的通信,两个进程分别位于管道的两端)</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">多进程中的管道是用来实现进程间的通信的,两个进程通信,需要在内存中开辟一个空间.</span><br><span class="line">单向通信:半双工  a进程写,b进程读</span><br><span class="line">双向通信:全双工  a进程写,b进程读,也可以b进程写,a进程读</span><br><span class="line">Pipe(duplex)</span><br><span class="line">功能：创建一个管道</span><br><span class="line">参数：duplex默认值为<span class="literal">True</span>,表示管道为双向管道（全双工）如果设置为<span class="literal">False</span>则为单项管道（半双工）</span><br><span class="line">返回值：返回两个管道流对象，两个管道流对象分别表示管道的两端，如果参数为<span class="literal">True</span>的时候，两个对象均可发送接收，如果为<span class="literal">False</span>时，则第一个对象只能接收，第二个就只能发送</span><br><span class="line">总结:</span><br><span class="line">    <span class="number">1.</span>向管道发送数据用send()函数,从管道接收数据使用recv()函数</span><br><span class="line">    <span class="number">2.</span>recv()函数为阻塞函数,当管道中数据为空的时候会阻塞</span><br><span class="line">    <span class="number">3.</span>一次recv()只能接收一次send()的内容</span><br><span class="line">    <span class="number">4.</span>send可以发送的数据类型比较多样,字符串,数字,列表等等</span><br><span class="line">注意一端发送了,宁一端必须接收</span><br></pre></td></tr></table></figure><h4 id="获取多进程的结果然后处理"><a href="#获取多进程的结果然后处理" class="headerlink" title="获取多进程的结果然后处理"></a>获取多进程的结果然后处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ls = []</span><br><span class="line">for i in range(3):</span><br><span class="line">res = pool.apply_async(func,args=(i,))</span><br><span class="line">ls.append(res)</span><br><span class="line">for data in ls:</span><br><span class="line">print(data.get())</span><br></pre></td></tr></table></figure><p>进程间通信之共享内存(python3.8)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Value,Array</span><br><span class="line"></span><br><span class="line">obj = Value(ctype,data) <span class="comment">#开辟共享内存  ctype 表示共享内存空间类型,'i','f','c'等</span></span><br><span class="line"><span class="comment">#data 共享空间初始数据    返回共享空间对象</span></span><br><span class="line">obj.value    <span class="comment">#对该属性的修改查看即对共享内存读写</span></span><br><span class="line"></span><br><span class="line">obj = Array(ctype,data)</span><br><span class="line">功能: 开辟共享内存空间</span><br><span class="line">参数: ctype:共享数据类型</span><br><span class="line">      data:整数则表示开辟空间建的大小,其他数据类型则表示开辟空间存放的数据</span><br><span class="line">Array共享内存读写： 通过遍历obj可以得到每个值，直接可以通过索引序号修改任意值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        Value实例</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> multiprocessing <span class="keyword">import</span>  Value,Process</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    <span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建共享内存</span></span><br><span class="line"></span><br><span class="line">    money = Value(<span class="string">'i'</span>,<span class="number">5000</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#操作共享内存</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">man</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">            time.sleep(<span class="number">0.2</span>)</span><br><span class="line">            money.value += random.randint(<span class="number">1</span>,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">girl</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">            time.sleep(<span class="number">0.15</span>)</span><br><span class="line">            money.value -= random.randint(<span class="number">100</span>,<span class="number">800</span>)</span><br><span class="line"></span><br><span class="line">    m = Process(target=man)</span><br><span class="line">    g = Process(target=girl)</span><br><span class="line"></span><br><span class="line">    g.start()</span><br><span class="line">    m.start()</span><br><span class="line"></span><br><span class="line">    m.join()</span><br><span class="line">    g.join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"一月余额："</span>,money.value)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="string">'''</span></span><br><span class="line"><span class="string">        Array实例</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Array</span><br><span class="line"></span><br><span class="line">    shm = Array(<span class="string">'c'</span>,<span class="string">'dd'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> shm:</span><br><span class="line">            print(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p = Process(target=fun)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure><p>####多线程<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_aaa</span><span class="params">(i)</span>:</span></span><br><span class="line">    print(i)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> i[<span class="number">0</span>]**<span class="number">3</span>,i[<span class="number">1</span>]*<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_thread_pool_sub</span><span class="params">(name_list)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">2</span>) <span class="keyword">as</span> t:</span><br><span class="line">        res = [t.submit(func_aaa, i) <span class="keyword">for</span> i <span class="keyword">in</span> name_list]</span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> res:</span><br><span class="line">        print(<span class="number">8979987</span>)</span><br><span class="line">        data = future.result()</span><br><span class="line">        print(data)</span><br><span class="line">name_list = [[<span class="number">1</span>,<span class="number">9999</span>],[<span class="number">2</span>,<span class="number">9999</span>],[<span class="number">3</span>,<span class="number">9999</span>],[<span class="number">4</span>,<span class="number">9999</span>],[<span class="number">5</span>,<span class="number">9999</span>],[<span class="number">6</span>,<span class="number">9999</span>]]</span><br><span class="line">run_thread_pool_sub(name_list)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql面试题</title>
      <link href="/2019/05/23/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/05/23/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>用一条SQL语句查询出每门课都大于80分的学生姓名</p><table><thead><tr><th>name</th><th>kecheng</th><th>fenshu</th></tr></thead><tbody><tr><td>张三</td><td>语文</td><td>81</td></tr><tr><td>张三</td><td>数学</td><td>75</td></tr><tr><td>李四</td><td>语文</td><td>76</td></tr><tr><td>李四</td><td>数学</td><td>90</td></tr><tr><td>王五</td><td>语文</td><td>81</td></tr><tr><td>王五</td><td>数学</td><td>100</td></tr><tr><td>王五</td><td>英语</td><td>90</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表语句</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mst_stu`</span> (</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`kecheng`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`fenshu`</span> <span class="built_in">int</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"><span class="comment">-- 数据 </span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_stu`</span> <span class="keyword">VALUES</span> (<span class="string">'张三'</span>, <span class="string">'语文'</span>, <span class="number">81</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_stu`</span> <span class="keyword">VALUES</span> (<span class="string">'张三'</span>, <span class="string">'数学'</span>, <span class="number">75</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_stu`</span> <span class="keyword">VALUES</span> (<span class="string">'李四'</span>, <span class="string">'语文'</span>, <span class="number">76</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_stu`</span> <span class="keyword">VALUES</span> (<span class="string">'李四'</span>, <span class="string">'数学'</span>, <span class="number">90</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_stu`</span> <span class="keyword">VALUES</span> (<span class="string">'王五'</span>, <span class="string">'语文'</span>, <span class="number">81</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_stu`</span> <span class="keyword">VALUES</span> (<span class="string">'王五'</span>, <span class="string">'数学'</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_stu`</span> <span class="keyword">VALUES</span> (<span class="string">'王五'</span>, <span class="string">'英语'</span>, <span class="number">90</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--分析: 每门课都要大于80分,因此学生的最低分要大于80分,先根据用户分组,看每个人的最低分</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,<span class="keyword">min</span>(fenshu) <span class="keyword">from</span> mst_stu <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br><span class="line">+<span class="comment">--------+-------------+</span></span><br><span class="line">| name   | min(fenshu) |</span><br><span class="line">+<span class="comment">--------+-------------+</span></span><br><span class="line">| 张三   |          75 |</span><br><span class="line">| 李四   |          76 |</span><br><span class="line">| 王五   |          81 |</span><br><span class="line">+<span class="comment">--------+-------------+</span></span><br><span class="line"><span class="comment">-- 在使用 having 筛选出最低分大于80的</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,<span class="keyword">min</span>(fenshu) <span class="keyword">as</span> min_f <span class="keyword">from</span> mst_stu <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">having</span> min_f &gt; <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 最终只需要学生姓名</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">name</span>,<span class="keyword">min</span>(fenshu) <span class="keyword">as</span> min_f <span class="keyword">from</span> mst_stu <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">having</span> min_f &gt; <span class="number">80</span>) <span class="keyword">as</span> s;</span><br></pre></td></tr></table></figure><p>查询后一天 temperature 比前一天高的date</p><blockquote><p>查找与之前（昨天的）日期相比温度更高的所有日期的 Id。</p></blockquote><table><thead><tr><th>id</th><th>date</th><th>temperature</th></tr></thead><tbody><tr><td>1</td><td>2013-04-01</td><td>20</td></tr><tr><td>2</td><td>2013-04-02</td><td>25</td></tr><tr><td>3</td><td>2013-04-03</td><td>21</td></tr><tr><td>4</td><td>2013-04-04</td><td>24</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- mst_Weather </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mst_weather`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`date`</span> <span class="built_in">date</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`temperature`</span> <span class="built_in">int</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">5</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_weather`</span> <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'2013-04-01'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_weather`</span> <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'2013-04-02'</span>, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_weather`</span> <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">'2013-04-03'</span>, <span class="number">21</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_weather`</span> <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">'2013-04-04'</span>, <span class="number">24</span>);</span><br><span class="line"><span class="comment">-- 当前表做join,比较日期同时要比较温度</span></span><br><span class="line"><span class="keyword">select</span> m2.date <span class="keyword">from</span> mst_weather <span class="keyword">as</span> m1 <span class="keyword">join</span> mst_weather <span class="keyword">as</span> m2 <span class="keyword">where</span> <span class="keyword">datediff</span>(m2.date,m1.date) = <span class="number">1</span> <span class="keyword">and</span> m2.temperature &gt; m1.temperature;</span><br></pre></td></tr></table></figure><p>查询每个主播的最大level以及对应的最小gap(注意:不是每个主播的最大level和最小gap)</p><table><thead><tr><th>zhuobo_id</th><th>level</th><th>gap</th></tr></thead><tbody><tr><td>123</td><td>8</td><td>20</td></tr><tr><td>123</td><td>9</td><td>40</td></tr><tr><td>123</td><td>9</td><td>30</td></tr><tr><td>246</td><td>6</td><td>30</td></tr><tr><td>246</td><td>6</td><td>20</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mst_zhubo`</span> (</span><br><span class="line">  <span class="string">`zhubo_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`level`</span> <span class="built_in">int</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`gap`</span> <span class="built_in">int</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_zhubo`</span> <span class="keyword">VALUES</span> (<span class="number">123</span>, <span class="number">8</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_zhubo`</span> <span class="keyword">VALUES</span> (<span class="number">123</span>, <span class="number">9</span>, <span class="number">40</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_zhubo`</span> <span class="keyword">VALUES</span> (<span class="number">123</span>, <span class="number">9</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_zhubo`</span> <span class="keyword">VALUES</span> (<span class="number">246</span>, <span class="number">6</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_zhubo`</span> <span class="keyword">VALUES</span> (<span class="number">246</span>, <span class="number">6</span>, <span class="number">20</span>);</span><br><span class="line"><span class="comment">--先查询出每个主播最大的level</span></span><br><span class="line"><span class="keyword">select</span> zhubo_id,<span class="keyword">max</span>(<span class="keyword">level</span>) <span class="keyword">from</span> mst_zhubo <span class="keyword">GROUP</span> <span class="keyword">BY</span> zhubo_id;</span><br><span class="line"><span class="comment">-- 再查询出每个主播所有符合最大level的数据</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mst_zhubo <span class="keyword">where</span> (zhubo_id,<span class="keyword">level</span>) <span class="keyword">in</span> (<span class="keyword">select</span> zhubo_id,<span class="keyword">max</span>(<span class="keyword">level</span>) <span class="keyword">from</span> mst_zhubo <span class="keyword">GROUP</span> <span class="keyword">BY</span> zhubo_id) ;</span><br><span class="line"><span class="comment">-- 再查询当前符合条件的数据中 gap最小的数据</span></span><br><span class="line"><span class="keyword">select</span> zhubo_id,<span class="keyword">level</span>,<span class="keyword">min</span>(gap) </span><br><span class="line"><span class="keyword">from</span> mst_zhubo <span class="keyword">where</span> (zhubo_id,<span class="keyword">level</span>) <span class="keyword">in</span> (<span class="keyword">select</span> zhubo_id,<span class="keyword">max</span>(<span class="keyword">level</span>) <span class="keyword">from</span> mst_zhubo <span class="keyword">GROUP</span> <span class="keyword">BY</span> zhubo_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> zhubo_id,<span class="keyword">level</span>;</span><br></pre></td></tr></table></figure><p>下表是每个课程class_id对应的年级(共有primary、middle、high三个),以及某种比率rate</p><table><thead><tr><th>class_id</th><th>grade</th><th>rate</th></tr></thead><tbody><tr><td>abc123</td><td>primary</td><td>70%</td></tr><tr><td>abc123</td><td>middle</td><td>65%</td></tr><tr><td>abc123</td><td>high</td><td>72%</td></tr><tr><td>hjkk86</td><td>primary</td><td>69%</td></tr><tr><td>hjkk86</td><td>middle</td><td>63%</td></tr><tr><td>hjkk86</td><td>high</td><td>74%</td></tr></tbody></table><p>请写出SQL查询出如下形式的表：</p><table><thead><tr><th>class_id</th><th>primary</th><th>middle</th><th>high</th></tr></thead><tbody><tr><td>abc123</td><td>70%</td><td>65%</td><td>72%</td></tr><tr><td>hjkk86</td><td>69%</td><td>63%</td><td>74%</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mst_class`</span> (</span><br><span class="line">  <span class="string">`class_id`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`grade`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`rate`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_class`</span> <span class="keyword">VALUES</span> (<span class="string">'abc123'</span>, <span class="string">'primary'</span>, <span class="string">'70%'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_class`</span> <span class="keyword">VALUES</span> (<span class="string">'abc123'</span>, <span class="string">'middle'</span>, <span class="string">'65%'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_class`</span> <span class="keyword">VALUES</span> (<span class="string">'abc123'</span>, <span class="string">'high'</span>, <span class="string">'72%'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_class`</span> <span class="keyword">VALUES</span> (<span class="string">'hjkk86'</span>, <span class="string">'primary'</span>, <span class="string">'69%'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_class`</span> <span class="keyword">VALUES</span> (<span class="string">'hjkk86'</span>, <span class="string">'middle'</span>, <span class="string">'63%'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_class`</span> <span class="keyword">VALUES</span> (<span class="string">'hjkk86'</span>, <span class="string">'high'</span>, <span class="string">'74%'</span>);</span><br><span class="line"><span class="comment">-- 按照class_id进行分组,由于使用分组,则必须使用聚合函数,因此此处使用max()函数进行即可,然后使用case...when....then 进行行转列</span></span><br><span class="line"><span class="keyword">select</span> class_id,</span><br><span class="line"><span class="keyword">max</span>(<span class="keyword">CASE</span>  <span class="keyword">WHEN</span> grade = <span class="string">'primary'</span> <span class="keyword">THEN</span> rate <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">as</span> <span class="string">'primary'</span>,</span><br><span class="line"><span class="keyword">max</span>(<span class="keyword">CASE</span>  <span class="keyword">WHEN</span> grade = <span class="string">'middle'</span> <span class="keyword">THEN</span> rate <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">as</span> <span class="string">'middle'</span>,</span><br><span class="line"><span class="keyword">max</span>(<span class="keyword">CASE</span>  <span class="keyword">WHEN</span> grade = <span class="string">'high'</span> <span class="keyword">THEN</span> rate <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">as</span> <span class="string">'high'</span></span><br><span class="line"><span class="keyword">from</span> mst_class <span class="keyword">group</span> <span class="keyword">by</span> class_id;</span><br></pre></td></tr></table></figure><p>怎么把这样一个表</p><table><thead><tr><th>year</th><th>month</th><th>amount</th></tr></thead><tbody><tr><td>1991</td><td>1</td><td>1</td></tr><tr><td>1991</td><td>2</td><td>2</td></tr><tr><td>1991</td><td>3</td><td>3</td></tr><tr><td>1991</td><td>4</td><td>4</td></tr><tr><td>1992</td><td>1</td><td>1</td></tr><tr><td>1992</td><td>2</td><td>2</td></tr><tr><td>1992</td><td>3</td><td>3</td></tr><tr><td>1992</td><td>4</td><td>4</td></tr></tbody></table><p>查成这样一个结果</p><table><thead><tr><th>year</th><th>m1</th><th>m2</th><th>m3</th><th>m4</th></tr></thead><tbody><tr><td>1991</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>1992</td><td>1</td><td>2</td><td>3</td><td>4</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mst_year`</span> ( </span><br><span class="line">    <span class="string">`year`</span> <span class="built_in">int</span>,<span class="string">`month`</span> <span class="built_in">int</span>,<span class="string">`amount`</span> <span class="built_in">float</span> </span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_year`</span> <span class="keyword">VALUES</span> (<span class="number">1991</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_year`</span> <span class="keyword">VALUES</span> (<span class="number">1991</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_year`</span> <span class="keyword">VALUES</span> (<span class="number">1991</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_year`</span> <span class="keyword">VALUES</span> (<span class="number">1991</span>, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_year`</span> <span class="keyword">VALUES</span> (<span class="number">1992</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_year`</span> <span class="keyword">VALUES</span> (<span class="number">1992</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_year`</span> <span class="keyword">VALUES</span> (<span class="number">1992</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_year`</span> <span class="keyword">VALUES</span> (<span class="number">1992</span>, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 同上一个问题类似,按照 year 进行分组,使用case...when....then 进行行转列,需要注意的是要对结果进行小数位限制</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">year</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">CASE</span>  <span class="keyword">WHEN</span> <span class="keyword">month</span> = <span class="number">1</span> <span class="keyword">THEN</span> <span class="keyword">round</span>(amount,<span class="number">1</span>) <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">as</span> <span class="string">'m1'</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">CASE</span>  <span class="keyword">WHEN</span> <span class="keyword">month</span> = <span class="number">2</span> <span class="keyword">THEN</span> <span class="keyword">round</span>(amount,<span class="number">1</span>) <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">as</span> <span class="string">'m2'</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">CASE</span>  <span class="keyword">WHEN</span> <span class="keyword">month</span> = <span class="number">3</span> <span class="keyword">THEN</span> <span class="keyword">round</span>(amount,<span class="number">1</span>) <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">as</span> <span class="string">'m3'</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">CASE</span>  <span class="keyword">WHEN</span> <span class="keyword">month</span> = <span class="number">4</span> <span class="keyword">THEN</span> <span class="keyword">round</span>(amount,<span class="number">1</span>) <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">as</span> <span class="string">'m4'</span></span><br><span class="line"><span class="keyword">from</span> mst_year <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">year</span>;</span><br></pre></td></tr></table></figure><p>有两个表A和B，均有key和value两个字段，如果B的key在A中也有，就把B的value换为A中对应的value</p><p>这道题的SQL语句怎么写？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先按题设计AB表,并查看结果</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mst_a`</span> (  <span class="string">`key`</span> <span class="built_in">varchar</span>,<span class="string">`value`</span> <span class="built_in">varchar</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_a`</span> <span class="keyword">VALUES</span> (<span class="string">'A'</span>, <span class="string">'aaa'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_a`</span> <span class="keyword">VALUES</span> (<span class="string">'B'</span>, <span class="string">'bbb'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_a`</span> <span class="keyword">VALUES</span> (<span class="string">'C'</span>, <span class="string">'ccc'</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mst_b`</span> (  <span class="string">`key`</span> <span class="built_in">varchar</span>,<span class="string">`value`</span> <span class="built_in">varchar</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_a`</span> <span class="keyword">VALUES</span> (<span class="string">'D'</span>, <span class="string">'ddd'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_a`</span> <span class="keyword">VALUES</span> (<span class="string">'E'</span>, <span class="string">'eee'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mst_a`</span> <span class="keyword">VALUES</span> (<span class="string">'A'</span>, <span class="string">'abc'</span>);</span><br><span class="line"><span class="comment">-- 查看当前两个表的数据</span></span><br><span class="line">mysql&gt; select * from mst_a;</span><br><span class="line">+<span class="comment">------+-------+</span></span><br><span class="line">| key  | value |</span><br><span class="line">+<span class="comment">------+-------+</span></span><br><span class="line">| A    | aaa   |</span><br><span class="line">| B    | bbb   |</span><br><span class="line">| C    | ccc   |</span><br><span class="line">+<span class="comment">------+-------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> mst_b;</span><br><span class="line">+<span class="comment">------+-------+</span></span><br><span class="line">| key  | value |</span><br><span class="line">+<span class="comment">------+-------+</span></span><br><span class="line">| D    | ddd   |</span><br><span class="line">| E    | eee   |</span><br><span class="line">| A    | abc   |</span><br><span class="line">+<span class="comment">------+-------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">00</span> sec)</span><br><span class="line"><span class="comment">-- 有两个表A和B，均有key和value两个字段，如果B的key在A中也有，就把B的value换为A中对应的value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分析,先查询符合条件的数据,(B的key在A中也有)</span></span><br><span class="line"><span class="keyword">select</span> mst_a.*,mst_b.* <span class="keyword">from</span> mst_a <span class="keyword">join</span> mst_b <span class="keyword">on</span> mst_a.key = mst_b.key;</span><br><span class="line">+<span class="comment">------+-------+------+-------+</span></span><br><span class="line">| key  | value | key  | value |</span><br><span class="line">+<span class="comment">------+-------+------+-------+</span></span><br><span class="line">| A    | aaa   | A    | abc   |</span><br><span class="line">+<span class="comment">------+-------+------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新数据 update mst_b set value = ? where key = ?</span></span><br><span class="line"><span class="comment">-- 根据以上的更新语句需要的数据,针对性的获取,先获取第二个问号中的key</span></span><br><span class="line"><span class="keyword">select</span> mst_b.key <span class="keyword">from</span> mst_a <span class="keyword">join</span> mst_b <span class="keyword">on</span> mst_a.key = mst_b.key;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| key  |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| A    |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line"><span class="comment">-- 在获取需要更新的值?也就是a表中的对应key的value</span></span><br><span class="line"><span class="keyword">select</span> mst_a.value,b.key  </span><br><span class="line"><span class="keyword">from</span> mst_a,(<span class="keyword">select</span> mst_b.key <span class="keyword">from</span> mst_a <span class="keyword">join</span> mst_b <span class="keyword">on</span> mst_a.key = mst_b.key) b</span><br><span class="line"><span class="keyword">where</span> mst_a.key = b.key;</span><br><span class="line"><span class="comment">-- 在将两次sql结果嵌套到对应的update中</span></span><br><span class="line"><span class="comment">-- 注意事项:</span></span><br><span class="line"><span class="comment">-- update 后面可以做任意的查询，这个作用等同于from</span></span><br><span class="line"><span class="comment">-- update 时，更新的表不能在set和where中用于子查询</span></span><br><span class="line"><span class="comment">-- update 时，可以对多个表进行更新（sqlserver不行）</span></span><br><span class="line"><span class="keyword">update</span> mst_b <span class="keyword">as</span> up, (<span class="keyword">select</span> mst_a.value,b.key  </span><br><span class="line"><span class="keyword">from</span> mst_a,(<span class="keyword">select</span> mst_b.key <span class="keyword">from</span> mst_a <span class="keyword">join</span> mst_b <span class="keyword">on</span> mst_a.key = mst_b.key) b</span><br><span class="line"><span class="keyword">where</span> mst_a.key = b.key) b</span><br><span class="line">    <span class="keyword">set</span> up.value = b.value</span><br><span class="line">    <span class="keyword">where</span> up.key = b.key;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 再次查询结果</span></span><br><span class="line">mysql&gt; select * from mst_a;</span><br><span class="line">+<span class="comment">------+-------+</span></span><br><span class="line">| key  | value |</span><br><span class="line">+<span class="comment">------+-------+</span></span><br><span class="line">| A    | aaa   |</span><br><span class="line">| B    | bbb   |</span><br><span class="line">| C    | ccc   |</span><br><span class="line">+<span class="comment">------+-------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> mst_b;</span><br><span class="line">+<span class="comment">------+-------+</span></span><br><span class="line">| key  | value |</span><br><span class="line">+<span class="comment">------+-------+</span></span><br><span class="line">| D    | ddd   |</span><br><span class="line">| E    | eee   |</span><br><span class="line">| A    | aaa   |</span><br><span class="line">+<span class="comment">------+-------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">00</span> sec)</span><br></pre></td></tr></table></figure><p>设计表，关系如下：教室、班级、学生、科室、科室与教师为一对多关系，教师与班级为多对多关系，班级与学生为一对多关系，科室中需体现层级关系。</p><p>1．写出各张表的逻辑字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">教师 mst_Teacher</span><br><span class="line">+<span class="comment">-----+--------------+</span></span><br><span class="line">| Tid | Tname        |</span><br><span class="line">+<span class="comment">-----+--------------+</span></span><br><span class="line">|   1 | 张三老师     |</span><br><span class="line">|   2 | 李四老师     |</span><br><span class="line">|   3 | 王五老师     |</span><br><span class="line">+<span class="comment">-----+--------------+</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mst_teacher`</span> (</span><br><span class="line">  <span class="string">`Tid`</span> <span class="built_in">int</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`Tname`</span> <span class="built_in">varchar</span>(<span class="number">10</span>)</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mst_teacher <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">'张三老师'</span>),(<span class="number">2</span>,<span class="string">'李四老师'</span>),(<span class="number">3</span>,<span class="string">'王五老师'</span>);</span><br><span class="line">班级 mst_cla</span><br><span class="line">+<span class="comment">-----+-------+</span></span><br><span class="line">| Cid | Cname |</span><br><span class="line">+<span class="comment">-----+-------+</span></span><br><span class="line">|   1 | 1班   |</span><br><span class="line">|   2 | 2班   |</span><br><span class="line">|   3 | 3班   |</span><br><span class="line">+<span class="comment">-----+-------+</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mst_cla`</span> (</span><br><span class="line">  <span class="string">`Cid`</span> <span class="built_in">int</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`Cname`</span> <span class="built_in">varchar</span>(<span class="number">10</span>)</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mst_cla <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">'1班'</span>),(<span class="number">2</span>,<span class="string">'2班'</span>),(<span class="number">3</span>,<span class="string">'3班'</span>);</span><br><span class="line">教师&amp;班级  mst_tc</span><br><span class="line">+<span class="comment">-----+------+------+</span></span><br><span class="line">| pid | Tid  | Cid  |</span><br><span class="line">+<span class="comment">-----+------+------+</span></span><br><span class="line">|   1 |    1 |    1 |</span><br><span class="line">|   2 |    2 |    1 |</span><br><span class="line">|   3 |    3 |    1 |</span><br><span class="line">|   4 |    1 |    2 |</span><br><span class="line">|   5 |    2 |    2 |</span><br><span class="line">|   6 |    3 |    2 |</span><br><span class="line">|   7 |    1 |    3 |</span><br><span class="line">|   8 |    2 |    3 |</span><br><span class="line">|   9 |    3 |    3 |</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mst_tc`</span> (</span><br><span class="line">  <span class="string">`pid`</span> <span class="built_in">int</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`Tid`</span> <span class="built_in">int</span>,<span class="string">`Cid`</span> <span class="built_in">int</span> </span><br><span class="line">  );</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mst_tc <span class="keyword">VALUES</span></span><br><span class="line">    (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>),(<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>),(<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>),(<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>),(<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>),(<span class="number">8</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">9</span>,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">学生 mst_St        </span><br><span class="line">+<span class="comment">-----+--------+------+</span></span><br><span class="line">| SId | Sname  | Cid  |</span><br><span class="line">+<span class="comment">-----+--------+------+</span></span><br><span class="line">|   1 | 赵雷   |    1 |</span><br><span class="line">|   2 | 钱电   |    1 |</span><br><span class="line">|   3 | 孙风   |    1 |</span><br><span class="line">|   4 | 李云   |    2 |</span><br><span class="line">|   5 | 周梅   |    2 |</span><br><span class="line">|   6 | 吴兰   |    3 |</span><br><span class="line">|   7 | 郑竹   |    3 |</span><br><span class="line">+<span class="comment">-----+--------+------+</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mst_St`</span> (</span><br><span class="line">  <span class="string">`SId`</span> <span class="built_in">int</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`Sname`</span> <span class="built_in">varchar</span>(<span class="number">20</span>),<span class="string">`Cid`</span> <span class="built_in">int</span> </span><br><span class="line">  );</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mst_St <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">'赵雷'</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="string">'钱电'</span>,<span class="number">1</span>),(<span class="number">3</span>,<span class="string">'孙风'</span>,<span class="number">1</span>),(<span class="number">4</span>,<span class="string">'李云'</span>,<span class="number">2</span>),(<span class="number">5</span>,<span class="string">'周梅'</span>,<span class="number">2</span>),(<span class="number">6</span>,<span class="string">'吴兰'</span>,<span class="number">3</span>),(<span class="number">7</span>,<span class="string">'郑竹'</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">科室 mst_ks</span><br><span class="line">+<span class="comment">-----+-----------+------+------+</span></span><br><span class="line">| Kid | Kname     | Pid  | Tid  |</span><br><span class="line">+<span class="comment">-----+-----------+------+------+</span></span><br><span class="line">|   1 | 校长室    |    0 |    1 |</span><br><span class="line">|   2 | 教务处    |    1 |    1 |</span><br><span class="line">|   3 | 教学处    |    1 |    2 |</span><br><span class="line">|   4 | 语文      |    3 |    1 |</span><br><span class="line">|   5 | 数学      |    3 |    2 |</span><br><span class="line">|   6 | 英语      |    3 |    3 |</span><br><span class="line">+<span class="comment">-----+-----------+------+------+</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mst_ks`</span> (</span><br><span class="line">  <span class="string">`Kid`</span> <span class="built_in">int</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`Kname`</span> <span class="built_in">varchar</span>(<span class="number">20</span>),<span class="string">`Pid`</span> <span class="built_in">int</span> ,<span class="string">`Tid`</span> <span class="built_in">int</span> </span><br><span class="line">  );</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mst_ks <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">'校长室'</span>,<span class="number">0</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="string">'教务处'</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">3</span>,<span class="string">'教学处'</span>,<span class="number">1</span>,<span class="number">2</span>),(<span class="number">4</span>,<span class="string">'语文'</span>,<span class="number">3</span>,<span class="number">1</span>),(<span class="number">5</span>,<span class="string">'数学'</span>,<span class="number">3</span>,<span class="number">2</span>),(<span class="number">6</span>,<span class="string">'英语'</span>,<span class="number">3</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>根据上述表关系</p><p>​    查询教师id=1的学生数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 已知教师Id就可以先到教师与班级的关系表中获取当前老师所带的班级</span></span><br><span class="line"><span class="keyword">select</span> cid <span class="keyword">from</span> mst_tc <span class="keyword">where</span> Tid = <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 获取所带班级后,到学生表中获取所带班级中的学员数即可</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> mst_St <span class="keyword">where</span> Cid <span class="keyword">in</span> (<span class="keyword">select</span> cid <span class="keyword">from</span> mst_tc <span class="keyword">where</span> Tid = <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>​    查询科室id=3的下级部门数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 科室id=3的下级部门的pid也就等于科室id,因此查询当前科室的父级id = 3的即可</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> mst_ks <span class="keyword">where</span> pid = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>​    查询所带学生最多的教师id</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先查询出每个老师带的学生数</span></span><br><span class="line"><span class="keyword">select</span> mst_teacher.tid,mst_teacher.tname,<span class="keyword">count</span>(mst_st.sid) <span class="keyword">as</span> count_stu</span><br><span class="line"><span class="keyword">from</span> mst_teacher,mst_tc,mst_St</span><br><span class="line"><span class="keyword">where</span> mst_teacher.tid = mst_tc.tid</span><br><span class="line"><span class="keyword">and</span> mst_tc.cid = mst_st.cid</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> mst_teacher.tid,mst_teacher.tname;</span><br><span class="line">+<span class="comment">-----+--------------+-----------+</span></span><br><span class="line">| tid | tname        | count_stu |</span><br><span class="line">+<span class="comment">-----+--------------+-----------+</span></span><br><span class="line">|   1 | 张三老师     |         7 |</span><br><span class="line">|   2 | 李四老师     |         7 |</span><br><span class="line">|   3 | 王五老师     |         7 |</span><br><span class="line">+<span class="comment">-----+--------------+-----------+</span></span><br><span class="line"><span class="comment">-- 因为目前所有老师带的班级都一样,所以数据结果都是一样的,因此可以改变一个老师所带的科目后在查询,比如语文和数学是一个老师带的,再次查询</span></span><br><span class="line"><span class="keyword">select</span> mst_teacher.tid,mst_teacher.tname,<span class="keyword">count</span>(mst_st.sid) <span class="keyword">as</span> count_stu</span><br><span class="line"><span class="keyword">from</span> mst_teacher,mst_tc,mst_St</span><br><span class="line"><span class="keyword">where</span> mst_teacher.tid = mst_tc.tid</span><br><span class="line"><span class="keyword">and</span> mst_tc.cid = mst_st.cid</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> mst_teacher.tid,mst_teacher.tname;</span><br><span class="line">+<span class="comment">-----+--------------+-----------+</span></span><br><span class="line">| tid | tname        | count_stu |</span><br><span class="line">+<span class="comment">-----+--------------+-----------+</span></span><br><span class="line">|   2 | 李四老师     |        14 |</span><br><span class="line">|   3 | 王五老师     |         7 |</span><br><span class="line">+<span class="comment">-----+--------------+-----------+</span></span><br></pre></td></tr></table></figure><p>(1)某奶粉品牌有以下销售数据(订单表Orderinfo)，请计算每个人得消费金额、消费频次、购买产品数量、第一次购买时间和最后一次购买时间。</p><table><thead><tr><th>CustomerID</th><th>OrderID</th><th>Sales</th><th>Quantity</th><th>OrderDate</th></tr></thead><tbody><tr><td>A</td><td>01</td><td>100</td><td>1</td><td>2017-03-01</td></tr><tr><td>A</td><td>02</td><td>420</td><td>3</td><td>2017-03-15</td></tr><tr><td>B</td><td>03</td><td>300</td><td>4</td><td>2017-03-02</td></tr><tr><td>B</td><td>04</td><td>1000</td><td>1</td><td>2017-04-01</td></tr><tr><td>C</td><td>05</td><td>500</td><td>3</td><td>2017-05-03</td></tr><tr><td>C</td><td>06</td><td>200</td><td>1</td><td>2017-05-04</td></tr><tr><td>……</td><td></td><td></td><td></td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`mst_Orderinfo`</span>(<span class="string">`CustomerID`</span> <span class="built_in">char</span>(<span class="number">5</span>),<span class="string">`OrderID`</span> <span class="built_in">int</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,<span class="string">`Sales`</span> <span class="built_in">int</span>,<span class="string">`Quantity`</span> <span class="built_in">int</span>,<span class="string">`OrderDate`</span> <span class="built_in">date</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">INTO</span> mst_Orderinfo <span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">'A'</span>,<span class="number">01</span>,<span class="number">100</span>,<span class="number">1</span>,<span class="string">'2017-03-01'</span>),</span><br><span class="line">    (<span class="string">'A'</span>,<span class="number">02</span>,<span class="number">420</span>,<span class="number">3</span>,<span class="string">'2017-03-15'</span>),</span><br><span class="line">    (<span class="string">'B'</span>,<span class="number">03</span>,<span class="number">300</span>,<span class="number">4</span>,<span class="string">'2017-03-02'</span>),</span><br><span class="line">    (<span class="string">'B'</span>,<span class="number">04</span>,<span class="number">1000</span>,<span class="number">1</span>,<span class="string">'2017-04-01'</span>),</span><br><span class="line">    (<span class="string">'C'</span>,<span class="number">05</span>,<span class="number">500</span>,<span class="number">3</span>,<span class="string">'2017-05-03'</span>),</span><br><span class="line">    (<span class="string">'C'</span>,<span class="number">06</span>,<span class="number">200</span>,<span class="number">1</span>,<span class="string">'2017-05-04'</span>);</span><br><span class="line"><span class="comment">--计算每个人得消费金额、消费频次、购买产品数量、第一次购买时间和最后一次购买时间。</span></span><br><span class="line"><span class="keyword">select</span> CustomerID,</span><br><span class="line"><span class="keyword">sum</span>(Sales) <span class="keyword">as</span> <span class="string">'消费金额'</span>,</span><br><span class="line"><span class="keyword">count</span>(CustomerID) <span class="keyword">as</span> <span class="string">'消费频次'</span>,</span><br><span class="line"><span class="keyword">sum</span>(Quantity) <span class="keyword">as</span> <span class="string">'购买产品数量'</span>,</span><br><span class="line"><span class="keyword">min</span>(OrderDate) <span class="keyword">as</span> <span class="string">'第一次购买时间'</span>,</span><br><span class="line"><span class="keyword">max</span>(OrderDate) <span class="keyword">as</span> <span class="string">'最后一次购买时间'</span></span><br><span class="line"><span class="keyword">from</span> mst_Orderinfo <span class="keyword">group</span> <span class="keyword">by</span> CustomerID;</span><br></pre></td></tr></table></figure><p>(2)该奶粉品牌还有一张订单明细表(OrderDetail ),请结合上题得订单表，计算出每个SKU被多少客户购买了。</p><table><thead><tr><th>OrderDetailID</th><th>OrderID</th><th>SKU</th><th>Qutity</th></tr></thead><tbody><tr><td>01</td><td>01</td><td>SKU1</td><td>1</td></tr><tr><td>02</td><td>02</td><td>SKU1</td><td>2</td></tr><tr><td>03</td><td>02</td><td>SKU2</td><td>1</td></tr><tr><td>04</td><td>03</td><td>SKU2</td><td>2</td></tr><tr><td>05</td><td>03</td><td>SKU3</td><td>2</td></tr><tr><td>06</td><td>04</td><td>SKU6</td><td>1</td></tr><tr><td>07</td><td>05</td><td>SKU4</td><td>2</td></tr><tr><td>……</td><td></td><td></td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`mst_OrderDetail`</span>(<span class="string">`OrderDetailID`</span> <span class="built_in">int</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,<span class="string">`OrderID`</span> <span class="built_in">int</span>,<span class="string">`SKU`</span> <span class="built_in">char</span>(<span class="number">5</span>),<span class="string">`Qutity`</span> <span class="built_in">int</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mst_OrderDetail <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="string">'SKU1'</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="string">'SKU1'</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">2</span>,<span class="string">'SKU2'</span>,<span class="number">1</span>),(<span class="number">4</span>,<span class="number">3</span>,<span class="string">'SKU2'</span>,<span class="number">2</span>),(<span class="number">5</span>,<span class="number">3</span>,<span class="string">'SKU3'</span>,<span class="number">2</span>),(<span class="number">6</span>,<span class="number">4</span>,<span class="string">'SKU6'</span>,<span class="number">1</span>),(<span class="number">7</span>,<span class="number">5</span>,<span class="string">'SKU4'</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">-- 分析:如果要统计出每个sku被多少客户购买了.就需要先把两个表做join,观察</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mst_Orderinfo o1,mst_OrderDetail o2</span><br><span class="line"><span class="keyword">where</span> oOrderID = oOrderID;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算出每个SKU被多少客户购买了,需要以sku分组,去统计用户id并去重</span></span><br><span class="line"><span class="keyword">select</span> SKU,<span class="keyword">count</span>(<span class="keyword">distinct</span> CustomerID) <span class="keyword">from</span> mst_Orderinfo o1,mst_OrderDetail o2</span><br><span class="line"><span class="keyword">where</span> oOrderID = oOrderID</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> SKU;</span><br><span class="line">+<span class="comment">------+----------------------------+</span></span><br><span class="line">| SKU  | count(distinct CustomerID) |</span><br><span class="line">+<span class="comment">------+----------------------------+</span></span><br><span class="line">| SKU1 |                          1 |</span><br><span class="line">| SKU2 |                          2 |</span><br><span class="line">| SKU3 |                          1 |</span><br><span class="line">| SKU4 |                          1 |</span><br><span class="line">| SKU6 |                          1 |</span><br><span class="line">+<span class="comment">------+----------------------------+</span></span><br></pre></td></tr></table></figure><p>(3)请结合Orderinfo表与OrderDetail表，找出购买了SKU1又购买SKU2产品的人。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先查询出购买过SKU1和SKU2的用户</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mst_Orderinfo o1</span><br><span class="line"><span class="keyword">join</span> mst_OrderDetail o2 <span class="keyword">on</span> oOrderID = oOrderID</span><br><span class="line"><span class="keyword">where</span> oSKU <span class="keyword">in</span> (<span class="string">'SKU1'</span>,<span class="string">'SKU2'</span>);</span><br><span class="line">+<span class="comment">------------+---------+-------+----------+------------+---------------+---------+------+--------+</span></span><br><span class="line">| CustomerID | OrderID | Sales | Quantity | OrderDate  | OrderDetailID | OrderID | SKU  | Qutity |</span><br><span class="line">+<span class="comment">------------+---------+-------+----------+------------+---------------+---------+------+--------+</span></span><br><span class="line">| A          |       1 |   100 |        1 | 2017-03-01 |             1 |       1 | SKU1 |      1 |</span><br><span class="line">| A          |       2 |   420 |        3 | 2017-03-15 |             2 |       2 | SKU1 |      2 |</span><br><span class="line">| A          |       2 |   420 |        3 | 2017-03-15 |             3 |       2 | SKU2 |      1 |</span><br><span class="line">| B          |       3 |   300 |        4 | 2017-03-02 |             4 |       3 | SKU2 |      2 |</span><br><span class="line">+<span class="comment">------------+---------+-------+----------+------------+---------------+---------+------+--------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在根据用户分组,筛选购买了不同的sku的数等于2 的</span></span><br><span class="line"><span class="keyword">select</span> oCustomerID <span class="keyword">from</span> mst_Orderinfo o1 </span><br><span class="line"><span class="keyword">join</span> mst_OrderDetail o2 <span class="keyword">on</span> oOrderID = oOrderID</span><br><span class="line"><span class="keyword">where</span> oSKU <span class="keyword">in</span> (<span class="string">'SKU1'</span>,<span class="string">'SKU2'</span>)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> oCustomerID</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> oSKU) = <span class="number">2</span></span><br><span class="line">+<span class="comment">------------+</span></span><br><span class="line">| CustomerID |</span><br><span class="line">+<span class="comment">------------+</span></span><br><span class="line">| A          |</span><br><span class="line">+<span class="comment">------------+</span></span><br></pre></td></tr></table></figure><p>现有一张房源表。</p><p>字段有房源基础信息以及小区id，小区name字段。</p><p>求sql查出top10的房源量的小区，按房源量降序排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 小区<span class="keyword">id</span>,小区<span class="keyword">name</span>,<span class="keyword">count</span>(*) <span class="keyword">as</span>  房源量 <span class="keyword">from</span> 房源表 <span class="keyword">group</span> <span class="keyword">by</span>  小区<span class="keyword">id</span>,小区<span class="keyword">name</span> <span class="keyword">order</span> <span class="keyword">by</span> 房源量 <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>说一下你熟悉的数据库，这个数据库有什么特点？</p><p>请用sql描述，如何给表中插入数据？如何更新数据？</p><p>你常用的mysql引擎有哪些？各引擎间有什么区别？</p><p>MySQL数据库中现有如下表，名为tbl:</p><table><thead><tr><th>id</th><th>name</th><th>age</th><th>sex</th></tr></thead><tbody><tr><td>1</td><td>zhangsan</td><td>25</td><td>1</td></tr><tr><td>2</td><td>lisi</td><td>22</td><td>0</td></tr><tr><td>3</td><td>wangwu</td><td>35</td><td>0</td></tr><tr><td>4</td><td>zhaoliu</td><td>24</td><td>1</td></tr><tr><td>5</td><td>tianqi</td><td>32</td><td>1</td></tr></tbody></table><p>按照要求写出SQL语句:</p><p>(1)查询前3条纪录。</p><p>(2)查询所有纪录，并按照字段age降序排列。</p><p> 请描述MySQL中left join和inner joinc的区别。</p><p> left join 左连接,以左边的表为基础</p><p>inner join 自连接\内连接 以公共部分为基础</p><p> 请写出你知道MySQL储存引擎和区别。</p><p> 请列出你最常使用的mysql版本，mysql默认端口号是多少？请写出你最常用的mysql数据库备份和恢复命令。</p><p> mysql 3306</p><p>mongodb 27017</p><p>redis 6379</p><p> 数据库A:datahn，其中具有表c、表d。 数据库B:datapubhn，现想要在数据库B中对数据库A中表c与表d中的字段进行增删改查。如何授权？</p><p> 对于处理高复杂sql，数据库查询特别慢，你有什么高招？</p><p>1.优化sql语句==避免子查询,避免使用join连接</p><p>2.适当使用索引</p><p>3.优化数据库结构</p><p>4.优化系统配置</p><p>5.优化服务器结构</p><p> 以下哪条语句在数据库sql书写时最为高效( b )</p><p>A.select * from emp where dep&gt;3</p><p>B.select * from emp where dep&gt;=4</p><p>C.select * from emp where dep≥4</p><p>D.select * from emp where dep&gt;=3 and dep≠4</p><p> 数据库修改用户时，用户的什么属性不能修改？( )</p><p>A.密码</p><p>B.名称</p><p>C.表空间</p><p>D.临时表空间</p><p> 数据库中执行删除操作，若要删除表中的所有行，建议使用( b )</p><p>A.delete 语句</p><p>B.turncate 语句</p><p>C.drop 语句</p><p>D.commit 语句</p><p>2在查询语句的select子句中尽量避免使用__来表示全部列名。</p><p> SQL中增加、删除、修改对应的命令是什么？</p><p> 查找条件为：姓名不是NULL的纪录( c )</p><p>A.WHERE NAME ! NULL</p><p>B.WHERE NAME NOT NULL</p><p>C.WHERE NAME IS NOT NULL</p><p>D.WHERE NAME!=NULL</p><p> 在SQL语言中，子查询是( d )</p><p>A.选取单表中字段子集的查询语句</p><p>B.选取多表中字段子集的查询语句</p><p>C.返回单表中数据子集的查询语言</p><p>D.嵌入到另一个查询语句之中的查询语句</p><p> 以下能够删除一列的是( b )</p><p>A.alter table emp remove addcolumn</p><p>B.alter table emp drop column addcolumn</p><p>C.alter table emp delete column addcolumn</p><p>D.alter table emp delete addcolumn</p><p> 学生关系模型S(S#,Sname,Sex,Age),S的属性分别表示学生的学号、姓名、性别、年龄。要在表S中删除一个属性”年龄”,可选用的SQL语句是( d )</p><p>A.UPDATE S Age</p><p>B.DELETE Age from S</p><p>C.ALTER TABLE S ‘Age’</p><p>D.ALTER TABLE S DROP Age</p><p> 补全语句:select vend_id,count(*) as num_prods from products group by______vend_id__;</p><p> SELECT distinct 部门名称，count(员工编号)，sum(个人工资) FROM 工资表 GROUP BY 部门名称 having count (员工编号&gt;10);查询结果是<strong>___</strong>。</p><p> 用SELECT进行模糊查询时，可以使用匹配符，但要在条件值中使用__或%等通配符来配合查询。</p><p> MySQL是一种___多用户 _(多用户、单用户)的数据库管理系统。</p><p> 对一个超过200个汉字的内容，应用一个<strong>varchar或者text</strong>型的字段来存放。</p><p> 查看当前数据库中表名语句是<strong><strong>_</strong></strong>;</p><p> Mysql数据库GD2312、utf8\utf8mb4字符集的区别<strong>___</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql-50题</title>
      <link href="/2019/05/23/mysql-50%E9%A2%98/"/>
      <url>/2019/05/23/mysql-50%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="数据表介绍"><a href="#数据表介绍" class="headerlink" title="数据表介绍"></a>数据表介绍</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1.学生表</span></span><br><span class="line">Student(SId,Sname,Sage,Ssex)</span><br><span class="line"><span class="comment">--SId 学生编号,Sname 学生姓名,Sage 出生年月,Ssex 学生性别</span></span><br><span class="line"><span class="comment">--2.课程表</span></span><br><span class="line">Course(CId,Cname,TId)</span><br><span class="line"><span class="comment">--CId 课程编号,Cname 课程名称,TId 教师编号</span></span><br><span class="line"><span class="comment">--3.教师表</span></span><br><span class="line">Teacher(TId,Tname)</span><br><span class="line"><span class="comment">--TId 教师编号,Tname 教师姓名</span></span><br><span class="line"><span class="comment">--4.成绩表</span></span><br><span class="line">SC(SId,CId,score)</span><br><span class="line"><span class="comment">--SId 学生编号,CId 课程编号,score 分数</span></span><br></pre></td></tr></table></figure><h3 id="练习题目"><a href="#练习题目" class="headerlink" title="练习题目"></a>练习题目</h3><p>1.查询” 01 “课程比” 02 “课程成绩高的学生的信息及课程分数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 此处可以先考虑分别查询 01和02课程的学员id和分数</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">SId</span>,score <span class="keyword">from</span> SC <span class="keyword">where</span> CId = <span class="string">'01'</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">SId</span>,score <span class="keyword">from</span> SC <span class="keyword">where</span> CId = <span class="string">'02'</span>;</span><br><span class="line"><span class="comment">-- 对比结果可以清楚的知道,两个表中有些SId不对应,不对应就没有可比性</span></span><br><span class="line"><span class="comment">-- 因此可以对两个结果做join,条件就是SId要相等,</span></span><br><span class="line"><span class="comment">-- 并且01的成绩要比02大</span></span><br><span class="line"><span class="keyword">select</span> s1.SId,s1.score</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">SId</span>,score <span class="keyword">from</span> SC <span class="keyword">where</span> CId = <span class="string">'01'</span>) s1</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">SId</span>,score <span class="keyword">from</span> SC <span class="keyword">where</span> CId = <span class="string">'02'</span>) s2</span><br><span class="line"><span class="keyword">on</span> s1.SId = s2.SId</span><br><span class="line"><span class="keyword">where</span> s1.score &gt; s2.score</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 通过以上的sql得到了符合条件的学员id和分数,再到学员表中获取学员信息</span></span><br><span class="line"><span class="keyword">select</span> stu.SId,stu.Sname,s.score </span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">as</span> stu </span><br><span class="line"><span class="keyword">right</span> <span class="keyword">join</span> (</span><br><span class="line">        <span class="keyword">select</span> s1.SId,s1.score</span><br><span class="line">        <span class="keyword">from</span> </span><br><span class="line">        (<span class="keyword">select</span> <span class="keyword">SId</span>,score <span class="keyword">from</span> SC <span class="keyword">where</span> CId = <span class="string">'01'</span>) s1</span><br><span class="line">        <span class="keyword">join</span></span><br><span class="line">        (<span class="keyword">select</span> <span class="keyword">SId</span>,score <span class="keyword">from</span> SC <span class="keyword">where</span> CId = <span class="string">'02'</span>) s2</span><br><span class="line">        <span class="keyword">on</span> s1.SId = s2.SId</span><br><span class="line">        <span class="keyword">where</span> s1.score &gt; s2.score</span><br><span class="line">    ) <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">on</span> stu.SId = s.SId;</span><br></pre></td></tr></table></figure><ol><li>查询同时存在” 01 “课程和” 02 “课程的情况</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 本题和上一题内容相似,我们只需要把01和02的学员的SID作为连接条件就可以</span></span><br><span class="line"><span class="keyword">select</span> s1.*</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">SId</span>,score <span class="keyword">from</span> SC <span class="keyword">where</span> CId = <span class="string">'01'</span>) s1</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">SId</span>,score <span class="keyword">from</span> SC <span class="keyword">where</span> CId = <span class="string">'02'</span>) s2</span><br><span class="line"><span class="keyword">on</span> s1.SId = s2.SId</span><br></pre></td></tr></table></figure><ol><li>查询存在” 01 “课程但可能不存在” 02 “课程的情况(不存在时显示为 null )</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s1.SId,s2.score</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">SId</span>,score <span class="keyword">from</span> SC <span class="keyword">where</span> CId = <span class="string">'01'</span>) s1</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">SId</span>,score <span class="keyword">from</span> SC <span class="keyword">where</span> CId = <span class="string">'02'</span>) s2</span><br><span class="line"><span class="keyword">on</span> s1.SId = s2.SId</span><br></pre></td></tr></table></figure><ol><li>查询不存在” 01 “课程但存在” 02 “课程的情况</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> SC </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">SId</span> <span class="keyword">not</span> <span class="keyword">in</span>(<span class="keyword">select</span> <span class="keyword">SId</span> <span class="keyword">from</span> SC <span class="keyword">where</span> CId = <span class="string">'01'</span>)</span><br><span class="line"><span class="keyword">and</span> CId = <span class="string">'02'</span></span><br></pre></td></tr></table></figure><p>5.查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 此题主要考核 分组后的条件过滤</span></span><br><span class="line"><span class="keyword">select</span> SC.SId,Sname,<span class="keyword">round</span>(<span class="keyword">avg</span>(score),<span class="number">2</span>) <span class="keyword">as</span> avg_score</span><br><span class="line"><span class="keyword">from</span> SC,Student</span><br><span class="line"><span class="keyword">where</span> SC.SId = Student.SId</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> SC.SId,Sname <span class="keyword">having</span> avg_score &gt;= <span class="number">60</span>;</span><br></pre></td></tr></table></figure><p>6.查询在 SC 表存在成绩的学生信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 此题主要考核 数据去重 distinct </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> stu.* <span class="keyword">from</span> Student stu <span class="keyword">join</span> SC <span class="keyword">on</span> SC.SId = stu.SId;</span><br></pre></td></tr></table></figure><p>7.查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩(没成绩的显示为 null )</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> stu.SId,stu.Sname,<span class="keyword">count</span>(SC.CId) <span class="keyword">as</span> total ,<span class="keyword">sum</span>(SC.score) <span class="keyword">as</span> sum_score</span><br><span class="line"><span class="keyword">from</span> Student <span class="keyword">as</span> stu <span class="keyword">left</span> <span class="keyword">join</span> SC <span class="keyword">on</span> stu.SId = SC.SId</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> stu.SId,stu.Sname;</span><br></pre></td></tr></table></figure><p>8.查询「李」姓老师的数量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> teacher <span class="keyword">where</span> Tname <span class="keyword">like</span> <span class="string">'李%'</span>;</span><br></pre></td></tr></table></figure><p>9.查询学过「张三」老师授课的同学的信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> stu.*</span><br><span class="line"><span class="keyword">from</span> Student <span class="keyword">as</span> stu </span><br><span class="line"><span class="keyword">join</span> SC <span class="keyword">on</span> stu.SId = SC.SId</span><br><span class="line"><span class="keyword">join</span> course <span class="keyword">as</span> C <span class="keyword">on</span> SC.CId = C.CId</span><br><span class="line"><span class="keyword">join</span> Teacher <span class="keyword">as</span> T <span class="keyword">on</span> C.TId = T.TId</span><br><span class="line"><span class="keyword">where</span> T.Tname = <span class="string">'张三'</span>;</span><br></pre></td></tr></table></figure><p>10.查询没有学全所有课程的同学的信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 排除法,找到所有学过全部课程的学生,</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> Student <span class="keyword">where</span> <span class="keyword">SId</span> <span class="keyword">not</span> <span class="keyword">in</span>(</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">SId</span> <span class="keyword">from</span> SC <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">SId</span> <span class="keyword">having</span> <span class="keyword">count</span>(CId) = (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> course)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>11.查询至少有一门课与学号为” 01 “的同学所学相同的同学的信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> stu.* </span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">as</span> stu </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> sc <span class="keyword">on</span> sc.SId = stu.SId </span><br><span class="line"><span class="keyword">where</span> sc.CId <span class="keyword">in</span> (<span class="keyword">select</span> CId <span class="keyword">from</span> sc <span class="keyword">where</span> <span class="keyword">SId</span> = <span class="string">'01'</span>);</span><br></pre></td></tr></table></figure><p>12.查询和” 01 “号的同学学习的课程   完全相同的其他同学的信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 注意要对比的是课程ID号,在对比课程数</span></span><br><span class="line"><span class="keyword">select</span> s2.SId</span><br><span class="line"><span class="keyword">from</span> SC <span class="keyword">as</span> s1 <span class="keyword">join</span> SC <span class="keyword">as</span> s2</span><br><span class="line"><span class="keyword">on</span> s1.CId = s2.CId <span class="keyword">and</span> s1.SId = <span class="string">'01'</span> <span class="keyword">and</span> s2.SId != <span class="string">'01'</span>  </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s2.SId </span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(s1.SId) = (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> SC <span class="keyword">where</span> <span class="keyword">SId</span> = <span class="string">'01'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> stu.* </span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">as</span> stu </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> sc <span class="keyword">on</span> sc.SId = stu.SId </span><br><span class="line"><span class="keyword">join</span> ( <span class="keyword">select</span> CId <span class="keyword">from</span> sc <span class="keyword">where</span> <span class="keyword">SId</span> = <span class="string">'01'</span>) <span class="keyword">as</span> t <span class="keyword">on</span> t.CId = sc.CId </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> stu.SId <span class="keyword">having</span> <span class="keyword">count</span>(sc.SId) = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>13.查询没学过”张三”老师讲授的任一门课程的学生姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">SId</span>,Sname <span class="keyword">from</span> Student <span class="keyword">where</span> <span class="keyword">SId</span> <span class="keyword">not</span> <span class="keyword">in</span> </span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">SId</span> <span class="keyword">from</span> SC</span><br><span class="line">    <span class="keyword">where</span> CId = (</span><br><span class="line">        <span class="keyword">select</span> Course.Cid <span class="keyword">from</span> Course </span><br><span class="line">        <span class="keyword">join</span> Teacher <span class="keyword">on</span> Teacher.TId = Course.TId </span><br><span class="line">        <span class="keyword">where</span> Teacher.Tname = <span class="string">'张三'</span></span><br><span class="line">        ))</span><br></pre></td></tr></table></figure><p>14.查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SC.SId,Student.Sname,<span class="keyword">round</span>(<span class="keyword">avg</span>(SC.score),<span class="number">2</span>) <span class="keyword">as</span> avg_sc </span><br><span class="line"><span class="keyword">from</span> SC <span class="keyword">join</span> Student <span class="keyword">on</span> Student.SId = SC.SId</span><br><span class="line"><span class="keyword">where</span> SC.score &lt; <span class="number">60</span> <span class="keyword">group</span> <span class="keyword">by</span> SC.SId,Student.Sname </span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(SC.CId) &gt;=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>15.检索” 01 “课程分数小于 60，按分数降序排列的学生信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SC.SId,Student.Sname,SC.score</span><br><span class="line"><span class="keyword">from</span> SC <span class="keyword">join</span> Student  <span class="keyword">on</span> SC.SId = Student.SId </span><br><span class="line"><span class="keyword">where</span> SC.CId = <span class="string">'01'</span> <span class="keyword">and</span> SC.score &lt; <span class="number">60</span> </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> SC.score <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>16.按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SC.*,s2.avg_sc <span class="keyword">from</span> SC </span><br><span class="line"><span class="keyword">join</span>  (<span class="keyword">select</span> <span class="keyword">SId</span>, <span class="keyword">avg</span>(score) <span class="keyword">as</span> avg_sc <span class="keyword">from</span> SC <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">SId</span>) <span class="keyword">as</span> s2</span><br><span class="line"><span class="keyword">on</span> SC.SId = s2.SId</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> avg_sc <span class="keyword">desc</span>, SC.SId;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--最佳解决方案 王宇鹏</span></span><br><span class="line"><span class="keyword">select</span> a.sname,b.score 语文,c.score 数学,d.score 英语,<span class="keyword">avg</span>(e.score) </span><br><span class="line"><span class="keyword">from</span> student a </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> sc b <span class="keyword">on</span> a.sid=b.sid <span class="keyword">and</span> b.cid=<span class="string">'01'</span> </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> sc c <span class="keyword">on</span> a.sid=c.sid <span class="keyword">and</span> c.cid=<span class="string">'02'</span> </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> sc d <span class="keyword">on</span> a.sid=d.sid <span class="keyword">and</span> d.cid=<span class="string">'03'</span> </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> sc e <span class="keyword">on</span> a.sid=e.sid </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a.sname,语文,数学,英语</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">avg</span>(e.score) <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>17.查询各科成绩最高分、最低分和平均分：<br>以如下形式显示：课程 ID，课程 name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率 及格为&gt;=60，中等为：70-80，优良为：80-90，优秀为：&gt;=90<br>要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SC.CId,C.Cname,</span><br><span class="line"><span class="keyword">max</span>(SC.score) <span class="keyword">as</span> <span class="string">'最高分'</span>,</span><br><span class="line"><span class="keyword">min</span>(SC.score) <span class="keyword">as</span> <span class="string">'最低分'</span>,</span><br><span class="line"><span class="keyword">avg</span>(SC.score) <span class="keyword">as</span> <span class="string">'平均分'</span>,</span><br><span class="line"><span class="keyword">count</span>(SC.CId) <span class="keyword">as</span> <span class="string">'选修人数'</span>,</span><br><span class="line"><span class="keyword">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> SC.score &gt;= <span class="number">60</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) / <span class="keyword">count</span>(SC.CId) <span class="keyword">as</span> <span class="string">'及格率'</span>,</span><br><span class="line"><span class="keyword">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> SC.score &gt;= <span class="number">70</span> <span class="keyword">and</span> SC.score &lt; <span class="number">80</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) / <span class="keyword">count</span>(SC.CId) <span class="keyword">as</span> <span class="string">'中等率'</span>,</span><br><span class="line"><span class="keyword">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> SC.score &gt;= <span class="number">80</span> <span class="keyword">and</span> SC.score &lt; <span class="number">90</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) / <span class="keyword">count</span>(SC.CId) <span class="keyword">as</span> <span class="string">'优良率'</span>,</span><br><span class="line"><span class="keyword">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> SC.score &gt;= <span class="number">90</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) / <span class="keyword">count</span>(SC.CId) <span class="keyword">as</span> <span class="string">'优秀率'</span></span><br><span class="line"><span class="keyword">from</span> SC,Course <span class="keyword">as</span> C</span><br><span class="line"><span class="keyword">where</span> SC.CId = C.CId</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> SC.CId,C.Cname</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="string">'选修人数'</span> <span class="keyword">desc</span>,SC.CId;</span><br></pre></td></tr></table></figure><p>18.按各科平均成绩进行排序，并显示排名， Score 重复时保留名次空缺</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s2.CId,s2.avg_sc,<span class="keyword">count</span>(<span class="keyword">distinct</span> s1.avg_sc) <span class="keyword">as</span> <span class="keyword">Rank</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span>  <span class="keyword">avg</span>(score) <span class="keyword">as</span> avg_sc <span class="keyword">from</span> SC <span class="keyword">group</span> <span class="keyword">by</span> CId) <span class="keyword">as</span> s1</span><br><span class="line"><span class="keyword">join</span> </span><br><span class="line">(<span class="keyword">select</span> CId,<span class="keyword">avg</span>(score) <span class="keyword">as</span> avg_sc <span class="keyword">from</span> SC <span class="keyword">group</span> <span class="keyword">by</span> CId) <span class="keyword">as</span> s2</span><br><span class="line"><span class="keyword">on</span> s1.avg_sc &gt;= s2.avg_sc</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s2.CId <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">Rank</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 解析过程</span></span><br><span class="line"><span class="keyword">select</span> s1.*,s2.*</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span>  CId,<span class="keyword">avg</span>(score) <span class="keyword">as</span> avg_sc <span class="keyword">from</span> SC <span class="keyword">group</span> <span class="keyword">by</span> CId) <span class="keyword">as</span> s1</span><br><span class="line"><span class="keyword">join</span> </span><br><span class="line">(<span class="keyword">select</span> CId,<span class="keyword">avg</span>(score) <span class="keyword">as</span> avg_sc <span class="keyword">from</span> SC <span class="keyword">group</span> <span class="keyword">by</span> CId) <span class="keyword">as</span> s2</span><br><span class="line"><span class="keyword">on</span> s1.avg_sc &gt;= s2.avg_sc</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s2.CId <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">Rank</span>;</span><br><span class="line"><span class="comment">-- 在这种情况下 去统计s1.平均分 还是去统计s2.平均分 的次数,数据中都有重复</span></span><br><span class="line"><span class="comment">-- 如果能把s1中的出现重复的平均分数去重,再去按照s1.平均分去统计次数就正常</span></span><br><span class="line">    +<span class="comment">------+----------+------+----------+</span></span><br><span class="line">    | CId  | avg_sc   | CId  | avg_sc   |</span><br><span class="line">    +<span class="comment">------+----------+------+----------+</span></span><br><span class="line">    | 01   | 64.50000 | 01   | 64.50000 |</span><br><span class="line">    | 02   | 79.33333 | 01   | 64.50000 |</span><br><span class="line">    | 03   | 70.00000 | 01   | 64.50000 |</span><br><span class="line">    | 04   | 79.30000 | 01   | 64.50000 |</span><br><span class="line">  <span class="comment">--| 5    | 70.00000 | 01   | 64.50000 |</span></span><br><span class="line">    | 02   | 79.33333 | 02   | 79.33333 |</span><br><span class="line">    | 02   | 79.33333 | 03   | 70.00000 |</span><br><span class="line">    | 03   | 70.00000 | 03   | 70.00000 |</span><br><span class="line">    | 04   | 79.30000 | 03   | 70.00000 |</span><br><span class="line">  <span class="comment">--| 5    | 70.00000 | 03   | 70.00000 |</span></span><br><span class="line">    | 02   | 79.33333 | 04   | 79.30000 |</span><br><span class="line">    | 04   | 79.30000 | 04   | 79.30000 |</span><br><span class="line">    | 02   | 79.33333 | 5    | 70.00000 |</span><br><span class="line">    | 03   | 70.00000 | 5    | 70.00000 |</span><br><span class="line">    | 04   | 79.30000 | 5    | 70.00000 |</span><br><span class="line">  <span class="comment">--| 5    | 70.00000 | 5    | 70.00000 |</span></span><br><span class="line">    +<span class="comment">------+----------+------+----------+</span></span><br></pre></td></tr></table></figure><p>19.按各科平均成绩进行排序，并显示排名， Score 重复时不保留名次空缺</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> b.CId,b.avg_sc,@i := @i+<span class="number">1</span> <span class="keyword">as</span> <span class="keyword">Rank</span> </span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> @i := <span class="number">0</span>) a,</span><br><span class="line">(<span class="keyword">select</span> CId,<span class="keyword">round</span>(<span class="keyword">avg</span>(Score),<span class="number">2</span>) <span class="keyword">as</span> avg_sc <span class="keyword">from</span> SC <span class="keyword">group</span> <span class="keyword">by</span> CId <span class="keyword">order</span> <span class="keyword">by</span> avg_sc <span class="keyword">desc</span>) b;</span><br></pre></td></tr></table></figure><p>20.查询学生的总成绩，并进行排名，总分重复时保留名次空缺</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s2.SId,s2.avg_sc,<span class="keyword">count</span>(<span class="keyword">distinct</span> s1.avg_sc) <span class="keyword">as</span> <span class="keyword">Rank</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span>  <span class="keyword">sum</span>(score) <span class="keyword">as</span> avg_sc <span class="keyword">from</span> SC <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">SId</span>) <span class="keyword">as</span> s1</span><br><span class="line"><span class="keyword">join</span> </span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">SId</span>,<span class="keyword">sum</span>(score) <span class="keyword">as</span> avg_sc <span class="keyword">from</span> SC <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">SId</span>) <span class="keyword">as</span> s2</span><br><span class="line"><span class="keyword">on</span> s1.avg_sc &gt;= s2.avg_sc</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s2.SId <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">Rank</span>;</span><br></pre></td></tr></table></figure><p>21.查询学生的总成绩，并进行排名，总分重复时不保留名次空缺</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> b.SId,b.avg_sc,@i := @i+<span class="number">1</span> <span class="keyword">as</span> <span class="keyword">Rank</span> </span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> @i := <span class="number">0</span>) a,</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">SId</span>,<span class="keyword">sum</span>(Score) <span class="keyword">as</span> avg_sc <span class="keyword">from</span> SC <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">sId</span> <span class="keyword">order</span> <span class="keyword">by</span> avg_sc <span class="keyword">desc</span>) b;</span><br></pre></td></tr></table></figure><p>22.统计各科成绩各分数段人数：课程编号，课程名称，[100-85]，[85-70]，[70-60]，[60-0]及所占百分比</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Course.CId,Course.Cname,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> SC.score &gt;= <span class="number">85</span> <span class="keyword">and</span> SC.score &lt;= <span class="number">100</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="string">'[100-85]'</span>,</span><br><span class="line"><span class="keyword">concat</span>(<span class="keyword">round</span>(<span class="keyword">sum</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> SC.score &gt;= <span class="number">85</span> <span class="keyword">and</span> SC.score &lt;= <span class="number">100</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>)/<span class="keyword">count</span>(SC.SId),<span class="number">2</span>)*<span class="number">100</span>,<span class="string">'%'</span>) <span class="keyword">as</span> <span class="string">'百分比'</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> SC.score &gt;= <span class="number">70</span> <span class="keyword">and</span> SC.score &lt; <span class="number">85</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="string">'[85-70]'</span>,</span><br><span class="line"><span class="keyword">concat</span>(<span class="keyword">round</span>(<span class="keyword">sum</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> SC.score &gt;= <span class="number">70</span> <span class="keyword">and</span> SC.score &lt; <span class="number">85</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>)/<span class="keyword">count</span>(SC.SId),<span class="number">2</span>)*<span class="number">100</span>,<span class="string">'%'</span>) <span class="keyword">as</span> <span class="string">'百分比'</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> SC.score &gt;= <span class="number">60</span> <span class="keyword">and</span> SC.score &lt; <span class="number">70</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="string">'[70-60]'</span>,</span><br><span class="line"><span class="keyword">concat</span>(<span class="keyword">round</span>(<span class="keyword">sum</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> SC.score &gt;= <span class="number">60</span> <span class="keyword">and</span> SC.score &lt; <span class="number">70</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>)/<span class="keyword">count</span>(SC.SId),<span class="number">2</span>)*<span class="number">100</span>,<span class="string">'%'</span>) <span class="keyword">as</span> <span class="string">'百分比'</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> SC.score &gt;= <span class="number">0</span> <span class="keyword">and</span> SC.score &lt; <span class="number">60</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="string">'[60-0]'</span>,</span><br><span class="line"><span class="keyword">concat</span>(<span class="keyword">round</span>(<span class="keyword">sum</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> SC.score &gt;= <span class="number">0</span> <span class="keyword">and</span> SC.score &lt; <span class="number">60</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>)/<span class="keyword">count</span>(SC.SId),<span class="number">2</span>)*<span class="number">100</span>,<span class="string">'%'</span>) <span class="keyword">as</span> <span class="string">'百分比'</span></span><br><span class="line"><span class="keyword">from</span> SC,Course</span><br><span class="line"><span class="keyword">where</span> SC.CId = Course.CId</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Course.CId,Course.Cname;</span><br></pre></td></tr></table></figure><p>23.查询各科成绩前三名的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">select</span> CId,score <span class="keyword">from</span> SC <span class="keyword">where</span> CId = <span class="string">'01'</span> <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">3</span>) </span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">(<span class="keyword">select</span> CId,score <span class="keyword">from</span> SC <span class="keyword">where</span> CId = <span class="string">'02'</span> <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">3</span>) </span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">(<span class="keyword">select</span> CId,score <span class="keyword">from</span> SC <span class="keyword">where</span> CId = <span class="string">'03'</span> <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>24.查询每门课程被选修的学生数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> CId,<span class="keyword">count</span>(<span class="keyword">SId</span>) <span class="keyword">from</span> SC <span class="keyword">group</span> <span class="keyword">by</span> CId;</span><br></pre></td></tr></table></figure><p>25.查询出只选修两门课程的学生学号和姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SC.SId,Student.Sname</span><br><span class="line"><span class="keyword">from</span> SC <span class="keyword">join</span> Student <span class="keyword">on</span> SC.SId = Student.SId</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> SC.SId,Student.Sname <span class="keyword">having</span> <span class="keyword">count</span>(SC.CId) = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>26.查询男生、女生人数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Ssex,<span class="keyword">count</span>(*) <span class="keyword">from</span> Student <span class="keyword">group</span> <span class="keyword">by</span> Ssex;</span><br></pre></td></tr></table></figure><p>27.查询名字中含有「风」字的学生信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> Student <span class="keyword">where</span> Sname <span class="keyword">like</span> <span class="string">'%风%'</span>;</span><br></pre></td></tr></table></figure><p>28.查询同名同性学生名单，并统计同名人数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s1.Sname,<span class="keyword">count</span>(s1.Sname)</span><br><span class="line"><span class="keyword">from</span> Student s1 <span class="keyword">join</span> Student s2 </span><br><span class="line"><span class="keyword">on</span> s1.Sname = s2.Sname <span class="keyword">and</span> s1.Ssex = s2.Ssex <span class="keyword">and</span> s1.SId != s2.SId</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s1.Sname;</span><br></pre></td></tr></table></figure><p>29.查询 1990 年出生的学生名单</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> Student <span class="keyword">where</span> <span class="keyword">year</span>(Sage) = <span class="number">1990</span>;</span><br></pre></td></tr></table></figure><p>30.查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> CId,<span class="keyword">avg</span>(score) <span class="keyword">as</span> avg_sc </span><br><span class="line"><span class="keyword">from</span> SC <span class="keyword">group</span> <span class="keyword">by</span> CId <span class="keyword">order</span> <span class="keyword">by</span> avg_sc <span class="keyword">desc</span>,CId;</span><br></pre></td></tr></table></figure><p>31.查询平均成绩大于等于 85 的所有学生的学号、姓名和平均成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SC.SId,Stu.Sname,<span class="keyword">round</span>(<span class="keyword">avg</span>(SC.score),<span class="number">2</span>) <span class="keyword">as</span> avg_sc </span><br><span class="line"><span class="keyword">from</span> SC <span class="keyword">join</span> Student <span class="keyword">as</span> Stu <span class="keyword">on</span> SC.SId = Stu.SId</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> SC.SId,Stu.Sname <span class="keyword">having</span> avg_sc &gt;= <span class="number">85</span>;</span><br></pre></td></tr></table></figure><p>32.查询课程名称为「数学」，且分数低于 60 的学生姓名和分数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> C.Cname,Stu.Sname,SC.score</span><br><span class="line"><span class="keyword">from</span> Course <span class="keyword">as</span> C <span class="keyword">join</span> SC  <span class="keyword">on</span> C.CId = SC.CId </span><br><span class="line"><span class="keyword">join</span> Student <span class="keyword">as</span> Stu <span class="keyword">on</span> SC.SId = Stu.SId</span><br><span class="line"><span class="keyword">where</span> C.Cname = <span class="string">'数学'</span> <span class="keyword">and</span> SC.score &lt; <span class="number">60</span>;</span><br></pre></td></tr></table></figure><p>33.查询所有学生的课程及分数情况（存在学生没成绩，没选课的情况）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Student.Sname,Course.Cname,SC.score</span><br><span class="line"><span class="keyword">from</span> Student <span class="keyword">left</span> <span class="keyword">join</span> SC <span class="keyword">on</span> Student.SId = SC.SId</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> Course <span class="keyword">on</span> SC.CId = Course.CId</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> Student.Sname;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 张波</span></span><br><span class="line"><span class="keyword">select</span> a.SId,a.sname,b.score 语文,c.score 数学,d.score 英语 </span><br><span class="line"><span class="keyword">from</span> student a </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> sc b <span class="keyword">on</span> a.sid=b.sid <span class="keyword">and</span> b.cid=<span class="string">'01'</span> </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> sc c <span class="keyword">on</span> a.sid=c.sid <span class="keyword">and</span> c.cid=<span class="string">'02'</span> </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> sc d <span class="keyword">on</span> a.sid=d.sid <span class="keyword">and</span> d.cid=<span class="string">'03'</span> </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a.SId,a.sname,语文,数学,英语</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> a.Sid;</span><br></pre></td></tr></table></figure><p>34.查询任何一门课程成绩在 70 分以上的姓名、课程名称和分数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Student.Sname,Course.Cname,SC.score</span><br><span class="line"><span class="keyword">from</span> Student,Course,SC </span><br><span class="line"><span class="keyword">where</span> Student.SId = SC.SId <span class="keyword">and</span> SC.CId = Course.CId</span><br><span class="line"><span class="keyword">and</span> SC.score &gt; <span class="number">70</span>;</span><br></pre></td></tr></table></figure><p>35.查询不及格的课程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Student.Sname,Course.Cname,SC.score</span><br><span class="line"><span class="keyword">from</span> Student,Course,SC </span><br><span class="line"><span class="keyword">where</span> Student.SId = SC.SId <span class="keyword">and</span> SC.CId = Course.CId</span><br><span class="line"><span class="keyword">and</span> SC.score &lt; <span class="number">60</span>;</span><br></pre></td></tr></table></figure><p>36.查询课程编号为 01 且课程成绩在 80 分以上的学生的学号和姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SC.SId,Student.Sname</span><br><span class="line"><span class="keyword">from</span> SC <span class="keyword">join</span> Student <span class="keyword">on</span> SC.SId = Student.SId</span><br><span class="line"><span class="keyword">where</span> SC.Score &gt; <span class="number">80</span> <span class="keyword">and</span> SC.CId = <span class="string">'01'</span>;</span><br></pre></td></tr></table></figure><p>37.求每门课程的学生人数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> CId,<span class="keyword">count</span>(<span class="keyword">SId</span>) <span class="keyword">from</span> SC <span class="keyword">group</span> <span class="keyword">by</span> CId;</span><br></pre></td></tr></table></figure><p>38.成绩不重复，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Student.SId,Student.Sname,SC.score</span><br><span class="line"><span class="keyword">from</span> Student <span class="keyword">join</span> SC <span class="keyword">on</span> Student.SId = SC.SId</span><br><span class="line"><span class="keyword">join</span> Course <span class="keyword">on</span> SC.CId = Course.CId</span><br><span class="line"><span class="keyword">join</span> Teacher <span class="keyword">on</span> Teacher.TId = Course.TId</span><br><span class="line"><span class="keyword">where</span> Teacher.Tname = <span class="string">'张三'</span>;</span><br><span class="line">order by SC.score desc limit 1;</span><br></pre></td></tr></table></figure><p>39.成绩有重复的情况下，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询张三老师授课的学生中最高分数,查询所有等于最高分的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- -- 先查询最高分数</span></span><br><span class="line"><span class="comment">-- select max(SC.score) </span></span><br><span class="line"><span class="comment">-- from SC join Course on SC.CId = Course.CId</span></span><br><span class="line"><span class="comment">-- join Teacher on Teacher.TId = Course.TId</span></span><br><span class="line"><span class="comment">-- where Teacher.Tname = '张三'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 追加 分数条件</span></span><br><span class="line"><span class="keyword">select</span> Student.SId,Student.Sname,SC.score</span><br><span class="line"><span class="keyword">from</span> Student <span class="keyword">join</span> SC <span class="keyword">on</span> Student.SId = SC.SId</span><br><span class="line"><span class="keyword">join</span> Course <span class="keyword">on</span> SC.CId = Course.CId</span><br><span class="line"><span class="keyword">join</span> Teacher <span class="keyword">on</span> Teacher.TId = Course.TId</span><br><span class="line"><span class="keyword">where</span> Teacher.Tname = <span class="string">'张三'</span> </span><br><span class="line"><span class="keyword">and</span> SC.score = (<span class="keyword">select</span> <span class="keyword">max</span>(SC.score) </span><br><span class="line"><span class="keyword">from</span> SC <span class="keyword">join</span> Course <span class="keyword">on</span> SC.CId = Course.CId</span><br><span class="line"><span class="keyword">join</span> Teacher <span class="keyword">on</span> Teacher.TId = Course.TId</span><br><span class="line"><span class="keyword">where</span> Teacher.Tname = <span class="string">'张三'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 王宇鹏</span></span><br><span class="line"><span class="keyword">select</span> a.sname,b.score </span><br><span class="line"><span class="keyword">from</span> student a <span class="keyword">join</span> sc b <span class="keyword">on</span> a.sid=b.sid </span><br><span class="line"><span class="keyword">and</span> b.cid <span class="keyword">in</span> (<span class="keyword">select</span> cid <span class="keyword">from</span> course <span class="keyword">where</span> tid <span class="keyword">in</span> (<span class="keyword">select</span> tid <span class="keyword">from</span> teacher <span class="keyword">where</span> tname=<span class="string">'张三'</span>)) </span><br><span class="line"><span class="keyword">join</span> (<span class="keyword">select</span> cid,<span class="keyword">max</span>(score) m <span class="keyword">from</span> sc <span class="keyword">group</span> <span class="keyword">by</span> cid) c <span class="keyword">on</span> b.cid=c.cid <span class="keyword">and</span> b.score=c.m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 张波</span></span><br><span class="line"><span class="keyword">select</span> stu.*,</span><br><span class="line"><span class="keyword">max</span>(SC.score) <span class="keyword">as</span> 成绩</span><br><span class="line"><span class="keyword">from</span> Student <span class="keyword">as</span> stu </span><br><span class="line"><span class="keyword">join</span> SC <span class="keyword">on</span> stu.SId = SC.SId</span><br><span class="line"><span class="keyword">join</span> course <span class="keyword">as</span> C <span class="keyword">on</span> SC.CId = C.CId</span><br><span class="line"><span class="keyword">join</span> Teacher <span class="keyword">as</span> T <span class="keyword">on</span> C.TId = T.TId</span><br><span class="line"><span class="keyword">where</span> T.Tname = <span class="string">'张三'</span>;</span><br></pre></td></tr></table></figure><p>40.查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  s1.CId,s1.SId,s1.Score</span><br><span class="line"><span class="keyword">from</span> SC s1 <span class="keyword">join</span> SC s2</span><br><span class="line"><span class="keyword">on</span> s1.CId != s2.CId <span class="keyword">and</span> s1.score = s2.score <span class="keyword">and</span> s1.SId = s2.SId</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> s1.Score;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> s1.SId,s1.CId,s1.Score</span><br><span class="line"><span class="keyword">from</span> SC s1 <span class="keyword">join</span> SC s2 </span><br><span class="line"><span class="keyword">on</span> s1.CId != s2.CId <span class="keyword">and</span> s1.score = s2.score</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>  s1.SId,s1.CId,s1.Score</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> s1.sid,s1.cid,s1.score </span><br><span class="line"><span class="keyword">FROM</span> sc s1,sc s2 <span class="keyword">WHERE</span> s1.cid != s2.cid <span class="keyword">AND</span> s1.score = s2.score</span><br></pre></td></tr></table></figure><p>41.查询每门课程成绩最好的前两名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">select</span> CId,score <span class="keyword">from</span> SC <span class="keyword">where</span> CId = <span class="string">'01'</span> <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">2</span>) </span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">(<span class="keyword">select</span> CId,score <span class="keyword">from</span> SC <span class="keyword">where</span> CId = <span class="string">'02'</span> <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">2</span>) </span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">(<span class="keyword">select</span> CId,score <span class="keyword">from</span> SC <span class="keyword">where</span> CId = <span class="string">'03'</span> <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>42.统计每门课程的学生选修人数（超过 5 人的课程才统计）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> CId,<span class="keyword">count</span>(<span class="keyword">SId</span>) <span class="keyword">from</span> SC <span class="keyword">group</span> <span class="keyword">by</span> CId <span class="keyword">having</span> <span class="keyword">count</span>(<span class="keyword">SId</span>) &gt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>43.检索至少选修两门课程的学生学号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">SId</span>,<span class="keyword">count</span>(CId) <span class="keyword">as</span> <span class="keyword">num</span> <span class="keyword">from</span> SC <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">SId</span> <span class="keyword">having</span> <span class="keyword">num</span> &gt;=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>44.查询选修了全部课程的学生信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">SId</span> <span class="keyword">from</span> SC <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">SId</span> </span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(CId) = (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> Course);</span><br></pre></td></tr></table></figure><p>45.查询各学生的年龄，只按年份来算</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Stu.SId,Stu.Sname,(<span class="keyword">year</span>(<span class="keyword">now</span>()) - <span class="keyword">year</span>(Stu.Sage)) <span class="keyword">as</span> <span class="string">'年龄'</span> </span><br><span class="line"><span class="keyword">from</span> Student <span class="keyword">as</span> stu;</span><br></pre></td></tr></table></figure><p>46.按照出生日期来算，当前月日 &lt; 出生年月的月日则，年龄减一</p><blockquote><p>TIMESTAMPDIFF()   从日期时间表达式中减去间隔<br><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html</a></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> student.SId,student.Sname,</span><br><span class="line"><span class="keyword">TIMESTAMPDIFF</span>(<span class="keyword">YEAR</span>,student.Sage,<span class="keyword">CURDATE</span>()) <span class="keyword">from</span> student</span><br></pre></td></tr></table></figure><p>47.查询本周过生日的学生</p><blockquote><p>返回日期从范围内的数字日历星期1到53</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *<span class="keyword">from</span> student </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">WEEKOFYEAR</span>(student.Sage)=<span class="keyword">WEEKOFYEAR</span>(<span class="keyword">CURDATE</span>());</span><br></pre></td></tr></table></figure><p>48.查询下周过生日的学生</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> student </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">WEEKOFYEAR</span>(student.Sage)=<span class="keyword">WEEKOFYEAR</span>(<span class="keyword">CURDATE</span>())+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>49.查询本月过生日的学生</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> student </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">MONTH</span>(student.Sage)=<span class="keyword">MONTH</span>(<span class="keyword">CURDATE</span>());</span><br></pre></td></tr></table></figure><p>50.查询下月过生日的学生</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> student </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">MONTH</span>(student.Sage)=<span class="keyword">MONTH</span>(<span class="keyword">CURDATE</span>())+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="数据Data"><a href="#数据Data" class="headerlink" title="数据Data"></a>数据Data</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--学生表 Student</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Student(<span class="keyword">SId</span> <span class="built_in">varchar</span>(<span class="number">10</span>),Sname <span class="built_in">varchar</span>(<span class="number">10</span>),Sage datetime,Ssex <span class="built_in">varchar</span>(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'01'</span> , <span class="string">'赵雷'</span> , <span class="string">'1990-01-01'</span> , <span class="string">'男'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'02'</span> , <span class="string">'钱电'</span> , <span class="string">'1990-12-21'</span> , <span class="string">'男'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'03'</span> , <span class="string">'孙风'</span> , <span class="string">'1990-12-20'</span> , <span class="string">'男'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'04'</span> , <span class="string">'李云'</span> , <span class="string">'1990-12-06'</span> , <span class="string">'男'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'05'</span> , <span class="string">'周梅'</span> , <span class="string">'1991-12-01'</span> , <span class="string">'女'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'06'</span> , <span class="string">'吴兰'</span> , <span class="string">'1992-01-01'</span> , <span class="string">'女'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'07'</span> , <span class="string">'郑竹'</span> , <span class="string">'1989-01-01'</span> , <span class="string">'女'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'09'</span> , <span class="string">'张三'</span> , <span class="string">'2017-12-20'</span> , <span class="string">'女'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'10'</span> , <span class="string">'李四'</span> , <span class="string">'2017-12-25'</span> , <span class="string">'女'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'11'</span> , <span class="string">'李四'</span> , <span class="string">'2012-06-06'</span> , <span class="string">'女'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'12'</span> , <span class="string">'赵六'</span> , <span class="string">'2013-06-13'</span> , <span class="string">'女'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'13'</span> , <span class="string">'孙七'</span> , <span class="string">'2014-06-01'</span> , <span class="string">'女'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 科目表 Course</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Course(CId <span class="built_in">varchar</span>(<span class="number">10</span>),Cname <span class="keyword">nvarchar</span>(<span class="number">10</span>),TId <span class="built_in">varchar</span>(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">'01'</span> , <span class="string">'语文'</span> , <span class="string">'02'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">'02'</span> , <span class="string">'数学'</span> , <span class="string">'01'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">'03'</span> , <span class="string">'英语'</span> , <span class="string">'03'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 教师表 Teacher</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Teacher(TId <span class="built_in">varchar</span>(<span class="number">10</span>),Tname <span class="built_in">varchar</span>(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="string">'01'</span> , <span class="string">'张三'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="string">'02'</span> , <span class="string">'李四'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="string">'03'</span> , <span class="string">'王五'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 成绩表 SC</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> SC(<span class="keyword">SId</span> <span class="built_in">varchar</span>(<span class="number">10</span>),CId <span class="built_in">varchar</span>(<span class="number">10</span>),score <span class="built_in">decimal</span>(<span class="number">18</span>,<span class="number">1</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">'01'</span> , <span class="string">'01'</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">'01'</span> , <span class="string">'02'</span> , <span class="number">90</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">'01'</span> , <span class="string">'03'</span> , <span class="number">99</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">'02'</span> , <span class="string">'01'</span> , <span class="number">70</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">'02'</span> , <span class="string">'02'</span> , <span class="number">60</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">'02'</span> , <span class="string">'03'</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">'03'</span> , <span class="string">'01'</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">'03'</span> , <span class="string">'02'</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">'03'</span> , <span class="string">'03'</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">'04'</span> , <span class="string">'01'</span> , <span class="number">50</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">'04'</span> , <span class="string">'02'</span> , <span class="number">30</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">'04'</span> , <span class="string">'03'</span> , <span class="number">20</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">'05'</span> , <span class="string">'01'</span> , <span class="number">76</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">'05'</span> , <span class="string">'02'</span> , <span class="number">87</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">'06'</span> , <span class="string">'01'</span> , <span class="number">31</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">'06'</span> , <span class="string">'03'</span> , <span class="number">34</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">'07'</span> , <span class="string">'02'</span> , <span class="number">89</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">'07'</span> , <span class="string">'03'</span> , <span class="number">98</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="/2019/05/21/Redis/"/>
      <url>/2019/05/21/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>​    Redis 一个内存数据库，通过 Key-Value 键值对的的方式存储数据。由于 Redis 的数据都存储在内存中，所以访问速度非常快，因此 Redis &lt;u大量用于缓存系统&lt;/u，存储热点数据，可以极大的提高网站的响应速度。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>支持数据的持久化，通过配置可以将内存中的数据保存在磁盘中，Redis 重启以后再将数据加载到内存中；</li><li>支持列表，哈希，有序集合等数据结构</li><li>原子操作，Redis 的所有操作都是原子性的，这使得基于 Redis 实现分布式锁非常简单；</li><li>支持发布/订阅功能，数据过期功能；</li></ul><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">keys *  返回键（key）</span><br><span class="line">keys list*   返回名以list开头的所有键（key）</span><br><span class="line">exists list1  判断键名为list1的是否存在   存在返回1， 不存在返回0</span><br><span class="line">del list1 删除一个键（名为list1）</span><br><span class="line">expire list1 10 设置键名为list1的过期时间为10秒后</span><br><span class="line">ttl list1 查看键名为list1的过期时间，若为-1表示永不过期，-2表示已过期</span><br><span class="line">move age 1 将键名age的转移到1数据库中。</span><br><span class="line">select 1 表示进入到1数据库中，默认在0数据库</span><br><span class="line">persist age 移除age的过期时间</span><br><span class="line">flushdb  删除所有的数据 清除当前所在库的所有数据</span><br><span class="line">flushall 清空所有数据</span><br></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>常用五种: 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)</p><h4 id="String（字符串类型）"><a href="#String（字符串类型）" class="headerlink" title="String（字符串类型）"></a>String（字符串类型）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">set 键  值   键存在则只覆盖 例如： set name zhangsan</span><br><span class="line">get 键     获取一个键的值   例如：get name</span><br><span class="line">setnx 键 值   设置一个不存在的键和值（防止覆盖），   若键已存在则返回0表示失败</span><br><span class="line">setex 键 [有效时间] 值  设置一个指定有效期的键和值（单位秒） 例如: setex color 10 red</span><br><span class="line">setrange命令：替换子字符串 (替换长度由子子串长度决定)</span><br><span class="line">setrange 键 位置 子字串</span><br><span class="line">setrange name 4 aa  将name键对应值的第4个位置开始替换</span><br><span class="line">mset 键1 值1 键2 值2 键3 值3 .... 批量设置键和值,</span><br><span class="line">msetnx 键1 值1 键2 值2 键3 值3 ....   批量设置不存在的键和值</span><br><span class="line">getset命令：获取原值，并设置新值</span><br><span class="line">getrange命令：获取指定范围的值</span><br><span class="line">getrange 键 0 4     获取指定0到4位置上的值</span><br><span class="line">mget命令： 批量获取值</span><br><span class="line">mget 键1 键2 键3....</span><br><span class="line">incr命令： 指定键的值做加加操作，返回加后的结果。</span><br><span class="line">incrby命令： 设置某个键加上指定值</span><br><span class="line">incrby 键 m    其中m可以是正整数或负整数</span><br><span class="line">decr命令： 指定键的值做减减操作，返回减后的结果。</span><br><span class="line">decr 键        例如： decr kid</span><br><span class="line">decrby命令： 设置某个键减上指定值</span><br><span class="line">decrby 键 m    其中m可以是正整数或负整数</span><br><span class="line">append命令：给指定key的字符串追加value，返回新字符串值的长度</span><br><span class="line">append 键 追加字串</span><br><span class="line">strlen求长度 strlen 键名   返回对应的值。</span><br></pre></td></tr></table></figure><h4 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hset hash名 键  值  设置一个哈希表的键和值   如：hset user:001 name zhangsan</span><br><span class="line">hget命令： 获取执行哈希名中的键对应值</span><br><span class="line">hsetnx hash名 键  值  设置一个哈希表中不存在的键和值  成功返回1，失败返回0 如：hsetnx user:001 name zhangsan</span><br><span class="line">hmset user:001 username zhangsan age 20 sex 1 批量设置</span><br><span class="line">hmget user:001 username age sex 批量获取值</span><br><span class="line">hexists user:001 name 是否存在， 若存在返回1</span><br><span class="line">hlen user:001  获取某哈希user001名中键的数量</span><br><span class="line">hdel user:001 name 删除哈希user:001 中name键</span><br><span class="line">hkeys user:002   返回哈希名为user:002中的所有键。</span><br><span class="line">hvals user:002   返回哈希名为user:002中的所有值。</span><br><span class="line">hgetall user:002 返回哈希名为user:002中的所有键和值。</span><br></pre></td></tr></table></figure><h3 id="List列表（双向链表结构）"><a href="#List列表（双向链表结构）" class="headerlink" title="List列表（双向链表结构）"></a>List列表（双向链表结构）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">list即可以作为“栈”也可以作为&quot;队列&quot;。</span><br><span class="line">操作：</span><br><span class="line">lpush list1 &quot;world&quot;  在list1头部压入一个字串</span><br><span class="line">lpush list1 &quot;hello&quot;   在list1头部压入一个字串</span><br><span class="line">lrange list1 0 -1  获取list1中内容  0:表示开头  -1表示结尾。</span><br><span class="line">rpush list2 &quot;world&quot;  在list2尾部压入一个字串</span><br><span class="line">rpush list2 &quot;hello&quot;   在list2尾部压入一个字串</span><br><span class="line">lrange list2 0 -1  获取list2中内容  0:表示开头  -1表示结尾。</span><br><span class="line">linsert list2 before hello there  在key对应list的特定位置前或后添加字符串</span><br><span class="line">lset list2 1 &quot;four&quot; 修改指定索引位置上的值</span><br><span class="line">lrem list2 2 &quot;hello&quot;  删除前两个hello值</span><br><span class="line">lrem list2 -2 &quot;hello&quot; 删除后两个hello值</span><br><span class="line">lrem list2 0 &quot;hello&quot;  删除所有hello值</span><br><span class="line">ltrim mylist8 1 3    删除此范围外的值</span><br><span class="line">lpop list2   从list2的头部删除元素，并返回删除元素</span><br><span class="line">rpop list2   从list2的尾部删除元素，并返回删除元素</span><br><span class="line">rpoplpush list1 list2    将list1的尾部一个元素移出到list2头部。并返回</span><br><span class="line">lindex list2 1 返回list2中索引位置上的元素</span><br><span class="line">llen list2 返回list2上长度</span><br></pre></td></tr></table></figure><h4 id="Redis-集合-Set"><a href="#Redis-集合-Set" class="headerlink" title="Redis 集合(Set)"></a>Redis 集合(Set)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sadd myset &quot;hello&quot; 向myset中添加一个元素 成功返回1，失败(重复)返回0</span><br><span class="line">smembers myset 获取myset中的所有元素(结果是无序的)</span><br><span class="line">srem myset &quot;one&quot; 从myset中删除一个one  成功返回1，失败(不存在)返回</span><br><span class="line">spop myset 随机返回并删除myset中的一个元素</span><br><span class="line">srandmember myset 随机获取myset中的一个元素，但是不删除</span><br><span class="line">move myset1 myset2 zhangsan:将myset1中zhangsan移动到myset2中</span><br><span class="line">scard myset1 返回myset1的个数</span><br><span class="line">sismember myset zhangsan:判断张三是否在myset中</span><br><span class="line">sdiff myset1 myset2 返回两个集合的差集  以myset1为标准，获取myset2中不存在的。</span><br><span class="line">sdiffstore dstset myset1 myset2 ... 返回所有集合的差集，并保存到dstset中</span><br><span class="line">sinter myset1 myset2 myset3...  返回N个集合中的交集</span><br><span class="line">sinterstore dstset myset1 myset2 ...  返回N个集合的交集并存储到dstset中</span><br><span class="line">sunion myset1 myset2 ...返回所有集合的并集</span><br><span class="line">sunionstore dstset myset1 myset2 返回所有集合的并集，并存储到dstset中</span><br></pre></td></tr></table></figure><h3 id="Redis-有序集合Sset-sorted-set"><a href="#Redis-有序集合Sset-sorted-set" class="headerlink" title="Redis 有序集合Sset (sorted set)"></a>Redis 有序集合Sset (sorted set)</h3><p>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">zadd zset 70 张三向zset中添加zhangsan，分数为70</span><br><span class="line">zrem zset zhangsan:删除zset中zhangsan</span><br><span class="line">zincrby zset 60 zhangsan:如果zhangsan存在，分数增加60，如果zhangsan不存在，分数就是60</span><br><span class="line">zrange zset 0 -1 withscores:根据score排序（根据score从小到大排序）</span><br><span class="line">zrevrange zset 0 -1 withscores:根据score排序（根据score从大到小排序）</span><br><span class="line">zrank zset zhangsan:返回zhangsan在zset中排名(从小到大的排序)</span><br><span class="line">zrevrank zset zhangsan:返回zhangsan在zset中排名(从大到小的排序)</span><br><span class="line">zrangebyscore zset 60 80 withscores:返回集合中score在给定区间的元素（包含60和80）</span><br><span class="line">zcount zset 60 80:返回集合中给定区间的数量</span><br><span class="line">zcard zset:返回集合中元素的个数</span><br><span class="line">zscore zset zhangsan:返回zhangsan元素的score</span><br><span class="line">zremrangebyrank zset 3 3:删除集合中排名在给定区间的元素 (从小到大)</span><br><span class="line">zremrangebyscore zset 10 20:删除 zset中 分数在 指定区间的元素</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB</title>
      <link href="/2019/05/20/MongoDB/"/>
      <url>/2019/05/20/MongoDB/</url>
      
        <content type="html"><![CDATA[<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>MongoDB 是一个基于分布式文件存储的数据库,是一个介于关系数据库和非关系数据库之间的产品.</p><h4 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h4><ul><li>面向文档存储,文档是一组键值(key-value)对(即BSON)Binary JSON</li><li>MongoDB中可以为数据设置索引,以提高查询和排序的速度</li><li>Mongo支持丰富的查询表达式</li><li>MongoDB支持各种编程语言</li><li>MongoDB安装简单</li></ul><h4 id="MongoDB和mysql概念对比"><a href="#MongoDB和mysql概念对比" class="headerlink" title="MongoDB和mysql概念对比"></a>MongoDB和mysql概念对比</h4><table><thead><tr><th>SQL术语/概念</th><th>MongoDB术语/概念</th><th>解释/说明</th></tr></thead><tbody><tr><td>database</td><td>database</td><td>数据库</td></tr><tr><td>table</td><td>collection</td><td>数据库表/集合</td></tr><tr><td>row</td><td>document</td><td>数据记录行/文档</td></tr><tr><td>column</td><td>field</td><td>数据字段/域</td></tr><tr><td>index</td><td>index</td><td>索引</td></tr><tr><td>table joins</td><td></td><td>表连接,MongoDB不支持</td></tr><tr><td>primary key</td><td>primary key</td><td>主键,MongoDB自动将_id字段设置为主键</td></tr></tbody></table><h4 id="mongoDB命令"><a href="#mongoDB命令" class="headerlink" title="mongoDB命令"></a>mongoDB命令</h4><p><strong>“show dbs”</strong>命令可以显示所有数据的列表====同show databases</p><p><strong>“db”</strong>查看当前所载数据库</p><p><strong>“use”</strong>命令，可以连接到一个指定的数据库,若不存在则创建</p><h4 id="mongoDB插入文档"><a href="#mongoDB插入文档" class="headerlink" title="mongoDB插入文档"></a>mongoDB插入文档</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">==================================insert=======================================</span><br><span class="line">db.集合名.insert(bson数据)</span><br><span class="line">举例:</span><br><span class="line">db.user.insert(&#123;&quot;name&quot;:&apos;zhangsan&apos;,&apos;age&apos;:20,&apos;sex&apos;:&apos;男&apos;,&apos;hobby&apos;:[&apos;篮球&apos;,&apos;足球&apos;]&#125;)</span><br><span class="line">插入多条数据的时候可以通过变量接收在传参</span><br><span class="line">b = [</span><br><span class="line">    &#123;&quot;name&quot;:&apos;张三&apos;,&apos;age&apos;:23,&apos;sex&apos;:&apos;男&apos;&#125;,</span><br><span class="line">    &#123;&quot;name&quot;:&apos;李四&apos;,&apos;age&apos;:24,&apos;sex&apos;:&apos;女&apos;&#125;,</span><br><span class="line">    &#123;&quot;name&quot;:&apos;赵柳&apos;,&apos;age&apos;:25,&apos;sex&apos;:&apos;男&apos;&#125;,</span><br><span class="line">    &#123;&quot;name&quot;:&apos;田七&apos;,&apos;age&apos;:26,&apos;sex&apos;:&apos;女&apos;&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">db.user.insert(b)</span><br><span class="line"></span><br><span class="line">查看集合中的所有文档  查看表中所有数据</span><br><span class="line">db.user.find()</span><br><span class="line">====================================save()=======================================</span><br><span class="line">不指定 _id 字段 save() 方法类似于 insert() 方法。如果指定 _id 字段，则会更新该 _id 的数据,不存在则提添加</span><br><span class="line">-- 如果不指定_id,则添加</span><br><span class="line">db.user.save(&#123;&apos;name&apos;:&apos;aabbcc&apos;,&apos;age&apos;:22,&apos;email&apos;:&apos;zbc@qq.com&apos;&#125;)</span><br><span class="line">-- 指定 _id,替换数据</span><br><span class="line">db.user.save(&#123;&apos;_id&apos;:ObjectId(&quot;5af2481389c88795375d5762&quot;),&apos;name&apos;:&apos;田六&apos;,&apos;age&apos;:22,&apos;email&apos;:&apos;zbc@qq.com&apos;&#125;)</span><br><span class="line">-- 无对应_id的数据,则添加</span><br><span class="line">db.user.save(&#123;&apos;_id&apos;:10011,&apos;name&apos;:&apos;田七&apos;,&apos;age&apos;:22,&apos;email&apos;:&apos;zbc@qq.com&apos;&#125;)</span><br></pre></td></tr></table></figure><h4 id="MongoDB-更新文档"><a href="#MongoDB-更新文档" class="headerlink" title="MongoDB 更新文档"></a>MongoDB 更新文档</h4><p>db.集合名.update(条件,修改值,{upsert:xxx, multi:xxx})</p><ul><li><strong>upsert</strong> : 可选,找不到指定的数据,true为插入，默认是false，不插入。</li><li><strong>multi</strong> : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,全部更新</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">实例:</span><br><span class="line">-- 找到 name=田七 的数据,更新age字段,只更新找到的第一条数据,如果没有找到也不添加</span><br><span class="line">db.user.update(&#123;&apos;name&apos;:&apos;田七&apos;&#125;,&#123;$set:&#123;&apos;age&apos;:29&#125;&#125;)</span><br><span class="line"></span><br><span class="line">-- multi默认为false,(只更新找到的第一条数据)</span><br><span class="line">-- 找到name=田七的 数据,更新eamil字段,更新所有符合条件的数据,如果没有找到,也不添加</span><br><span class="line">db.user.update(&#123;&quot;name&quot;:&quot;田七&quot;&#125;,&#123;$set:&#123;&apos;age&apos;:26,&apos;email&apos;:&apos;tq@qq.com&apos;&#125;&#125;,&#123;multi:true&#125;)</span><br><span class="line"></span><br><span class="line">-- upsert 默认为false,(如果找到不到符合条件的数据,也不添加)</span><br><span class="line">-- 找到name=田七的 数据,更新eamil字段,更新所有符合条件的数据,如果没有找到,就添加数据</span><br><span class="line">db.user.update(&#123;&quot;name&quot;:&quot;田八&quot;&#125;,&#123;$set:&#123;&apos;age&apos;:26,&apos;email&apos;:&apos;tq@qq.com&apos;&#125;&#125;,&#123;multi:true,upsert:true&#125;)</span><br></pre></td></tr></table></figure><h4 id="MongoDB-删除文档"><a href="#MongoDB-删除文档" class="headerlink" title="MongoDB 删除文档"></a>MongoDB 删除文档</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.集合名.remove(条件) 删除所有符合条件的</span><br><span class="line">db.集合名.remove(条件,1) 删除第一条符合条件的</span><br><span class="line">db.集合名.remove(&#123;&#125;) 删除所有数据</span><br><span class="line">db.集合名.drop() 删除集合</span><br><span class="line">db.集合名.dropDatabase() 删除数据库</span><br></pre></td></tr></table></figure><h4 id="MongoDB-查询文档"><a href="#MongoDB-查询文档" class="headerlink" title="MongoDB 查询文档"></a>MongoDB 查询文档</h4><p>①db.集合名.find() 查询所有数据<br>②db.集合.find(条件) 条件查询  db.col.find({“likes”:{$gt:50}})<br>|    操作    |           格式           |<br>| :——–: | :———————-: |<br>|    等于    |    <code>{&lt;key&gt;:&lt;value&gt;</code>}     |<br>|    小于    | <code>{&lt;key&gt;:{$lt:&lt;value&gt;}}</code>  |<br>| 小于或等于 | <code>{&lt;key&gt;:{$lte:&lt;value&gt;}}</code> |<br>|    大于    | <code>{&lt;key&gt;:{$gt:&lt;value&gt;}}</code>  |<br>| 大于或等于 | <code>{&lt;key&gt;:{$gte:&lt;value&gt;}}</code> |<br>|   不等于   | <code>{&lt;key&gt;:{$ne:&lt;value&gt;}}</code>  |<br>③MongoDB AND 条件 以逗号隔开  db.col.find({key1:value1, key2:value2})<br>④MongoDB OR 条件  db.col.find({$or:[{“by”:”菜鸟教程”},{“title”: “MongoDB 教程”}]})<br>⑤AND 和 OR 联合使用  db.col.find({“likes”: {$gt:50},$or: [{“by”: “菜鸟教程”},{“title”: “MongoDB 教程”}]})<br>⑥显示指定字段 find({},{‘_id’:1,’name’:1} 1代表显示 0代表不显示 _id默认一直显示,为0才不显示<br>⑦limit约束 db.集合名.find().limit(数字) 约束显示个数(分页)<br>⑧sort排序  db.集合名.find().sort({‘排序的键’:1}) 1代表升序  ,-1代表降序<br>⑨ Skip()  db.集合名.find().limit(数字).skip(数字)  跳过前几个去取<br>⑩aggregate()  db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$sum : 1}}}])  按照指定字段分组 然后计算对应数据,_id是固定的<br>| 表达式 |                描述                |<br>| :—-: | :——————————–: |<br>|  $sum  |             计算总和。             |<br>|  $avg  |             计算平均值             |<br>|  $min  | 获取集合中所有文档对应值得最小值。 |<br>|  $max  | 获取集合中所有文档对应值得最大值。 |</p><h4 id="python访问mongoDB"><a href="#python访问mongoDB" class="headerlink" title="python访问mongoDB"></a>python访问mongoDB</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">client = pymongo.MongoClient(<span class="string">'127.0.0.1'</span>, <span class="number">27017</span>)</span><br><span class="line">db = client.库名</span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> db.集合名.find():</span><br><span class="line">    print(user)</span><br><span class="line"><span class="comment">#插入数据</span></span><br><span class="line"><span class="comment">#定义数据</span></span><br><span class="line">data = &#123;<span class="string">'name'</span>: <span class="string">'Aiden'</span>, <span class="string">'age'</span>: <span class="number">30</span>&#125;</span><br><span class="line"><span class="comment">#执行数据添加</span></span><br><span class="line">db.test.insert(data)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意在使用ObjectId()方法时需要在python中导入包</span><br><span class="line">from bson.objectid import ObjectId</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excel-mysql-存储过程、触发器和视图</title>
      <link href="/2019/05/19/Excel-mysql-%E8%A7%A6%E5%8F%91%E5%99%A8%E5%92%8C%E8%A7%86%E5%9B%BE/"/>
      <url>/2019/05/19/Excel-mysql-%E8%A7%A6%E5%8F%91%E5%99%A8%E5%92%8C%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>复制表结构:create table del_user like users<br>复制表数据:insert into users select * from del_users </p><p>####Mysql储存过程<br>`是一组为了完成特定功能的SQL语句集，经过编译之后存储在数据库中(类似于函数)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定义存储过程</span></span><br><span class="line">\d //</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">set</span> @i=<span class="number">10</span>;</span><br><span class="line">while @i&lt;90 do</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">users</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="keyword">concat</span>(<span class="string">'user:'</span>,@i),<span class="keyword">concat</span>(<span class="string">'user:'</span>,@i,<span class="string">'@qq.com'</span>),<span class="keyword">concat</span>(<span class="string">'137013730'</span>,@i));</span><br><span class="line"><span class="keyword">set</span> @i=@i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">//</span><br></pre></td></tr></table></figure></p><p>执行储存：call p1<br>查看存储具体信息：show create procedure p1\G<br>删除触发器: drop procedure p1<br>应用场景:<br>分页显示,那么通常情况下是使用limit方式来完成,还可以借助存储过程和游标来实现,在存储过程中去定义并使用游标来获取指定的数据</p><p>####MySQL的触发器<br>含义:提前定义好一个或一组操作,在指定的sql操作前或后来触发指定的sql执行<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">定义：</span><br><span class="line"> <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name trigger_time trigger_event</span><br><span class="line">   <span class="keyword">ON</span> tbl_name <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> trigger_stmt</span><br><span class="line">说明：</span><br><span class="line"><span class="comment"># trigger_name：触发器名称</span></span><br><span class="line"><span class="comment"># trigger_time:触发时间，可取值：BEFORE或AFTER</span></span><br><span class="line"><span class="comment"># trigger_event：触发事件，可取值：INSERT、UPDATE或DELETE。</span></span><br><span class="line"><span class="comment"># tb1_name：指定在哪个表上</span></span><br><span class="line"><span class="comment"># trigger_stmt：触发处理SQL语句。</span></span><br><span class="line"><span class="comment">-- 查看所有的 触发器</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">triggers</span>\G;</span><br><span class="line"><span class="comment">-- 删除触发器</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> trigger_name;</span><br></pre></td></tr></table></figure></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">触发器举例:</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> del_users <span class="keyword">like</span> <span class="keyword">users</span>;</span><br><span class="line">\d //</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> deluser <span class="keyword">before</span> <span class="keyword">delete</span> <span class="keyword">on</span> <span class="keyword">users</span> <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> del_users <span class="keyword">values</span>(old.uid,old.uname,old.email,old.phone);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">//</span><br><span class="line">\d ;</span><br></pre></td></tr></table></figure><p>触发器注意事项:<br>1.在触发器中只想语句,要确保sql语句能正确执行<br>2.在创建一个insert类型触发器时,在触发器中无法使用add来获取原来的数据</p><p>####mysql视图<br>定义:视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。<br>特点:<br>    1.视图仅仅是用来查看存储在别处的数据的一种设施<br>    2.视图本身不包含数据<br>    3.在添加或更改这些表中的数据时，视图将返回改变过的数据<br>视图的作用:<br>    1.重用SQL语句<br>    2.简化复杂的SQL操作<br>    3.使用表的组成部分而不是整个表<br>    4.保护数据<br>    5.更改数据格式和表示<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">视图操作:</span><br><span class="line">创建视图</span><br><span class="line">mysql&gt; create view v_t1 as select * from t1 where id&gt;4 and id&lt;11;</span><br><span class="line">查看当前库中所有的视图</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>; <span class="comment">--可以查看到所有的表和视图</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span> <span class="keyword">where</span> <span class="keyword">comment</span>=<span class="string">'view'</span>; <span class="comment">--只查看当前库中的所有视图</span></span><br><span class="line">删除视图</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> v_t1;</span><br></pre></td></tr></table></figure></p><p>####mysql数据库备份以及恢复<br>1.配置mysql的bin log日志<br>在windows中找到 my.ini  配置文件,在mysqld的配置项配置<br>server_id=123456<br>log_bin = mysql-bin<br>binlog_format = ROW<br>2.配置完成后重启mysql服务<br>3.进入mysql中<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">重置binlog日志 <span class="keyword">reset</span> <span class="keyword">master</span>;</span><br><span class="line">查看当前的所有日志 <span class="keyword">show</span> <span class="built_in">binary</span> <span class="keyword">logs</span></span><br><span class="line">创建数据库 <span class="keyword">create</span> <span class="keyword">database</span> ops</span><br><span class="line">选择并打开库 <span class="keyword">use</span> ops;</span><br><span class="line"> 创建表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    age <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line">    添加数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">"wangbo"</span>,<span class="string">"24"</span>),(<span class="number">2</span>,<span class="string">"guohui"</span>,<span class="string">"22"</span>),(<span class="number">3</span>,<span class="string">"zhangheng"</span>,<span class="string">"27"</span>);</span><br><span class="line">数据备份</span><br><span class="line">mysqldump -uroot -p -B -F -R -x <span class="comment">--master-data=2 ops &gt;F:\mysql-5.7.25\bf\ops.sql</span></span><br><span class="line">    再添加新的数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">"liupeng"</span>,<span class="string">"21"</span>),(<span class="number">5</span>,<span class="string">"xiaoda"</span>,<span class="string">"31"</span>),(<span class="number">6</span>,<span class="string">"fuaiai"</span>,<span class="string">"26"</span>);</span><br><span class="line">此时误操作，删除了test数据库</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> ops;</span><br><span class="line">binlog文件导出,将binlog文件导出sql文件，删除其中的<span class="keyword">drop</span>语句</span><br><span class="line">mysqlbinlog -d ops F:\mysql<span class="number">-5.7</span><span class="number">.25</span>\<span class="keyword">data</span>\mysql-<span class="keyword">bin</span><span class="number">.000002</span>&gt; F:\mysql<span class="number">-5.7</span><span class="number">.25</span>\bf\<span class="number">002</span>bin.sql</span><br><span class="line">导入备份的数据文件,</span><br><span class="line">mysql -uroot -p &lt; F:\mysql<span class="number">-5.7</span><span class="number">.25</span>\bf\ops.sql </span><br><span class="line">再导入删除 <span class="keyword">drop</span>语句后的 <span class="keyword">binlog</span>日志文件</span><br><span class="line">mysql -uroot -p ops &lt; F:\mysql<span class="number">-5.7</span><span class="number">.25</span>\bf\<span class="number">002</span>bin.sql</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excel-mysql-explain和慢查询</title>
      <link href="/2019/05/16/Excel-mysql-explain%E5%92%8C%E6%85%A2%E6%9F%A5%E8%AF%A2/"/>
      <url>/2019/05/16/Excel-mysql-explain%E5%92%8C%E6%85%A2%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">查看“慢查询”的配置信息</span><br><span class="line">show variables like &quot;%slow%&quot;</span><br><span class="line">查看“慢查询”的时间定义</span><br><span class="line">show variables like &quot;long%&quot;;  </span><br><span class="line"></span><br><span class="line">设置“慢查询”的时间定义</span><br><span class="line">set long_query_time=2;</span><br><span class="line">开启慢日志</span><br><span class="line">set global slow_query_log=&apos;ON&apos;;</span><br></pre></td></tr></table></figure><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>作用同desc<br>返回SELECT语句中使用的每个表的一行信息</p><h4 id="EXPLAIN输出列具体信息"><a href="#EXPLAIN输出列具体信息" class="headerlink" title="EXPLAIN输出列具体信息"></a>EXPLAIN输出列具体信息</h4><table><thead><tr><th>Column</th><th>JSON名称</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td><code>select_id</code></td><td>该<code>SELECT</code>标识符</td></tr><tr><td>select_type</td><td>没有</td><td>该<code>SELECT</code>类型</td></tr><tr><td>table</td><td><code>table_name</code></td><td>输出行的表</td></tr><tr><td>partitions</td><td><code>partitions</code></td><td>匹配的分区,通常不用</td></tr><tr><td>type</td><td><code>access_type</code></td><td>连接类型</td></tr><tr><td>possible_keys</td><td><code>possible_keys</code></td><td>可供选择的索引</td></tr><tr><td>key</td><td><code>key</code></td><td>实际选择的指数</td></tr><tr><td>key_len</td><td><code>key_length</code></td><td>所选键的长度</td></tr><tr><td>ref</td><td><code>ref</code></td><td>列与索引进行比较</td></tr><tr><td>rows</td><td><code>rows</code></td><td>估计要检查的行</td></tr><tr><td>filtered</td><td><code>filtered</code></td><td>按表条件过滤的行的百分比</td></tr><tr><td>Extra</td><td>没有</td><td>附加信息</td></tr></tbody></table><h2 id="MySQL索引使用的注意事项"><a href="#MySQL索引使用的注意事项" class="headerlink" title="MySQL索引使用的注意事项"></a>MySQL索引使用的注意事项</h2><h3 id="1-不要在列上使用函数和进行运算"><a href="#1-不要在列上使用函数和进行运算" class="headerlink" title="1.不要在列上使用函数和进行运算"></a>1.不要在列上使用函数和进行运算</h3><p>不要在列上使用函数，这将导致索引失效而进行全表扫描。</p><h3 id="2-尽量避免使用-或-not-in或-lt-gt-等否定操作符"><a href="#2-尽量避免使用-或-not-in或-lt-gt-等否定操作符" class="headerlink" title="2.尽量避免使用 != 或 not in或 &lt;&gt; 等否定操作符"></a>2.尽量避免使用 != 或 not in或 &lt;&gt; 等否定操作符</h3><p>应该尽量避免在 where 子句中使用 != 或 not in 或 &lt;&gt; 操作符，因为这几个操作符都会导致索引失效而进行全表扫描。</p><h3 id="3-尽量避免使用-or-来连接条件"><a href="#3-尽量避免使用-or-来连接条件" class="headerlink" title="3.尽量避免使用 or 来连接条件"></a>3.尽量避免使用 or 来连接条件</h3><p>应该尽量避免在 where 子句中使用 or 来连接条件</p><h3 id="4-多个单列索引并不是最佳选择"><a href="#4-多个单列索引并不是最佳选择" class="headerlink" title="4.多个单列索引并不是最佳选择"></a>4.多个单列索引并不是最佳选择</h3><p>MySQL 只能使用一个单列索引,会从多个索引中选择一个限制最为严格的索引为了提高性能，可以使用复合索引 </p><h3 id="5-复合索引的最左前缀原则"><a href="#5-复合索引的最左前缀原则" class="headerlink" title="5.复合索引的最左前缀原则"></a>5.复合索引的最左前缀原则</h3><p>复合索引遵守“最左前缀”原则，即在查询条件中使用了复合索引的第一个字段，索引才会被使用</p><h3 id="6-覆盖索引的好处"><a href="#6-覆盖索引的好处" class="headerlink" title="6.覆盖索引的好处"></a>6.覆盖索引的好处</h3><p>如果一个索引自身就包含了所要查询字段的值,无需回行可直接获取数据(如组合索引,索引上就有数据无需去其对应主键去找)</p><h3 id="7-范围查询对多列查询的影响"><a href="#7-范围查询对多列查询的影响" class="headerlink" title="7.范围查询对多列查询的影响"></a>7.范围查询对多列查询的影响</h3><p>查询中的某个列有范围查询，则其右边所有列都无法使用索引优化查找<br>    解决方案:<br>            1.多列联合索引的情况下尽量避免前面的列使用索引<br>            2.修改当前的联合索引,修改组合索引顺序<br>            3.可以重新设计表结构进行优化<br>            4.使用新服务,如redis</p><h3 id="8-索引不会包含有NULL值的列"><a href="#8-索引不会包含有NULL值的列" class="headerlink" title="8.索引不会包含有NULL值的列"></a>8.索引不会包含有NULL值的列</h3><p>只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有一列含有 NULL值，那么这一列对于此复合索引就是无效的。<br>因此，在数据库设计时，除非有一个很特别的原因使用 NULL 值，不然尽量不要让字段的默认值为 NULL。</p><h3 id="9-隐式转换的影响"><a href="#9-隐式转换的影响" class="headerlink" title="9.隐式转换的影响"></a>9.隐式转换的影响</h3><p>当查询条件左右两侧类型不匹配的时候会发生隐式转换</p><h3 id="10-like-语句的索引失效问题"><a href="#10-like-语句的索引失效问题" class="headerlink" title="10.like 语句的索引失效问题"></a>10.like 语句的索引失效问题</h3><p>like模糊查询当通配符写在最前面会出现索引无法使用的情况</p><p>##回行<br>对于myisam(非聚簇索引)叶子结点对应的是数据的物理地址,去物理地址获取数据的过程就是回行<br>对于innodb(聚簇索引),叶子结点对应了索引和数据本身,主索引不存在回行,辅助索引当中需要获取多个字段,在不使用组合索引的情况下就需要通过对应的主键到数据中去找,这一过程成为回行<br>所有辅助索引都是非聚簇索引,INNODB辅助索引存储的是主键的键</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>SQL语句优化 ===1.避免嵌套查询  2.避免多表查询</li><li>索引优化 === 1.正确建立索引  2.合理使用索引</li><li>数据库结构优化<pre><code> 1.垂直分表:把一个表中很多的字段,分成多个表存储2.水平分表:某个表中数据异常大,把表按照数据量进行切分,查询时不需要改变(user1,user2 不需要)3.分库:把一个非常大的系统分成n个子系统,不同的系统使用不同的库进行数据的操作但是会产生跨库操作</code></pre></li><li>系统配置优化</li><li>服务器硬件优化</li></ul><p>###负载均衡和读写分离</p><p><img src="/2019/05/16/Excel-mysql-explain和慢查询/负载均衡和读写分离.png" alt="载均衡和读写分"></p><p>###web服务器工作原理</p><p><img src="/2019/05/16/Excel-mysql-explain和慢查询/web服务器的工作原理.png" alt="eb服务器的工作原"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excel-mysql索引和B-Tree</title>
      <link href="/2019/05/15/Excel-mysql%E7%B4%A2%E5%BC%95%E5%92%8CB-Tree/"/>
      <url>/2019/05/15/Excel-mysql%E7%B4%A2%E5%BC%95%E5%92%8CB-Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="一、MySQL中索引的语法"><a href="#一、MySQL中索引的语法" class="headerlink" title="一、MySQL中索引的语法"></a>一、MySQL中索引的语法</h2><p><strong>创建索引</strong></p><p>在创建表的时候添加索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable(  </span><br><span class="line">    <span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,   </span><br><span class="line">    username <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">    <span class="keyword">INDEX</span> [indexName] (username(<span class="keyword">length</span>))  </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在创建表以后添加索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> my_table <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span>] <span class="keyword">INDEX</span> index_name(column_name);</span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> my_table(column_name);</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>1、索引需要占用<strong>磁盘空间</strong></p><p>2、创建索引时需要<strong>对表加锁</strong></p><p><strong>删除索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> my_index <span class="keyword">ON</span> tablename；(无法删除主键)</span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name;(删除主键先去掉唯一约束)</span><br></pre></td></tr></table></figure><p><strong>查看表中的索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> tablename;</span><br></pre></td></tr></table></figure><h2 id="二、索引的优缺点"><a href="#二、索引的优缺点" class="headerlink" title="二、索引的优缺点"></a>二、索引的优缺点</h2><p><strong>优势：</strong>可以快速检索，减少I/O次数,加快分组和排序；</p><p><strong>劣势：    </strong>1.占用存储空间</p><p>​        2.成本随着数据量增大而增大</p><p>​        3.降低数据表的修改操作（删除，添加，修改）的效率</p><h2 id="三、索引的分类"><a href="#三、索引的分类" class="headerlink" title="三、索引的分类"></a>三、索引的分类</h2><p><strong>常见的索引类型有：主键索引、唯一索引、普通索引、全文索引、组合索引</strong></p><p>1、主键索引：即主索引，根据主键pk_clolum（length）建立索引，<strong>不允许重复，不允许空值</strong>；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">'table_name'</span> <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span> pk_index(<span class="string">'col'</span>)；</span><br><span class="line">secondary <span class="keyword">key</span></span><br></pre></td></tr></table></figure><p>2、唯一索引：用来建立索引的列的值必须是<strong>唯一的，允许空值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">'table_name'</span> <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> index_name(<span class="string">'col'</span>)；</span><br></pre></td></tr></table></figure><p>3、普通索引：用表中的普通列构建的索引，没有任何限制</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">'table_name'</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name(<span class="string">'col'</span>)；</span><br></pre></td></tr></table></figure><p>4、全文索引：用大文本对象的列构建的索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">'table_name'</span> <span class="keyword">ADD</span> FULLTEXT <span class="keyword">INDEX</span> ft_index(<span class="string">'col'</span>)；</span><br><span class="line"><span class="comment">-- 5.6版本前的MySQL自带的全文索引只能用于MyISAM存储引擎，如果是其它数据引擎，那么全文索引不会生效。--- 5.6版本之后InnoDB存储引擎开始支持全文索引</span></span><br><span class="line"><span class="comment">-- 在MySQL中，全文索引支队英文有用，目前对中文还不支持。5.7版本之后通过使用ngram插件开始支持中文。</span></span><br></pre></td></tr></table></figure><p>5、组合索引：用多个列组合构建的索引，这多个列中的值不允许有空值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">'table_name'</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name(<span class="string">'col1'</span>,<span class="string">'col2'</span>,<span class="string">'col3'</span>)；</span><br></pre></td></tr></table></figure><p>*遵循“最左前缀”原则，把最常用作为检索或排序的列放在最左，依次递减，组合索引<strong>相当于建立了col1,col1col2,col1col2col3三个索引</strong>，而col2或者col3是不能使用索引的。</p><p>*在使用组合索引的时候可能因为列名长度过长而导致索引的key太大，导致效率降低，在允许的情况下，可以只取col1和col2的前几个字符作为索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">'table_name'</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name(col1(<span class="number">4</span>),col2（<span class="number">3</span>))；</span><br><span class="line"><span class="comment">--表示使用col1的前4个字符和col2的前3个字符作为索引</span></span><br></pre></td></tr></table></figure><h2 id="四、索引的实现原理"><a href="#四、索引的实现原理" class="headerlink" title="四、索引的实现原理"></a>四、索引的实现原理</h2><h3 id="1、哈希索引："><a href="#1、哈希索引：" class="headerlink" title="1、哈希索引："></a>1、哈希索引：</h3><p>只有memory（内存）存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，<strong>因此哈希索引不支持范围查找和排序的功能</strong></p><h3 id="2、B-Tree索引"><a href="#2、B-Tree索引" class="headerlink" title="2、B+Tree索引"></a>2、B+Tree索引</h3><blockquote><p>正常情况下，如果不指定索引的类型，那么一般是指B+Tree索引（或者B+Tree索引）。</p><p>存储引擎以不同的方式使用B+Tree索引。性能也各有不同，但是InnoDB按照原数据格式进行存储。</p><p>B+Tree 索引能够加快数据的读取速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，相反是从索引的根节点开始进行搜索，通过相应的指针移动，最终存储引擎要么找到了对应的值，要么该记录不存在。树的深度与表的大小直接相关。</p><p>B+Tree索引是按照顺序组织存储的，所以适合范围查找数据</p><p>B+Tree索引使用与全键值、键值范围或者键前缀查找，其中键前缀进适用于根据最左前缀的查找。</p></blockquote><p>B-Tree</p><p><img src="/2019/05/15/Excel-mysql索引和B-Tree/btreebuild.gif" alt="treebuil"></p><p>B+Tree</p><p><img src="/2019/05/15/Excel-mysql索引和B-Tree/Bplustreebuild.gif" alt="plustreebuil"></p><h3 id="为什么使用B-树而不是B树"><a href="#为什么使用B-树而不是B树" class="headerlink" title="为什么使用B+树而不是B树"></a>为什么使用B+树而不是B树</h3><h4 id="1-磁盘读写代价更低"><a href="#1-磁盘读写代价更低" class="headerlink" title="1.磁盘读写代价更低"></a>1.磁盘读写代价更低</h4><h4 id="2-随机I-O的次数更少"><a href="#2-随机I-O的次数更少" class="headerlink" title="2.随机I/O的次数更少"></a>2.随机I/O的次数更少</h4><h4 id="3-查询速度更稳定"><a href="#3-查询速度更稳定" class="headerlink" title="3.查询速度更稳定"></a>3.查询速度更稳定</h4><h4 id="3-聚簇索引和非聚簇索引"><a href="#3-聚簇索引和非聚簇索引" class="headerlink" title="3,聚簇索引和非聚簇索引"></a>3,聚簇索引和非聚簇索引</h4><blockquote><p>在索引的分类中，我们可以按照索引的键是否为主键来分为“主索引”和“辅助索引”，使用主键键值建立的索引称为“主索引”，其它的称为“辅助索引”。因此主索引只能有一个，辅助索引可以有很多个。</p></blockquote><h5 id="MyISAM——非聚簇索引"><a href="#MyISAM——非聚簇索引" class="headerlink" title="MyISAM——非聚簇索引"></a><strong>MyISAM——非聚簇索引</strong></h5><blockquote><p>MyISAM存储引擎采用的是非聚簇索引，非聚簇索引的主索引和辅助索引几乎是一样的，只是主索引不允许重复，不允许空值，他们的叶子结点的key都存储指向键值对应的数据的物理地址。</p><p>非聚簇索引的主索引和辅助索引的叶子节点的data都是存储的数据的物理地址，也就是说索引和数据并不是存储在一起的，数据的顺序和索引的顺序并没有任何关系，也就是索引顺序与数据物理排列顺序无关。</p></blockquote><p><img src="/2019/05/15/Excel-mysql索引和B-Tree/D:/Python学习素材及资源\xdl共享文件\正式\Excel数据分析\mysql\软件和资料\Python_Excel.pdf\MySQL&amp;SQL\imgs\Myisam-%E9%9D%9E%E8%81%9A%E7%B0%87png.png" alt></p><h5 id="InnoDB——聚簇索引"><a href="#InnoDB——聚簇索引" class="headerlink" title="InnoDB——聚簇索引"></a><strong>InnoDB——聚簇索引</strong></h5><blockquote><p>聚簇索引的主索引的叶子结点存储的是键值对应的数据本身，辅助索引的叶子结点存储的是键值对应的数据的主键键值。因此主键的值长度越小越好，类型越简单越好。</p><p>聚簇索引的辅助索引的叶子节点的data存储的是主键的值，主索引的叶子节点的data存储的是数据本身，也就是说数据和索引存储在一起，并且索引查询到的地方就是数据（data）本身，那么索引的顺序和数据本身的顺序就是相同的；</p></blockquote><p><img src="/2019/05/15/Excel-mysql索引和B-Tree/D:/Python学习素材及资源\xdl共享文件\正式\Excel数据分析\mysql\软件和资料\Python_Excel.pdf\MySQL&amp;SQL\imgs\innodb-%E8%81%9A%E7%B0%87%E4%B8%8E%E9%9D%9E%E8%81%9A%E7%B0%87.png" alt>、索引的使用策略</p><blockquote><p>B+Tree索引是按照顺序组织存储的，所以适合范围查找数据</p><p>B+Tree索引使用与全键值、键值范围或者键前缀查找，其中键前缀进适用于根据最左前缀的查找。</p></blockquote><p>– varchar char区别<br>varchar不能超长度存储,但依然是变长的<br>你可以限制长度为10,存储不能超过10 ,但是可以少于10 ,而存储的长度就是你字符的实际长度<br>char 定长存储,不能超长存储数据,存储数据不管是否符合长度要求,都占指定长度空间</p><p>索引的优势就是提高了数据检索速度,不要浪费索引<br>有索引但是用不上情况:<br>    1.like 模糊查询, 当不符合最左前缀原则时,有索引也不用上<br>    select <em> from users where email = ‘zl@%’  ok<br>    select </em> from users where email = ‘%l@’  NO<br>    以下语句为什么没有用到索引?<br>    select * from users where phone = 13701383017<br>    2.phone是一个字符串类型的列,在查询时给定的参数是int类型</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excel-mysql事务</title>
      <link href="/2019/05/14/Excel-mysql%E4%BA%8B%E5%8A%A1/"/>
      <url>/2019/05/14/Excel-mysql%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。</p><h2 id="一-事务的语法"><a href="#一-事务的语法" class="headerlink" title="一,事务的语法"></a>一,事务的语法</h2><ol><li>start transaction   /  begin</li><li>commit;  使得当前的修改确认</li><li>rollback;  使得当前的修改被放弃<h2 id="二-事务的ACID特性"><a href="#二-事务的ACID特性" class="headerlink" title="二,事务的ACID特性"></a>二,事务的ACID特性</h2><h4 id="1-原子性（Atomicity）"><a href="#1-原子性（Atomicity）" class="headerlink" title="1. 原子性（Atomicity）"></a>1. 原子性（Atomicity）</h4>事务的原子性是指事务必须是一个原子的操作序列单元</li></ol><ul><li>全部执行成功</li><li>全部执行失败<h4 id="2-一致性（Consistency）"><a href="#2-一致性（Consistency）" class="headerlink" title="2. 一致性（Consistency）"></a>2. 一致性（Consistency）</h4>事务的一致性是指事务的执行不能破坏数据库数据的完整性和一致性<h4 id="3-隔离性（Isolation）"><a href="#3-隔离性（Isolation）" class="headerlink" title="3. 隔离性（Isolation）"></a>3. 隔离性（Isolation）</h4>事务的隔离性是指在并发环境中，并发的事务是互相隔离的<h4 id="4-持久性（Duration）"><a href="#4-持久性（Duration）" class="headerlink" title="4. 持久性（Duration）"></a>4. 持久性（Duration）</h4>事务的持久性是指事务一旦提交后，数据库中的数据必须被永久的保存下来<h2 id="三-事务的并发问题"><a href="#三-事务的并发问题" class="headerlink" title="三,事务的并发问题"></a>三,事务的并发问题</h2></li><li>脏读：读取到了没有提交的数据</li><li>不可重复读：同一条命令返回不同的结果集（更新）</li><li>幻读：重复查询的过程中，数据就发生了量的变化（insert， delete<h2 id="四-事务隔离级别"><a href="#四-事务隔离级别" class="headerlink" title="四,事务隔离级别"></a>四,事务隔离级别</h2>| 事务隔离级别                 | 脏    读 | 不可重复读 | 幻    读 |<br>| —————————- | ——– | ———- | ——– |<br>| 读未提交（READ_UNCOMMITTED） | 允许     | 允许       | 允许     |<br>| 读已提交（READ_COMMITTED）   | 禁止     | 允许       | 允许     |<br>| 可重复读（REPEATABLE_READ）  | 禁止     | 禁止       | 可能会   |<br>| 顺序读（SERIALIZABLE）       | 禁止     | 禁止       | 禁止     |</li></ul><blockquote><p>4种事务隔离级别从上往下，级别越高，并发性越差，安全性就越来越高。<br>一般数据默认级别是读以提交或可重复读。</p></blockquote><p><strong>查看当前会话中事务的隔离级别</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @@tx_isolation;</span><br></pre></td></tr></table></figure><p><strong>设置当前会话中的事务隔离级别</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> uncommitted;</span><br></pre></td></tr></table></figure><h4 id="1-读未提交（READ-UNCOMMITTED）"><a href="#1-读未提交（READ-UNCOMMITTED）" class="headerlink" title="1. 读未提交（READ_UNCOMMITTED）"></a>1. 读未提交（READ_UNCOMMITTED）</h4><p>读未提交，该隔离级别允许脏读取，其隔离级别是最低的</p><h4 id="2-读已提交（READ-COMMITTED）"><a href="#2-读已提交（READ-COMMITTED）" class="headerlink" title="2. 读已提交（READ_COMMITTED）"></a>2. 读已提交（READ_COMMITTED）</h4><p>读已提交是不同的时候执行的时候只能获取到已经提交的数据。</p><h4 id="3-可重复读（REPEATABLE-READ）"><a href="#3-可重复读（REPEATABLE-READ）" class="headerlink" title="3. 可重复读（REPEATABLE_READ）"></a>3. 可重复读（REPEATABLE_READ）</h4><p>可重复读就是保证在事务处理过程中，多次读取同一个数据时，该数据的值和事务开始时刻是一致的。因此该事务级别进制了不可重复读取和脏读，但是有可能出现幻读的数据。</p><h4 id="4-顺序读（SERIALIZABLE）"><a href="#4-顺序读（SERIALIZABLE）" class="headerlink" title="4. 顺序读（SERIALIZABLE）"></a>4. 顺序读（SERIALIZABLE）</h4><p>顺序读是最严格的事务隔离级别。它要求所有的事务排队顺序执行，即事务只能一个接一个地处理，不能并发。</p><h2 id="五-不同的隔离级别的锁的情况-了解"><a href="#五-不同的隔离级别的锁的情况-了解" class="headerlink" title="五,不同的隔离级别的锁的情况(了解)"></a>五,不同的隔离级别的锁的情况(了解)</h2><ol><li>读未提交（RU）: 有行级的锁，没有间隙锁</li><li>读已提交（RC）：有行级的锁，没有间隙锁</li><li>可重复读（RR）：有行级的锁，也有间隙锁</li><li>序列化（S）：有行级锁，也有间隙锁<h2 id="六-隐式提交-了解"><a href="#六-隐式提交-了解" class="headerlink" title="六,隐式提交(了解)"></a>六,隐式提交(了解)</h2>DDL（Data Define Language）：都是隐式提交。<br>隐式提交：执行这种语句相当于执行commit; DDL</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫阶段网页和网络基本知识</title>
      <link href="/2019/05/12/%E7%88%AC%E8%99%AB%E9%98%B6%E6%AE%B5%E7%BD%91%E9%A1%B5%E5%92%8C%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/05/12/%E7%88%AC%E8%99%AB%E9%98%B6%E6%AE%B5%E7%BD%91%E9%A1%B5%E5%92%8C%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>##python实现UDP和TCP</p><p>###实现udp服务端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#udp服务端</span><br><span class="line">import socket</span><br><span class="line">#创建套接字</span><br><span class="line">sock = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line">#绑定ip和端口号</span><br><span class="line">sock.bind((&apos;localhost&apos;,2222))</span><br><span class="line">#接受消息</span><br><span class="line">data,addr = sock.recvfrom(1024)#元组解包</span><br><span class="line">print(addr)</span><br><span class="line">print(data.decode(&apos;utf-8&apos;))</span><br><span class="line">#返回消息</span><br><span class="line">sock.sendto(&apos;ok&apos;.encode(&apos;utf-8&apos;),addr)</span><br><span class="line">#关闭套接字</span><br><span class="line">sock.close()</span><br></pre></td></tr></table></figure></p><p>###实现UDP客户端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># #udp客户端</span><br><span class="line">import socket</span><br><span class="line"># #创建套接字对象</span><br><span class="line">sock = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line">#发送消息</span><br><span class="line">sock.sendto(&apos;666&apos;.encode(&apos;utf-8&apos;),(&apos;localhost&apos;,2222))</span><br><span class="line">data,addr = sock.recvfrom(1024)</span><br><span class="line">print(data.decode(&apos;utf-8&apos;))</span><br></pre></td></tr></table></figure></p><p>###实现TCP客户端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#tcp客户端</span><br><span class="line">import socket</span><br><span class="line">sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">#建立连接</span><br><span class="line">sock.connect((&apos;localhost&apos;,6666))</span><br><span class="line">#发送数据</span><br><span class="line">while True:</span><br><span class="line">    mes = input(&apos;我:&apos;)</span><br><span class="line">    sock.send(mes.encode(&apos;utf-8&apos;))</span><br><span class="line">    res = sock.recv(1024)</span><br><span class="line">    print(&apos;对方:&apos;,res.decode(&apos;utf-8&apos;))</span><br><span class="line">#关闭套接字</span><br><span class="line"># sock.close()</span><br></pre></td></tr></table></figure></p><p>###实现TCP服务端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#tcp协议服务端</span><br><span class="line">import socket</span><br><span class="line">#创建套接字对象</span><br><span class="line">sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">#绑定ip和端口</span><br><span class="line">sock.bind((&apos;localhost&apos;,6666))</span><br><span class="line">#设置最大监听数</span><br><span class="line">sock.listen(4)</span><br><span class="line">#接收数据</span><br><span class="line"># with open(&apos;2&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;) as l:</span><br><span class="line">so,addre = sock.accept()</span><br><span class="line">while True:</span><br><span class="line">    # d = l.readline()</span><br><span class="line">    data = so.recv(1024)</span><br><span class="line">    print(&apos;对方:&apos;,data.decode(&apos;utf-8&apos;))</span><br><span class="line">    d = input(&apos;我:&apos;)</span><br><span class="line">    so.send(d.encode(&apos;utf-8&apos;))</span><br><span class="line">#关闭套接字</span><br><span class="line"># so.close()</span><br><span class="line"># sock.close()</span><br></pre></td></tr></table></figure></p><p>###实现socket轰炸飞秋<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">#利用socket模块生成套接字</span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line">#定义一个元组,包含ip地址,和端口号,ip地址必须为字符串,端口号为</span><br><span class="line">#数字 飞秋的默认端口为2425</span><br><span class="line">add = ((&apos;192.168.151.95&apos;,2425))</span><br><span class="line">while True:  #设置无线循环</span><br><span class="line">    #定义字符串 其中1表示版本525表示包号 这里可以自由设置 王五表示昵称</span><br><span class="line">    #和主机名 32表示发送消息 我无敌是发送的内容 这个是固定的格式</span><br><span class="line">    a = &quot;1:525:王振伦:王振伦:32:我无敌&quot;</span><br><span class="line">    #完成发送</span><br><span class="line">    s.sendto(a.encode(&quot;gbk&quot;),add)</span><br></pre></td></tr></table></figure></p><p><img src="/2019/05/12/爬虫阶段网页和网络基本知识/爬虫阶段前端和网络知识.jpg" alt="虫阶段前端和网络知"></p><p>思维导图地址：<a href="https://www.processon.com/view/link/5cd7ccd9e4b0406c6414deb4" target="_blank" rel="noopener">https://www.processon.com/view/link/5cd7ccd9e4b0406c6414deb4</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excel数据分析mysql进阶之基础</title>
      <link href="/2019/05/12/Excel%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90mysql%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/05/12/Excel%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90mysql%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="数据库与数据仓库的区别"><a href="#数据库与数据仓库的区别" class="headerlink" title="数据库与数据仓库的区别"></a>数据库与数据仓库的区别</h3><p><strong>数据仓库(DataWareHouse,DW或DWH)</strong>:是一种面向主题,集成的,稳定的,反映历史变化的数据集合,用于支持管理决策.面向主题:数据仓库中的数据按照一定的主题域进行组织.集成:原有分散的数据库数据经过系统加工,消除源数据中的不一致性相对稳定:指一旦某个数据进入数据仓库后只需定期的加载和更新反映历史变化:指通过信息,对企业未来趋势定量做出分析预测.</p><p><strong>数据仓库与数据库区别</strong>:1.数据库是面向事务的,而数据仓库是面向主题设计的2.数据库中存储的一般为实时数据,而数据仓库一般为历史数据3.数据库设计尽量避免冗余,而数据仓库是有意引入冗余4.数据库是为了存储数据设计的,而数据仓库是为了分析数据引入的.</p><h3 id="检索单个列"><a href="#检索单个列" class="headerlink" title="检索单个列"></a>检索单个列</h3><p>  <code>select name from user</code></p><h3 id="检索多个列"><a href="#检索多个列" class="headerlink" title="检索多个列"></a>检索多个列</h3><p>  <code>select id,name,age,sex from user</code></p><h3 id="检索所有列"><a href="#检索所有列" class="headerlink" title="检索所有列"></a>检索所有列</h3><p>  <code>select * from user</code><br>  使用通配符 一般除非你确实需要表中的每个列，否则最好别使用*通配符</p><h3 id="检索不同的行-DISTINCT"><a href="#检索不同的行-DISTINCT" class="headerlink" title="检索不同的行 DISTINCT"></a>检索不同的行 DISTINCT</h3><p>  <code>select distinct classid from user</code><br>类似于group by 分组<br>  例如: <code>select distinct a,b,c from tableA;</code> 等同于 <code>select a,b,c from tableA group by a,b,c</code></p><h3 id="限制结果-LIMIT"><a href="#限制结果-LIMIT" class="headerlink" title="限制结果 LIMIT"></a>限制结果 LIMIT</h3><p>  <code>select * from user limit 3,4</code><br>   LIMIT 3, 4的含义是从行3开始的4行.(跳过前3行,取4行)</p><h3 id="使用完全限定的表名"><a href="#使用完全限定的表名" class="headerlink" title="使用完全限定的表名"></a>使用完全限定的表名</h3><p>  <code>select name from user</code><br>  <code>select user.name from user</code><br>  <code>select user.name from itxdl.user</code></p><h3 id="排序数据-ORDER-BY"><a href="#排序数据-ORDER-BY" class="headerlink" title="排序数据 ORDER BY"></a>排序数据 ORDER BY</h3><p>  <code>select * from user order by age</code><br>    默认升序asc，降序desc</p><h3 id="按多个列排序"><a href="#按多个列排序" class="headerlink" title="按多个列排序"></a>按多个列排序</h3><p>  <code>select * from user order by classid,age</code><br>  在需要对多列数据进行排序时,使用逗号分隔列名,并会按照前后顺序依次对比排序</p><h3 id="过-滤-数-据-WHERE"><a href="#过-滤-数-据-WHERE" class="headerlink" title="过 滤 数 据 WHERE"></a>过 滤 数 据 WHERE</h3><p>  在SELECT语句中，数据根据WHERE子句中指定的搜索条件进行过滤。<br>  <code>select name from user where age = 22</code><br> 在同时使用ORDER BY和WHERE子句时，应该让ORDER BY位于WHERE之后，否则将会产生错误</p><h3 id="WHERE子句操作符"><a href="#WHERE子句操作符" class="headerlink" title="WHERE子句操作符"></a>WHERE子句操作符</h3><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt;    !=</td><td>不等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>BETWEEN</td><td>指定两个值之间</td></tr><tr><td>IS NULL</td><td>空值</td></tr></tbody></table><h3 id="AND与OR"><a href="#AND与OR" class="headerlink" title="AND与OR"></a>AND与OR</h3><p>SQL在处理OR操作符前，优先处理AND操作符。<br>  <code>select name from user where (classid=18 or classid =19) and sex=&#39;m&#39;</code><br>  因为圆括号具有较AND或OR操作符高的计算次序，数据库首先过滤圆括号内的OR条件。</p><h3 id="IN与NOT"><a href="#IN与NOT" class="headerlink" title="IN与NOT"></a>IN与NOT</h3><p>  <code>select name from user where classid in (18,19)</code><br>IN WHERE子句中用来指定要匹配值的清单的关键字，功能与OR相当<br>  <code>select user from user where classid not in (18,19)</code><br>在与IN操作符联合使用时，NOT使找出与条件列表不匹配的行非常简单。</p><h3 id="LIKE与通配符"><a href="#LIKE与通配符" class="headerlink" title="LIKE与通配符"></a>LIKE与通配符</h3><ul><li>百分号（%）通配符 在搜索串中，%表示任何字符出现任意次数<br><code>select name from user where name like &#39;a%&#39;</code></li><li>下划线（_）通配符 下划线的用途与%一样，但下划线只匹配单个字符而不是多个字符</li></ul><h4 id="了解下MySQL的正则-REGEXP"><a href="#了解下MySQL的正则-REGEXP" class="headerlink" title="了解下MySQL的正则 REGEXP"></a>了解下MySQL的正则 REGEXP</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 所有种类的程序设计语言、文本编辑器、操作系统等都支持正则表达式</span><br><span class="line">&gt; mysql没有\d\w等</span><br><span class="line">`select name from user where name regexp &apos;[0-5]abc&apos;`</span><br></pre></td></tr></table></figure><h4 id="拼接-Concat"><a href="#拼接-Concat" class="headerlink" title="拼接 Concat"></a>拼接 Concat</h4><p>  解决办法是把两个列拼接起来。在MySQL的SELECT语句中，可使用Concat()函数来拼接两个列<br>  <code>select concat(vend_name,&#39;(&#39;,vend_country&#39;)&#39;) from vendors order by vend_name</code><br>     起别名:<br>  <code>select concat(vend_name,&#39;(&#39;,vend_country&#39;)&#39;) as vend_title from vendors order by vend_name</code></p><h3 id="函数的使用"><a href="#函数的使用" class="headerlink" title="函数的使用"></a>函数的使用</h3><h4 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">| 函数        | 说明             |</span><br><span class="line">| ----------- | ---------------- |</span><br><span class="line">| Left()      | 返回串左边的字符 |</span><br><span class="line">| Length()    | 返回串的长度     |</span><br><span class="line">| Locate()    | 找出串的一个子串 |</span><br><span class="line">| Lower()     | 将串转换为小写   |</span><br><span class="line">| LTrim()     | 去掉串左边的空格 |</span><br><span class="line">| Right()     | 返回串右边的字符 |</span><br><span class="line">| RTrim()     | 去掉串右边的空格 |</span><br><span class="line">| SubString() | 返回子串的字符   |</span><br><span class="line">| Upper()     | 将串转换为大写   |</span><br><span class="line">| Concat      | 拼接字符串       |</span><br></pre></td></tr></table></figure><h4 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">| 函数          | 说明                           |</span><br><span class="line">| ------------- | ------------------------------ |</span><br><span class="line">| AddTime()     | 增加一个时间（时、分等）       |</span><br><span class="line">| CurDate()     | 返回当前日期                   |</span><br><span class="line">| CurTime()     | 返回当前时间                   |</span><br><span class="line">| Date()        | 返回日期时间的日期部分         |</span><br><span class="line">| DateDiff()    | 计算两个日期之差               |</span><br><span class="line">| Date_Add()    | 高度灵活的日期运算函数         |</span><br><span class="line">| Date_Format() | 返回一个格式化的日期或时间串   |</span><br><span class="line">| Day()         | 返回一个日期的天数部分         |</span><br><span class="line">| DayOfWeek()   | 对于一个日期，返回对应的星期几 |</span><br><span class="line">| Hour()        | 返回一个时间的小时部分         |</span><br><span class="line">| Minute()      | 返回一个时间的分钟部分         |</span><br><span class="line">| Month()       | 返回一个日期的月份部分         |</span><br><span class="line">| Now()         | 返回当前日期和时间             |</span><br><span class="line">| Second()      | 返回一个时间的秒部分           |</span><br><span class="line">| Time()        | 返回一个日期时间的时间部分     |</span><br><span class="line">| Year()        | 返回一个日期的年份部分         |</span><br></pre></td></tr></table></figure><h4 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">| 函 数  | 说 明              |</span><br><span class="line">| ------ | ------------------ |</span><br><span class="line">| Abs()  | 返回一个数的绝对值 |</span><br><span class="line">| Cos()  | 返回一个角度的余弦 |</span><br><span class="line">| Exp()  | 返回一个数的指数值 |</span><br><span class="line">| Mod()  | 返回除操作的余数   |</span><br><span class="line">| Pi()   | 返回圆周率         |</span><br><span class="line">| Rand() | 返回一个随机数     |</span><br><span class="line">| Sin()  | 返回一个角度的正弦 |</span><br><span class="line">| Sqrt() | 返回一个数的平方根 |</span><br><span class="line">| Tan()  | 返回一个角度的正切 |</span><br></pre></td></tr></table></figure><h3 id="聚集函数的使用"><a href="#聚集函数的使用" class="headerlink" title="聚集函数的使用"></a>聚集函数的使用</h3><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>AVG()</td><td>返回某列的平均值</td></tr><tr><td>COUNT()</td><td>返回某列的行数</td></tr><tr><td>MAX()</td><td>返回某列的最大值</td></tr><tr><td>MIN()</td><td>返回某列的最小值</td></tr><tr><td>SUM()</td><td>返回某列值之和</td></tr></tbody></table><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>  在使用count时,如果指定列名，则指定列的值为空的行被忽略，但如果COUNT()函数中用的是星号（*），则不忽略</p><h3 id="数据分组-GROUP-BY与HAVING"><a href="#数据分组-GROUP-BY与HAVING" class="headerlink" title="数据分组 GROUP BY与HAVING"></a>数据分组 GROUP BY与HAVING</h3><ul><li>GROUP BY<br><code>select vend_id,count(*) as num_prods from products group by vend_id</code></li><li>HAVING<br><code>select cust_id,count(*) as orders from orders group by cust_id having count(*) &gt;= 2;</code></li></ul><h3 id="总结SELECT子句及其顺序"><a href="#总结SELECT子句及其顺序" class="headerlink" title="总结SELECT子句及其顺序"></a>总结SELECT子句及其顺序</h3><table><thead><tr><th>子句</th><th>说明</th><th>是否必须</th></tr></thead><tbody><tr><td>SELECT</td><td>要返回的列或表达式</td><td>是</td></tr><tr><td>FROM</td><td>从中检索数据的表</td><td>仅在从表选择数据时使用</td></tr><tr><td>WHERE</td><td>行级过滤</td><td>否</td></tr><tr><td>GROUP BY</td><td>分组说明</td><td>仅在按组计算聚集时使用</td></tr><tr><td>HAVING</td><td>组级过滤</td><td>否</td></tr><tr><td>ORDER BY</td><td>输出排序顺序</td><td>否</td></tr><tr><td>LIMIT</td><td>要检索的行数</td><td>否</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excel数据分析基本技能</title>
      <link href="/2019/05/10/Excel%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E6%9C%AC%E6%8A%80%E8%83%BD/"/>
      <url>/2019/05/10/Excel%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E6%9C%AC%E6%8A%80%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.简单排序：数值大小排,颜色排,笔画字母排</span><br><span class="line">2.复杂排序：自定义排列多列多条件英文数字混合合并单元格的数字</span><br></pre></td></tr></table></figure><h2 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.简单筛选：普通筛选（按颜色字体等排)自定义筛选 包含某数据的某值开头结尾（*和？的使用） 固定位数（？的使用）</span><br><span class="line">2.复杂筛选：某据某条件区域去筛选(若条件是或者的关系需要换行书写）</span><br></pre></td></tr></table></figure><h2 id="分类汇总"><a href="#分类汇总" class="headerlink" title="分类汇总"></a>分类汇总</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.基于一层的使用</span><br><span class="line">2.嵌套使用,嵌套汇总需要用到自定义排序,即针对要汇总的项目进行排序</span><br></pre></td></tr></table></figure><h2 id="条件格式"><a href="#条件格式" class="headerlink" title="条件格式"></a>条件格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5种条件格式：突出显示单元格规则和最前/最后规则比较类似,都是增加单元格底色</span><br><span class="line">数据条格式是根据同一列单元格数值的大小,增加不同长短的数据条</span><br><span class="line">色阶是通过不同的颜色来显示数据的大小</span><br><span class="line">图标集是为数据增加图标,以区分数据类型</span><br></pre></td></tr></table></figure><h2 id="透视表的使用"><a href="#透视表的使用" class="headerlink" title="透视表的使用"></a>透视表的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">要求：1 原始数据要给力</span><br><span class="line">1.所有数据在一张表里</span><br><span class="line">2.是一维表格不是二维表  </span><br><span class="line">3.表中不要有空值</span><br><span class="line">4.表中不要有合并单元格(ctrl+g定位空值,然后写内容ctrl+enter去填充)</span><br><span class="line">5.数据格式要正确 </span><br><span class="line"> 2 建表方法要正确</span><br><span class="line"> 1.使用推荐的透视表（新手推荐）</span><br><span class="line"> 2.自定义建立透视表</span><br></pre></td></tr></table></figure><h2 id="字段布局"><a href="#字段布局" class="headerlink" title="字段布局"></a>字段布局</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.理解字段 透视表的列和行分别显示什么</span><br><span class="line">2.字段设置要点</span><br><span class="line">（1）移动字段  首先,字段可以从字段列表中直接拖拽添加到下方区域</span><br><span class="line">（2）设置字段的值  透视表是一种可以快速汇总大量数据的表格。在透视表的字段设置区域,【值】区域内的字段会被进行</span><br></pre></td></tr></table></figure><h2 id="透视表7个方法"><a href="#透视表7个方法" class="headerlink" title="透视表7个方法"></a>透视表7个方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.总计的百分比  这种方式值显示方式展示了某项目占所有项目总和的百分比</span><br><span class="line">2.列汇总的百分比  这种方式显示了每项数据占该列所有数据总和的百分比</span><br><span class="line">3.行汇总的百分比  这种方式显示了每项数据占该行所有数据总和的百分比。计算原理是：（单独项目的数值/项目所在行的总值）*100%</span><br><span class="line">4.百分比  这种值显示方式是以某项目为标准,显示其他项目与该项目的比例。这种汇总方式,需要选择某项目为参照标准</span><br><span class="line">5.父行汇总的百分比  这种方式显示了项目数据占该列分类项目数据总和的百分比。计算原理是：（项目数值/项目所在列分类项目总值）*100%</span><br><span class="line">6.父列汇总的百分比  这种方式显示了项目数据占该行分类项目数据总和的百分比。计算原理是：（项目数值/项目所在行分类项目总值）*100%</span><br><span class="line">7.父级汇总的百分比  这种值汇总方式,显示了每个项目占所在分类数据总和的百分比。计算原理是：（项目数值/项目所在列分类项目总值）*100%</span><br></pre></td></tr></table></figure><h2 id="透视数据差异"><a href="#透视数据差异" class="headerlink" title="透视数据差异"></a>透视数据差异</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.分析数值差异  分析数值之间的差异,可以选定一个项目为参照标准,将值显示方式调整为【差异】方式,就能看到其他项目与参照</span><br><span class="line">2.分析同比/环比差异  利用透视表分析项目数据差异,还可以设置要计算差异百分比的基本字段、基本项,来实现项目同比/环比的计算</span><br></pre></td></tr></table></figure><h2 id="透视表两大利器"><a href="#透视表两大利器" class="headerlink" title="透视表两大利器"></a>透视表两大利器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.使用切片器分析数据  切片器可以从不同的维度进行同时筛选</span><br><span class="line">2.使用日程表分析数据  日程表是从日期的角度对数据进行筛选</span><br></pre></td></tr></table></figure><h2 id="透视表数据可视化分析"><a href="#透视表数据可视化分析" class="headerlink" title="透视表数据可视化分析"></a>透视表数据可视化分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.添加数据透视图表  为透视表数据添加图表的方法是,选中一个透视表区域的单元格,在【插入】选项卡下【图表】组中选择一种图表</span><br><span class="line">2.学会图表筛选</span><br></pre></td></tr></table></figure><h2 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">1.图表的使用场景</span><br><span class="line">1.为了揭示数据规律</span><br><span class="line">2.为了有说服力、促进沟通  数据分析工作常常需要团队合作,数据分析的成果也需要向他人展示</span><br><span class="line">3.为了展示专业素养  </span><br><span class="line">2.建立图表的步骤</span><br><span class="line">1.选择数据</span><br><span class="line">2.选择图标</span><br><span class="line">3.确认图例项、坐标轴数据</span><br><span class="line">3.柱形图数据分析</span><br><span class="line">1.使用技巧：</span><br><span class="line">（1）慎用三维柱形图</span><br><span class="line">（2）保证类别名称清晰显示  柱形图要保证X轴的类别名称清晰,否则会造成读图困难,当类别不是时间时不可以通过调整单位来</span><br><span class="line">2.分类：</span><br><span class="line">（1）簇状柱形图  普通的柱形图可以用来对比多个项目的值、或项目随时间推移的变化</span><br><span class="line"></span><br><span class="line">（2）堆积柱形图  堆积柱形图是将数据叠加到一根柱形上,通过柱形叠加的高度,判断数据总量的对比</span><br><span class="line">（3）百分比堆积柱形图  百分比堆积柱形图是将数据叠加到一柱形上,每根柱形的总值都是100%,各项数据在柱条中占据了一定比例的长度</span><br><span class="line">3.柱形图和条形图区别</span><br><span class="line">1.条形图适用于类别名称长的数据</span><br><span class="line">2.柱形图适合表现有负数的数据</span><br><span class="line">3.条形图更能展现大量数据</span><br><span class="line">4.折线图数据分析</span><br><span class="line">1.分类：</span><br><span class="line">1.折线图,折线图用来表现不同数据的趋势</span><br><span class="line">2.堆积折线图,堆积折线图可以反映所有数据项目的总值随时间变化趋势</span><br><span class="line">3.百分比堆积折线图,百分比堆积折线图用来表现数据项目所占百分比随时间变化的趋势</span><br><span class="line">2.折线图使用技巧</span><br><span class="line">1.X轴只能是时间</span><br><span class="line">2.学会拆分图表</span><br><span class="line">3.让折线变圆滑</span><br><span class="line">4.设置数据标记不同图表在形态上有所区别,在格式调整上也有区别</span><br><span class="line">3.饼图数据分析</span><br><span class="line">1.分类:</span><br><span class="line">（1）普通饼图用来展示各数据项目的比例</span><br><span class="line">（2）圆环图也可以展示各数据项目的比例,但是增加圆环图的层数,还可以体现数据项目随时间或其他  因素变化时的比例</span><br><span class="line">（3）复合饼图又称为子母饼图,用来展示不同数据项目的占比,及其中一个数据项目所包含的分类占比</span><br><span class="line">2.使用技巧:</span><br><span class="line">1.在制作饼图时,需要考虑饼图制作是符合规范,是否方便读取图表信息,以最大限度保证图表准确传达了数据含义</span><br><span class="line">2.不注意饼图扇区数据排序和角度,是饼图常见的第二种错误</span><br><span class="line">5.面积图数据分析</span><br><span class="line">1.分类</span><br><span class="line">（1）普通面积图如左下图所示,体现数据项目随着时间变化的趋势及累计的量</span><br><span class="line">（2）堆积面积图,体现了单项数据的变化趋势、数据的变化趋势和量的累加</span><br><span class="line">（3）百分比堆积面积图体现了数据项目占总值的百分比变化趋势</span><br><span class="line">2.面积图使用技巧</span><br><span class="line">（1）注意面积之间不要互相遮挡</span><br><span class="line">（2）为面积图增加轮廓线,强调趋势</span><br><span class="line">6.散点图数据分析</span><br><span class="line">1.分类</span><br><span class="line">（1）散点图/带平滑线和数据标记的散点图散点图用来分析两个变量之间的关系,或数据项目分布</span><br><span class="line">（2）气泡图和三维气泡图如果需要体现三个变量之间的关系,就要选择气泡图或三维气泡图</span><br><span class="line">2.散点使用技巧</span><br><span class="line">（1）调整坐标轴边界值、区分数据类别</span><br><span class="line">（2）使用象限图可以将数据划分到不同的象限,以便直观清晰地分析出不同项目的现状及改进策略</span><br><span class="line">7.曲面图数据分析</span><br><span class="line">1.分类</span><br><span class="line">1.三维曲面图,三维曲面图是最常用的一种曲面图,它通过曲面在三维空间的跨度来显示数据的范围</span><br><span class="line">2.三维线框曲面图</span><br><span class="line">3.曲面图,曲面图是以俯视的角度观看三维曲面图的效果</span><br><span class="line">4.曲面图（俯视框架图)将曲面图的颜色去掉,仅留下框架,便是曲面图（俯视框架图）的效果</span><br><span class="line">8.雷达图数据分析</span><br><span class="line">1.雷达图  雷达图将将所有数据项目集中显示在一个圆形图表上,以便一目了然对数据进行对比、进行整体情况分析</span><br><span class="line">2.带数据标记的雷达图  带数据标记的雷达图与常规雷达图的区别是,在雷达图轮廓上增加了数据标记,起到了强调数据值的作用</span><br><span class="line">3.填充雷达图  填充雷达图与常规雷达图的区别是,填充雷达图不再是轮廓线,而是有填充色的面积。填充雷达图更强调数据系列的综合指数,即整体水平</span><br><span class="line">9.其他图表</span><br><span class="line">1.旭日图</span><br><span class="line">2.直方图</span><br><span class="line">3.树状图</span><br><span class="line">4.瀑布图</span><br><span class="line">10.专业图表的5个特征</span><br><span class="line">1.标注数据来源和时间</span><br><span class="line">2.表意明确</span><br><span class="line">3.纵坐标从0开始</span><br><span class="line">4.使用二维图表</span><br><span class="line">5.添加必要说明</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excel数据清洗与加工处理</title>
      <link href="/2019/05/10/Excel%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E5%8A%A0%E5%B7%A5%E5%A4%84%E7%90%86/"/>
      <url>/2019/05/10/Excel%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E5%8A%A0%E5%B7%A5%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h2><pre><code>目的：的是将多余的、错误的数据清洗出去，留下有价值的数据1.数据去重的三种方式    1.用删除重复项功能    2.排序删除重复项，人工查找删除    3.条件格式删除重复项2.3种方法处理缺省值    1.替换缺省值    2.删除缺省值    3.忽略缺省值3.检查数据逻辑    1.用函数检查逻辑如IF（首选）    2.用条件格式检查逻辑4.数据格式的检查    主要检查：1.日期格式 2.时间格式 3.数值格式的小数位数 4.百分比格式 5.数值格式的千位分隔符</code></pre><hr><h2 id="数据加工"><a href="#数据加工" class="headerlink" title="数据加工"></a>数据加工</h2><pre><code>启发数据分析灵感的一个重要步骤1.数据计算    1.简单计算 2.常用函数计算 3.不常用函数计算2.数据转换    1.行列转换（TRANPOSE和粘贴里面的转置） 2。记录方式转换3.数据分类    用VLOOKUP函数实现数据分组4.数据重组    考虑方面：1数据拆分2.数据合并3.数据抽取</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excel数据分析</title>
      <link href="/2019/05/09/Excel%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
      <url>/2019/05/09/Excel%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h4 id="数据分析的核心"><a href="#数据分析的核心" class="headerlink" title="数据分析的核心"></a>数据分析的核心</h4><h5 id="1-数据分析概念-意义"><a href="#1-数据分析概念-意义" class="headerlink" title="1.数据分析概念(意义)"></a>1.数据分析概念(意义)</h5><p>​    数据分析是指通过恰当的统计方法和可行的分析手段，对数据进行收集汇总,然后再加工处理。最后数据进行分析,发现有效的决策.</p><h5 id="2-不要将思维局限于“数字”"><a href="#2-不要将思维局限于“数字”" class="headerlink" title="2.不要将思维局限于“数字”"></a>2.不要将思维局限于“数字”</h5><p>​    数据并不局限于狭义上的“数字”，还包括文字、图形、行为方式等等。</p><h5 id="3-数据分析类型"><a href="#3-数据分析类型" class="headerlink" title="3.数据分析类型"></a>3.数据分析类型</h5><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td>描述型数据分析</td><td>概括表述事物关系</td></tr><tr><td>数据分析类型</td><td>探索性数据分析</td><td>发现数据新征</td></tr><tr><td></td><td>验证型数据分析</td><td>对假设进行证实</td></tr></tbody></table><h4 id="数据分析步骤-6步"><a href="#数据分析步骤-6步" class="headerlink" title="数据分析步骤(6步)"></a>数据分析步骤(6步)</h4><h5 id="第一步是目标导向"><a href="#第一步是目标导向" class="headerlink" title="第一步是目标导向"></a>第一步是目标导向</h5><p>​        数据分析的关键,分析是围绕着目标展开的</p><h5 id="第二步数据收集"><a href="#第二步数据收集" class="headerlink" title="第二步数据收集"></a>第二步数据收集</h5><p>​        数据来源:1.公司内部数据库  2.互联网爬虫获取 3.出版物 4.问卷,市场调查 5.购买数据</p><h5 id="第三步数据数据处理"><a href="#第三步数据数据处理" class="headerlink" title="第三步数据数据处理"></a>第三步数据数据处理</h5><p>​        五个步骤:检查–&gt;清洗–&gt;转换–&gt;提取–&gt;计算</p><p>​        检查:逻辑检查(1.通过函数,2.通过条件格式判断)和是否符合要求</p><p>​        清洗:删除多余数据,删除重复数据,删除错误数据</p><p>​        转换:格式转换和单位转换</p><p>​        提取:重点数据提取和最大最小数据</p><p>​        计算:主要是平均值和求和</p><h5 id="第四步数据分析-11中思路6个工具5个分析模型-后面补充"><a href="#第四步数据分析-11中思路6个工具5个分析模型-后面补充" class="headerlink" title="第四步数据分析(11中思路6个工具5个分析模型===后面补充)"></a>第四步数据分析(11中思路6个工具5个分析模型===后面补充)</h5><h5 id="第五步数据展现"><a href="#第五步数据展现" class="headerlink" title="第五步数据展现"></a>第五步数据展现</h5><p>​        将数据转换为更直观的图标</p><p>​        作用:1.便于发现规律 2.便于读者理解</p><h5 id="第六步数据报告"><a href="#第六步数据报告" class="headerlink" title="第六步数据报告"></a>第六步数据报告</h5><p>​        要求:1.完善的内容 2.合理的表达</p><p>​        方式:1.word报告 2.PPT报告 3.报告自动化(VBA语言)</p><h4 id="数据分析的七个专业术语"><a href="#数据分析的七个专业术语" class="headerlink" title="数据分析的七个专业术语"></a>数据分析的七个专业术语</h4><h5 id="1-平均数"><a href="#1-平均数" class="headerlink" title="1.平均数"></a>1.平均数</h5><p>​        一组数据的集中趋势量数</p><h5 id="2-众数"><a href="#2-众数" class="headerlink" title="2.众数"></a>2.众数</h5><p>​        众数是一组数据中出现次数最多的数值</p><p>​        一个众数的数据集合叫单峰,二个 众数的数据集合叫双峰，三个众数的数据集合叫三峰,数据集合中每种数值都只出现了一次，那么这组数据没有众数.</p><h5 id="3-中位数"><a href="#3-中位数" class="headerlink" title="3.中位数"></a>3.中位数</h5><p>​        指一组数据按照从大小顺序排列，处在最在中间的数据（或中间两个数据的平均数）叫这组数据的中位数</p><h5 id="4-绝对值与相对值"><a href="#4-绝对值与相对值" class="headerlink" title="4.绝对值与相对值"></a>4.绝对值与相对值</h5><p>​        绝对值是某个具体数据,相对值是两个比较产生</p><h5 id="5-百分比与百分点"><a href="#5-百分比与百分点" class="headerlink" title="5.百分比与百分点"></a>5.百分比与百分点</h5><p>​        百分比也称为百分率或百分数，表示一个数是另一个数的百分之几</p><p>​        百分点可认为是%的替代</p><h5 id="6-比例与比率"><a href="#6-比例与比率" class="headerlink" title="6.比例与比率"></a>6.比例与比率</h5><p>​        比例表示总体中部分数值与总体数值的比较</p><p>​        比率表示总体中一部分数值与另一部分数值的比较</p><h5 id="7-同比与环比"><a href="#7-同比与环比" class="headerlink" title="7.同比与环比"></a>7.同比与环比</h5><p>​        同比，指今年某个时期与去年相同时期的数据比较</p><p>​        环比，指某个时期与前一时期的数据比较。</p><h4 id="数据分析模型-5种"><a href="#数据分析模型-5种" class="headerlink" title="数据分析模型(5种)"></a>数据分析模型(5种)</h4><h5 id="1-SWOT模型"><a href="#1-SWOT模型" class="headerlink" title="1.SWOT模型"></a>1.SWOT模型</h5><p>​        S代表 strength（优势），W代表weakness（劣势）；外部因素包括，O代表opportunity（机会），T代表threat（威胁）</p><h5 id="2-PEST模型"><a href="#2-PEST模型" class="headerlink" title="2.PEST模型"></a>2.PEST模型</h5><p>​        P是政治(politics)，E是经济(economy)，S是社会(society)，T是技术(technology)</p><h5 id="3-5W2H模型"><a href="#3-5W2H模型" class="headerlink" title="3.5W2H模型"></a>3.5W2H模型</h5><p>​        WHO WHERE WHEN WHY WHAT HOW HOW MUCH</p><h5 id="4-4P营销模型"><a href="#4-4P营销模型" class="headerlink" title="4.4P营销模型"></a>4.4P营销模型</h5><p>​        产品（Product）、价格（Price）、渠道（Place）、宣传（Promotion）</p><h5 id="5-逻辑树模型"><a href="#5-逻辑树模型" class="headerlink" title="5.逻辑树模型"></a>5.逻辑树模型</h5><p>​        层层分解、追本溯源</p><h4 id="数据分析优秀网站-3个"><a href="#数据分析优秀网站-3个" class="headerlink" title="数据分析优秀网站(3个)"></a>数据分析优秀网站(3个)</h4><h5 id="1-艾瑞网"><a href="#1-艾瑞网" class="headerlink" title="1.艾瑞网"></a>1.艾瑞网</h5><h5 id="2-网易数读"><a href="#2-网易数读" class="headerlink" title="2.网易数读"></a>2.网易数读</h5><h5 id="3-UED"><a href="#3-UED" class="headerlink" title="3.UED"></a>3.UED</h5><h4 id="数据分析的11种思路"><a href="#数据分析的11种思路" class="headerlink" title="数据分析的11种思路"></a>数据分析的11种思路</h4><h5 id="1-预测的思路"><a href="#1-预测的思路" class="headerlink" title="1.预测的思路"></a>1.预测的思路</h5><p>​        预测分析是实质是根据现在和过去的数据进行未来趋势预测，关键点，一是数据在时间上的连续性，二是数据的  数量，三是数据的全面性</p><h5 id="2-交叉的思路"><a href="#2-交叉的思路" class="headerlink" title="2.交叉的思路"></a>2.交叉的思路</h5><p>​        作用:（1）理清数据间的关系；（2）快速分析每个交叉点的值；（3）方便地对数值进行求和计算；（4）将注意力集中在目标数据项上</p><h5 id="3-假设的思路"><a href="#3-假设的思路" class="headerlink" title="3.假设的思路"></a>3.假设的思路</h5><p>​        目标分析对象的样本数量太大或者是无法获取全面，只能通过  样本分析总体情况</p><h5 id="4-对比的思路"><a href="#4-对比的思路" class="headerlink" title="4.对比的思路"></a>4.对比的思路</h5><p>​        分类:1.时间对比  2.空间对比  3.项目对比  4.标准对比  </p><h5 id="5-分组的思路"><a href="#5-分组的思路" class="headerlink" title="5.分组的思路"></a>5.分组的思路</h5><p>​        第一步便是要确定分组依据 </p><p>​        第二步确定组距与组数</p><p>​        第三步按规划对数据分组</p><h5 id="6-概率的思路"><a href="#6-概率的思路" class="headerlink" title="6.概率的思路"></a>6.概率的思路</h5><p>​        分类:1.互斥事件的概率   2.相互事件的概率</p><h5 id="7-平均的思路"><a href="#7-平均的思路" class="headerlink" title="7.平均的思路"></a>7.平均的思路</h5><p>​        分类:1.算数平均  2.几何平均  3.中位数  4.众数</p><h5 id="8-指标综合的思路"><a href="#8-指标综合的思路" class="headerlink" title="8.指标综合的思路"></a>8.指标综合的思路</h5><p>​        第一步：确定指标</p><p>​        第二步：收集指标数据/信息</p><p>​        第三步：确定指标权重</p><p>​        第四步：完成综合计算</p><h5 id="9-杜邦分析的思路"><a href="#9-杜邦分析的思路" class="headerlink" title="9.杜邦分析的思路"></a>9.杜邦分析的思路</h5><p>​        将企业的权益净利率使用结构化的相关因素表现出来，并通过加减乘除等运算符号体现因素间 的内在联系</p><h5 id="10-漏斗分析的思路"><a href="#10-漏斗分析的思路" class="headerlink" title="10.漏斗分析的思路"></a>10.漏斗分析的思路</h5><p>​        寻找问题原因，找到多个环节中出纰漏最大的一步，建议使用漏斗分析的思路</p><h5 id="11-象限分析的思路"><a href="#11-象限分析的思路" class="headerlink" title="11.象限分析的思路"></a>11.象限分析的思路</h5><p>​        常规的象限分析法适用两个因素相互作用的情况</p><p>​        常规象 限分析用小圆点的X、Y坐标来表示数据的两个维度，如果改变圆点的大小，就可以增加第三个维度，即用圆点 大小来体现销量大小</p><h4 id="6个数据分析基本工具"><a href="#6个数据分析基本工具" class="headerlink" title="6个数据分析基本工具"></a>6个数据分析基本工具</h4><h5 id="1-海量数据的克星——数据透视表"><a href="#1-海量数据的克星——数据透视表" class="headerlink" title="1.海量数据的克星——数据透视表"></a>1.海量数据的克星——数据透视表</h5><h5 id="2-让抽象数据直观展现的利器——图表"><a href="#2-让抽象数据直观展现的利器——图表" class="headerlink" title="2.让抽象数据直观展现的利器——图表"></a>2.让抽象数据直观展现的利器——图表</h5><h5 id="3-简单工具也能有大用处——条件格式"><a href="#3-简单工具也能有大用处——条件格式" class="headerlink" title="3.简单工具也能有大用处——条件格式"></a>3.简单工具也能有大用处——条件格式</h5><h5 id="4-麻雀虽小五脏俱全——迷你图"><a href="#4-麻雀虽小五脏俱全——迷你图" class="headerlink" title="4.麻雀虽小五脏俱全——迷你图"></a>4.麻雀虽小五脏俱全——迷你图</h5><h5 id="5-数据归类统计利器——分类汇总"><a href="#5-数据归类统计利器——分类汇总" class="headerlink" title="5.数据归类统计利器——分类汇总"></a>5.数据归类统计利器——分类汇总</h5><h5 id="6-交互式数据可视化工具——Power-BI"><a href="#6-交互式数据可视化工具——Power-BI" class="headerlink" title="6.交互式数据可视化工具——Power  BI"></a>6.交互式数据可视化工具——Power  BI</h5><p><img src="/2019/05/09/Excel数据分析/excel.jpg" alt="xce"></p><p>思维导图网址:<a href="https://www.processon.com/view/link/5cd42b66e4b0841b84517467" target="_blank" rel="noopener">https://www.processon.com/view/link/5cd42b66e4b0841b84517467</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excel数据分析之基础操作章</title>
      <link href="/2019/05/09/Excel%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E7%AB%A0/"/>
      <url>/2019/05/09/Excel%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="1-使用AVERAGE函数求取一组数字的平均值"><a href="#1-使用AVERAGE函数求取一组数字的平均值" class="headerlink" title="1.使用AVERAGE函数求取一组数字的平均值"></a>1.使用AVERAGE函数求取一组数字的平均值</h4><p>公式—-&gt;插入函数—-&gt;搜索函数(输入:求平均值,转到)—-&gt;选择函数:AVERAGE—-&gt;确定</p><p>函数参数—-&gt;Number1(选择要求平均值的选框)—-&gt;确定</p><p>一行或一列的平均值,鼠标光标移至右下角变成十字后下拉或者右拉即可</p><h4 id="2使用COUNT函数统计参数中包含数字的个数"><a href="#2使用COUNT函数统计参数中包含数字的个数" class="headerlink" title="2使用COUNT函数统计参数中包含数字的个数"></a>2使用COUNT函数统计参数中包含数字的个数</h4><p>公式—-&gt;自动求和(下拉选框)—-&gt;计数—-&gt;选择B2到B15区域,回车(Enter)即可</p><h4 id="3使用MAX函数返回一组数字中的最大值"><a href="#3使用MAX函数返回一组数字中的最大值" class="headerlink" title="3使用MAX函数返回一组数字中的最大值"></a>3使用MAX函数返回一组数字中的最大值</h4><p>公式—-&gt;自动求和(下拉选框)—-&gt;最大值—-&gt;选择C2到F15区域,回车(Enter)即可</p><h4 id="4使用MIN函数返回一组数字中的最小值"><a href="#4使用MIN函数返回一组数字中的最小值" class="headerlink" title="4使用MIN函数返回一组数字中的最小值"></a>4使用MIN函数返回一组数字中的最小值</h4><p>公式—-&gt;自动求和(下拉选框)—-&gt;最小值—-&gt;选择C2到F15区域,回车(Enter)即可</p><h4 id="5-使用IF函数根据指定的条件返回不同的结果"><a href="#5-使用IF函数根据指定的条件返回不同的结果" class="headerlink" title="5.使用IF函数根据指定的条件返回不同的结果"></a>5.使用IF函数根据指定的条件返回不同的结果</h4><p>公式—-&gt;插入函数—-&gt;IF(确定)</p><h4 id="6-使用SUMIF函数按给定条件对指定单元格求和"><a href="#6-使用SUMIF函数按给定条件对指定单元格求和" class="headerlink" title="6.使用SUMIF函数按给定条件对指定单元格求和"></a>6.使用SUMIF函数按给定条件对指定单元格求和</h4><p>SUMIF(range, criteria, [sum_range])<br>range 要按条件计算的单元格区域。<br>criteria 定义哪些单元格将被添加的数字、表达式、单元格引用、文本或函数形式的条件。<br>sum_range  要添加的实际单元格</p><p>操作如下:公式—-&gt;数学和三角函数—-&gt;在下拉选项里面选择</p><h4 id="7-使用VLOOKUP函数在区域或数组的列中查找数据"><a href="#7-使用VLOOKUP函数在区域或数组的列中查找数据" class="headerlink" title="7.使用VLOOKUP函数在区域或数组的列中查找数据"></a>7.使用VLOOKUP函数在区域或数组的列中查找数据</h4><p>VLOOKUP（要查找的值、要在其中查找值的区域、区域中包含返回值的列号、精确匹配或近似匹配 – 指定为 0/FALSE 或 1/TRUE）</p><p>公式—-&gt;插入函数—-&gt;或选择类别里面选择&lt;查找与引用&gt;—–&gt;选择VLOOKUP函数确定</p><h4 id="8-让公式与函数实现混合运算"><a href="#8-让公式与函数实现混合运算" class="headerlink" title="8.让公式与函数实现混合运算"></a>8.让公式与函数实现混合运算</h4><p>插播一个四舍五入的函数ROUND</p><p>用法:ROUND(求值的单元格,保留几位小数)</p><h4 id="9-使用EXACT函数比较两个字符串是否相同"><a href="#9-使用EXACT函数比较两个字符串是否相同" class="headerlink" title="9.使用EXACT函数比较两个字符串是否相同"></a>9.使用EXACT函数比较两个字符串是否相同</h4><p>用法:EXACT(值1单元格,值二单元格)</p><p>插入函数选择文本函数或者直接找EXACT函数都可以</p><p>EXACT(A2,B2)</p><h4 id="10-使用LEN函数计算文本中的字符个数"><a href="#10-使用LEN函数计算文本中的字符个数" class="headerlink" title="10.使用LEN函数计算文本中的字符个数"></a>10.使用LEN函数计算文本中的字符个数</h4><p>len函数的语法格式=Len( text)</p><h4 id="11-使用T函数将参数转换为文本"><a href="#11-使用T函数将参数转换为文本" class="headerlink" title="11.使用T函数将参数转换为文本"></a>11.使用T函数将参数转换为文本</h4><p>T(value)</p><p>值   要测试的值。</p><h4 id="12-使用FIND函数以字符为单位并区分大小写地查找指定字符的位置"><a href="#12-使用FIND函数以字符为单位并区分大小写地查找指定字符的位置" class="headerlink" title="12.使用FIND函数以字符为单位并区分大小写地查找指定字符的位置"></a>12.使用FIND函数以字符为单位并区分大小写地查找指定字符的位置</h4><p>FIND(find_text, within_text, [start_num])<br>find_text   要查找的文本。<br>within_text    包含要查找文本的文本。<br>start_num    指定开始进行查找的字符</p><h4 id="13-使用REPLACE函数以字符为单位根据指定位置进行替换"><a href="#13-使用REPLACE函数以字符为单位根据指定位置进行替换" class="headerlink" title="13.使用REPLACE函数以字符为单位根据指定位置进行替换"></a>13.使用REPLACE函数以字符为单位根据指定位置进行替换</h4><p>REPLACE(old_text, start_num, num_chars, new_text)</p><p>old_text    要替换其部分字符的文本。</p><p>start_num   old_text 中要替换为 new_text 的字符位置。</p><p>num_chars   old_text 中希望 REPLACE 使用 new_text 来进行替换的字符数。</p><p>Num_bytes   old_text 中希望 REPLACEB 使用 new_text 来进行替换的字节数。</p><p>new_text    将替换 old_text 中字符的文本。</p><h4 id="14-使用FALSE函数返回逻辑值FALSE"><a href="#14-使用FALSE函数返回逻辑值FALSE" class="headerlink" title="14.使用FALSE函数返回逻辑值FALSE"></a>14.使用FALSE函数返回逻辑值FALSE</h4><p>IF(B2&gt;$C$2,FALSE(),TRUE())</p><h4 id="15-使用AND函数判断指定的多个条件是否同时成立"><a href="#15-使用AND函数判断指定的多个条件是否同时成立" class="headerlink" title="15.使用AND函数判断指定的多个条件是否同时成立"></a>15.使用AND函数判断指定的多个条件是否同时成立</h4><p>用于确定测试中的所有条件是否均为 TRUE</p><p>IF(AND(C2&gt;3,D2&lt;15,E2&lt;35200),”可申请”,””)</p><h4 id="16-使用OR函数判断指定的任一条件是为真，即返回真"><a href="#16-使用OR函数判断指定的任一条件是为真，即返回真" class="headerlink" title="16.使用OR函数判断指定的任一条件是为真，即返回真"></a>16.使用OR函数判断指定的任一条件是为真，即返回真</h4><p>用于确定测试中的所有条件是否均为 TRUE</p><p>IF(OR(C2&gt;=$I$2,D2&gt;=$I$2,E2&gt;=$I$2),”优秀”,IF(OR(C2&gt;=$I$3,D2=$I$3,E2&gt;=$I$3),”及格”,”不及格”))</p><h4 id="17-使用NOT函数对逻辑值求反"><a href="#17-使用NOT函数对逻辑值求反" class="headerlink" title="17.使用NOT函数对逻辑值求反"></a>17.使用NOT函数对逻辑值求反</h4><p>确保一个值不等同于另一值</p><p>IF(NOT(MAX(C2:E2)&lt;$I$2),”优秀”,IF(NOT(MAX(C2:E2)&lt;$I$3),”及格”,”不及格”))</p><h4 id="18-使用IFERROR函数对错误结果进行处理"><a href="#18-使用IFERROR函数对错误结果进行处理" class="headerlink" title="18.使用IFERROR函数对错误结果进行处理"></a>18.使用IFERROR函数对错误结果进行处理</h4><p>IFERROR(value, value_if_error)<br>值     检查是否存在错误的参数。<br>Value_if_error    公式的计算结果错误时返回的值。</p><p>IFERROR(A2,”公式出错”)</p><h4 id="19-使用TODAY函数返回当前日期"><a href="#19-使用TODAY函数返回当前日期" class="headerlink" title="19.使用TODAY函数返回当前日期"></a>19.使用TODAY函数返回当前日期</h4><p>用法:TODAY()</p><h4 id="20-使用TIME函数返回某一特定时间的小数值"><a href="#20-使用TIME函数返回某一特定时间的小数值" class="headerlink" title="20.使用TIME函数返回某一特定时间的小数值"></a>20.使用TIME函数返回某一特定时间的小数值</h4><p>TIME(hour, minute, second)<br>hour  代表小时。<br>minute  代表分钟。<br>second  代表秒。</p><p>=B2+TIME(8,0,0)</p><h4 id="21-使用YEAR函数返回某日期对应的年份"><a href="#21-使用YEAR函数返回某日期对应的年份" class="headerlink" title="21.使用YEAR函数返回某日期对应的年份"></a>21.使用YEAR函数返回某日期对应的年份</h4><p>YEAR(serial_number)<br>Serial_number   要查找的年份的日期</p><p>YEAR(TODAY())-YEAR(J2)</p><p>开始—-&gt;数字(下拉选框选择常规)</p><h4 id="22-使用MONTH函数返回某日期对应的月份"><a href="#22-使用MONTH函数返回某日期对应的月份" class="headerlink" title="22.使用MONTH函数返回某日期对应的月份"></a>22.使用MONTH函数返回某日期对应的月份</h4><p>MONTH(serial_number)<br>Serial_number 要查找的月份日期</p><p>单击公式—-&gt;定义的名称—-&gt;根据所选的内容创建—-&gt;勾选首行,确定</p><p>IF(MONTH(DATE(年份,2,29))=2,”闰年”,”平年”)</p><h4 id="23-使用CHOOSE函数根据序号从列表中选择对应的内容"><a href="#23-使用CHOOSE函数根据序号从列表中选择对应的内容" class="headerlink" title="23.使用CHOOSE函数根据序号从列表中选择对应的内容"></a>23.使用CHOOSE函数根据序号从列表中选择对应的内容</h4><p>CHOOSE(index_num, value1, [value2], …)<br>index_num     用于指定所选定的数值参数<br>如果 index_num 为 1，则 CHOOSE 返回 value1；如果为 2，则 CHOOSE 返回 value2，以此类推<br>如果 index_num 小于 1 或大于列表中最后一个值的索引号，则 CHOOSE 返回 #VALUE! 错误值<br>如果 index_num 为小数，则在使用前将被截尾取整<br>value1, value2, …    Value1 是必需的，后续值是可选的</p><p>OFFSET(工资表!$A$1,CHOOSE(MOD(ROW(工资表!A1)-1,3)+1,0,(ROW(工资表!A1)-1)/3+1,65535),COLUMN()-1)&amp;””</p><h4 id="24-使用MATCH函数返回指定内容所在的位置"><a href="#24-使用MATCH函数返回指定内容所在的位置" class="headerlink" title="24.使用MATCH函数返回指定内容所在的位置"></a>24.使用MATCH函数返回指定内容所在的位置</h4><p>MATCH(lookup_value, lookup_array, [match_type])<br>lookup_value     要在 lookup_array 中匹配的值<br>lookup_value 参数可以为值（数字、文本或逻辑值）或对数字、文本或逻辑值的单元格引用。<br>lookup_array    要搜索的单元格区域<br>match_type    数字 -1、0 或 1。 match_type 参数指定 Excel 如何将 lookup_value 与 lookup_array 中的值匹配。 此参数的默认值为 1。</p><p>INDEX($A$2:$A$7,MATCH(LARGE($G$2:$G$7,ROW()-1),$G$2:$G$7,0))</p><h4 id="25-使用TRANSPOSE函数转置数据区域的行列位置"><a href="#25-使用TRANSPOSE函数转置数据区域的行列位置" class="headerlink" title="25.使用TRANSPOSE函数转置数据区域的行列位置"></a>25.使用TRANSPOSE函数转置数据区域的行列位置</h4><p>TRANSPOSE(array)<br>数组   要转置的工作表上的数组或单元格区域</p><p>TRANSPOSE(A1:E5)</p><p>按下Ctrl+Shift+Enter组合件,即可对原来工作表进行转置</p><h4 id="26-使用COUNTA函数计算参数中包含非空值的个数"><a href="#26-使用COUNTA函数计算参数中包含非空值的个数" class="headerlink" title="26.使用COUNTA函数计算参数中包含非空值的个数"></a>26.使用COUNTA函数计算参数中包含非空值的个数</h4><p>COUNTA(value1, [value2], …)<br>value1     表示要计数的值的第一个参数。<br>value2, …    表示要计数的值的其他参数，最多可包含 255 个参数。<br>COUNTA 函数计算范围中不为空的单元格的个数。</p><p>=COUNTA(D2:D19)</p><h4 id="27-使用COUNTIF函数计算满足给定条件的单元格的个"><a href="#27-使用COUNTIF函数计算满足给定条件的单元格的个" class="headerlink" title="27.使用COUNTIF函数计算满足给定条件的单元格的个"></a>27.使用COUNTIF函数计算满足给定条件的单元格的个</h4><p>COUNTIF(range, criteria)<br>range    要进行计数的单元格组<br>criteria   用于决定要统计哪些单元格的数量的数字、表达式、单元格引用或文本字符串。<br>COUNTIF 是一个统计函数，用于统计满足某个条件的单元格的数量；</p><p>=COUNTIF(C2:C19,”行政部”)</p><h4 id="28-使用SUMIFS函数计算多重条件的"><a href="#28-使用SUMIFS函数计算多重条件的" class="headerlink" title="28.使用SUMIFS函数计算多重条件的"></a>28.使用SUMIFS函数计算多重条件的</h4><p>SUMIFS(sum_range, criteria_range1, criteria1, [criteria_range2, criteria2], …)<br>Sum_rang  要求和的单元格区域<br>Criteria_range1 使用 Criteria1 测试的区域<br>Criteria1 定义将计算 Criteria_range1 中的哪些单元格的和的条件</p><p>Criteria_range2,     附加的区域及其关联条件。 最多可以输入 127 个区域/条件对。<br>criteria2, …    (optional)<br>SUMIFS 函数是一个数学与三角函数，用于计算其满足多个条件的全部参数的总量</p><p>SUMIFS(D2:D40,A2:A40,”=*商用型”,B2:B40,”6”)</p><h4 id="29-使用AVERAGEA函数计算参数中非空值的平均值"><a href="#29-使用AVERAGEA函数计算参数中非空值的平均值" class="headerlink" title="29.使用AVERAGEA函数计算参数中非空值的平均值"></a>29.使用AVERAGEA函数计算参数中非空值的平均值</h4><p>AVERAGEA(value1, [value2], …)<br>Value1, value2, …    Value1 是必需的，后续值是可选的</p><p>=AVERAGEA(D2:D19)</p><h4 id="30-使用AVERAGEIF函数计算满足给定条件的单元格的平均值"><a href="#30-使用AVERAGEIF函数计算满足给定条件的单元格的平均值" class="headerlink" title="30.使用AVERAGEIF函数计算满足给定条件的单元格的平均值"></a>30.使用AVERAGEIF函数计算满足给定条件的单元格的平均值</h4><p>AVERAGEIF(range, criteria, [average_range])<br>Range    要计算平均值的一个或多个单元格<br>Criteria   形式为数字、表达式、单元格引用或文本的条件，用来定义将计算平均值的单元格<br>Average_rang计算平均值的实际单元格组</p><p>AVERAGEIF(C2:C19,F2,D2:D19)</p><h4 id="31-使用RANK-EQ函数返回一个数字在一组数字中的排位"><a href="#31-使用RANK-EQ函数返回一个数字在一组数字中的排位" class="headerlink" title="31.使用RANK.EQ函数返回一个数字在一组数字中的排位"></a>31.使用RANK.EQ函数返回一个数字在一组数字中的排位</h4><p>RANK.EQ(number,ref,[order])<br>Number    要找到其排位的数字。<br>Ref    数字列表的数组，对数字列表的引用。<br>Order   一个指定数字排位方式的数字。</p><p>=RANK.EQ(J2,$J$2:$J​$31)</p><h4 id="32-使用DELTA函数测试两个值是否相等"><a href="#32-使用DELTA函数测试两个值是否相等" class="headerlink" title="32.使用DELTA函数测试两个值是否相等"></a>32.使用DELTA函数测试两个值是否相等</h4><p>DELTA(number1, [number2])<br>Number1     第一个数字。<br>Number2     第二个数字。<br>检验两个值是否相等。</p><p>DELTA(A2,B2)</p><p><img src="/2019/05/09/Excel数据分析之基础操作章/33.jpg" alt></p><p> 思维导图地址:<a href="https://www.processon.com/view/link/5cd4352fe4b059e20a1a2d9f" target="_blank" rel="noopener">https://www.processon.com/view/link/5cd4352fe4b059e20a1a2d9f</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫阶段mysql</title>
      <link href="/2019/05/09/%E7%88%AC%E8%99%AB%E9%98%B6%E6%AE%B5mysql/"/>
      <url>/2019/05/09/%E7%88%AC%E8%99%AB%E9%98%B6%E6%AE%B5mysql/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Python连接数据库:</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DB</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,database = <span class="string">"kl"</span>,user = <span class="string">"root"</span>,password = <span class="string">"123456"</span>,port = <span class="number">3306</span>,host = <span class="string">"localhost"</span>)</span>:</span></span><br><span class="line">        self.db = pymysql.connect(host = host,port = port, user = user, database = database, password = password,</span><br><span class="line">                                  cursorclass = pymysql.cursors.DictCursor, charset=<span class="string">'utf8mb4'</span>)</span><br><span class="line">        self.cursor = self.db.cursor()</span><br><span class="line">    <span class="comment"># 为什么使用data这个元组</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self,sql, data)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.cursor.execute(sql, data)</span><br><span class="line">            self.db.commit()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            print(<span class="string">"操作失败，请检查sql语句"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self,sql)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.cursor.execute(sql)</span><br><span class="line">            data = self.cursor.fetchall()</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            print(<span class="string">"查询失败，请检查sql语句"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.cursor.close()</span><br><span class="line">        self.db.close()</span><br></pre></td></tr></table></figure><p><img src="/2019/05/09/爬虫阶段mysql/爬虫阶段.jpg" alt="虫阶"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">模糊查询库里的表名</span><br><span class="line">select  table_name <span class="keyword">from</span> user_tables where table_name like <span class="string">'%tab_name%'</span>;</span><br></pre></td></tr></table></figure><p>cursor.executemany()</p><p>sql = “insert into myTable (created_day,name,count) values(%s,%s,%s) ”</p><p>args=[(“2012-08-27”,”name1”,100),(“2012-08-27”,”name1”,200),(“2012-08-27”,”name2”,300)]</p><p>cursor.executemany(sql, args)</p><p>args为列表格式</p><p>思维导图网址:</p><p><a href="https://www.processon.com/view/link/5cd42958e4b09a3e45bd6a52" target="_blank" rel="noopener">https://www.processon.com/view/link/5cd42958e4b09a3e45bd6a52</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python常见面试题</title>
      <link href="/2019/05/09/Python%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/05/09/Python%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">列表推导式:</span><br><span class="line">优化一下下面的程序</span><br><span class="line">result = []</span><br><span class="line">for x in range(10):</span><br><span class="line">result.append(x ** 2)</span><br><span class="line">print(result)</span><br><span class="line">print([(x ** 2) for x in range(10)])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">深浅拷贝:</span><br><span class="line">写出下面a,b,c,d四个变量的值</span><br><span class="line">import copy </span><br><span class="line">a = [1,2,3,4,[&apos;a&apos;,&apos;b&apos;]]  # 原始对象</span><br><span class="line">b = a</span><br><span class="line">c = copy.copy(a)</span><br><span class="line">d = copy.deepcopy(a)</span><br><span class="line">a.append(5)</span><br><span class="line">a[4].append(&apos;c&apos;)</span><br><span class="line">print(&apos;a的值是&apos;,a)</span><br><span class="line">print(&apos;b的值是&apos;,b)</span><br><span class="line">print(&apos;c的值是&apos;,c)</span><br><span class="line">print(&apos;d的值是&apos;,d)</span><br><span class="line">答案: </span><br><span class="line">a的值是 [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 5]</span><br><span class="line">b的值是 [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 5]</span><br><span class="line">c的值是 [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]</span><br><span class="line">d的值是 [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;]]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">字符串特性:</span><br><span class="line">a = &apos;abc&apos;</span><br><span class="line">print(a[1])</span><br><span class="line">a[1]=&apos;a&apos;</span><br><span class="line">print(a[1])</span><br><span class="line">答案：</span><br><span class="line">&apos;b&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">面向对象继承:</span><br><span class="line">class Parent(object):</span><br><span class="line">x = 1</span><br><span class="line">class Child1(Parent):</span><br><span class="line">pass</span><br><span class="line">class Child2(Parent):</span><br><span class="line">pass</span><br><span class="line">print(Parent.x,Child1.x, Child2.x)</span><br><span class="line">Child1.x = 3</span><br><span class="line">print(Parent.x,Child1.x, Child2.x)</span><br><span class="line">Parent.x = &apos;a&apos;</span><br><span class="line">print(Parent.x,Child1.x, Child2.x)</span><br><span class="line">答案：  1 1 1</span><br><span class="line">1 3 1</span><br><span class="line">a 3 a</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">闭包和延迟绑定:</span><br><span class="line">       def count():</span><br><span class="line">            fs = []</span><br><span class="line">            for i in range(1, 4):</span><br><span class="line">                def f():</span><br><span class="line">                    return i * i</span><br><span class="line">                fs.append(f)</span><br><span class="line">            return fs</span><br><span class="line"></span><br><span class="line">        for f in count():</span><br><span class="line">            print(f())</span><br><span class="line"></span><br><span class="line">        答案：</span><br><span class="line">            9</span><br><span class="line">            9</span><br><span class="line">            9</span><br><span class="line">        闭包函数，外函数 count() 再调用结束时会将在内部函数 f() 使用到的临时变量的最终结果值，也传给内部函数。所以此处的 i 都是 3 。</span><br><span class="line">        for f in count(): 遍历是因为 count() 函数的返回值是 内部函数本身 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">下面的代码会输入什么?</span><br><span class="line">def f(x,l=[]):</span><br><span class="line">for i in range(x):</span><br><span class="line">l.append(i*i)</span><br><span class="line">print(l)</span><br><span class="line"></span><br><span class="line">f(2)</span><br><span class="line">f(3,[3,2,1])</span><br><span class="line">f(3)</span><br><span class="line">    答案:</span><br><span class="line">    [0, 1]</span><br><span class="line">    [3, 2, 1, 0, 1, 4]</span><br><span class="line">    [0, 1, 0, 1, 4]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输出结果是什么?</span><br><span class="line">    lists = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]</span><br><span class="line">    print(lists[10:])</span><br><span class="line">    输出结果:</span><br><span class="line">    []</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">A0-A6的值是什么?</span><br><span class="line">    A0=dict(zip((&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;),(1,2,3,4,5)))</span><br><span class="line">    A1=range(10)</span><br><span class="line">    A2=sorted([i for i in A l if i in A0])</span><br><span class="line">    A3=sorted([A0[s] for s in A0 ])</span><br><span class="line">    A4=[i for i in A l if i in A3]</span><br><span class="line">    A5=&#123;i:i*i for i in A1&#125;</span><br><span class="line">    A6=[[i,i*i] for i in A1]</span><br><span class="line"></span><br><span class="line">    A0:&#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3, &apos;d&apos;: 4, &apos;e&apos;: 5&#125;</span><br><span class="line">    A1:range(0,10)</span><br><span class="line">    A2:[]</span><br><span class="line">    A3:[1,2,3,4,5]</span><br><span class="line">    A4:[1,2,3,4,5]</span><br><span class="line">    A5:&#123;0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81&#125;</span><br><span class="line">    A6:[[0, 0], [1, 1], [2, 4], [3, 9], [4, 16], [5, 25], [6, 36], [7, 49], [8, 64], [9, 81]]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">有一个列表，[1,2,3,4,5,6,5,6,7,7,8],请写出列表去重的三种方式</span><br><span class="line"></span><br><span class="line">    #利用集合，直接将列表转化为集合，自动去重后转回列表。有一个问题，转换为集合的同时，数据无序了。</span><br><span class="line">    li = [11,22,22,33,44,44]</span><br><span class="line">    set = set(li)</span><br><span class="line">    li = list(set)</span><br><span class="line">    print(li) #[33, 11, 44, 22]</span><br><span class="line"></span><br><span class="line">    # 第二种运用新建字典的方式，去除重复的键</span><br><span class="line">    list = [11,22,33,22,44,33]</span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    list = dic.fromkeys(list).keys()#字典在创建新的字典时，有重复key则覆盖</span><br><span class="line">    print(list) #dict_keys([11, 22, 33, 44])</span><br><span class="line"></span><br><span class="line">    #第三种是用列表的推导</span><br><span class="line">    list = [11,22,33,22,44,33]</span><br><span class="line">    lis = [] #创建一个新列表</span><br><span class="line">    for i in list: #循环list里的每一个元素</span><br><span class="line">        if i not in lis: #判断元素是否存在新列表中，不存在则添加，存在则跳过，以此去重</span><br><span class="line">            lis.append(i)</span><br><span class="line">    print(lis) #[11, 22, 33, 44]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">range   xrange     的区别</span><br><span class="line">答案:</span><br><span class="line">range ：range会直接生成一个list对象</span><br><span class="line">           xrange：并不会直接生成一个list对象，会在每一个调用时返回其中的一个值。</span><br><span class="line">           在 python3 中，去除了 range 函数，将 xrange 函数更名为 range 函数</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">考察闭包的延迟绑定:</span><br><span class="line">如下代码输出的是什么</span><br><span class="line">    def multipliers():</span><br><span class="line">        return [lambda x:i * x for i in range(4)]</span><br><span class="line">    print [m(2) for m in multipliers()]</span><br><span class="line">    </span><br><span class="line">    结果 [6, 6, 6, 6]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如何用python生成一个指定长度的斐波那契数列？</span><br><span class="line">    def fib(n):</span><br><span class="line">        a,b = 0,1</span><br><span class="line">        for i in range(n):</span><br><span class="line">            a,b =b,a+b</span><br><span class="line">        print(a)</span><br><span class="line">    f = fib(10)</span><br><span class="line">    print(f)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var1 = &quot;8&quot;</span><br><span class="line">var2 = &quot;3&quot;</span><br><span class="line">var1 += var2,var1等于几?</span><br><span class="line">答:var1=&quot;83&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">如下代码输出的是什么？</span><br><span class="line">def extendList(val,list=[]):</span><br><span class="line">list.append(val)</span><br><span class="line">return list</span><br><span class="line">list1 = extendList(10)</span><br><span class="line">list2 = extendList(123,[])</span><br><span class="line">list3 = extendList(&apos;a&apos;)</span><br><span class="line">print(&quot;list1 = %s&quot; % list1)</span><br><span class="line">print(&quot;list2 = %s&quot; % list2)</span><br><span class="line">print(&quot;list3 = %s&quot; % list3)</span><br><span class="line">答案：</span><br><span class="line">    list1 = [10, &apos;a&apos;]</span><br><span class="line">    list2 = [123]</span><br><span class="line">    list3 = [10, &apos;a&apos;]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
